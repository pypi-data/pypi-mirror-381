# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AlbBackendGroupGrpcBackend',
    'AlbBackendGroupGrpcBackendHealthcheck',
    'AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck',
    'AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck',
    'AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck',
    'AlbBackendGroupGrpcBackendLoadBalancingConfig',
    'AlbBackendGroupGrpcBackendTls',
    'AlbBackendGroupGrpcBackendTlsValidationContext',
    'AlbBackendGroupHttpBackend',
    'AlbBackendGroupHttpBackendHealthcheck',
    'AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck',
    'AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck',
    'AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck',
    'AlbBackendGroupHttpBackendLoadBalancingConfig',
    'AlbBackendGroupHttpBackendTls',
    'AlbBackendGroupHttpBackendTlsValidationContext',
    'AlbBackendGroupSessionAffinity',
    'AlbBackendGroupSessionAffinityConnection',
    'AlbBackendGroupSessionAffinityCookie',
    'AlbBackendGroupSessionAffinityHeader',
    'AlbBackendGroupStreamBackend',
    'AlbBackendGroupStreamBackendHealthcheck',
    'AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck',
    'AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck',
    'AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck',
    'AlbBackendGroupStreamBackendLoadBalancingConfig',
    'AlbBackendGroupStreamBackendTls',
    'AlbBackendGroupStreamBackendTlsValidationContext',
    'AlbHttpRouterRouteOptions',
    'AlbHttpRouterRouteOptionsRbac',
    'AlbHttpRouterRouteOptionsRbacPrincipal',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader',
    'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue',
    'AlbLoadBalancerAllocationPolicy',
    'AlbLoadBalancerAllocationPolicyLocation',
    'AlbLoadBalancerAutoScalePolicy',
    'AlbLoadBalancerListener',
    'AlbLoadBalancerListenerEndpoint',
    'AlbLoadBalancerListenerEndpointAddress',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv4Address',
    'AlbLoadBalancerListenerEndpointAddressExternalIpv6Address',
    'AlbLoadBalancerListenerEndpointAddressInternalIpv4Address',
    'AlbLoadBalancerListenerHttp',
    'AlbLoadBalancerListenerHttpHandler',
    'AlbLoadBalancerListenerHttpHandlerHttp2Options',
    'AlbLoadBalancerListenerHttpRedirects',
    'AlbLoadBalancerListenerStream',
    'AlbLoadBalancerListenerStreamHandler',
    'AlbLoadBalancerListenerTls',
    'AlbLoadBalancerListenerTlsDefaultHandler',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler',
    'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options',
    'AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler',
    'AlbLoadBalancerListenerTlsSniHandler',
    'AlbLoadBalancerListenerTlsSniHandlerHandler',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options',
    'AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler',
    'AlbLoadBalancerLogOptions',
    'AlbLoadBalancerLogOptionsDiscardRule',
    'AlbTargetGroupTarget',
    'AlbVirtualHostModifyRequestHeader',
    'AlbVirtualHostModifyResponseHeader',
    'AlbVirtualHostRateLimit',
    'AlbVirtualHostRateLimitAllRequests',
    'AlbVirtualHostRateLimitRequestsPerIp',
    'AlbVirtualHostRoute',
    'AlbVirtualHostRouteGrpcRoute',
    'AlbVirtualHostRouteGrpcRouteGrpcMatch',
    'AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteAction',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests',
    'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp',
    'AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction',
    'AlbVirtualHostRouteHttpRoute',
    'AlbVirtualHostRouteHttpRouteDirectResponseAction',
    'AlbVirtualHostRouteHttpRouteHttpMatch',
    'AlbVirtualHostRouteHttpRouteHttpMatchPath',
    'AlbVirtualHostRouteHttpRouteHttpRouteAction',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp',
    'AlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewrite',
    'AlbVirtualHostRouteHttpRouteRedirectAction',
    'AlbVirtualHostRouteOptions',
    'AlbVirtualHostRouteOptionsRbac',
    'AlbVirtualHostRouteOptionsRbacPrincipal',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader',
    'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue',
    'AlbVirtualHostRouteRouteOptions',
    'AlbVirtualHostRouteRouteOptionsRbac',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipal',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader',
    'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue',
    'ApiGatewayCanary',
    'ApiGatewayConnectivity',
    'ApiGatewayCustomDomain',
    'ApiGatewayLogOptions',
    'AuditTrailsTrailDataStreamDestination',
    'AuditTrailsTrailFilter',
    'AuditTrailsTrailFilterEventFilter',
    'AuditTrailsTrailFilterEventFilterCategory',
    'AuditTrailsTrailFilterEventFilterPathFilter',
    'AuditTrailsTrailFilterEventFilterPathFilterAnyFilter',
    'AuditTrailsTrailFilterEventFilterPathFilterSomeFilter',
    'AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter',
    'AuditTrailsTrailFilterPathFilter',
    'AuditTrailsTrailFilterPathFilterAnyFilter',
    'AuditTrailsTrailFilterPathFilterSomeFilter',
    'AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter',
    'AuditTrailsTrailFilteringPolicy',
    'AuditTrailsTrailFilteringPolicyDataEventsFilter',
    'AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter',
    'AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope',
    'AuditTrailsTrailFilteringPolicyManagementEventsFilter',
    'AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope',
    'AuditTrailsTrailLoggingDestination',
    'AuditTrailsTrailStorageDestination',
    'BackupPolicyFileFilters',
    'BackupPolicyReattempts',
    'BackupPolicyRetention',
    'BackupPolicyRetentionRule',
    'BackupPolicyScheduling',
    'BackupPolicySchedulingBackupSet',
    'BackupPolicySchedulingBackupSetExecuteByTime',
    'BackupPolicySchedulingExecuteByTime',
    'BackupPolicyVmSnapshotReattempts',
    'CdnOriginGroupOrigin',
    'CdnResourceOptions',
    'CdnResourceOptionsIpAddressAcl',
    'CdnResourceSslCertificate',
    'CmCertificateChallenge',
    'CmCertificateManaged',
    'CmCertificateSelfManaged',
    'CmCertificateSelfManagedPrivateKeyLockboxSecret',
    'ComputeDiskDiskPlacementPolicy',
    'ComputeDiskHardwareGeneration',
    'ComputeDiskHardwareGenerationGeneration2Features',
    'ComputeDiskHardwareGenerationLegacyFeatures',
    'ComputeImageHardwareGeneration',
    'ComputeImageHardwareGenerationGeneration2Features',
    'ComputeImageHardwareGenerationLegacyFeatures',
    'ComputeInstanceBootDisk',
    'ComputeInstanceBootDiskInitializeParams',
    'ComputeInstanceFilesystem',
    'ComputeInstanceGroupAllocationPolicy',
    'ComputeInstanceGroupAllocationPolicyInstanceTagsPool',
    'ComputeInstanceGroupApplicationLoadBalancer',
    'ComputeInstanceGroupDeployPolicy',
    'ComputeInstanceGroupHealthCheck',
    'ComputeInstanceGroupHealthCheckHttpOptions',
    'ComputeInstanceGroupHealthCheckTcpOptions',
    'ComputeInstanceGroupInstance',
    'ComputeInstanceGroupInstanceNetworkInterface',
    'ComputeInstanceGroupInstanceTemplate',
    'ComputeInstanceGroupInstanceTemplateBootDisk',
    'ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams',
    'ComputeInstanceGroupInstanceTemplateFilesystem',
    'ComputeInstanceGroupInstanceTemplateMetadataOptions',
    'ComputeInstanceGroupInstanceTemplateNetworkInterface',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord',
    'ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord',
    'ComputeInstanceGroupInstanceTemplateNetworkSetting',
    'ComputeInstanceGroupInstanceTemplatePlacementPolicy',
    'ComputeInstanceGroupInstanceTemplateResources',
    'ComputeInstanceGroupInstanceTemplateSchedulingPolicy',
    'ComputeInstanceGroupInstanceTemplateSecondaryDisk',
    'ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams',
    'ComputeInstanceGroupLoadBalancer',
    'ComputeInstanceGroupScalePolicy',
    'ComputeInstanceGroupScalePolicyAutoScale',
    'ComputeInstanceGroupScalePolicyAutoScaleCustomRule',
    'ComputeInstanceGroupScalePolicyFixedScale',
    'ComputeInstanceGroupScalePolicyTestAutoScale',
    'ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule',
    'ComputeInstanceHardwareGeneration',
    'ComputeInstanceHardwareGenerationGeneration2Feature',
    'ComputeInstanceHardwareGenerationLegacyFeature',
    'ComputeInstanceLocalDisk',
    'ComputeInstanceMetadataOptions',
    'ComputeInstanceNetworkInterface',
    'ComputeInstanceNetworkInterfaceDnsRecord',
    'ComputeInstanceNetworkInterfaceIpv6DnsRecord',
    'ComputeInstanceNetworkInterfaceNatDnsRecord',
    'ComputeInstancePlacementPolicy',
    'ComputeInstancePlacementPolicyHostAffinityRule',
    'ComputeInstanceResources',
    'ComputeInstanceSchedulingPolicy',
    'ComputeInstanceSecondaryDisk',
    'ComputeSnapshotHardwareGeneration',
    'ComputeSnapshotHardwareGenerationGeneration2Features',
    'ComputeSnapshotHardwareGenerationLegacyFeatures',
    'ComputeSnapshotScheduleSchedulePolicy',
    'ComputeSnapshotScheduleSnapshotSpec',
    'ContainerRepositoryLifecyclePolicyRule',
    'DataprocClusterClusterConfig',
    'DataprocClusterClusterConfigHadoop',
    'DataprocClusterClusterConfigHadoopInitializationAction',
    'DataprocClusterClusterConfigSubclusterSpec',
    'DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig',
    'DataprocClusterClusterConfigSubclusterSpecResources',
    'DatatransferEndpointSettings',
    'DatatransferEndpointSettingsClickhouseSource',
    'DatatransferEndpointSettingsClickhouseSourceConnection',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword',
    'DatatransferEndpointSettingsClickhouseTarget',
    'DatatransferEndpointSettingsClickhouseTargetAltName',
    'DatatransferEndpointSettingsClickhouseTargetConnection',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword',
    'DatatransferEndpointSettingsClickhouseTargetSharding',
    'DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping',
    'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue',
    'DatatransferEndpointSettingsClickhouseTargetShardingRoundRobin',
    'DatatransferEndpointSettingsClickhouseTargetShardingTransferId',
    'DatatransferEndpointSettingsKafkaSource',
    'DatatransferEndpointSettingsKafkaSourceAuth',
    'DatatransferEndpointSettingsKafkaSourceAuthNoAuth',
    'DatatransferEndpointSettingsKafkaSourceAuthSasl',
    'DatatransferEndpointSettingsKafkaSourceAuthSaslPassword',
    'DatatransferEndpointSettingsKafkaSourceConnection',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremise',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsKafkaSourceParser',
    'DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1Parser',
    'DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParser',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParser',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFields',
    'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsField',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParser',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFields',
    'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsField',
    'DatatransferEndpointSettingsKafkaSourceTransformer',
    'DatatransferEndpointSettingsKafkaTarget',
    'DatatransferEndpointSettingsKafkaTargetAuth',
    'DatatransferEndpointSettingsKafkaTargetAuthNoAuth',
    'DatatransferEndpointSettingsKafkaTargetAuthSasl',
    'DatatransferEndpointSettingsKafkaTargetAuthSaslPassword',
    'DatatransferEndpointSettingsKafkaTargetConnection',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremise',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsKafkaTargetSerializer',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerAuto',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameter',
    'DatatransferEndpointSettingsKafkaTargetSerializerSerializerJson',
    'DatatransferEndpointSettingsKafkaTargetTopicSettings',
    'DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic',
    'DatatransferEndpointSettingsMetrikaSource',
    'DatatransferEndpointSettingsMetrikaSourceStream',
    'DatatransferEndpointSettingsMetrikaSourceToken',
    'DatatransferEndpointSettingsMongoSource',
    'DatatransferEndpointSettingsMongoSourceCollection',
    'DatatransferEndpointSettingsMongoSourceConnection',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword',
    'DatatransferEndpointSettingsMongoSourceExcludedCollection',
    'DatatransferEndpointSettingsMongoTarget',
    'DatatransferEndpointSettingsMongoTargetConnection',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword',
    'DatatransferEndpointSettingsMysqlSource',
    'DatatransferEndpointSettingsMysqlSourceConnection',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremise',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsMysqlSourceObjectTransferSettings',
    'DatatransferEndpointSettingsMysqlSourcePassword',
    'DatatransferEndpointSettingsMysqlTarget',
    'DatatransferEndpointSettingsMysqlTargetConnection',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremise',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsMysqlTargetPassword',
    'DatatransferEndpointSettingsPostgresSource',
    'DatatransferEndpointSettingsPostgresSourceConnection',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremise',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsPostgresSourceObjectTransferSettings',
    'DatatransferEndpointSettingsPostgresSourcePassword',
    'DatatransferEndpointSettingsPostgresTarget',
    'DatatransferEndpointSettingsPostgresTargetConnection',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremise',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled',
    'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled',
    'DatatransferEndpointSettingsPostgresTargetPassword',
    'DatatransferEndpointSettingsYdbSource',
    'DatatransferEndpointSettingsYdbTarget',
    'DatatransferEndpointSettingsYdsSource',
    'DatatransferEndpointSettingsYdsSourceParser',
    'DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1Parser',
    'DatatransferEndpointSettingsYdsSourceParserCloudLoggingParser',
    'DatatransferEndpointSettingsYdsSourceParserJsonParser',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFields',
    'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsField',
    'DatatransferEndpointSettingsYdsSourceParserTskvParser',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFields',
    'DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsField',
    'DatatransferEndpointSettingsYdsTarget',
    'DatatransferEndpointSettingsYdsTargetSerializer',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerAuto',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameter',
    'DatatransferEndpointSettingsYdsTargetSerializerSerializerJson',
    'DatatransferTransferRuntime',
    'DatatransferTransferRuntimeYcRuntime',
    'DatatransferTransferRuntimeYcRuntimeUploadShardParams',
    'DatatransferTransferTransformation',
    'DatatransferTransferTransformationTransformer',
    'DatatransferTransferTransformationTransformerConvertToString',
    'DatatransferTransferTransformationTransformerConvertToStringColumns',
    'DatatransferTransferTransformationTransformerConvertToStringTables',
    'DatatransferTransferTransformationTransformerFilterColumns',
    'DatatransferTransferTransformationTransformerFilterColumnsColumns',
    'DatatransferTransferTransformationTransformerFilterColumnsTables',
    'DatatransferTransferTransformationTransformerFilterRows',
    'DatatransferTransferTransformationTransformerFilterRowsTables',
    'DatatransferTransferTransformationTransformerMaskField',
    'DatatransferTransferTransformationTransformerMaskFieldFunction',
    'DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash',
    'DatatransferTransferTransformationTransformerMaskFieldTables',
    'DatatransferTransferTransformationTransformerRenameTables',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTable',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName',
    'DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName',
    'DatatransferTransferTransformationTransformerReplacePrimaryKey',
    'DatatransferTransferTransformationTransformerReplacePrimaryKeyTables',
    'DatatransferTransferTransformationTransformerSharderTransformer',
    'DatatransferTransferTransformationTransformerSharderTransformerColumns',
    'DatatransferTransferTransformationTransformerSharderTransformerTables',
    'DatatransferTransferTransformationTransformerTableSplitterTransformer',
    'DatatransferTransferTransformationTransformerTableSplitterTransformerTables',
    'FunctionAsyncInvocation',
    'FunctionAsyncInvocationYmqFailureTarget',
    'FunctionAsyncInvocationYmqSuccessTarget',
    'FunctionConnectivity',
    'FunctionContent',
    'FunctionLogOptions',
    'FunctionMetadataOptions',
    'FunctionMount',
    'FunctionMountEphemeralDisk',
    'FunctionMountObjectStorage',
    'FunctionPackage',
    'FunctionScalingPolicyPolicy',
    'FunctionSecret',
    'FunctionStorageMount',
    'FunctionTriggerContainer',
    'FunctionTriggerContainerRegistry',
    'FunctionTriggerDataStreams',
    'FunctionTriggerDlq',
    'FunctionTriggerFunction',
    'FunctionTriggerIot',
    'FunctionTriggerLogGroup',
    'FunctionTriggerLogging',
    'FunctionTriggerMail',
    'FunctionTriggerMessageQueue',
    'FunctionTriggerObjectStorage',
    'FunctionTriggerTimer',
    'IamServiceAccountApiKeyOutputToLockbox',
    'IamServiceAccountKeyOutputToLockbox',
    'IamServiceAccountStaticAccessKeyOutputToLockbox',
    'IotCoreBrokerLogOptions',
    'IotCoreRegistryLogOptions',
    'KubernetesClusterKmsProvider',
    'KubernetesClusterMaster',
    'KubernetesClusterMasterMaintenancePolicy',
    'KubernetesClusterMasterMaintenancePolicyMaintenanceWindow',
    'KubernetesClusterMasterMasterLocation',
    'KubernetesClusterMasterMasterLogging',
    'KubernetesClusterMasterRegional',
    'KubernetesClusterMasterRegionalLocation',
    'KubernetesClusterMasterScalePolicy',
    'KubernetesClusterMasterScalePolicyAutoScale',
    'KubernetesClusterMasterVersionInfo',
    'KubernetesClusterMasterZonal',
    'KubernetesClusterNetworkImplementation',
    'KubernetesClusterNetworkImplementationCilium',
    'KubernetesClusterWorkloadIdentityFederation',
    'KubernetesNodeGroupAllocationPolicy',
    'KubernetesNodeGroupAllocationPolicyLocation',
    'KubernetesNodeGroupDeployPolicy',
    'KubernetesNodeGroupInstanceTemplate',
    'KubernetesNodeGroupInstanceTemplateBootDisk',
    'KubernetesNodeGroupInstanceTemplateContainerNetwork',
    'KubernetesNodeGroupInstanceTemplateContainerRuntime',
    'KubernetesNodeGroupInstanceTemplateGpuSettings',
    'KubernetesNodeGroupInstanceTemplateNetworkInterface',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord',
    'KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord',
    'KubernetesNodeGroupInstanceTemplatePlacementPolicy',
    'KubernetesNodeGroupInstanceTemplateResources',
    'KubernetesNodeGroupInstanceTemplateSchedulingPolicy',
    'KubernetesNodeGroupMaintenancePolicy',
    'KubernetesNodeGroupMaintenancePolicyMaintenanceWindow',
    'KubernetesNodeGroupScalePolicy',
    'KubernetesNodeGroupScalePolicyAutoScale',
    'KubernetesNodeGroupScalePolicyFixedScale',
    'KubernetesNodeGroupVersionInfo',
    'LbNetworkLoadBalancerAttachedTargetGroup',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheck',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions',
    'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions',
    'LbNetworkLoadBalancerListener',
    'LbNetworkLoadBalancerListenerExternalAddressSpec',
    'LbNetworkLoadBalancerListenerInternalAddressSpec',
    'LbTargetGroupTarget',
    'LoadtestingAgentComputeInstance',
    'LoadtestingAgentComputeInstanceBootDisk',
    'LoadtestingAgentComputeInstanceBootDiskInitializeParams',
    'LoadtestingAgentComputeInstanceNetworkInterface',
    'LoadtestingAgentComputeInstanceResources',
    'LoadtestingAgentLogSettings',
    'LockboxSecretPasswordPayloadSpecification',
    'LockboxSecretVersionEntry',
    'LockboxSecretVersionEntryCommand',
    'MdbClickhouseClusterAccess',
    'MdbClickhouseClusterBackupWindowStart',
    'MdbClickhouseClusterClickhouse',
    'MdbClickhouseClusterClickhouseConfig',
    'MdbClickhouseClusterClickhouseConfigCompression',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollup',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern',
    'MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention',
    'MdbClickhouseClusterClickhouseConfigJdbcBridge',
    'MdbClickhouseClusterClickhouseConfigKafka',
    'MdbClickhouseClusterClickhouseConfigKafkaTopic',
    'MdbClickhouseClusterClickhouseConfigKafkaTopicSettings',
    'MdbClickhouseClusterClickhouseConfigMergeTree',
    'MdbClickhouseClusterClickhouseConfigQueryCache',
    'MdbClickhouseClusterClickhouseConfigQueryMaskingRule',
    'MdbClickhouseClusterClickhouseConfigRabbitmq',
    'MdbClickhouseClusterClickhouseResources',
    'MdbClickhouseClusterCloudStorage',
    'MdbClickhouseClusterDatabase',
    'MdbClickhouseClusterFormatSchema',
    'MdbClickhouseClusterHost',
    'MdbClickhouseClusterMaintenanceWindow',
    'MdbClickhouseClusterMlModel',
    'MdbClickhouseClusterShard',
    'MdbClickhouseClusterShardGroup',
    'MdbClickhouseClusterShardResources',
    'MdbClickhouseClusterUser',
    'MdbClickhouseClusterUserPermission',
    'MdbClickhouseClusterUserQuota',
    'MdbClickhouseClusterUserSettings',
    'MdbClickhouseClusterZookeeper',
    'MdbClickhouseClusterZookeeperResources',
    'MdbGreenplumClusterAccess',
    'MdbGreenplumClusterBackgroundActivity',
    'MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum',
    'MdbGreenplumClusterBackgroundActivityQueryKillerIdle',
    'MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction',
    'MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning',
    'MdbGreenplumClusterBackupWindowStart',
    'MdbGreenplumClusterCloudStorage',
    'MdbGreenplumClusterLogging',
    'MdbGreenplumClusterMaintenanceWindow',
    'MdbGreenplumClusterMasterHost',
    'MdbGreenplumClusterMasterSubcluster',
    'MdbGreenplumClusterMasterSubclusterResources',
    'MdbGreenplumClusterPoolerConfig',
    'MdbGreenplumClusterPxfConfig',
    'MdbGreenplumClusterSegmentHost',
    'MdbGreenplumClusterSegmentSubcluster',
    'MdbGreenplumClusterSegmentSubclusterResources',
    'MdbKafkaClusterConfig',
    'MdbKafkaClusterConfigAccess',
    'MdbKafkaClusterConfigDiskSizeAutoscaling',
    'MdbKafkaClusterConfigKafka',
    'MdbKafkaClusterConfigKafkaKafkaConfig',
    'MdbKafkaClusterConfigKafkaResources',
    'MdbKafkaClusterConfigKafkaUi',
    'MdbKafkaClusterConfigKraft',
    'MdbKafkaClusterConfigKraftResources',
    'MdbKafkaClusterConfigRestApi',
    'MdbKafkaClusterConfigZookeeper',
    'MdbKafkaClusterConfigZookeeperResources',
    'MdbKafkaClusterHost',
    'MdbKafkaClusterMaintenanceWindow',
    'MdbKafkaClusterTopic',
    'MdbKafkaClusterTopicTopicConfig',
    'MdbKafkaClusterUser',
    'MdbKafkaClusterUserPermission',
    'MdbKafkaConnectorConnectorConfigMirrormaker',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster',
    'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster',
    'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster',
    'MdbKafkaConnectorConnectorConfigS3Sink',
    'MdbKafkaConnectorConnectorConfigS3SinkS3Connection',
    'MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3',
    'MdbKafkaTopicTopicConfig',
    'MdbKafkaUserPermission',
    'MdbMongodbClusterClusterConfig',
    'MdbMongodbClusterClusterConfigAccess',
    'MdbMongodbClusterClusterConfigBackupWindowStart',
    'MdbMongodbClusterClusterConfigMongocfg',
    'MdbMongodbClusterClusterConfigMongocfgNet',
    'MdbMongodbClusterClusterConfigMongocfgOperationProfiling',
    'MdbMongodbClusterClusterConfigMongocfgStorage',
    'MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger',
    'MdbMongodbClusterClusterConfigMongod',
    'MdbMongodbClusterClusterConfigMongodAuditLog',
    'MdbMongodbClusterClusterConfigMongodNet',
    'MdbMongodbClusterClusterConfigMongodOperationProfiling',
    'MdbMongodbClusterClusterConfigMongodSecurity',
    'MdbMongodbClusterClusterConfigMongodSecurityKmip',
    'MdbMongodbClusterClusterConfigMongodSetParameter',
    'MdbMongodbClusterClusterConfigMongodStorage',
    'MdbMongodbClusterClusterConfigMongodStorageJournal',
    'MdbMongodbClusterClusterConfigMongodStorageWiredTiger',
    'MdbMongodbClusterClusterConfigMongos',
    'MdbMongodbClusterClusterConfigMongosNet',
    'MdbMongodbClusterClusterConfigPerformanceDiagnostics',
    'MdbMongodbClusterDatabase',
    'MdbMongodbClusterDiskSizeAutoscalingMongocfg',
    'MdbMongodbClusterDiskSizeAutoscalingMongod',
    'MdbMongodbClusterDiskSizeAutoscalingMongoinfra',
    'MdbMongodbClusterDiskSizeAutoscalingMongos',
    'MdbMongodbClusterHost',
    'MdbMongodbClusterHostHostParameters',
    'MdbMongodbClusterMaintenanceWindow',
    'MdbMongodbClusterResources',
    'MdbMongodbClusterResourcesMongocfg',
    'MdbMongodbClusterResourcesMongod',
    'MdbMongodbClusterResourcesMongoinfra',
    'MdbMongodbClusterResourcesMongos',
    'MdbMongodbClusterRestore',
    'MdbMongodbClusterUser',
    'MdbMongodbClusterUserPermission',
    'MdbMysqlClusterAccess',
    'MdbMysqlClusterBackupWindowStart',
    'MdbMysqlClusterDatabase',
    'MdbMysqlClusterDiskSizeAutoscaling',
    'MdbMysqlClusterHost',
    'MdbMysqlClusterMaintenanceWindow',
    'MdbMysqlClusterPerformanceDiagnostics',
    'MdbMysqlClusterResources',
    'MdbMysqlClusterRestore',
    'MdbMysqlClusterUser',
    'MdbMysqlClusterUserConnectionLimits',
    'MdbMysqlClusterUserPermission',
    'MdbMysqlUserConnectionLimits',
    'MdbMysqlUserPermission',
    'MdbPostgresqlClusterConfig',
    'MdbPostgresqlClusterConfigAccess',
    'MdbPostgresqlClusterConfigBackupWindowStart',
    'MdbPostgresqlClusterConfigDiskSizeAutoscaling',
    'MdbPostgresqlClusterConfigPerformanceDiagnostics',
    'MdbPostgresqlClusterConfigPoolerConfig',
    'MdbPostgresqlClusterConfigResources',
    'MdbPostgresqlClusterDatabase',
    'MdbPostgresqlClusterDatabaseExtension',
    'MdbPostgresqlClusterHost',
    'MdbPostgresqlClusterMaintenanceWindow',
    'MdbPostgresqlClusterRestore',
    'MdbPostgresqlClusterUser',
    'MdbPostgresqlClusterUserPermission',
    'MdbPostgresqlDatabaseExtension',
    'MdbPostgresqlUserPermission',
    'MdbRedisClusterAccess',
    'MdbRedisClusterConfig',
    'MdbRedisClusterConfigBackupWindowStart',
    'MdbRedisClusterDiskSizeAutoscaling',
    'MdbRedisClusterHost',
    'MdbRedisClusterMaintenanceWindow',
    'MdbRedisClusterResources',
    'MdbSqlserverClusterBackupWindowStart',
    'MdbSqlserverClusterDatabase',
    'MdbSqlserverClusterHost',
    'MdbSqlserverClusterResources',
    'MdbSqlserverClusterUser',
    'MdbSqlserverClusterUserPermission',
    'MonitoringDashboardParametrization',
    'MonitoringDashboardParametrizationParameter',
    'MonitoringDashboardParametrizationParameterCustom',
    'MonitoringDashboardParametrizationParameterLabelValue',
    'MonitoringDashboardParametrizationParameterText',
    'MonitoringDashboardWidget',
    'MonitoringDashboardWidgetChart',
    'MonitoringDashboardWidgetChartNameHidingSetting',
    'MonitoringDashboardWidgetChartQuery',
    'MonitoringDashboardWidgetChartQueryDownsampling',
    'MonitoringDashboardWidgetChartQueryTarget',
    'MonitoringDashboardWidgetChartSeriesOverride',
    'MonitoringDashboardWidgetChartSeriesOverrideSetting',
    'MonitoringDashboardWidgetChartVisualizationSetting',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient',
    'MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard',
    'MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSetting',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft',
    'MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight',
    'MonitoringDashboardWidgetPosition',
    'MonitoringDashboardWidgetText',
    'MonitoringDashboardWidgetTitle',
    'OrganizationmanagerOsLoginSettingsSshCertificateSettings',
    'OrganizationmanagerOsLoginSettingsUserSshKeySettings',
    'OrganizationmanagerSamlFederationSecuritySettings',
    'ServerlessContainerAsyncInvocation',
    'ServerlessContainerConnectivity',
    'ServerlessContainerImage',
    'ServerlessContainerLogOptions',
    'ServerlessContainerMetadataOptions',
    'ServerlessContainerMount',
    'ServerlessContainerMountEphemeralDisk',
    'ServerlessContainerMountObjectStorage',
    'ServerlessContainerProvisionPolicy',
    'ServerlessContainerRuntime',
    'ServerlessContainerSecret',
    'ServerlessContainerStorageMount',
    'ServerlessEventrouterConnectorTimer',
    'ServerlessEventrouterConnectorYd',
    'ServerlessEventrouterConnectorYmq',
    'ServerlessEventrouterRuleContainer',
    'ServerlessEventrouterRuleContainerBatchSettings',
    'ServerlessEventrouterRuleFunction',
    'ServerlessEventrouterRuleFunctionBatchSettings',
    'ServerlessEventrouterRuleGatewayWebsocketBroadcast',
    'ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings',
    'ServerlessEventrouterRuleLogging',
    'ServerlessEventrouterRuleWorkflow',
    'ServerlessEventrouterRuleWorkflowBatchSettings',
    'ServerlessEventrouterRuleYd',
    'ServerlessEventrouterRuleYmq',
    'SmartcaptchaCaptchaOverrideVariant',
    'SmartcaptchaCaptchaSecurityRule',
    'SmartcaptchaCaptchaSecurityRuleCondition',
    'SmartcaptchaCaptchaSecurityRuleConditionHeader',
    'SmartcaptchaCaptchaSecurityRuleConditionHeaderValue',
    'SmartcaptchaCaptchaSecurityRuleConditionHost',
    'SmartcaptchaCaptchaSecurityRuleConditionHostHost',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIp',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch',
    'SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch',
    'SmartcaptchaCaptchaSecurityRuleConditionUri',
    'SmartcaptchaCaptchaSecurityRuleConditionUriPath',
    'SmartcaptchaCaptchaSecurityRuleConditionUriQuery',
    'SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue',
    'StorageBucketAnonymousAccessFlags',
    'StorageBucketCorsRule',
    'StorageBucketGrant',
    'StorageBucketHttps',
    'StorageBucketLifecycleRule',
    'StorageBucketLifecycleRuleExpiration',
    'StorageBucketLifecycleRuleFilter',
    'StorageBucketLifecycleRuleFilterAnd',
    'StorageBucketLifecycleRuleFilterTag',
    'StorageBucketLifecycleRuleNoncurrentVersionExpiration',
    'StorageBucketLifecycleRuleNoncurrentVersionTransition',
    'StorageBucketLifecycleRuleTransition',
    'StorageBucketLogging',
    'StorageBucketObjectLockConfiguration',
    'StorageBucketObjectLockConfigurationRule',
    'StorageBucketObjectLockConfigurationRuleDefaultRetention',
    'StorageBucketServerSideEncryptionConfiguration',
    'StorageBucketServerSideEncryptionConfigurationRule',
    'StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault',
    'StorageBucketVersioning',
    'StorageBucketWebsite',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRule',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuota',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristic',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristic',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthority',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeader',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUri',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQuery',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuota',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthority',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeader',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUri',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQuery',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch',
    'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch',
    'SwsSecurityProfileAnalyzeRequestBody',
    'SwsSecurityProfileSecurityRule',
    'SwsSecurityProfileSecurityRuleRuleCondition',
    'SwsSecurityProfileSecurityRuleRuleConditionCondition',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionAuthority',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHeader',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch',
    'SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch',
    'SwsSecurityProfileSecurityRuleSmartProtection',
    'SwsSecurityProfileSecurityRuleSmartProtectionCondition',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHeader',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch',
    'SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch',
    'SwsSecurityProfileSecurityRuleWaf',
    'SwsSecurityProfileSecurityRuleWafCondition',
    'SwsSecurityProfileSecurityRuleWafConditionAuthority',
    'SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority',
    'SwsSecurityProfileSecurityRuleWafConditionHeader',
    'SwsSecurityProfileSecurityRuleWafConditionHeaderValue',
    'SwsSecurityProfileSecurityRuleWafConditionHttpMethod',
    'SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUri',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriPath',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriQuery',
    'SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIp',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatch',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatch',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch',
    'SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch',
    'SwsWafProfileAnalyzeRequestBody',
    'SwsWafProfileCoreRuleSet',
    'SwsWafProfileCoreRuleSetRuleSet',
    'SwsWafProfileExclusionRule',
    'SwsWafProfileExclusionRuleCondition',
    'SwsWafProfileExclusionRuleConditionAuthority',
    'SwsWafProfileExclusionRuleConditionAuthorityAuthority',
    'SwsWafProfileExclusionRuleConditionHeader',
    'SwsWafProfileExclusionRuleConditionHeaderValue',
    'SwsWafProfileExclusionRuleConditionHttpMethod',
    'SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod',
    'SwsWafProfileExclusionRuleConditionRequestUri',
    'SwsWafProfileExclusionRuleConditionRequestUriPath',
    'SwsWafProfileExclusionRuleConditionRequestUriQuery',
    'SwsWafProfileExclusionRuleConditionRequestUriQueryValue',
    'SwsWafProfileExclusionRuleConditionSourceIp',
    'SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatch',
    'SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatch',
    'SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch',
    'SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch',
    'SwsWafProfileExclusionRuleExcludeRules',
    'SwsWafProfileRule',
    'SwsWafProfileRuleSet',
    'SwsWafProfileRuleSetCoreRuleSet',
    'SwsWafProfileRuleSetCoreRuleSetRuleSet',
    'SwsWafProfileRuleSetMlRuleSet',
    'SwsWafProfileRuleSetMlRuleSetRuleGroup',
    'SwsWafProfileRuleSetMlRuleSetRuleSet',
    'SwsWafProfileRuleSetYaRuleSet',
    'SwsWafProfileRuleSetYaRuleSetRuleGroup',
    'SwsWafProfileRuleSetYaRuleSetRuleSet',
    'VpcAddressDnsRecord',
    'VpcAddressExternalIpv4Address',
    'VpcDefaultSecurityGroupEgress',
    'VpcDefaultSecurityGroupIngress',
    'VpcGatewaySharedEgressGateway',
    'VpcPrivateEndpointDnsOptions',
    'VpcPrivateEndpointEndpointAddress',
    'VpcPrivateEndpointObjectStorage',
    'VpcRouteTableStaticRoute',
    'VpcSecurityGroupEgress',
    'VpcSecurityGroupIngress',
    'VpcSubnetDhcpOptions',
    'YdbDatabaseDedicatedLocation',
    'YdbDatabaseDedicatedLocationRegion',
    'YdbDatabaseDedicatedScalePolicy',
    'YdbDatabaseDedicatedScalePolicyAutoScale',
    'YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking',
    'YdbDatabaseDedicatedScalePolicyFixedScale',
    'YdbDatabaseDedicatedStorageConfig',
    'YdbDatabaseServerlessServerlessDatabase',
    'YdbTableChangefeedConsumer',
    'YdbTableColumn',
    'YdbTableFamily',
    'YdbTablePartitioningSettings',
    'YdbTablePartitioningSettingsPartitionAtKey',
    'YdbTableTtl',
    'YdbTopicAutoPartitioningSettings',
    'YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy',
    'YdbTopicConsumer',
    'GetAlbBackendGroupGrpcBackendResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult',
    'GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult',
    'GetAlbBackendGroupGrpcBackendTlsResult',
    'GetAlbBackendGroupGrpcBackendTlsValidationContextResult',
    'GetAlbBackendGroupHttpBackendResult',
    'GetAlbBackendGroupHttpBackendHealthcheckResult',
    'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult',
    'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult',
    'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult',
    'GetAlbBackendGroupHttpBackendLoadBalancingConfigResult',
    'GetAlbBackendGroupHttpBackendTlsResult',
    'GetAlbBackendGroupHttpBackendTlsValidationContextResult',
    'GetAlbBackendGroupSessionAffinityResult',
    'GetAlbBackendGroupSessionAffinityConnectionResult',
    'GetAlbBackendGroupSessionAffinityCookieResult',
    'GetAlbBackendGroupSessionAffinityHeaderResult',
    'GetAlbBackendGroupStreamBackendResult',
    'GetAlbBackendGroupStreamBackendHealthcheckResult',
    'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult',
    'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult',
    'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult',
    'GetAlbBackendGroupStreamBackendLoadBalancingConfigResult',
    'GetAlbBackendGroupStreamBackendTlsResult',
    'GetAlbBackendGroupStreamBackendTlsValidationContextResult',
    'GetAlbHttpRouterRouteOptionResult',
    'GetAlbHttpRouterRouteOptionRbacResult',
    'GetAlbHttpRouterRouteOptionRbacPrincipalResult',
    'GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalResult',
    'GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderResult',
    'GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValueResult',
    'GetAlbLoadBalancerAllocationPolicyResult',
    'GetAlbLoadBalancerAllocationPolicyLocationResult',
    'GetAlbLoadBalancerAutoScalePolicyResult',
    'GetAlbLoadBalancerListenerResult',
    'GetAlbLoadBalancerListenerEndpointResult',
    'GetAlbLoadBalancerListenerEndpointAddressResult',
    'GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult',
    'GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult',
    'GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult',
    'GetAlbLoadBalancerListenerHttpResult',
    'GetAlbLoadBalancerListenerHttpHandlerResult',
    'GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult',
    'GetAlbLoadBalancerListenerHttpRedirectResult',
    'GetAlbLoadBalancerListenerStreamResult',
    'GetAlbLoadBalancerListenerStreamHandlerResult',
    'GetAlbLoadBalancerListenerTlResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult',
    'GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult',
    'GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult',
    'GetAlbLoadBalancerLogOptionResult',
    'GetAlbLoadBalancerLogOptionDiscardRuleResult',
    'GetAlbTargetGroupTargetResult',
    'GetAlbVirtualHostModifyRequestHeaderResult',
    'GetAlbVirtualHostModifyResponseHeaderResult',
    'GetAlbVirtualHostRateLimitResult',
    'GetAlbVirtualHostRateLimitAllRequestResult',
    'GetAlbVirtualHostRateLimitRequestsPerIpResult',
    'GetAlbVirtualHostRouteResult',
    'GetAlbVirtualHostRouteGrpcRouteResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpResult',
    'GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult',
    'GetAlbVirtualHostRouteHttpRouteResult',
    'GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult',
    'GetAlbVirtualHostRouteHttpRouteHttpMatchResult',
    'GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult',
    'GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult',
    'GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitResult',
    'GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestResult',
    'GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpResult',
    'GetAlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewriteResult',
    'GetAlbVirtualHostRouteHttpRouteRedirectActionResult',
    'GetAlbVirtualHostRouteOptionResult',
    'GetAlbVirtualHostRouteOptionRbacResult',
    'GetAlbVirtualHostRouteOptionRbacPrincipalResult',
    'GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalResult',
    'GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderResult',
    'GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValueResult',
    'GetAlbVirtualHostRouteRouteOptionResult',
    'GetAlbVirtualHostRouteRouteOptionRbacResult',
    'GetAlbVirtualHostRouteRouteOptionRbacPrincipalResult',
    'GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalResult',
    'GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderResult',
    'GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValueResult',
    'GetApiGatewayCanaryResult',
    'GetApiGatewayConnectivityResult',
    'GetApiGatewayCustomDomainResult',
    'GetApiGatewayLogOptionResult',
    'GetAuditTrailsTrailDataStreamDestinationResult',
    'GetAuditTrailsTrailFilterResult',
    'GetAuditTrailsTrailFilterEventFilterResult',
    'GetAuditTrailsTrailFilterEventFilterCategoryResult',
    'GetAuditTrailsTrailFilterEventFilterPathFilterResult',
    'GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilterResult',
    'GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterResult',
    'GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterResult',
    'GetAuditTrailsTrailFilterPathFilterResult',
    'GetAuditTrailsTrailFilterPathFilterAnyFilterResult',
    'GetAuditTrailsTrailFilterPathFilterSomeFilterResult',
    'GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilterResult',
    'GetAuditTrailsTrailFilteringPolicyResult',
    'GetAuditTrailsTrailFilteringPolicyDataEventsFilterResult',
    'GetAuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilterResult',
    'GetAuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeResult',
    'GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResult',
    'GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeResult',
    'GetAuditTrailsTrailLoggingDestinationResult',
    'GetAuditTrailsTrailStorageDestinationResult',
    'GetBackupPolicyFileFilterResult',
    'GetBackupPolicyReattemptResult',
    'GetBackupPolicyRetentionResult',
    'GetBackupPolicyRetentionRuleResult',
    'GetBackupPolicySchedulingResult',
    'GetBackupPolicySchedulingBackupSetResult',
    'GetBackupPolicySchedulingBackupSetExecuteByTimeResult',
    'GetBackupPolicyVmSnapshotReattemptResult',
    'GetCdnOriginGroupOriginResult',
    'GetCdnResourceOptionsResult',
    'GetCdnResourceOptionsIpAddressAclResult',
    'GetCdnResourceSslCertificateResult',
    'GetCmCertificateChallengeResult',
    'GetComputeDiskDiskPlacementPolicyResult',
    'GetComputeDiskHardwareGenerationResult',
    'GetComputeDiskHardwareGenerationGeneration2FeatureResult',
    'GetComputeDiskHardwareGenerationLegacyFeatureResult',
    'GetComputeImageHardwareGenerationResult',
    'GetComputeImageHardwareGenerationGeneration2FeatureResult',
    'GetComputeImageHardwareGenerationLegacyFeatureResult',
    'GetComputeInstanceBootDiskResult',
    'GetComputeInstanceBootDiskInitializeParamResult',
    'GetComputeInstanceFilesystemResult',
    'GetComputeInstanceGroupAllocationPolicyResult',
    'GetComputeInstanceGroupAllocationPolicyInstanceTagsPoolResult',
    'GetComputeInstanceGroupApplicationBalancerStateResult',
    'GetComputeInstanceGroupApplicationLoadBalancerResult',
    'GetComputeInstanceGroupDeployPolicyResult',
    'GetComputeInstanceGroupHealthCheckResult',
    'GetComputeInstanceGroupHealthCheckHttpOptionResult',
    'GetComputeInstanceGroupHealthCheckTcpOptionResult',
    'GetComputeInstanceGroupInstanceResult',
    'GetComputeInstanceGroupInstanceNetworkInterfaceResult',
    'GetComputeInstanceGroupInstanceTemplateResult',
    'GetComputeInstanceGroupInstanceTemplateBootDiskResult',
    'GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult',
    'GetComputeInstanceGroupInstanceTemplateFilesystemResult',
    'GetComputeInstanceGroupInstanceTemplateMetadataOptionsResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult',
    'GetComputeInstanceGroupInstanceTemplateNetworkSettingResult',
    'GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult',
    'GetComputeInstanceGroupInstanceTemplateResourceResult',
    'GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult',
    'GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult',
    'GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult',
    'GetComputeInstanceGroupLoadBalancerResult',
    'GetComputeInstanceGroupLoadBalancerStateResult',
    'GetComputeInstanceGroupScalePolicyResult',
    'GetComputeInstanceGroupScalePolicyAutoScaleResult',
    'GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult',
    'GetComputeInstanceGroupScalePolicyFixedScaleResult',
    'GetComputeInstanceGroupScalePolicyTestAutoScaleResult',
    'GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult',
    'GetComputeInstanceHardwareGenerationResult',
    'GetComputeInstanceHardwareGenerationGeneration2FeatureResult',
    'GetComputeInstanceHardwareGenerationLegacyFeatureResult',
    'GetComputeInstanceLocalDiskResult',
    'GetComputeInstanceMetadataOptionsResult',
    'GetComputeInstanceNetworkInterfaceResult',
    'GetComputeInstanceNetworkInterfaceDnsRecordResult',
    'GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult',
    'GetComputeInstanceNetworkInterfaceNatDnsRecordResult',
    'GetComputeInstancePlacementPolicyResult',
    'GetComputeInstancePlacementPolicyHostAffinityRuleResult',
    'GetComputeInstanceResourceResult',
    'GetComputeInstanceSchedulingPolicyResult',
    'GetComputeInstanceSecondaryDiskResult',
    'GetComputeSnapshotHardwareGenerationResult',
    'GetComputeSnapshotHardwareGenerationGeneration2FeatureResult',
    'GetComputeSnapshotHardwareGenerationLegacyFeatureResult',
    'GetComputeSnapshotScheduleSchedulePolicyResult',
    'GetComputeSnapshotScheduleSnapshotSpecResult',
    'GetContainerRepositoryLifecyclePolicyRuleResult',
    'GetDataprocClusterClusterConfigResult',
    'GetDataprocClusterClusterConfigHadoopResult',
    'GetDataprocClusterClusterConfigHadoopInitializationActionResult',
    'GetDataprocClusterClusterConfigSubclusterSpecResult',
    'GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult',
    'GetDataprocClusterClusterConfigSubclusterSpecResourceResult',
    'GetFunctionAsyncInvocationResult',
    'GetFunctionAsyncInvocationYmqFailureTargetResult',
    'GetFunctionAsyncInvocationYmqSuccessTargetResult',
    'GetFunctionConnectivityResult',
    'GetFunctionLogOptionResult',
    'GetFunctionMetadataOptionsResult',
    'GetFunctionMountResult',
    'GetFunctionMountEphemeralDiskResult',
    'GetFunctionMountObjectStorageResult',
    'GetFunctionScalingPolicyPolicyResult',
    'GetFunctionSecretResult',
    'GetFunctionStorageMountResult',
    'GetFunctionTriggerContainerResult',
    'GetFunctionTriggerContainerRegistryResult',
    'GetFunctionTriggerDataStreamResult',
    'GetFunctionTriggerDlqResult',
    'GetFunctionTriggerFunctionResult',
    'GetFunctionTriggerIotResult',
    'GetFunctionTriggerLogGroupResult',
    'GetFunctionTriggerLoggingResult',
    'GetFunctionTriggerMailResult',
    'GetFunctionTriggerMessageQueueResult',
    'GetFunctionTriggerObjectStorageResult',
    'GetFunctionTriggerTimerResult',
    'GetIamPolicyBindingResult',
    'GetIotCoreBrokerLogOptionResult',
    'GetIotCoreRegistryLogOptionResult',
    'GetKubernetesClusterKmsProviderResult',
    'GetKubernetesClusterMasterResult',
    'GetKubernetesClusterMasterMaintenancePolicyResult',
    'GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult',
    'GetKubernetesClusterMasterMasterLocationResult',
    'GetKubernetesClusterMasterMasterLoggingResult',
    'GetKubernetesClusterMasterRegionalResult',
    'GetKubernetesClusterMasterScalePolicyResult',
    'GetKubernetesClusterMasterScalePolicyAutoScaleResult',
    'GetKubernetesClusterMasterVersionInfoResult',
    'GetKubernetesClusterMasterZonalResult',
    'GetKubernetesClusterNetworkImplementationResult',
    'GetKubernetesClusterNetworkImplementationCiliumResult',
    'GetKubernetesClusterWorkloadIdentityFederationResult',
    'GetKubernetesNodeGroupAllocationPolicyResult',
    'GetKubernetesNodeGroupAllocationPolicyLocationResult',
    'GetKubernetesNodeGroupDeployPolicyResult',
    'GetKubernetesNodeGroupInstanceTemplateResult',
    'GetKubernetesNodeGroupInstanceTemplateBootDiskResult',
    'GetKubernetesNodeGroupInstanceTemplateContainerNetworkResult',
    'GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult',
    'GetKubernetesNodeGroupInstanceTemplateGpuSettingResult',
    'GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult',
    'GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordResult',
    'GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult',
    'GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult',
    'GetKubernetesNodeGroupInstanceTemplateResourceResult',
    'GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult',
    'GetKubernetesNodeGroupMaintenancePolicyResult',
    'GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult',
    'GetKubernetesNodeGroupScalePolicyResult',
    'GetKubernetesNodeGroupScalePolicyAutoScaleResult',
    'GetKubernetesNodeGroupScalePolicyFixedScaleResult',
    'GetKubernetesNodeGroupVersionInfoResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult',
    'GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult',
    'GetLbNetworkLoadBalancerListenerResult',
    'GetLbNetworkLoadBalancerListenerExternalAddressSpecResult',
    'GetLbNetworkLoadBalancerListenerInternalAddressSpecResult',
    'GetLbTargetGroupTargetResult',
    'GetLoadtestingAgentComputeInstanceResult',
    'GetLoadtestingAgentComputeInstanceBootDiskResult',
    'GetLoadtestingAgentComputeInstanceBootDiskInitializeParamResult',
    'GetLoadtestingAgentComputeInstanceNetworkInterfaceResult',
    'GetLoadtestingAgentComputeInstanceResourceResult',
    'GetLoadtestingAgentLogSettingsResult',
    'GetLockboxSecretCurrentVersionResult',
    'GetLockboxSecretPasswordPayloadSpecificationResult',
    'GetLockboxSecretVersionEntryResult',
    'GetMdbClickhouseClusterAccessResult',
    'GetMdbClickhouseClusterBackupWindowStartResult',
    'GetMdbClickhouseClusterClickhouseResult',
    'GetMdbClickhouseClusterClickhouseConfigResult',
    'GetMdbClickhouseClusterClickhouseConfigCompressionResult',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult',
    'GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult',
    'GetMdbClickhouseClusterClickhouseConfigJdbcBridgeResult',
    'GetMdbClickhouseClusterClickhouseConfigKafkaResult',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult',
    'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult',
    'GetMdbClickhouseClusterClickhouseConfigMergeTreeResult',
    'GetMdbClickhouseClusterClickhouseConfigQueryCacheResult',
    'GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleResult',
    'GetMdbClickhouseClusterClickhouseConfigRabbitmqResult',
    'GetMdbClickhouseClusterClickhouseResourcesResult',
    'GetMdbClickhouseClusterCloudStorageResult',
    'GetMdbClickhouseClusterDatabaseResult',
    'GetMdbClickhouseClusterFormatSchemaResult',
    'GetMdbClickhouseClusterHostResult',
    'GetMdbClickhouseClusterMaintenanceWindowResult',
    'GetMdbClickhouseClusterMlModelResult',
    'GetMdbClickhouseClusterShardResult',
    'GetMdbClickhouseClusterShardGroupResult',
    'GetMdbClickhouseClusterShardResourcesResult',
    'GetMdbClickhouseClusterUserResult',
    'GetMdbClickhouseClusterUserPermissionResult',
    'GetMdbClickhouseClusterUserQuotaResult',
    'GetMdbClickhouseClusterUserSettingsResult',
    'GetMdbClickhouseClusterZookeeperResult',
    'GetMdbClickhouseClusterZookeeperResourcesResult',
    'GetMdbGreenplumClusterAccessResult',
    'GetMdbGreenplumClusterBackgroundActivityResult',
    'GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumResult',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleResult',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionResult',
    'GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningResult',
    'GetMdbGreenplumClusterBackupWindowStartResult',
    'GetMdbGreenplumClusterCloudStorageResult',
    'GetMdbGreenplumClusterLoggingResult',
    'GetMdbGreenplumClusterMaintenanceWindowResult',
    'GetMdbGreenplumClusterMasterHostResult',
    'GetMdbGreenplumClusterMasterSubclusterResult',
    'GetMdbGreenplumClusterMasterSubclusterResourceResult',
    'GetMdbGreenplumClusterPoolerConfigResult',
    'GetMdbGreenplumClusterPxfConfigResult',
    'GetMdbGreenplumClusterSegmentHostResult',
    'GetMdbGreenplumClusterSegmentSubclusterResult',
    'GetMdbGreenplumClusterSegmentSubclusterResourceResult',
    'GetMdbKafkaClusterConfigResult',
    'GetMdbKafkaClusterConfigAccessResult',
    'GetMdbKafkaClusterConfigDiskSizeAutoscalingResult',
    'GetMdbKafkaClusterConfigKafkaResult',
    'GetMdbKafkaClusterConfigKafkaKafkaConfigResult',
    'GetMdbKafkaClusterConfigKafkaResourcesResult',
    'GetMdbKafkaClusterConfigKafkaUiResult',
    'GetMdbKafkaClusterConfigKraftResult',
    'GetMdbKafkaClusterConfigKraftResourcesResult',
    'GetMdbKafkaClusterConfigRestApiResult',
    'GetMdbKafkaClusterConfigZookeeperResult',
    'GetMdbKafkaClusterConfigZookeeperResourcesResult',
    'GetMdbKafkaClusterHostResult',
    'GetMdbKafkaClusterMaintenanceWindowResult',
    'GetMdbKafkaClusterTopicResult',
    'GetMdbKafkaClusterTopicTopicConfigResult',
    'GetMdbKafkaClusterUserResult',
    'GetMdbKafkaClusterUserPermissionResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterResult',
    'GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterResult',
    'GetMdbKafkaConnectorConnectorConfigS3SinkResult',
    'GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionResult',
    'GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Result',
    'GetMdbKafkaTopicTopicConfigResult',
    'GetMdbKafkaUserPermissionResult',
    'GetMdbMongodbClusterClusterConfigResult',
    'GetMdbMongodbClusterClusterConfigAccessResult',
    'GetMdbMongodbClusterClusterConfigBackupWindowStartResult',
    'GetMdbMongodbClusterClusterConfigMongocfgResult',
    'GetMdbMongodbClusterClusterConfigMongocfgNetResult',
    'GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingResult',
    'GetMdbMongodbClusterClusterConfigMongocfgStorageResult',
    'GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerResult',
    'GetMdbMongodbClusterClusterConfigMongodResult',
    'GetMdbMongodbClusterClusterConfigMongodAuditLogResult',
    'GetMdbMongodbClusterClusterConfigMongodNetResult',
    'GetMdbMongodbClusterClusterConfigMongodOperationProfilingResult',
    'GetMdbMongodbClusterClusterConfigMongodSecurityResult',
    'GetMdbMongodbClusterClusterConfigMongodSecurityKmipResult',
    'GetMdbMongodbClusterClusterConfigMongodSetParameterResult',
    'GetMdbMongodbClusterClusterConfigMongodStorageResult',
    'GetMdbMongodbClusterClusterConfigMongodStorageJournalResult',
    'GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerResult',
    'GetMdbMongodbClusterClusterConfigMongosResult',
    'GetMdbMongodbClusterClusterConfigMongosNetResult',
    'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsResult',
    'GetMdbMongodbClusterDatabaseResult',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongocfgResult',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongodResult',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraResult',
    'GetMdbMongodbClusterDiskSizeAutoscalingMongosResult',
    'GetMdbMongodbClusterHostResult',
    'GetMdbMongodbClusterHostHostParametersResult',
    'GetMdbMongodbClusterMaintenanceWindowResult',
    'GetMdbMongodbClusterResourcesResult',
    'GetMdbMongodbClusterResourcesMongocfgResult',
    'GetMdbMongodbClusterResourcesMongodResult',
    'GetMdbMongodbClusterResourcesMongoinfraResult',
    'GetMdbMongodbClusterResourcesMongosResult',
    'GetMdbMongodbClusterRestoreResult',
    'GetMdbMongodbClusterUserResult',
    'GetMdbMongodbClusterUserPermissionResult',
    'GetMdbMysqlClusterAccessResult',
    'GetMdbMysqlClusterBackupWindowStartResult',
    'GetMdbMysqlClusterDatabaseResult',
    'GetMdbMysqlClusterDiskSizeAutoscalingResult',
    'GetMdbMysqlClusterHostResult',
    'GetMdbMysqlClusterMaintenanceWindowResult',
    'GetMdbMysqlClusterPerformanceDiagnosticResult',
    'GetMdbMysqlClusterResourceResult',
    'GetMdbMysqlClusterUserResult',
    'GetMdbMysqlClusterUserConnectionLimitResult',
    'GetMdbMysqlClusterUserPermissionResult',
    'GetMdbMysqlUserConnectionLimitResult',
    'GetMdbMysqlUserPermissionResult',
    'GetMdbPostgresqlClusterConfigResult',
    'GetMdbPostgresqlClusterConfigAccessResult',
    'GetMdbPostgresqlClusterConfigBackupWindowStartResult',
    'GetMdbPostgresqlClusterConfigDiskSizeAutoscalingResult',
    'GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult',
    'GetMdbPostgresqlClusterConfigPoolerConfigResult',
    'GetMdbPostgresqlClusterConfigResourceResult',
    'GetMdbPostgresqlClusterDatabaseResult',
    'GetMdbPostgresqlClusterDatabaseExtensionResult',
    'GetMdbPostgresqlClusterHostResult',
    'GetMdbPostgresqlClusterMaintenanceWindowResult',
    'GetMdbPostgresqlClusterUserResult',
    'GetMdbPostgresqlClusterUserPermissionResult',
    'GetMdbPostgresqlDatabaseExtensionResult',
    'GetMdbPostgresqlUserPermissionResult',
    'GetMdbRedisClusterConfigResult',
    'GetMdbRedisClusterConfigBackupWindowStartResult',
    'GetMdbRedisClusterDiskSizeAutoscalingResult',
    'GetMdbRedisClusterHostResult',
    'GetMdbRedisClusterMaintenanceWindowResult',
    'GetMdbRedisClusterResourceResult',
    'GetMdbSqlserverClusterBackupWindowStartResult',
    'GetMdbSqlserverClusterDatabaseResult',
    'GetMdbSqlserverClusterHostResult',
    'GetMdbSqlserverClusterResourceResult',
    'GetMdbSqlserverClusterUserResult',
    'GetMdbSqlserverClusterUserPermissionResult',
    'GetMonitoringDashboardParametrizationResult',
    'GetMonitoringDashboardParametrizationParameterResult',
    'GetMonitoringDashboardParametrizationParameterCustomResult',
    'GetMonitoringDashboardParametrizationParameterLabelValueResult',
    'GetMonitoringDashboardParametrizationParameterTextResult',
    'GetMonitoringDashboardWidgetResult',
    'GetMonitoringDashboardWidgetChartResult',
    'GetMonitoringDashboardWidgetChartNameHidingSettingResult',
    'GetMonitoringDashboardWidgetChartQueryResult',
    'GetMonitoringDashboardWidgetChartQueryDownsamplingResult',
    'GetMonitoringDashboardWidgetChartQueryTargetResult',
    'GetMonitoringDashboardWidgetChartSeriesOverrideResult',
    'GetMonitoringDashboardWidgetChartSeriesOverrideSettingResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftResult',
    'GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightResult',
    'GetMonitoringDashboardWidgetPositionResult',
    'GetMonitoringDashboardWidgetTextResult',
    'GetMonitoringDashboardWidgetTitleResult',
    'GetOrganizationmanagerGroupMemberResult',
    'GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsResult',
    'GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsResult',
    'GetOrganizationmanagerSamlFederationSecuritySettingResult',
    'GetServerlessContainerAsyncInvocationResult',
    'GetServerlessContainerConnectivityResult',
    'GetServerlessContainerImageResult',
    'GetServerlessContainerLogOptionResult',
    'GetServerlessContainerMetadataOptionsResult',
    'GetServerlessContainerMountResult',
    'GetServerlessContainerMountEphemeralDiskResult',
    'GetServerlessContainerMountObjectStorageResult',
    'GetServerlessContainerRuntimeResult',
    'GetServerlessContainerSecretResult',
    'GetServerlessContainerStorageMountResult',
    'GetServerlessEventrouterConnectorTimerResult',
    'GetServerlessEventrouterConnectorYdResult',
    'GetServerlessEventrouterConnectorYmqResult',
    'GetServerlessEventrouterRuleContainerResult',
    'GetServerlessEventrouterRuleFunctionResult',
    'GetServerlessEventrouterRuleFunctionBatchSettingResult',
    'GetServerlessEventrouterRuleGatewayWebsocketBroadcastResult',
    'GetServerlessEventrouterRuleLoggingResult',
    'GetServerlessEventrouterRuleWorkflowResult',
    'GetServerlessEventrouterRuleYdResult',
    'GetServerlessEventrouterRuleYmqResult',
    'GetSmartcaptchaCaptchaOverrideVariantResult',
    'GetSmartcaptchaCaptchaSecurityRuleResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionHeaderResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionHeaderValueResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionHostResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionHostHostResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionUriResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionUriPathResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryResult',
    'GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryValueResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchResult',
    'GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchResult',
    'GetSwsSecurityProfileAnalyzeRequestBodyResult',
    'GetSwsSecurityProfileSecurityRuleResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchResult',
    'GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchResult',
    'GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchResult',
    'GetSwsSecurityProfileSecurityRuleWafResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionAuthorityResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionHeaderResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionHeaderValueResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionRequestUriResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionRequestUriPathResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionSourceIpResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchResult',
    'GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchResult',
    'GetSwsWafProfileAnalyzeRequestBodyResult',
    'GetSwsWafProfileCoreRuleSetResult',
    'GetSwsWafProfileCoreRuleSetRuleSetResult',
    'GetSwsWafProfileExclusionRuleResult',
    'GetSwsWafProfileExclusionRuleConditionResult',
    'GetSwsWafProfileExclusionRuleConditionAuthorityResult',
    'GetSwsWafProfileExclusionRuleConditionAuthorityAuthorityResult',
    'GetSwsWafProfileExclusionRuleConditionHeaderResult',
    'GetSwsWafProfileExclusionRuleConditionHeaderValueResult',
    'GetSwsWafProfileExclusionRuleConditionHttpMethodResult',
    'GetSwsWafProfileExclusionRuleConditionHttpMethodHttpMethodResult',
    'GetSwsWafProfileExclusionRuleConditionRequestUriResult',
    'GetSwsWafProfileExclusionRuleConditionRequestUriPathResult',
    'GetSwsWafProfileExclusionRuleConditionRequestUriQueryResult',
    'GetSwsWafProfileExclusionRuleConditionRequestUriQueryValueResult',
    'GetSwsWafProfileExclusionRuleConditionSourceIpResult',
    'GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchResult',
    'GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchResult',
    'GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchResult',
    'GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchResult',
    'GetSwsWafProfileExclusionRuleExcludeRuleResult',
    'GetSwsWafProfileRuleResult',
    'GetSwsWafProfileRuleSetResult',
    'GetSwsWafProfileRuleSetCoreRuleSetResult',
    'GetSwsWafProfileRuleSetCoreRuleSetRuleSetResult',
    'GetSwsWafProfileRuleSetMlRuleSetResult',
    'GetSwsWafProfileRuleSetMlRuleSetRuleGroupResult',
    'GetSwsWafProfileRuleSetMlRuleSetRuleSetResult',
    'GetSwsWafProfileRuleSetYaRuleSetResult',
    'GetSwsWafProfileRuleSetYaRuleSetRuleGroupResult',
    'GetSwsWafProfileRuleSetYaRuleSetRuleSetResult',
    'GetSwsWafRuleSetDescriptorRuleResult',
    'GetVpcAddressDnsRecordResult',
    'GetVpcAddressExternalIpv4AddressResult',
    'GetVpcGatewaySharedEgressGatewayResult',
    'GetVpcPrivateEndpointDnsOptionResult',
    'GetVpcPrivateEndpointEndpointAddressResult',
    'GetVpcPrivateEndpointObjectStorageResult',
    'GetVpcRouteTableStaticRouteResult',
    'GetVpcSecurityGroupEgressResult',
    'GetVpcSecurityGroupIngressResult',
    'GetVpcSubnetDhcpOptionResult',
    'GetYdbDatabaseDedicatedLocationResult',
    'GetYdbDatabaseDedicatedLocationRegionResult',
    'GetYdbDatabaseDedicatedScalePolicyResult',
    'GetYdbDatabaseDedicatedScalePolicyAutoScaleResult',
    'GetYdbDatabaseDedicatedScalePolicyAutoScaleTargetTrackingResult',
    'GetYdbDatabaseDedicatedScalePolicyFixedScaleResult',
    'GetYdbDatabaseDedicatedStorageConfigResult',
    'GetYdbDatabaseServerlessServerlessDatabaseResult',
]

@pulumi.output_type
class AlbBackendGroupGrpcBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupIds":
            suggest = "target_group_ids"
        elif key == "loadBalancingConfig":
            suggest = "load_balancing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 target_group_ids: Sequence[_builtins.str],
                 healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheck'] = None,
                 load_balancing_config: Optional['outputs.AlbBackendGroupGrpcBackendLoadBalancingConfig'] = None,
                 port: Optional[_builtins.int] = None,
                 tls: Optional['outputs.AlbBackendGroupGrpcBackendTls'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of the backend.
        :param Sequence[_builtins.str] target_group_ids: References target groups for the backend.
        :param 'AlbBackendGroupGrpcBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend.
        :param 'AlbBackendGroupGrpcBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend.
        :param _builtins.int port: Port for incoming traffic.
        :param 'AlbBackendGroupGrpcBackendTlsArgs' tls: TLS specification that will be used by this backend.
               
               > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        :param _builtins.int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[_builtins.str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheck']:
        """
        Healthcheck specification that will be used by this backend.
        """
        return pulumi.get(self, "healthcheck")

    @_builtins.property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional['outputs.AlbBackendGroupGrpcBackendLoadBalancingConfig']:
        """
        Load Balancing Config specification that will be used by this backend.
        """
        return pulumi.get(self, "load_balancing_config")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbBackendGroupGrpcBackendTls']:
        """
        TLS specification that will be used by this backend.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcHealthcheck":
            suggest = "grpc_healthcheck"
        elif key == "healthcheckPort":
            suggest = "healthcheck_port"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpHealthcheck":
            suggest = "http_healthcheck"
        elif key == "intervalJitterPercent":
            suggest = "interval_jitter_percent"
        elif key == "streamHealthcheck":
            suggest = "stream_healthcheck"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: _builtins.str,
                 timeout: _builtins.str,
                 grpc_healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck'] = None,
                 healthcheck_port: Optional[_builtins.int] = None,
                 healthy_threshold: Optional[_builtins.int] = None,
                 http_healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck'] = None,
                 interval_jitter_percent: Optional[_builtins.float] = None,
                 stream_healthcheck: Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck'] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str interval: Interval between health checks.
        :param _builtins.str timeout: Time to wait for a health check response.
        :param 'AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: gRPC Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int healthcheck_port: Optional alternative port for health checking.
        :param _builtins.int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: HTTP Healthcheck specification that will be used by this healthcheck.
        :param _builtins.float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        :param 'AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck']:
        """
        gRPC Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @_builtins.property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[_builtins.int]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck']:
        """
        HTTP Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "http_healthcheck")

    @_builtins.property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[_builtins.float]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @_builtins.property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional['outputs.AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck']:
        """
        Stream Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "stream_healthcheck")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_name: Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedStatuses":
            suggest = "expected_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 expected_statuses: Optional[Sequence[_builtins.int]] = None,
                 host: Optional[_builtins.str] = None,
                 http2: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: HTTP path.
        :param Sequence[_builtins.int] expected_statuses: A list of HTTP response statuses considered healthy.
        :param _builtins.str host: `Host` HTTP header value.
        :param _builtins.bool http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if expected_statuses is not None:
            pulumi.set(__self__, "expected_statuses", expected_statuses)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Optional[Sequence[_builtins.int]]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        `Host` HTTP header value.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> Optional[_builtins.bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck(dict):
    def __init__(__self__, *,
                 receive: Optional[_builtins.str] = None,
                 send: Optional[_builtins.str] = None):
        """
        :param _builtins.str receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param _builtins.str send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> Optional[_builtins.str]:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @_builtins.property
    @pulumi.getter
    def send(self) -> Optional[_builtins.str]:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class AlbBackendGroupGrpcBackendLoadBalancingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localityAwareRoutingPercent":
            suggest = "locality_aware_routing_percent"
        elif key == "panicThreshold":
            suggest = "panic_threshold"
        elif key == "strictLocality":
            suggest = "strict_locality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendLoadBalancingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendLoadBalancingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendLoadBalancingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 panic_threshold: Optional[_builtins.int] = None,
                 strict_locality: Optional[_builtins.bool] = None):
        """
        :param _builtins.int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param _builtins.str mode: Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        :param _builtins.int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param _builtins.bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @_builtins.property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[_builtins.int]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[_builtins.int]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @_builtins.property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[_builtins.bool]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class AlbBackendGroupGrpcBackendTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationContext":
            suggest = "validation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sni: Optional[_builtins.str] = None,
                 validation_context: Optional['outputs.AlbBackendGroupGrpcBackendTlsValidationContext'] = None):
        """
        :param _builtins.str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[_builtins.str]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional['outputs.AlbBackendGroupGrpcBackendTlsValidationContext']:
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class AlbBackendGroupGrpcBackendTlsValidationContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaBytes":
            suggest = "trusted_ca_bytes"
        elif key == "trustedCaId":
            suggest = "trusted_ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupGrpcBackendTlsValidationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupGrpcBackendTlsValidationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupGrpcBackendTlsValidationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[_builtins.str] = None,
                 trusted_ca_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param _builtins.str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @_builtins.property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[_builtins.str]:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @_builtins.property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[_builtins.str]:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class AlbBackendGroupHttpBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancingConfig":
            suggest = "load_balancing_config"
        elif key == "storageBucket":
            suggest = "storage_bucket"
        elif key == "targetGroupIds":
            suggest = "target_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheck'] = None,
                 http2: Optional[_builtins.bool] = None,
                 load_balancing_config: Optional['outputs.AlbBackendGroupHttpBackendLoadBalancingConfig'] = None,
                 port: Optional[_builtins.int] = None,
                 storage_bucket: Optional[_builtins.str] = None,
                 target_group_ids: Optional[Sequence[_builtins.str]] = None,
                 tls: Optional['outputs.AlbBackendGroupHttpBackendTls'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of the backend.
        :param 'AlbBackendGroupHttpBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend.
        :param _builtins.bool http2: Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        :param 'AlbBackendGroupHttpBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend.
        :param _builtins.int port: Port for incoming traffic.
        :param _builtins.str storage_bucket: Name of bucket which should be used as a backend.
        :param Sequence[_builtins.str] target_group_ids: References target groups for the backend.
        :param 'AlbBackendGroupHttpBackendTlsArgs' tls: TLS specification that will be used by this backend.
               
               > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        :param _builtins.int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if storage_bucket is not None:
            pulumi.set(__self__, "storage_bucket", storage_bucket)
        if target_group_ids is not None:
            pulumi.set(__self__, "target_group_ids", target_group_ids)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheck']:
        """
        Healthcheck specification that will be used by this backend.
        """
        return pulumi.get(self, "healthcheck")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> Optional[_builtins.bool]:
        """
        Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        """
        return pulumi.get(self, "http2")

    @_builtins.property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional['outputs.AlbBackendGroupHttpBackendLoadBalancingConfig']:
        """
        Load Balancing Config specification that will be used by this backend.
        """
        return pulumi.get(self, "load_balancing_config")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="storageBucket")
    def storage_bucket(self) -> Optional[_builtins.str]:
        """
        Name of bucket which should be used as a backend.
        """
        return pulumi.get(self, "storage_bucket")

    @_builtins.property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbBackendGroupHttpBackendTls']:
        """
        TLS specification that will be used by this backend.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcHealthcheck":
            suggest = "grpc_healthcheck"
        elif key == "healthcheckPort":
            suggest = "healthcheck_port"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpHealthcheck":
            suggest = "http_healthcheck"
        elif key == "intervalJitterPercent":
            suggest = "interval_jitter_percent"
        elif key == "streamHealthcheck":
            suggest = "stream_healthcheck"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: _builtins.str,
                 timeout: _builtins.str,
                 grpc_healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck'] = None,
                 healthcheck_port: Optional[_builtins.int] = None,
                 healthy_threshold: Optional[_builtins.int] = None,
                 http_healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck'] = None,
                 interval_jitter_percent: Optional[_builtins.float] = None,
                 stream_healthcheck: Optional['outputs.AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck'] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str interval: Interval between health checks.
        :param _builtins.str timeout: Time to wait for a health check response.
        :param 'AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: gRPC Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int healthcheck_port: Optional alternative port for health checking.
        :param _builtins.int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'AlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: HTTP Healthcheck specification that will be used by this healthcheck.
        :param _builtins.float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        :param 'AlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck']:
        """
        gRPC Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @_builtins.property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[_builtins.int]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck']:
        """
        HTTP Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "http_healthcheck")

    @_builtins.property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[_builtins.float]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @_builtins.property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional['outputs.AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck']:
        """
        Stream Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "stream_healthcheck")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_name: Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedStatuses":
            suggest = "expected_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 expected_statuses: Optional[Sequence[_builtins.int]] = None,
                 host: Optional[_builtins.str] = None,
                 http2: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: HTTP path.
        :param Sequence[_builtins.int] expected_statuses: A list of HTTP response statuses considered healthy.
        :param _builtins.str host: `Host` HTTP header value.
        :param _builtins.bool http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if expected_statuses is not None:
            pulumi.set(__self__, "expected_statuses", expected_statuses)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Optional[Sequence[_builtins.int]]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        `Host` HTTP header value.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> Optional[_builtins.bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck(dict):
    def __init__(__self__, *,
                 receive: Optional[_builtins.str] = None,
                 send: Optional[_builtins.str] = None):
        """
        :param _builtins.str receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param _builtins.str send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> Optional[_builtins.str]:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @_builtins.property
    @pulumi.getter
    def send(self) -> Optional[_builtins.str]:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class AlbBackendGroupHttpBackendLoadBalancingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localityAwareRoutingPercent":
            suggest = "locality_aware_routing_percent"
        elif key == "panicThreshold":
            suggest = "panic_threshold"
        elif key == "strictLocality":
            suggest = "strict_locality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendLoadBalancingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendLoadBalancingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendLoadBalancingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 panic_threshold: Optional[_builtins.int] = None,
                 strict_locality: Optional[_builtins.bool] = None):
        """
        :param _builtins.int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param _builtins.str mode: Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        :param _builtins.int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param _builtins.bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @_builtins.property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[_builtins.int]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[_builtins.int]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @_builtins.property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[_builtins.bool]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class AlbBackendGroupHttpBackendTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationContext":
            suggest = "validation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sni: Optional[_builtins.str] = None,
                 validation_context: Optional['outputs.AlbBackendGroupHttpBackendTlsValidationContext'] = None):
        """
        :param _builtins.str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[_builtins.str]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional['outputs.AlbBackendGroupHttpBackendTlsValidationContext']:
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class AlbBackendGroupHttpBackendTlsValidationContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaBytes":
            suggest = "trusted_ca_bytes"
        elif key == "trustedCaId":
            suggest = "trusted_ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupHttpBackendTlsValidationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupHttpBackendTlsValidationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupHttpBackendTlsValidationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[_builtins.str] = None,
                 trusted_ca_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param _builtins.str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @_builtins.property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[_builtins.str]:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @_builtins.property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[_builtins.str]:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class AlbBackendGroupSessionAffinity(dict):
    def __init__(__self__, *,
                 connection: Optional['outputs.AlbBackendGroupSessionAffinityConnection'] = None,
                 cookie: Optional['outputs.AlbBackendGroupSessionAffinityCookie'] = None,
                 header: Optional['outputs.AlbBackendGroupSessionAffinityHeader'] = None):
        """
        :param 'AlbBackendGroupSessionAffinityConnectionArgs' connection: Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address.
        :param 'AlbBackendGroupSessionAffinityCookieArgs' cookie: Requests with the same cookie value and the specified file name are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        :param 'AlbBackendGroupSessionAffinityHeaderArgs' header: Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.AlbBackendGroupSessionAffinityConnection']:
        """
        Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.AlbBackendGroupSessionAffinityCookie']:
        """
        Requests with the same cookie value and the specified file name are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        """
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.AlbBackendGroupSessionAffinityHeader']:
        """
        Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        """
        return pulumi.get(self, "header")


@pulumi.output_type
class AlbBackendGroupSessionAffinityConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupSessionAffinityConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupSessionAffinityConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupSessionAffinityConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_ip: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool source_ip: Source IP address to use with affinity.
        """
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.bool]:
        """
        Source IP address to use with affinity.
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class AlbBackendGroupSessionAffinityCookie(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the HTTP cookie to use with affinity.
        :param _builtins.str ttl: TTL for the cookie (if not set, session cookie will be used).
        """
        pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the HTTP cookie to use with affinity.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        TTL for the cookie (if not set, session cookie will be used).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class AlbBackendGroupSessionAffinityHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupSessionAffinityHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupSessionAffinityHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupSessionAffinityHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: _builtins.str):
        """
        :param _builtins.str header_name: The name of the request header that will be used with affinity.
        """
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the request header that will be used with affinity.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class AlbBackendGroupStreamBackend(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupIds":
            suggest = "target_group_ids"
        elif key == "enableProxyProtocol":
            suggest = "enable_proxy_protocol"
        elif key == "keepConnectionsOnHostHealthFailure":
            suggest = "keep_connections_on_host_health_failure"
        elif key == "loadBalancingConfig":
            suggest = "load_balancing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackend. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackend.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackend.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 target_group_ids: Sequence[_builtins.str],
                 enable_proxy_protocol: Optional[_builtins.bool] = None,
                 healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheck'] = None,
                 keep_connections_on_host_health_failure: Optional[_builtins.bool] = None,
                 load_balancing_config: Optional['outputs.AlbBackendGroupStreamBackendLoadBalancingConfig'] = None,
                 port: Optional[_builtins.int] = None,
                 tls: Optional['outputs.AlbBackendGroupStreamBackendTls'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of the backend.
        :param Sequence[_builtins.str] target_group_ids: References target groups for the backend.
        :param 'AlbBackendGroupStreamBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend.
        :param _builtins.bool keep_connections_on_host_health_failure: If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        :param 'AlbBackendGroupStreamBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend.
        :param _builtins.int port: Port for incoming traffic.
        :param 'AlbBackendGroupStreamBackendTlsArgs' tls: TLS specification that will be used by this backend.
               
               > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        :param _builtins.int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        if enable_proxy_protocol is not None:
            pulumi.set(__self__, "enable_proxy_protocol", enable_proxy_protocol)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if keep_connections_on_host_health_failure is not None:
            pulumi.set(__self__, "keep_connections_on_host_health_failure", keep_connections_on_host_health_failure)
        if load_balancing_config is not None:
            pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[_builtins.str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @_builtins.property
    @pulumi.getter(name="enableProxyProtocol")
    def enable_proxy_protocol(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_proxy_protocol")

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheck']:
        """
        Healthcheck specification that will be used by this backend.
        """
        return pulumi.get(self, "healthcheck")

    @_builtins.property
    @pulumi.getter(name="keepConnectionsOnHostHealthFailure")
    def keep_connections_on_host_health_failure(self) -> Optional[_builtins.bool]:
        """
        If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        return pulumi.get(self, "keep_connections_on_host_health_failure")

    @_builtins.property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> Optional['outputs.AlbBackendGroupStreamBackendLoadBalancingConfig']:
        """
        Load Balancing Config specification that will be used by this backend.
        """
        return pulumi.get(self, "load_balancing_config")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbBackendGroupStreamBackendTls']:
        """
        TLS specification that will be used by this backend.

        > Only one of `validation_context.0.trusted_ca_id` or `validation_context.0.trusted_ca_bytes` should be specified.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcHealthcheck":
            suggest = "grpc_healthcheck"
        elif key == "healthcheckPort":
            suggest = "healthcheck_port"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpHealthcheck":
            suggest = "http_healthcheck"
        elif key == "intervalJitterPercent":
            suggest = "interval_jitter_percent"
        elif key == "streamHealthcheck":
            suggest = "stream_healthcheck"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval: _builtins.str,
                 timeout: _builtins.str,
                 grpc_healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck'] = None,
                 healthcheck_port: Optional[_builtins.int] = None,
                 healthy_threshold: Optional[_builtins.int] = None,
                 http_healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck'] = None,
                 interval_jitter_percent: Optional[_builtins.float] = None,
                 stream_healthcheck: Optional['outputs.AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck'] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str interval: Interval between health checks.
        :param _builtins.str timeout: Time to wait for a health check response.
        :param 'AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: gRPC Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int healthcheck_port: Optional alternative port for health checking.
        :param _builtins.int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'AlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: HTTP Healthcheck specification that will be used by this healthcheck.
        :param _builtins.float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        :param 'AlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "timeout", timeout)
        if grpc_healthcheck is not None:
            pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        if healthcheck_port is not None:
            pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_healthcheck is not None:
            pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        if interval_jitter_percent is not None:
            pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        if stream_healthcheck is not None:
            pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck']:
        """
        gRPC Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @_builtins.property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> Optional[_builtins.int]:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck']:
        """
        HTTP Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "http_healthcheck")

    @_builtins.property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> Optional[_builtins.float]:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @_builtins.property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> Optional['outputs.AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck']:
        """
        Stream Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "stream_healthcheck")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_name: Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectedStatuses":
            suggest = "expected_statuses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: _builtins.str,
                 expected_statuses: Optional[Sequence[_builtins.int]] = None,
                 host: Optional[_builtins.str] = None,
                 http2: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: HTTP path.
        :param Sequence[_builtins.int] expected_statuses: A list of HTTP response statuses considered healthy.
        :param _builtins.str host: `Host` HTTP header value.
        :param _builtins.bool http2: If set, health checks will use HTTP2.
        """
        pulumi.set(__self__, "path", path)
        if expected_statuses is not None:
            pulumi.set(__self__, "expected_statuses", expected_statuses)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Optional[Sequence[_builtins.int]]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        `Host` HTTP header value.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> Optional[_builtins.bool]:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")


@pulumi.output_type
class AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck(dict):
    def __init__(__self__, *,
                 receive: Optional[_builtins.str] = None,
                 send: Optional[_builtins.str] = None):
        """
        :param _builtins.str receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param _builtins.str send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        if receive is not None:
            pulumi.set(__self__, "receive", receive)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> Optional[_builtins.str]:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @_builtins.property
    @pulumi.getter
    def send(self) -> Optional[_builtins.str]:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class AlbBackendGroupStreamBackendLoadBalancingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localityAwareRoutingPercent":
            suggest = "locality_aware_routing_percent"
        elif key == "panicThreshold":
            suggest = "panic_threshold"
        elif key == "strictLocality":
            suggest = "strict_locality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendLoadBalancingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendLoadBalancingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendLoadBalancingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locality_aware_routing_percent: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 panic_threshold: Optional[_builtins.int] = None,
                 strict_locality: Optional[_builtins.bool] = None):
        """
        :param _builtins.int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param _builtins.str mode: Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        :param _builtins.int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param _builtins.bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        if locality_aware_routing_percent is not None:
            pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if panic_threshold is not None:
            pulumi.set(__self__, "panic_threshold", panic_threshold)
        if strict_locality is not None:
            pulumi.set(__self__, "strict_locality", strict_locality)

    @_builtins.property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> Optional[_builtins.int]:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> Optional[_builtins.int]:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @_builtins.property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> Optional[_builtins.bool]:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class AlbBackendGroupStreamBackendTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationContext":
            suggest = "validation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sni: Optional[_builtins.str] = None,
                 validation_context: Optional['outputs.AlbBackendGroupStreamBackendTlsValidationContext'] = None):
        """
        :param _builtins.str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if validation_context is not None:
            pulumi.set(__self__, "validation_context", validation_context)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[_builtins.str]:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> Optional['outputs.AlbBackendGroupStreamBackendTlsValidationContext']:
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class AlbBackendGroupStreamBackendTlsValidationContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaBytes":
            suggest = "trusted_ca_bytes"
        elif key == "trustedCaId":
            suggest = "trusted_ca_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbBackendGroupStreamBackendTlsValidationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbBackendGroupStreamBackendTlsValidationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbBackendGroupStreamBackendTlsValidationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_ca_bytes: Optional[_builtins.str] = None,
                 trusted_ca_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param _builtins.str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        if trusted_ca_bytes is not None:
            pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        if trusted_ca_id is not None:
            pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @_builtins.property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> Optional[_builtins.str]:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @_builtins.property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> Optional[_builtins.str]:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class AlbHttpRouterRouteOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityProfileId":
            suggest = "security_profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbHttpRouterRouteOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbHttpRouterRouteOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbHttpRouterRouteOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rbac: Optional['outputs.AlbHttpRouterRouteOptionsRbac'] = None,
                 security_profile_id: Optional[_builtins.str] = None):
        """
        :param 'AlbHttpRouterRouteOptionsRbacArgs' rbac: RBAC configuration.
        :param _builtins.str security_profile_id: SWS profile ID.
        """
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @_builtins.property
    @pulumi.getter
    def rbac(self) -> Optional['outputs.AlbHttpRouterRouteOptionsRbac']:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbac")

    @_builtins.property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[_builtins.str]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")


@pulumi.output_type
class AlbHttpRouterRouteOptionsRbac(dict):
    def __init__(__self__, *,
                 principals: Sequence['outputs.AlbHttpRouterRouteOptionsRbacPrincipal'],
                 action: Optional[_builtins.str] = None):
        pulumi.set(__self__, "principals", principals)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence['outputs.AlbHttpRouterRouteOptionsRbacPrincipal']:
        return pulumi.get(self, "principals")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action")


@pulumi.output_type
class AlbHttpRouterRouteOptionsRbacPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andPrincipals":
            suggest = "and_principals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbHttpRouterRouteOptionsRbacPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbHttpRouterRouteOptionsRbacPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbHttpRouterRouteOptionsRbacPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_principals: Sequence['outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal']):
        pulumi.set(__self__, "and_principals", and_principals)

    @_builtins.property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> Sequence['outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal']:
        return pulumi.get(self, "and_principals")


@pulumi.output_type
class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteIp":
            suggest = "remote_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any: Optional[_builtins.bool] = None,
                 header: Optional['outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader'] = None,
                 remote_ip: Optional[_builtins.str] = None):
        if any is not None:
            pulumi.set(__self__, "any", any)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if remote_ip is not None:
            pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: Optional['outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue'] = None):
        """
        :param 'AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs' value: The `path` and `fqmn` blocks.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AlbLoadBalancerAllocationPolicy(dict):
    def __init__(__self__, *,
                 locations: Sequence['outputs.AlbLoadBalancerAllocationPolicyLocation']):
        """
        :param Sequence['AlbLoadBalancerAllocationPolicyLocationArgs'] locations: Unique set of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.AlbLoadBalancerAllocationPolicyLocation']:
        """
        Unique set of locations.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class AlbLoadBalancerAllocationPolicyLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "disableTraffic":
            suggest = "disable_traffic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerAllocationPolicyLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerAllocationPolicyLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerAllocationPolicyLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 zone_id: _builtins.str,
                 disable_traffic: Optional[_builtins.bool] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet that location is located at.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool disable_traffic: If set, will disable all L7 instances in the zone for request handling.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if disable_traffic is not None:
            pulumi.set(__self__, "disable_traffic", disable_traffic)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet that location is located at.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter(name="disableTraffic")
    def disable_traffic(self) -> Optional[_builtins.bool]:
        """
        If set, will disable all L7 instances in the zone for request handling.
        """
        return pulumi.get(self, "disable_traffic")


@pulumi.output_type
class AlbLoadBalancerAutoScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minZoneSize":
            suggest = "min_zone_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerAutoScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerAutoScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerAutoScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: Optional[_builtins.int] = None,
                 min_zone_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_size: Upper limit for total instance count (across all zones)
        :param _builtins.int min_zone_size: Lower limit for instance count in each zone.
        """
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        Upper limit for total instance count (across all zones)
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[_builtins.int]:
        """
        Lower limit for instance count in each zone.
        """
        return pulumi.get(self, "min_zone_size")


@pulumi.output_type
class AlbLoadBalancerListener(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 endpoints: Optional[Sequence['outputs.AlbLoadBalancerListenerEndpoint']] = None,
                 http: Optional['outputs.AlbLoadBalancerListenerHttp'] = None,
                 stream: Optional['outputs.AlbLoadBalancerListenerStream'] = None,
                 tls: Optional['outputs.AlbLoadBalancerListenerTls'] = None):
        """
        :param _builtins.str name: Name of the listener.
        :param Sequence['AlbLoadBalancerListenerEndpointArgs'] endpoints: Network endpoint (addresses and ports) of the listener.
        :param 'AlbLoadBalancerListenerHttpArgs' http: HTTP handler that sets plain text HTTP router.
        :param 'AlbLoadBalancerListenerStreamArgs' stream: Stream configuration
        :param 'AlbLoadBalancerListenerTlsArgs' tls: TLS configuration
        """
        pulumi.set(__self__, "name", name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the listener.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AlbLoadBalancerListenerEndpoint']]:
        """
        Network endpoint (addresses and ports) of the listener.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional['outputs.AlbLoadBalancerListenerHttp']:
        """
        HTTP handler that sets plain text HTTP router.
        """
        return pulumi.get(self, "http")

    @_builtins.property
    @pulumi.getter
    def stream(self) -> Optional['outputs.AlbLoadBalancerListenerStream']:
        """
        Stream configuration
        """
        return pulumi.get(self, "stream")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AlbLoadBalancerListenerTls']:
        """
        TLS configuration
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class AlbLoadBalancerListenerEndpoint(dict):
    def __init__(__self__, *,
                 addresses: Sequence['outputs.AlbLoadBalancerListenerEndpointAddress'],
                 ports: Sequence[_builtins.int]):
        """
        :param Sequence['AlbLoadBalancerListenerEndpointAddressArgs'] addresses: One or more addresses to listen on.
        :param Sequence[_builtins.int] ports: One or more ports to listen on.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence['outputs.AlbLoadBalancerListenerEndpointAddress']:
        """
        One or more addresses to listen on.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.int]:
        """
        One or more ports to listen on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIpv4Address":
            suggest = "external_ipv4_address"
        elif key == "externalIpv6Address":
            suggest = "external_ipv6_address"
        elif key == "internalIpv4Address":
            suggest = "internal_ipv4_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerEndpointAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerEndpointAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerEndpointAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_ipv4_address: Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv4Address'] = None,
                 external_ipv6_address: Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv6Address'] = None,
                 internal_ipv4_address: Optional['outputs.AlbLoadBalancerListenerEndpointAddressInternalIpv4Address'] = None):
        """
        :param 'AlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs' external_ipv4_address: External IPv4 address.
        :param 'AlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs' external_ipv6_address: External IPv6 address.
        :param 'AlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs' internal_ipv4_address: Internal IPv4 address.
        """
        if external_ipv4_address is not None:
            pulumi.set(__self__, "external_ipv4_address", external_ipv4_address)
        if external_ipv6_address is not None:
            pulumi.set(__self__, "external_ipv6_address", external_ipv6_address)
        if internal_ipv4_address is not None:
            pulumi.set(__self__, "internal_ipv4_address", internal_ipv4_address)

    @_builtins.property
    @pulumi.getter(name="externalIpv4Address")
    def external_ipv4_address(self) -> Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv4Address']:
        """
        External IPv4 address.
        """
        return pulumi.get(self, "external_ipv4_address")

    @_builtins.property
    @pulumi.getter(name="externalIpv6Address")
    def external_ipv6_address(self) -> Optional['outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv6Address']:
        """
        External IPv6 address.
        """
        return pulumi.get(self, "external_ipv6_address")

    @_builtins.property
    @pulumi.getter(name="internalIpv4Address")
    def internal_ipv4_address(self) -> Optional['outputs.AlbLoadBalancerListenerEndpointAddressInternalIpv4Address']:
        """
        Internal IPv4 address.
        """
        return pulumi.get(self, "internal_ipv4_address")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddressExternalIpv4Address(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Provided by the client or computed automatically.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddressExternalIpv6Address(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Provided by the client or computed automatically.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class AlbLoadBalancerListenerEndpointAddressInternalIpv4Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerEndpointAddressInternalIpv4Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerEndpointAddressInternalIpv4Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerEndpointAddressInternalIpv4Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Provided by the client or computed automatically.
        :param _builtins.str subnet_id: ID of the subnet that the address belongs to.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet that the address belongs to.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AlbLoadBalancerListenerHttp(dict):
    def __init__(__self__, *,
                 handler: Optional['outputs.AlbLoadBalancerListenerHttpHandler'] = None,
                 redirects: Optional['outputs.AlbLoadBalancerListenerHttpRedirects'] = None):
        """
        :param 'AlbLoadBalancerListenerHttpHandlerArgs' handler: HTTP handler.
        :param 'AlbLoadBalancerListenerHttpRedirectsArgs' redirects: Shortcut for adding http > https redirects.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @_builtins.property
    @pulumi.getter
    def handler(self) -> Optional['outputs.AlbLoadBalancerListenerHttpHandler']:
        """
        HTTP handler.
        """
        return pulumi.get(self, "handler")

    @_builtins.property
    @pulumi.getter
    def redirects(self) -> Optional['outputs.AlbLoadBalancerListenerHttpRedirects']:
        """
        Shortcut for adding http > https redirects.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class AlbLoadBalancerListenerHttpHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHttp10":
            suggest = "allow_http10"
        elif key == "http2Options":
            suggest = "http2_options"
        elif key == "httpRouterId":
            suggest = "http_router_id"
        elif key == "rewriteRequestId":
            suggest = "rewrite_request_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerHttpHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerHttpHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerHttpHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_http10: Optional[_builtins.bool] = None,
                 http2_options: Optional['outputs.AlbLoadBalancerListenerHttpHandlerHttp2Options'] = None,
                 http_router_id: Optional[_builtins.str] = None,
                 rewrite_request_id: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        :param 'AlbLoadBalancerListenerHttpHandlerHttp2OptionsArgs' http2_options: If set, will enable HTTP2 protocol for the handler.
        :param _builtins.str http_router_id: HTTP router id.
        :param _builtins.bool rewrite_request_id: When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)
        if rewrite_request_id is not None:
            pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)

    @_builtins.property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[_builtins.bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")

    @_builtins.property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional['outputs.AlbLoadBalancerListenerHttpHandlerHttp2Options']:
        """
        If set, will enable HTTP2 protocol for the handler.
        """
        return pulumi.get(self, "http2_options")

    @_builtins.property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[_builtins.str]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @_builtins.property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> Optional[_builtins.bool]:
        """
        When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")


@pulumi.output_type
class AlbLoadBalancerListenerHttpHandlerHttp2Options(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentStreams":
            suggest = "max_concurrent_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerHttpHandlerHttp2Options. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerHttpHandlerHttp2Options.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerHttpHandlerHttp2Options.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_streams: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class AlbLoadBalancerListenerHttpRedirects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpToHttps":
            suggest = "http_to_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerHttpRedirects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerHttpRedirects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerHttpRedirects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_to_https: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool http_to_https: If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
        if http_to_https is not None:
            pulumi.set(__self__, "http_to_https", http_to_https)

    @_builtins.property
    @pulumi.getter(name="httpToHttps")
    def http_to_https(self) -> Optional[_builtins.bool]:
        """
        If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
        return pulumi.get(self, "http_to_https")


@pulumi.output_type
class AlbLoadBalancerListenerStream(dict):
    def __init__(__self__, *,
                 handler: Optional['outputs.AlbLoadBalancerListenerStreamHandler'] = None):
        """
        :param 'AlbLoadBalancerListenerStreamHandlerArgs' handler: Stream handler resource.
        """
        if handler is not None:
            pulumi.set(__self__, "handler", handler)

    @_builtins.property
    @pulumi.getter
    def handler(self) -> Optional['outputs.AlbLoadBalancerListenerStreamHandler']:
        """
        Stream handler resource.
        """
        return pulumi.get(self, "handler")


@pulumi.output_type
class AlbLoadBalancerListenerStreamHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerStreamHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerStreamHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerStreamHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: Optional[_builtins.str] = None,
                 idle_timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str backend_group_id: Backend Group ID.
        :param _builtins.str idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[_builtins.str]:
        """
        Backend Group ID.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class AlbLoadBalancerListenerTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultHandler":
            suggest = "default_handler"
        elif key == "sniHandlers":
            suggest = "sni_handlers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_handler: 'outputs.AlbLoadBalancerListenerTlsDefaultHandler',
                 sni_handlers: Optional[Sequence['outputs.AlbLoadBalancerListenerTlsSniHandler']] = None):
        """
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerArgs' default_handler: TLS handler resource.
        :param Sequence['AlbLoadBalancerListenerTlsSniHandlerArgs'] sni_handlers: Settings for handling requests with Server Name Indication (SNI)
        """
        pulumi.set(__self__, "default_handler", default_handler)
        if sni_handlers is not None:
            pulumi.set(__self__, "sni_handlers", sni_handlers)

    @_builtins.property
    @pulumi.getter(name="defaultHandler")
    def default_handler(self) -> 'outputs.AlbLoadBalancerListenerTlsDefaultHandler':
        """
        TLS handler resource.
        """
        return pulumi.get(self, "default_handler")

    @_builtins.property
    @pulumi.getter(name="sniHandlers")
    def sni_handlers(self) -> Optional[Sequence['outputs.AlbLoadBalancerListenerTlsSniHandler']]:
        """
        Settings for handling requests with Server Name Indication (SNI)
        """
        return pulumi.get(self, "sni_handlers")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateIds":
            suggest = "certificate_ids"
        elif key == "httpHandler":
            suggest = "http_handler"
        elif key == "streamHandler":
            suggest = "stream_handler"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_ids: Sequence[_builtins.str],
                 http_handler: Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler'] = None,
                 stream_handler: Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler'] = None):
        """
        :param Sequence[_builtins.str] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerArgs' http_handler: HTTP handler.
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerStreamHandlerArgs' stream_handler: Stream handler resource.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handler is not None:
            pulumi.set(__self__, "http_handler", http_handler)
        if stream_handler is not None:
            pulumi.set(__self__, "stream_handler", stream_handler)

    @_builtins.property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[_builtins.str]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        """
        return pulumi.get(self, "certificate_ids")

    @_builtins.property
    @pulumi.getter(name="httpHandler")
    def http_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler']:
        """
        HTTP handler.
        """
        return pulumi.get(self, "http_handler")

    @_builtins.property
    @pulumi.getter(name="streamHandler")
    def stream_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler']:
        """
        Stream handler resource.
        """
        return pulumi.get(self, "stream_handler")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHttp10":
            suggest = "allow_http10"
        elif key == "http2Options":
            suggest = "http2_options"
        elif key == "httpRouterId":
            suggest = "http_router_id"
        elif key == "rewriteRequestId":
            suggest = "rewrite_request_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_http10: Optional[_builtins.bool] = None,
                 http2_options: Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options'] = None,
                 http_router_id: Optional[_builtins.str] = None,
                 rewrite_request_id: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        :param 'AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2OptionsArgs' http2_options: If set, will enable HTTP2 protocol for the handler.
        :param _builtins.str http_router_id: HTTP router id.
        :param _builtins.bool rewrite_request_id: When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)
        if rewrite_request_id is not None:
            pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)

    @_builtins.property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[_builtins.bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")

    @_builtins.property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional['outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options']:
        """
        If set, will enable HTTP2 protocol for the handler.
        """
        return pulumi.get(self, "http2_options")

    @_builtins.property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[_builtins.str]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @_builtins.property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> Optional[_builtins.bool]:
        """
        When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentStreams":
            suggest = "max_concurrent_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_streams: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: Optional[_builtins.str] = None,
                 idle_timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str backend_group_id: Backend Group ID.
        :param _builtins.str idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[_builtins.str]:
        """
        Backend Group ID.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverNames":
            suggest = "server_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 handler: 'outputs.AlbLoadBalancerListenerTlsSniHandlerHandler',
                 name: _builtins.str,
                 server_names: Sequence[_builtins.str]):
        """
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerArgs' handler: TLS handler resource.
        :param _builtins.str name: Name of the SNI handler
        :param Sequence[_builtins.str] server_names: Server names that are matched by the SNI handler
        """
        pulumi.set(__self__, "handler", handler)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_names", server_names)

    @_builtins.property
    @pulumi.getter
    def handler(self) -> 'outputs.AlbLoadBalancerListenerTlsSniHandlerHandler':
        """
        TLS handler resource.
        """
        return pulumi.get(self, "handler")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the SNI handler
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverNames")
    def server_names(self) -> Sequence[_builtins.str]:
        """
        Server names that are matched by the SNI handler
        """
        return pulumi.get(self, "server_names")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateIds":
            suggest = "certificate_ids"
        elif key == "httpHandler":
            suggest = "http_handler"
        elif key == "streamHandler":
            suggest = "stream_handler"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_ids: Sequence[_builtins.str],
                 http_handler: Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler'] = None,
                 stream_handler: Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler'] = None):
        """
        :param Sequence[_builtins.str] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerArgs' http_handler: HTTP handler.
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandlerArgs' stream_handler: Stream handler resource.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handler is not None:
            pulumi.set(__self__, "http_handler", http_handler)
        if stream_handler is not None:
            pulumi.set(__self__, "stream_handler", stream_handler)

    @_builtins.property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[_builtins.str]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        """
        return pulumi.get(self, "certificate_ids")

    @_builtins.property
    @pulumi.getter(name="httpHandler")
    def http_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler']:
        """
        HTTP handler.
        """
        return pulumi.get(self, "http_handler")

    @_builtins.property
    @pulumi.getter(name="streamHandler")
    def stream_handler(self) -> Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler']:
        """
        Stream handler resource.
        """
        return pulumi.get(self, "stream_handler")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHttp10":
            suggest = "allow_http10"
        elif key == "http2Options":
            suggest = "http2_options"
        elif key == "httpRouterId":
            suggest = "http_router_id"
        elif key == "rewriteRequestId":
            suggest = "rewrite_request_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_http10: Optional[_builtins.bool] = None,
                 http2_options: Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options'] = None,
                 http_router_id: Optional[_builtins.str] = None,
                 rewrite_request_id: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        :param 'AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2OptionsArgs' http2_options: If set, will enable HTTP2 protocol for the handler.
        :param _builtins.str http_router_id: HTTP router id.
        :param _builtins.bool rewrite_request_id: When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)
        if http2_options is not None:
            pulumi.set(__self__, "http2_options", http2_options)
        if http_router_id is not None:
            pulumi.set(__self__, "http_router_id", http_router_id)
        if rewrite_request_id is not None:
            pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)

    @_builtins.property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[_builtins.bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")

    @_builtins.property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Optional['outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options']:
        """
        If set, will enable HTTP2 protocol for the handler.
        """
        return pulumi.get(self, "http2_options")

    @_builtins.property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> Optional[_builtins.str]:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @_builtins.property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> Optional[_builtins.bool]:
        """
        When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentStreams":
            suggest = "max_concurrent_streams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_streams: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_concurrent_streams: Maximum number of concurrent streams.
        """
        if max_concurrent_streams is not None:
            pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: Optional[_builtins.str] = None,
                 idle_timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str backend_group_id: Backend Group ID.
        :param _builtins.str idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        if backend_group_id is not None:
            pulumi.set(__self__, "backend_group_id", backend_group_id)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> Optional[_builtins.str]:
        """
        Backend Group ID.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class AlbLoadBalancerLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardRules":
            suggest = "discard_rules"
        elif key == "logGroupId":
            suggest = "log_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable: Optional[_builtins.bool] = None,
                 discard_rules: Optional[Sequence['outputs.AlbLoadBalancerLogOptionsDiscardRule']] = None,
                 log_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable: Set to `true` to disable Cloud Logging for the balancer.
        :param Sequence['AlbLoadBalancerLogOptionsDiscardRuleArgs'] discard_rules: List of rules to discard a fraction of logs.
        :param _builtins.str log_group_id: Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if discard_rules is not None:
            pulumi.set(__self__, "discard_rules", discard_rules)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to disable Cloud Logging for the balancer.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter(name="discardRules")
    def discard_rules(self) -> Optional[Sequence['outputs.AlbLoadBalancerLogOptionsDiscardRule']]:
        """
        List of rules to discard a fraction of logs.
        """
        return pulumi.get(self, "discard_rules")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class AlbLoadBalancerLogOptionsDiscardRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discardPercent":
            suggest = "discard_percent"
        elif key == "grpcCodes":
            suggest = "grpc_codes"
        elif key == "httpCodeIntervals":
            suggest = "http_code_intervals"
        elif key == "httpCodes":
            suggest = "http_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbLoadBalancerLogOptionsDiscardRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbLoadBalancerLogOptionsDiscardRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbLoadBalancerLogOptionsDiscardRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discard_percent: Optional[_builtins.int] = None,
                 grpc_codes: Optional[Sequence[_builtins.str]] = None,
                 http_code_intervals: Optional[Sequence[_builtins.str]] = None,
                 http_codes: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int discard_percent: The percent of logs which will be discarded.
        :param Sequence[_builtins.str] grpc_codes: list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
        :param Sequence[_builtins.str] http_code_intervals: List of http code intervals *1XX*-*5XX* or *ALL*
        :param Sequence[_builtins.int] http_codes: List of http codes *100*-*599*.
        """
        if discard_percent is not None:
            pulumi.set(__self__, "discard_percent", discard_percent)
        if grpc_codes is not None:
            pulumi.set(__self__, "grpc_codes", grpc_codes)
        if http_code_intervals is not None:
            pulumi.set(__self__, "http_code_intervals", http_code_intervals)
        if http_codes is not None:
            pulumi.set(__self__, "http_codes", http_codes)

    @_builtins.property
    @pulumi.getter(name="discardPercent")
    def discard_percent(self) -> Optional[_builtins.int]:
        """
        The percent of logs which will be discarded.
        """
        return pulumi.get(self, "discard_percent")

    @_builtins.property
    @pulumi.getter(name="grpcCodes")
    def grpc_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
        """
        return pulumi.get(self, "grpc_codes")

    @_builtins.property
    @pulumi.getter(name="httpCodeIntervals")
    def http_code_intervals(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of http code intervals *1XX*-*5XX* or *ALL*
        """
        return pulumi.get(self, "http_code_intervals")

    @_builtins.property
    @pulumi.getter(name="httpCodes")
    def http_codes(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of http codes *100*-*599*.
        """
        return pulumi.get(self, "http_codes")


@pulumi.output_type
class AlbTargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "privateIpv4Address":
            suggest = "private_ipv4_address"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbTargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbTargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbTargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 private_ipv4_address: Optional[_builtins.bool] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_address: IP address of the target.
        :param _builtins.str subnet_id: ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if private_ipv4_address is not None:
            pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address of the target.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "private_ipv4_address")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AlbVirtualHostModifyRequestHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 remove: Optional[_builtins.bool] = None,
                 replace: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the header to modify.
        :param _builtins.str append: Append string to the header value.
        :param _builtins.bool remove: If set, remove the header.
        :param _builtins.str replace: New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "name", name)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the header to modify.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter
    def remove(self) -> Optional[_builtins.bool]:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.str]:
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class AlbVirtualHostModifyResponseHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 append: Optional[_builtins.str] = None,
                 remove: Optional[_builtins.bool] = None,
                 replace: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the header to modify.
        :param _builtins.str append: Append string to the header value.
        :param _builtins.bool remove: If set, remove the header.
        :param _builtins.str replace: New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "name", name)
        if append is not None:
            pulumi.set(__self__, "append", append)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the header to modify.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def append(self) -> Optional[_builtins.str]:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter
    def remove(self) -> Optional[_builtins.bool]:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.str]:
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class AlbVirtualHostRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allRequests":
            suggest = "all_requests"
        elif key == "requestsPerIp":
            suggest = "requests_per_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_requests: Optional['outputs.AlbVirtualHostRateLimitAllRequests'] = None,
                 requests_per_ip: Optional['outputs.AlbVirtualHostRateLimitRequestsPerIp'] = None):
        """
        :param 'AlbVirtualHostRateLimitAllRequestsArgs' all_requests: Rate limit configuration applied to all incoming requests
        :param 'AlbVirtualHostRateLimitRequestsPerIpArgs' requests_per_ip: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        if all_requests is not None:
            pulumi.set(__self__, "all_requests", all_requests)
        if requests_per_ip is not None:
            pulumi.set(__self__, "requests_per_ip", requests_per_ip)

    @_builtins.property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Optional['outputs.AlbVirtualHostRateLimitAllRequests']:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @_builtins.property
    @pulumi.getter(name="requestsPerIp")
    def requests_per_ip(self) -> Optional['outputs.AlbVirtualHostRateLimitRequestsPerIp']:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ip")


@pulumi.output_type
class AlbVirtualHostRateLimitAllRequests(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perMinute":
            suggest = "per_minute"
        elif key == "perSecond":
            suggest = "per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRateLimitAllRequests. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRateLimitAllRequests.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRateLimitAllRequests.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_minute: Optional[_builtins.int] = None,
                 per_second: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class AlbVirtualHostRateLimitRequestsPerIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perMinute":
            suggest = "per_minute"
        elif key == "perSecond":
            suggest = "per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRateLimitRequestsPerIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRateLimitRequestsPerIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRateLimitRequestsPerIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_minute: Optional[_builtins.int] = None,
                 per_second: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class AlbVirtualHostRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSecurityProfile":
            suggest = "disable_security_profile"
        elif key == "grpcRoute":
            suggest = "grpc_route"
        elif key == "httpRoute":
            suggest = "http_route"
        elif key == "routeOptions":
            suggest = "route_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_security_profile: Optional[_builtins.bool] = None,
                 grpc_route: Optional['outputs.AlbVirtualHostRouteGrpcRoute'] = None,
                 http_route: Optional['outputs.AlbVirtualHostRouteHttpRoute'] = None,
                 name: Optional[_builtins.str] = None,
                 route_options: Optional['outputs.AlbVirtualHostRouteRouteOptions'] = None):
        """
        :param _builtins.bool disable_security_profile: Disables security profile for the route
        :param 'AlbVirtualHostRouteGrpcRouteArgs' grpc_route: gRPC route resource.
        :param 'AlbVirtualHostRouteHttpRouteArgs' http_route: HTTP route resource.
               
               > Exactly one type of actions `http_route_action` or `redirect_action` or `direct_response_action` should be specified.
        :param _builtins.str name: The resource name.
        :param 'AlbVirtualHostRouteRouteOptionsArgs' route_options: Route options for the virtual host.
        """
        if disable_security_profile is not None:
            pulumi.set(__self__, "disable_security_profile", disable_security_profile)
        if grpc_route is not None:
            pulumi.set(__self__, "grpc_route", grpc_route)
        if http_route is not None:
            pulumi.set(__self__, "http_route", http_route)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if route_options is not None:
            pulumi.set(__self__, "route_options", route_options)

    @_builtins.property
    @pulumi.getter(name="disableSecurityProfile")
    def disable_security_profile(self) -> Optional[_builtins.bool]:
        """
        Disables security profile for the route
        """
        return pulumi.get(self, "disable_security_profile")

    @_builtins.property
    @pulumi.getter(name="grpcRoute")
    def grpc_route(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRoute']:
        """
        gRPC route resource.
        """
        return pulumi.get(self, "grpc_route")

    @_builtins.property
    @pulumi.getter(name="httpRoute")
    def http_route(self) -> Optional['outputs.AlbVirtualHostRouteHttpRoute']:
        """
        HTTP route resource.

        > Exactly one type of actions `http_route_action` or `redirect_action` or `direct_response_action` should be specified.
        """
        return pulumi.get(self, "http_route")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="routeOptions")
    def route_options(self) -> Optional['outputs.AlbVirtualHostRouteRouteOptions']:
        """
        Route options for the virtual host.
        """
        return pulumi.get(self, "route_options")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcMatches":
            suggest = "grpc_matches"
        elif key == "grpcRouteAction":
            suggest = "grpc_route_action"
        elif key == "grpcStatusResponseAction":
            suggest = "grpc_status_response_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_matches: Optional[Sequence['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatch']] = None,
                 grpc_route_action: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteAction'] = None,
                 grpc_status_response_action: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction'] = None):
        """
        :param Sequence['AlbVirtualHostRouteGrpcRouteGrpcMatchArgs'] grpc_matches: Checks `/` prefix by default.
        :param 'AlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs' grpc_route_action: gRPC route action resource.
        :param 'AlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs' grpc_status_response_action: gRPC status response action resource.
        """
        if grpc_matches is not None:
            pulumi.set(__self__, "grpc_matches", grpc_matches)
        if grpc_route_action is not None:
            pulumi.set(__self__, "grpc_route_action", grpc_route_action)
        if grpc_status_response_action is not None:
            pulumi.set(__self__, "grpc_status_response_action", grpc_status_response_action)

    @_builtins.property
    @pulumi.getter(name="grpcMatches")
    def grpc_matches(self) -> Optional[Sequence['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatch']]:
        """
        Checks `/` prefix by default.
        """
        return pulumi.get(self, "grpc_matches")

    @_builtins.property
    @pulumi.getter(name="grpcRouteAction")
    def grpc_route_action(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteAction']:
        """
        gRPC route action resource.
        """
        return pulumi.get(self, "grpc_route_action")

    @_builtins.property
    @pulumi.getter(name="grpcStatusResponseAction")
    def grpc_status_response_action(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction']:
        """
        gRPC status response action resource.
        """
        return pulumi.get(self, "grpc_status_response_action")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcMatch(dict):
    def __init__(__self__, *,
                 fqmn: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn'] = None):
        """
        :param 'AlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs' fqmn: The `path` and `fqmn` blocks.
        """
        if fqmn is not None:
            pulumi.set(__self__, "fqmn", fqmn)

    @_builtins.property
    @pulumi.getter
    def fqmn(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "fqmn")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "autoHostRewrite":
            suggest = "auto_host_rewrite"
        elif key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "maxTimeout":
            suggest = "max_timeout"
        elif key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRouteGrpcRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: _builtins.str,
                 auto_host_rewrite: Optional[_builtins.bool] = None,
                 host_rewrite: Optional[_builtins.str] = None,
                 idle_timeout: Optional[_builtins.str] = None,
                 max_timeout: Optional[_builtins.str] = None,
                 rate_limit: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit'] = None):
        """
        :param _builtins.str backend_group_id: Backend group to route requests.
        :param _builtins.bool auto_host_rewrite: If set, will automatically rewrite host.
        :param _builtins.str host_rewrite: Host rewrite specifier.
        :param _builtins.str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle*timeout to something meaningful and max*timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param _builtins.str max_timeout: Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        :param 'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs' rate_limit: Rate limit configuration applied for a whole virtual host
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        if auto_host_rewrite is not None:
            pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_timeout is not None:
            pulumi.set(__self__, "max_timeout", max_timeout)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> Optional[_builtins.bool]:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle*timeout to something meaningful and max*timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="maxTimeout")
    def max_timeout(self) -> Optional[_builtins.str]:
        """
        Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        """
        return pulumi.get(self, "max_timeout")

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit']:
        """
        Rate limit configuration applied for a whole virtual host
        """
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allRequests":
            suggest = "all_requests"
        elif key == "requestsPerIp":
            suggest = "requests_per_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_requests: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests'] = None,
                 requests_per_ip: Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp'] = None):
        """
        :param 'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestsArgs' all_requests: Rate limit configuration applied to all incoming requests
        :param 'AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs' requests_per_ip: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        if all_requests is not None:
            pulumi.set(__self__, "all_requests", all_requests)
        if requests_per_ip is not None:
            pulumi.set(__self__, "requests_per_ip", requests_per_ip)

    @_builtins.property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests']:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @_builtins.property
    @pulumi.getter(name="requestsPerIp")
    def requests_per_ip(self) -> Optional['outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp']:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ip")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perMinute":
            suggest = "per_minute"
        elif key == "perSecond":
            suggest = "per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequests.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_minute: Optional[_builtins.int] = None,
                 per_second: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perMinute":
            suggest = "per_minute"
        elif key == "perSecond":
            suggest = "per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_minute: Optional[_builtins.int] = None,
                 per_second: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction(dict):
    def __init__(__self__, *,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str status: The status of the response. Supported values are: ok, invalid*argumet, not*found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the response. Supported values are: ok, invalid*argumet, not*found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AlbVirtualHostRouteHttpRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directResponseAction":
            suggest = "direct_response_action"
        elif key == "httpMatches":
            suggest = "http_matches"
        elif key == "httpRouteAction":
            suggest = "http_route_action"
        elif key == "redirectAction":
            suggest = "redirect_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direct_response_action: Optional['outputs.AlbVirtualHostRouteHttpRouteDirectResponseAction'] = None,
                 http_matches: Optional[Sequence['outputs.AlbVirtualHostRouteHttpRouteHttpMatch']] = None,
                 http_route_action: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteAction'] = None,
                 redirect_action: Optional['outputs.AlbVirtualHostRouteHttpRouteRedirectAction'] = None):
        """
        :param 'AlbVirtualHostRouteHttpRouteDirectResponseActionArgs' direct_response_action: Direct response action resource.
        :param Sequence['AlbVirtualHostRouteHttpRouteHttpMatchArgs'] http_matches: Checks `/` prefix by default.
        :param 'AlbVirtualHostRouteHttpRouteHttpRouteActionArgs' http_route_action: HTTP route action resource.
        :param 'AlbVirtualHostRouteHttpRouteRedirectActionArgs' redirect_action: Redirect action resource.
               
               > Only one type of paths `replace_path` or `replace_prefix` should be specified.
        """
        if direct_response_action is not None:
            pulumi.set(__self__, "direct_response_action", direct_response_action)
        if http_matches is not None:
            pulumi.set(__self__, "http_matches", http_matches)
        if http_route_action is not None:
            pulumi.set(__self__, "http_route_action", http_route_action)
        if redirect_action is not None:
            pulumi.set(__self__, "redirect_action", redirect_action)

    @_builtins.property
    @pulumi.getter(name="directResponseAction")
    def direct_response_action(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteDirectResponseAction']:
        """
        Direct response action resource.
        """
        return pulumi.get(self, "direct_response_action")

    @_builtins.property
    @pulumi.getter(name="httpMatches")
    def http_matches(self) -> Optional[Sequence['outputs.AlbVirtualHostRouteHttpRouteHttpMatch']]:
        """
        Checks `/` prefix by default.
        """
        return pulumi.get(self, "http_matches")

    @_builtins.property
    @pulumi.getter(name="httpRouteAction")
    def http_route_action(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteAction']:
        """
        HTTP route action resource.
        """
        return pulumi.get(self, "http_route_action")

    @_builtins.property
    @pulumi.getter(name="redirectAction")
    def redirect_action(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteRedirectAction']:
        """
        Redirect action resource.

        > Only one type of paths `replace_path` or `replace_prefix` should be specified.
        """
        return pulumi.get(self, "redirect_action")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteDirectResponseAction(dict):
    def __init__(__self__, *,
                 body: Optional[_builtins.str] = None,
                 status: Optional[_builtins.int] = None):
        """
        :param _builtins.str body: Response body text.
        :param _builtins.int status: HTTP response status. Should be between `100` and `599`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[_builtins.str]:
        """
        Response body text.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.int]:
        """
        HTTP response status. Should be between `100` and `599`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence[_builtins.str]] = None,
                 path: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpMatchPath'] = None):
        """
        :param Sequence[_builtins.str] http_methods: List of methods (strings).
        :param 'AlbVirtualHostRouteHttpRouteHttpMatchPathArgs' path: The `path` and `fqmn` blocks.
        """
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of methods (strings).
        """
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpMatchPath']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpMatchPath(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpRouteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendGroupId":
            suggest = "backend_group_id"
        elif key == "autoHostRewrite":
            suggest = "auto_host_rewrite"
        elif key == "hostRewrite":
            suggest = "host_rewrite"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "prefixRewrite":
            suggest = "prefix_rewrite"
        elif key == "rateLimit":
            suggest = "rate_limit"
        elif key == "regexRewrite":
            suggest = "regex_rewrite"
        elif key == "upgradeTypes":
            suggest = "upgrade_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpRouteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_group_id: _builtins.str,
                 auto_host_rewrite: Optional[_builtins.bool] = None,
                 host_rewrite: Optional[_builtins.str] = None,
                 idle_timeout: Optional[_builtins.str] = None,
                 prefix_rewrite: Optional[_builtins.str] = None,
                 rate_limit: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit'] = None,
                 regex_rewrite: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewrite'] = None,
                 timeout: Optional[_builtins.str] = None,
                 upgrade_types: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str backend_group_id: Backend group to route requests.
        :param _builtins.bool auto_host_rewrite: If set, will automatically rewrite host.
        :param _builtins.str host_rewrite: Host rewrite specifier.
        :param _builtins.str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param _builtins.str prefix_rewrite: If not empty, matched path prefix will be replaced by this value.
        :param 'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs' rate_limit: Rate limit configuration applied for a whole virtual host
        :param 'AlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewriteArgs' regex_rewrite: Replacement for path substrings that match the pattern
        :param _builtins.str timeout: Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        :param Sequence[_builtins.str] upgrade_types: List of upgrade types. Only specified upgrade types will be allowed. For example, `websocket`.
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        if auto_host_rewrite is not None:
            pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        if host_rewrite is not None:
            pulumi.set(__self__, "host_rewrite", host_rewrite)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if prefix_rewrite is not None:
            pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if regex_rewrite is not None:
            pulumi.set(__self__, "regex_rewrite", regex_rewrite)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if upgrade_types is not None:
            pulumi.set(__self__, "upgrade_types", upgrade_types)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> Optional[_builtins.bool]:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> Optional[_builtins.str]:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        If not empty, matched path prefix will be replaced by this value.
        """
        return pulumi.get(self, "prefix_rewrite")

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit']:
        """
        Rate limit configuration applied for a whole virtual host
        """
        return pulumi.get(self, "rate_limit")

    @_builtins.property
    @pulumi.getter(name="regexRewrite")
    def regex_rewrite(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewrite']:
        """
        Replacement for path substrings that match the pattern
        """
        return pulumi.get(self, "regex_rewrite")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="upgradeTypes")
    def upgrade_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of upgrade types. Only specified upgrade types will be allowed. For example, `websocket`.
        """
        return pulumi.get(self, "upgrade_types")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allRequests":
            suggest = "all_requests"
        elif key == "requestsPerIp":
            suggest = "requests_per_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_requests: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests'] = None,
                 requests_per_ip: Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp'] = None):
        """
        :param 'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestsArgs' all_requests: Rate limit configuration applied to all incoming requests
        :param 'AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs' requests_per_ip: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        if all_requests is not None:
            pulumi.set(__self__, "all_requests", all_requests)
        if requests_per_ip is not None:
            pulumi.set(__self__, "requests_per_ip", requests_per_ip)

    @_builtins.property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests']:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @_builtins.property
    @pulumi.getter(name="requestsPerIp")
    def requests_per_ip(self) -> Optional['outputs.AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp']:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ip")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perMinute":
            suggest = "per_minute"
        elif key == "perSecond":
            suggest = "per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequests.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_minute: Optional[_builtins.int] = None,
                 per_second: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perMinute":
            suggest = "per_minute"
        elif key == "perSecond":
            suggest = "per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_minute: Optional[_builtins.int] = None,
                 per_second: Optional[_builtins.int] = None):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        if per_minute is not None:
            pulumi.set(__self__, "per_minute", per_minute)
        if per_second is not None:
            pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> Optional[_builtins.int]:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewrite(dict):
    def __init__(__self__, *,
                 regex: Optional[_builtins.str] = None,
                 substitute: Optional[_builtins.str] = None):
        """
        :param _builtins.str regex: RE2 regular expression
        :param _builtins.str substitute: The string which should be used to substitute matched substrings
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if substitute is not None:
            pulumi.set(__self__, "substitute", substitute)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        RE2 regular expression
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def substitute(self) -> Optional[_builtins.str]:
        """
        The string which should be used to substitute matched substrings
        """
        return pulumi.get(self, "substitute")


@pulumi.output_type
class AlbVirtualHostRouteHttpRouteRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeQuery":
            suggest = "remove_query"
        elif key == "replaceHost":
            suggest = "replace_host"
        elif key == "replacePath":
            suggest = "replace_path"
        elif key == "replacePort":
            suggest = "replace_port"
        elif key == "replacePrefix":
            suggest = "replace_prefix"
        elif key == "replaceScheme":
            suggest = "replace_scheme"
        elif key == "responseCode":
            suggest = "response_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteHttpRouteRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteHttpRouteRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteHttpRouteRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remove_query: Optional[_builtins.bool] = None,
                 replace_host: Optional[_builtins.str] = None,
                 replace_path: Optional[_builtins.str] = None,
                 replace_port: Optional[_builtins.int] = None,
                 replace_prefix: Optional[_builtins.str] = None,
                 replace_scheme: Optional[_builtins.str] = None,
                 response_code: Optional[_builtins.str] = None):
        """
        :param _builtins.bool remove_query: If set, remove query part.
        :param _builtins.str replace_host: Replaces hostname.
        :param _builtins.str replace_path: Replace path.
        :param _builtins.int replace_port: Replaces port.
        :param _builtins.str replace_prefix: Replace only matched prefix. Example:\\n\\n match:{ prefix*match: `/some` } \\n\\n redirect: { replace*prefix: `/other` } \\n\\n will redirect `/something` to `/otherthing`.
        :param _builtins.str replace_scheme: Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        :param _builtins.str response_code: The HTTP status code to use in the redirect response. Supported values are: `moved_permanently`, `found`, `see_other`, `temporary_redirect`, `permanent_redirect`.
        """
        if remove_query is not None:
            pulumi.set(__self__, "remove_query", remove_query)
        if replace_host is not None:
            pulumi.set(__self__, "replace_host", replace_host)
        if replace_path is not None:
            pulumi.set(__self__, "replace_path", replace_path)
        if replace_port is not None:
            pulumi.set(__self__, "replace_port", replace_port)
        if replace_prefix is not None:
            pulumi.set(__self__, "replace_prefix", replace_prefix)
        if replace_scheme is not None:
            pulumi.set(__self__, "replace_scheme", replace_scheme)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)

    @_builtins.property
    @pulumi.getter(name="removeQuery")
    def remove_query(self) -> Optional[_builtins.bool]:
        """
        If set, remove query part.
        """
        return pulumi.get(self, "remove_query")

    @_builtins.property
    @pulumi.getter(name="replaceHost")
    def replace_host(self) -> Optional[_builtins.str]:
        """
        Replaces hostname.
        """
        return pulumi.get(self, "replace_host")

    @_builtins.property
    @pulumi.getter(name="replacePath")
    def replace_path(self) -> Optional[_builtins.str]:
        """
        Replace path.
        """
        return pulumi.get(self, "replace_path")

    @_builtins.property
    @pulumi.getter(name="replacePort")
    def replace_port(self) -> Optional[_builtins.int]:
        """
        Replaces port.
        """
        return pulumi.get(self, "replace_port")

    @_builtins.property
    @pulumi.getter(name="replacePrefix")
    def replace_prefix(self) -> Optional[_builtins.str]:
        """
        Replace only matched prefix. Example:\\n\\n match:{ prefix*match: `/some` } \\n\\n redirect: { replace*prefix: `/other` } \\n\\n will redirect `/something` to `/otherthing`.
        """
        return pulumi.get(self, "replace_prefix")

    @_builtins.property
    @pulumi.getter(name="replaceScheme")
    def replace_scheme(self) -> Optional[_builtins.str]:
        """
        Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        """
        return pulumi.get(self, "replace_scheme")

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[_builtins.str]:
        """
        The HTTP status code to use in the redirect response. Supported values are: `moved_permanently`, `found`, `see_other`, `temporary_redirect`, `permanent_redirect`.
        """
        return pulumi.get(self, "response_code")


@pulumi.output_type
class AlbVirtualHostRouteOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityProfileId":
            suggest = "security_profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rbac: Optional['outputs.AlbVirtualHostRouteOptionsRbac'] = None,
                 security_profile_id: Optional[_builtins.str] = None):
        """
        :param 'AlbVirtualHostRouteOptionsRbacArgs' rbac: RBAC configuration.
        :param _builtins.str security_profile_id: SWS profile ID.
        """
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @_builtins.property
    @pulumi.getter
    def rbac(self) -> Optional['outputs.AlbVirtualHostRouteOptionsRbac']:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbac")

    @_builtins.property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[_builtins.str]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")


@pulumi.output_type
class AlbVirtualHostRouteOptionsRbac(dict):
    def __init__(__self__, *,
                 principals: Sequence['outputs.AlbVirtualHostRouteOptionsRbacPrincipal'],
                 action: Optional[_builtins.str] = None):
        pulumi.set(__self__, "principals", principals)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence['outputs.AlbVirtualHostRouteOptionsRbacPrincipal']:
        return pulumi.get(self, "principals")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action")


@pulumi.output_type
class AlbVirtualHostRouteOptionsRbacPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andPrincipals":
            suggest = "and_principals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteOptionsRbacPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteOptionsRbacPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteOptionsRbacPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_principals: Sequence['outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal']):
        pulumi.set(__self__, "and_principals", and_principals)

    @_builtins.property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> Sequence['outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal']:
        return pulumi.get(self, "and_principals")


@pulumi.output_type
class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteIp":
            suggest = "remote_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any: Optional[_builtins.bool] = None,
                 header: Optional['outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader'] = None,
                 remote_ip: Optional[_builtins.str] = None):
        if any is not None:
            pulumi.set(__self__, "any", any)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if remote_ip is not None:
            pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: Optional['outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue'] = None):
        """
        :param 'AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs' value: The `path` and `fqmn` blocks.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AlbVirtualHostRouteRouteOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityProfileId":
            suggest = "security_profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteRouteOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteRouteOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteRouteOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rbac: Optional['outputs.AlbVirtualHostRouteRouteOptionsRbac'] = None,
                 security_profile_id: Optional[_builtins.str] = None):
        """
        :param 'AlbVirtualHostRouteRouteOptionsRbacArgs' rbac: RBAC configuration.
        :param _builtins.str security_profile_id: SWS profile ID.
        """
        if rbac is not None:
            pulumi.set(__self__, "rbac", rbac)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @_builtins.property
    @pulumi.getter
    def rbac(self) -> Optional['outputs.AlbVirtualHostRouteRouteOptionsRbac']:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbac")

    @_builtins.property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[_builtins.str]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")


@pulumi.output_type
class AlbVirtualHostRouteRouteOptionsRbac(dict):
    def __init__(__self__, *,
                 principals: Sequence['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipal'],
                 action: Optional[_builtins.str] = None):
        pulumi.set(__self__, "principals", principals)
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipal']:
        return pulumi.get(self, "principals")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action")


@pulumi.output_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andPrincipals":
            suggest = "and_principals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteRouteOptionsRbacPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteRouteOptionsRbacPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteRouteOptionsRbacPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_principals: Sequence['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal']):
        pulumi.set(__self__, "and_principals", and_principals)

    @_builtins.property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> Sequence['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal']:
        return pulumi.get(self, "and_principals")


@pulumi.output_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteIp":
            suggest = "remote_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any: Optional[_builtins.bool] = None,
                 header: Optional['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader'] = None,
                 remote_ip: Optional[_builtins.str] = None):
        if any is not None:
            pulumi.set(__self__, "any", any)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if remote_ip is not None:
            pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter
    def any(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader']:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: Optional['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue'] = None):
        """
        :param 'AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValueArgs' value: The `path` and `fqmn` blocks.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class ApiGatewayCanary(dict):
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, _builtins.str]] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param Mapping[str, _builtins.str] variables: A list of values for variables in gateway specification of canary release.
        :param _builtins.int weight: Percentage of requests, which will be processed by canary release.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of values for variables in gateway specification of canary release.
        """
        return pulumi.get(self, "variables")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Percentage of requests, which will be processed by canary release.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class ApiGatewayConnectivity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiGatewayConnectivity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiGatewayConnectivity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiGatewayConnectivity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: _builtins.str):
        """
        :param _builtins.str network_id: Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class ApiGatewayCustomDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"
        elif key == "domainId":
            suggest = "domain_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiGatewayCustomDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiGatewayCustomDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiGatewayCustomDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: _builtins.str,
                 fqdn: _builtins.str,
                 domain_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "fqdn", fqdn)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "domain_id")


@pulumi.output_type
class ApiGatewayLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderId":
            suggest = "folder_id"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiGatewayLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiGatewayLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiGatewayLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 log_group_id: Optional[_builtins.str] = None,
                 min_level: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Is logging from Yandex Cloud API Gateway disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Is logging from Yandex Cloud API Gateway disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[_builtins.str]:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class AuditTrailsTrailDataStreamDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseId":
            suggest = "database_id"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailDataStreamDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailDataStreamDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailDataStreamDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str database_id: ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        :param _builtins.str stream_name: Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class AuditTrailsTrailFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventFilters":
            suggest = "event_filters"
        elif key == "pathFilter":
            suggest = "path_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_filters: Optional[Sequence['outputs.AuditTrailsTrailFilterEventFilter']] = None,
                 path_filter: Optional['outputs.AuditTrailsTrailFilterPathFilter'] = None):
        """
        :param Sequence['AuditTrailsTrailFilterEventFilterArgs'] event_filters: Deprecated.
        :param 'AuditTrailsTrailFilterPathFilterArgs' path_filter: Deprecated.
        """
        if event_filters is not None:
            pulumi.set(__self__, "event_filters", event_filters)
        if path_filter is not None:
            pulumi.set(__self__, "path_filter", path_filter)

    @_builtins.property
    @pulumi.getter(name="eventFilters")
    def event_filters(self) -> Optional[Sequence['outputs.AuditTrailsTrailFilterEventFilter']]:
        """
        Deprecated.
        """
        return pulumi.get(self, "event_filters")

    @_builtins.property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> Optional['outputs.AuditTrailsTrailFilterPathFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "path_filter")


@pulumi.output_type
class AuditTrailsTrailFilterEventFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathFilter":
            suggest = "path_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterEventFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterEventFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterEventFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.AuditTrailsTrailFilterEventFilterCategory'],
                 path_filter: 'outputs.AuditTrailsTrailFilterEventFilterPathFilter',
                 service: _builtins.str):
        """
        :param Sequence['AuditTrailsTrailFilterEventFilterCategoryArgs'] categories: Deprecated.
        :param 'AuditTrailsTrailFilterEventFilterPathFilterArgs' path_filter: Deprecated.
        :param _builtins.str service: Deprecated.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "path_filter", path_filter)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.AuditTrailsTrailFilterEventFilterCategory']:
        """
        Deprecated.
        """
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter(name="pathFilter")
    def path_filter(self) -> 'outputs.AuditTrailsTrailFilterEventFilterPathFilter':
        """
        Deprecated.
        """
        return pulumi.get(self, "path_filter")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class AuditTrailsTrailFilterEventFilterCategory(dict):
    def __init__(__self__, *,
                 plane: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str plane: Deprecated.
        :param _builtins.str type: Deprecated.
        """
        pulumi.set(__self__, "plane", plane)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def plane(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "plane")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AuditTrailsTrailFilterEventFilterPathFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFilter":
            suggest = "any_filter"
        elif key == "someFilter":
            suggest = "some_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterEventFilterPathFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_filter: Optional['outputs.AuditTrailsTrailFilterEventFilterPathFilterAnyFilter'] = None,
                 some_filter: Optional['outputs.AuditTrailsTrailFilterEventFilterPathFilterSomeFilter'] = None):
        """
        :param 'AuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs' any_filter: Deprecated.
        :param 'AuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs' some_filter: Deprecated.
        """
        if any_filter is not None:
            pulumi.set(__self__, "any_filter", any_filter)
        if some_filter is not None:
            pulumi.set(__self__, "some_filter", some_filter)

    @_builtins.property
    @pulumi.getter(name="anyFilter")
    def any_filter(self) -> Optional['outputs.AuditTrailsTrailFilterEventFilterPathFilterAnyFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filter")

    @_builtins.property
    @pulumi.getter(name="someFilter")
    def some_filter(self) -> Optional['outputs.AuditTrailsTrailFilterEventFilterPathFilterSomeFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "some_filter")


@pulumi.output_type
class AuditTrailsTrailFilterEventFilterPathFilterAnyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterEventFilterPathFilterAnyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilterAnyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilterAnyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilterEventFilterPathFilterSomeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFilters":
            suggest = "any_filters"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterEventFilterPathFilterSomeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilterSomeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilterSomeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_filters: Sequence['outputs.AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter'],
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param Sequence['AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs'] any_filters: Deprecated.
        :param _builtins.str resource_id: Deprecated.
        :param _builtins.str resource_type: Deprecated.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> Sequence['outputs.AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filters")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilterPathFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFilter":
            suggest = "any_filter"
        elif key == "someFilter":
            suggest = "some_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterPathFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterPathFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterPathFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_filter: Optional['outputs.AuditTrailsTrailFilterPathFilterAnyFilter'] = None,
                 some_filter: Optional['outputs.AuditTrailsTrailFilterPathFilterSomeFilter'] = None):
        """
        :param 'AuditTrailsTrailFilterPathFilterAnyFilterArgs' any_filter: Deprecated.
        :param 'AuditTrailsTrailFilterPathFilterSomeFilterArgs' some_filter: Deprecated.
        """
        if any_filter is not None:
            pulumi.set(__self__, "any_filter", any_filter)
        if some_filter is not None:
            pulumi.set(__self__, "some_filter", some_filter)

    @_builtins.property
    @pulumi.getter(name="anyFilter")
    def any_filter(self) -> Optional['outputs.AuditTrailsTrailFilterPathFilterAnyFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filter")

    @_builtins.property
    @pulumi.getter(name="someFilter")
    def some_filter(self) -> Optional['outputs.AuditTrailsTrailFilterPathFilterSomeFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "some_filter")


@pulumi.output_type
class AuditTrailsTrailFilterPathFilterAnyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterPathFilterAnyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterPathFilterAnyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterPathFilterAnyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilterPathFilterSomeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFilters":
            suggest = "any_filters"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterPathFilterSomeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterPathFilterSomeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterPathFilterSomeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_filters: Sequence['outputs.AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter'],
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param Sequence['AuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs'] any_filters: Deprecated.
        :param _builtins.str resource_id: Deprecated.
        :param _builtins.str resource_type: Deprecated.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> Sequence['outputs.AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filters")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilteringPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataEventsFilters":
            suggest = "data_events_filters"
        elif key == "managementEventsFilter":
            suggest = "management_events_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilteringPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilteringPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilteringPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_events_filters: Optional[Sequence['outputs.AuditTrailsTrailFilteringPolicyDataEventsFilter']] = None,
                 management_events_filter: Optional['outputs.AuditTrailsTrailFilteringPolicyManagementEventsFilter'] = None):
        """
        :param Sequence['AuditTrailsTrailFilteringPolicyDataEventsFilterArgs'] data_events_filters: Structure describing filtering process for the service-specific data events.
        :param 'AuditTrailsTrailFilteringPolicyManagementEventsFilterArgs' management_events_filter: Structure describing filtering process for management events.
        """
        if data_events_filters is not None:
            pulumi.set(__self__, "data_events_filters", data_events_filters)
        if management_events_filter is not None:
            pulumi.set(__self__, "management_events_filter", management_events_filter)

    @_builtins.property
    @pulumi.getter(name="dataEventsFilters")
    def data_events_filters(self) -> Optional[Sequence['outputs.AuditTrailsTrailFilteringPolicyDataEventsFilter']]:
        """
        Structure describing filtering process for the service-specific data events.
        """
        return pulumi.get(self, "data_events_filters")

    @_builtins.property
    @pulumi.getter(name="managementEventsFilter")
    def management_events_filter(self) -> Optional['outputs.AuditTrailsTrailFilteringPolicyManagementEventsFilter']:
        """
        Structure describing filtering process for management events.
        """
        return pulumi.get(self, "management_events_filter")


@pulumi.output_type
class AuditTrailsTrailFilteringPolicyDataEventsFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceScopes":
            suggest = "resource_scopes"
        elif key == "dnsFilter":
            suggest = "dns_filter"
        elif key == "excludedEvents":
            suggest = "excluded_events"
        elif key == "includedEvents":
            suggest = "included_events"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilteringPolicyDataEventsFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilteringPolicyDataEventsFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilteringPolicyDataEventsFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_scopes: Sequence['outputs.AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope'],
                 service: _builtins.str,
                 dns_filter: Optional['outputs.AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter'] = None,
                 excluded_events: Optional[Sequence[_builtins.str]] = None,
                 included_events: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs'] resource_scopes: Structure describing that events will be gathered from the specified resource.
        :param _builtins.str service: ID of the service which events will be gathered.
        :param 'AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilterArgs' dns_filter: Specific filter for DNS service.
        :param Sequence[_builtins.str] excluded_events: A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        :param Sequence[_builtins.str] included_events: A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        """
        pulumi.set(__self__, "resource_scopes", resource_scopes)
        pulumi.set(__self__, "service", service)
        if dns_filter is not None:
            pulumi.set(__self__, "dns_filter", dns_filter)
        if excluded_events is not None:
            pulumi.set(__self__, "excluded_events", excluded_events)
        if included_events is not None:
            pulumi.set(__self__, "included_events", included_events)

    @_builtins.property
    @pulumi.getter(name="resourceScopes")
    def resource_scopes(self) -> Sequence['outputs.AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope']:
        """
        Structure describing that events will be gathered from the specified resource.
        """
        return pulumi.get(self, "resource_scopes")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        ID of the service which events will be gathered.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="dnsFilter")
    def dns_filter(self) -> Optional['outputs.AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter']:
        """
        Specific filter for DNS service.
        """
        return pulumi.get(self, "dns_filter")

    @_builtins.property
    @pulumi.getter(name="excludedEvents")
    def excluded_events(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        """
        return pulumi.get(self, "excluded_events")

    @_builtins.property
    @pulumi.getter(name="includedEvents")
    def included_events(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        """
        return pulumi.get(self, "included_events")


@pulumi.output_type
class AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeNonrecursiveQueries":
            suggest = "include_nonrecursive_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_nonrecursive_queries: _builtins.bool):
        """
        :param _builtins.bool include_nonrecursive_queries: All types of queries will be delivered.
        """
        pulumi.set(__self__, "include_nonrecursive_queries", include_nonrecursive_queries)

    @_builtins.property
    @pulumi.getter(name="includeNonrecursiveQueries")
    def include_nonrecursive_queries(self) -> _builtins.bool:
        """
        All types of queries will be delivered.
        """
        return pulumi.get(self, "include_nonrecursive_queries")


@pulumi.output_type
class AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilteringPolicyDataEventsFilterResourceScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailFilteringPolicyManagementEventsFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceScopes":
            suggest = "resource_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilteringPolicyManagementEventsFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilteringPolicyManagementEventsFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilteringPolicyManagementEventsFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_scopes: Sequence['outputs.AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope']):
        """
        :param Sequence['AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs'] resource_scopes: Structure describing that events will be gathered from the specified resource.
        """
        pulumi.set(__self__, "resource_scopes", resource_scopes)

    @_builtins.property
    @pulumi.getter(name="resourceScopes")
    def resource_scopes(self) -> Sequence['outputs.AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope']:
        """
        Structure describing that events will be gathered from the specified resource.
        """
        return pulumi.get(self, "resource_scopes")


@pulumi.output_type
class AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class AuditTrailsTrailLoggingDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupId":
            suggest = "log_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailLoggingDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailLoggingDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailLoggingDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_id: _builtins.str):
        """
        :param _builtins.str log_group_id: ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class AuditTrailsTrailStorageDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectPrefix":
            suggest = "object_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuditTrailsTrailStorageDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuditTrailsTrailStorageDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuditTrailsTrailStorageDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 object_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        :param _builtins.str object_prefix: Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if object_prefix is not None:
            pulumi.set(__self__, "object_prefix", object_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> Optional[_builtins.str]:
        """
        Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
        return pulumi.get(self, "object_prefix")


@pulumi.output_type
class BackupPolicyFileFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exclusionMasks":
            suggest = "exclusion_masks"
        elif key == "inclusionMasks":
            suggest = "inclusion_masks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyFileFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyFileFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyFileFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclusion_masks: Optional[Sequence[_builtins.str]] = None,
                 inclusion_masks: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] exclusion_masks: Do not backup files that match the following criteria.
        :param Sequence[_builtins.str] inclusion_masks: Backup only files that match the following criteria.
        """
        if exclusion_masks is not None:
            pulumi.set(__self__, "exclusion_masks", exclusion_masks)
        if inclusion_masks is not None:
            pulumi.set(__self__, "inclusion_masks", inclusion_masks)

    @_builtins.property
    @pulumi.getter(name="exclusionMasks")
    def exclusion_masks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Do not backup files that match the following criteria.
        """
        return pulumi.get(self, "exclusion_masks")

    @_builtins.property
    @pulumi.getter(name="inclusionMasks")
    def inclusion_masks(self) -> Optional[Sequence[_builtins.str]]:
        """
        Backup only files that match the following criteria.
        """
        return pulumi.get(self, "inclusion_masks")


@pulumi.output_type
class BackupPolicyReattempts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAttempts":
            suggest = "max_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyReattempts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyReattempts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyReattempts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 interval: Optional[_builtins.str] = None,
                 max_attempts: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enable flag. Default `true`.
        :param _builtins.str interval: Retry interval. See `interval_type` for available values. Default: `5m`.
        :param _builtins.int max_attempts: Maximum number of attempts before throwing an error. Default `5`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable flag. Default `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.str]:
        """
        Retry interval. See `interval_type` for available values. Default: `5m`.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[_builtins.int]:
        """
        Maximum number of attempts before throwing an error. Default `5`.
        """
        return pulumi.get(self, "max_attempts")


@pulumi.output_type
class BackupPolicyRetention(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterBackup":
            suggest = "after_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyRetention. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyRetention.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyRetention.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_backup: Optional[_builtins.bool] = None,
                 rules: Optional[Sequence['outputs.BackupPolicyRetentionRule']] = None):
        """
        :param _builtins.bool after_backup: Defines whether retention rule applies after creating backup or before.
        :param Sequence['BackupPolicyRetentionRuleArgs'] rules: A list of retention rules.
        """
        if after_backup is not None:
            pulumi.set(__self__, "after_backup", after_backup)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="afterBackup")
    def after_backup(self) -> Optional[_builtins.bool]:
        """
        Defines whether retention rule applies after creating backup or before.
        """
        return pulumi.get(self, "after_backup")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.BackupPolicyRetentionRule']]:
        """
        A list of retention rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class BackupPolicyRetentionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "repeatPeriods":
            suggest = "repeat_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyRetentionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyRetentionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyRetentionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_age: Optional[_builtins.str] = None,
                 max_count: Optional[_builtins.int] = None,
                 repeat_periods: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str max_age: Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        :param _builtins.int max_count: Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        :param Sequence[_builtins.str] repeat_periods: Possible types: `REPEATE_PERIOD_UNSPECIFIED`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`. Specifies repeat period of the backupset.
        """
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if repeat_periods is not None:
            pulumi.set(__self__, "repeat_periods", repeat_periods)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        """
        return pulumi.get(self, "max_age")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="repeatPeriods")
    def repeat_periods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Possible types: `REPEATE_PERIOD_UNSPECIFIED`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`. Specifies repeat period of the backupset.
        """
        return pulumi.get(self, "repeat_periods")


@pulumi.output_type
class BackupPolicyScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupSets":
            suggest = "backup_sets"
        elif key == "executeByInterval":
            suggest = "execute_by_interval"
        elif key == "executeByTimes":
            suggest = "execute_by_times"
        elif key == "maxParallelBackups":
            suggest = "max_parallel_backups"
        elif key == "randomMaxDelay":
            suggest = "random_max_delay"
        elif key == "weeklyBackupDay":
            suggest = "weekly_backup_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_sets: Optional[Sequence['outputs.BackupPolicySchedulingBackupSet']] = None,
                 enabled: Optional[_builtins.bool] = None,
                 execute_by_interval: Optional[_builtins.int] = None,
                 execute_by_times: Optional[Sequence['outputs.BackupPolicySchedulingExecuteByTime']] = None,
                 max_parallel_backups: Optional[_builtins.int] = None,
                 random_max_delay: Optional[_builtins.str] = None,
                 scheme: Optional[_builtins.str] = None,
                 weekly_backup_day: Optional[_builtins.str] = None):
        """
        :param Sequence['BackupPolicySchedulingBackupSetArgs'] backup_sets: A list of schedules with backup sets that compose the whole scheme.
        :param _builtins.bool enabled: Enables or disables scheduling. Default `true`.
        :param _builtins.int execute_by_interval: Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param Sequence['BackupPolicySchedulingExecuteByTimeArgs'] execute_by_times: Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param _builtins.int max_parallel_backups: Maximum number of backup processes allowed to run in parallel. 0 for unlimited. Default `0`.
        :param _builtins.str random_max_delay: Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values. Default `30m`.
        :param _builtins.str scheme: Scheme of the backups. Available values are: `ALWAYS_INCREMENTAL`, `ALWAYS_FULL`, `WEEKLY_FULL_DAILY_INCREMENTAL`, `WEEKLY_INCREMENTAL`. Default `ALWAYS_INCREMENTAL`.
        :param _builtins.str weekly_backup_day: A day of week to start weekly backups. See `day_type` for available values. Default `MONDAY`.
        """
        if backup_sets is not None:
            pulumi.set(__self__, "backup_sets", backup_sets)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if execute_by_interval is not None:
            pulumi.set(__self__, "execute_by_interval", execute_by_interval)
        if execute_by_times is not None:
            pulumi.set(__self__, "execute_by_times", execute_by_times)
        if max_parallel_backups is not None:
            pulumi.set(__self__, "max_parallel_backups", max_parallel_backups)
        if random_max_delay is not None:
            pulumi.set(__self__, "random_max_delay", random_max_delay)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if weekly_backup_day is not None:
            pulumi.set(__self__, "weekly_backup_day", weekly_backup_day)

    @_builtins.property
    @pulumi.getter(name="backupSets")
    def backup_sets(self) -> Optional[Sequence['outputs.BackupPolicySchedulingBackupSet']]:
        """
        A list of schedules with backup sets that compose the whole scheme.
        """
        return pulumi.get(self, "backup_sets")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables scheduling. Default `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="executeByInterval")
    @_utilities.deprecated("""The 'execute_by_interval' field has been deprecated. Please use 'backup_sets' instead.""")
    def execute_by_interval(self) -> Optional[_builtins.int]:
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_interval")

    @_builtins.property
    @pulumi.getter(name="executeByTimes")
    @_utilities.deprecated("""The 'execute_by_time' field has been deprecated. Please use 'backup_sets' instead.""")
    def execute_by_times(self) -> Optional[Sequence['outputs.BackupPolicySchedulingExecuteByTime']]:
        """
        Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_times")

    @_builtins.property
    @pulumi.getter(name="maxParallelBackups")
    def max_parallel_backups(self) -> Optional[_builtins.int]:
        """
        Maximum number of backup processes allowed to run in parallel. 0 for unlimited. Default `0`.
        """
        return pulumi.get(self, "max_parallel_backups")

    @_builtins.property
    @pulumi.getter(name="randomMaxDelay")
    def random_max_delay(self) -> Optional[_builtins.str]:
        """
        Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values. Default `30m`.
        """
        return pulumi.get(self, "random_max_delay")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        Scheme of the backups. Available values are: `ALWAYS_INCREMENTAL`, `ALWAYS_FULL`, `WEEKLY_FULL_DAILY_INCREMENTAL`, `WEEKLY_INCREMENTAL`. Default `ALWAYS_INCREMENTAL`.
        """
        return pulumi.get(self, "scheme")

    @_builtins.property
    @pulumi.getter(name="weeklyBackupDay")
    def weekly_backup_day(self) -> Optional[_builtins.str]:
        """
        A day of week to start weekly backups. See `day_type` for available values. Default `MONDAY`.
        """
        return pulumi.get(self, "weekly_backup_day")


@pulumi.output_type
class BackupPolicySchedulingBackupSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executeByInterval":
            suggest = "execute_by_interval"
        elif key == "executeByTimes":
            suggest = "execute_by_times"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicySchedulingBackupSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicySchedulingBackupSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicySchedulingBackupSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execute_by_interval: Optional[_builtins.int] = None,
                 execute_by_times: Optional[Sequence['outputs.BackupPolicySchedulingBackupSetExecuteByTime']] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int execute_by_interval: Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param Sequence['BackupPolicySchedulingBackupSetExecuteByTimeArgs'] execute_by_times: Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param _builtins.str type: BackupSet type. See `backup_set_type` for available values. Default `TYPE_AUTO`.
        """
        if execute_by_interval is not None:
            pulumi.set(__self__, "execute_by_interval", execute_by_interval)
        if execute_by_times is not None:
            pulumi.set(__self__, "execute_by_times", execute_by_times)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="executeByInterval")
    def execute_by_interval(self) -> Optional[_builtins.int]:
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_interval")

    @_builtins.property
    @pulumi.getter(name="executeByTimes")
    def execute_by_times(self) -> Optional[Sequence['outputs.BackupPolicySchedulingBackupSetExecuteByTime']]:
        """
        Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_times")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        BackupSet type. See `backup_set_type` for available values. Default `TYPE_AUTO`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BackupPolicySchedulingBackupSetExecuteByTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeLastDayOfMonth":
            suggest = "include_last_day_of_month"
        elif key == "repeatAts":
            suggest = "repeat_ats"
        elif key == "repeatEvery":
            suggest = "repeat_every"
        elif key == "runLater":
            suggest = "run_later"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicySchedulingBackupSetExecuteByTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicySchedulingBackupSetExecuteByTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicySchedulingBackupSetExecuteByTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 include_last_day_of_month: Optional[_builtins.bool] = None,
                 monthdays: Optional[Sequence[_builtins.int]] = None,
                 months: Optional[Sequence[_builtins.int]] = None,
                 repeat_ats: Optional[Sequence[_builtins.str]] = None,
                 repeat_every: Optional[_builtins.str] = None,
                 run_later: Optional[_builtins.bool] = None,
                 weekdays: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: Type of the scheduling. Available values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        :param _builtins.bool include_last_day_of_month: If true, schedule will be applied on the last day of month. See `day_type` for available values. Default `false`.
        :param Sequence[_builtins.int] monthdays: List of days when schedule applies. Used in `MONTHLY` type.
        :param Sequence[_builtins.int] months: Set of values. Allowed values form 1 to 12.
        :param Sequence[_builtins.str] repeat_ats: List of time in format `HH:MM` (24-hours format), when the schedule applies.
        :param _builtins.str repeat_every: Frequency of backup repetition. See `interval_type` for available values.
        :param _builtins.bool run_later: If true and if the machine is off, launch missed tasks on boot up. Default `false`.
        :param Sequence[_builtins.str] weekdays: List of weekdays when the backup will be applied. Used in `WEEKLY` type.
        """
        pulumi.set(__self__, "type", type)
        if include_last_day_of_month is not None:
            pulumi.set(__self__, "include_last_day_of_month", include_last_day_of_month)
        if monthdays is not None:
            pulumi.set(__self__, "monthdays", monthdays)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if repeat_ats is not None:
            pulumi.set(__self__, "repeat_ats", repeat_ats)
        if repeat_every is not None:
            pulumi.set(__self__, "repeat_every", repeat_every)
        if run_later is not None:
            pulumi.set(__self__, "run_later", run_later)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the scheduling. Available values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="includeLastDayOfMonth")
    def include_last_day_of_month(self) -> Optional[_builtins.bool]:
        """
        If true, schedule will be applied on the last day of month. See `day_type` for available values. Default `false`.
        """
        return pulumi.get(self, "include_last_day_of_month")

    @_builtins.property
    @pulumi.getter
    def monthdays(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of days when schedule applies. Used in `MONTHLY` type.
        """
        return pulumi.get(self, "monthdays")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Set of values. Allowed values form 1 to 12.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="repeatAts")
    def repeat_ats(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of time in format `HH:MM` (24-hours format), when the schedule applies.
        """
        return pulumi.get(self, "repeat_ats")

    @_builtins.property
    @pulumi.getter(name="repeatEvery")
    def repeat_every(self) -> Optional[_builtins.str]:
        """
        Frequency of backup repetition. See `interval_type` for available values.
        """
        return pulumi.get(self, "repeat_every")

    @_builtins.property
    @pulumi.getter(name="runLater")
    def run_later(self) -> Optional[_builtins.bool]:
        """
        If true and if the machine is off, launch missed tasks on boot up. Default `false`.
        """
        return pulumi.get(self, "run_later")

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of weekdays when the backup will be applied. Used in `WEEKLY` type.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class BackupPolicySchedulingExecuteByTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeLastDayOfMonth":
            suggest = "include_last_day_of_month"
        elif key == "repeatAts":
            suggest = "repeat_ats"
        elif key == "repeatEvery":
            suggest = "repeat_every"
        elif key == "runLater":
            suggest = "run_later"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicySchedulingExecuteByTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicySchedulingExecuteByTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicySchedulingExecuteByTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 include_last_day_of_month: Optional[_builtins.bool] = None,
                 monthdays: Optional[Sequence[_builtins.int]] = None,
                 months: Optional[Sequence[_builtins.int]] = None,
                 repeat_ats: Optional[Sequence[_builtins.str]] = None,
                 repeat_every: Optional[_builtins.str] = None,
                 run_later: Optional[_builtins.bool] = None,
                 weekdays: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: Type of the scheduling. Available values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        :param _builtins.bool include_last_day_of_month: If true, schedule will be applied on the last day of month. See `day_type` for available values. Default `false`.
        :param Sequence[_builtins.int] monthdays: List of days when schedule applies. Used in `MONTHLY` type.
        :param Sequence[_builtins.int] months: Set of values. Allowed values form 1 to 12.
        :param Sequence[_builtins.str] repeat_ats: List of time in format `HH:MM` (24-hours format), when the schedule applies.
        :param _builtins.str repeat_every: Frequency of backup repetition. See `interval_type` for available values.
        :param _builtins.bool run_later: If true and if the machine is off, launch missed tasks on boot up. Default `false`.
        :param Sequence[_builtins.str] weekdays: List of weekdays when the backup will be applied. Used in `WEEKLY` type.
        """
        pulumi.set(__self__, "type", type)
        if include_last_day_of_month is not None:
            pulumi.set(__self__, "include_last_day_of_month", include_last_day_of_month)
        if monthdays is not None:
            pulumi.set(__self__, "monthdays", monthdays)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if repeat_ats is not None:
            pulumi.set(__self__, "repeat_ats", repeat_ats)
        if repeat_every is not None:
            pulumi.set(__self__, "repeat_every", repeat_every)
        if run_later is not None:
            pulumi.set(__self__, "run_later", run_later)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the scheduling. Available values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="includeLastDayOfMonth")
    def include_last_day_of_month(self) -> Optional[_builtins.bool]:
        """
        If true, schedule will be applied on the last day of month. See `day_type` for available values. Default `false`.
        """
        return pulumi.get(self, "include_last_day_of_month")

    @_builtins.property
    @pulumi.getter
    def monthdays(self) -> Optional[Sequence[_builtins.int]]:
        """
        List of days when schedule applies. Used in `MONTHLY` type.
        """
        return pulumi.get(self, "monthdays")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Optional[Sequence[_builtins.int]]:
        """
        Set of values. Allowed values form 1 to 12.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="repeatAts")
    def repeat_ats(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of time in format `HH:MM` (24-hours format), when the schedule applies.
        """
        return pulumi.get(self, "repeat_ats")

    @_builtins.property
    @pulumi.getter(name="repeatEvery")
    def repeat_every(self) -> Optional[_builtins.str]:
        """
        Frequency of backup repetition. See `interval_type` for available values.
        """
        return pulumi.get(self, "repeat_every")

    @_builtins.property
    @pulumi.getter(name="runLater")
    def run_later(self) -> Optional[_builtins.bool]:
        """
        If true and if the machine is off, launch missed tasks on boot up. Default `false`.
        """
        return pulumi.get(self, "run_later")

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of weekdays when the backup will be applied. Used in `WEEKLY` type.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class BackupPolicyVmSnapshotReattempts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAttempts":
            suggest = "max_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyVmSnapshotReattempts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyVmSnapshotReattempts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyVmSnapshotReattempts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 interval: Optional[_builtins.str] = None,
                 max_attempts: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enable flag. Default `true`.
        :param _builtins.str interval: Retry interval. See `interval_type` for available values. Default: `5m`.
        :param _builtins.int max_attempts: Maximum number of attempts before throwing an error. Default `5`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_attempts is not None:
            pulumi.set(__self__, "max_attempts", max_attempts)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable flag. Default `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.str]:
        """
        Retry interval. See `interval_type` for available values. Default: `5m`.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> Optional[_builtins.int]:
        """
        Maximum number of attempts before throwing an error. Default `5`.
        """
        return pulumi.get(self, "max_attempts")


@pulumi.output_type
class CdnOriginGroupOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originGroupId":
            suggest = "origin_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnOriginGroupOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnOriginGroupOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnOriginGroupOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 backup: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 origin_group_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str source: IP address or Domain name of your origin and the port.
        :param _builtins.bool backup: Specifies whether the origin is used in its origin group as backup. A backup origin is used when one of active origins becomes unavailable.
        :param _builtins.bool enabled: The origin is enabled and used as a source for the CDN. Default `enabled`.
        :param _builtins.int origin_group_id: The ID of a specific origin group.
        """
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if origin_group_id is not None:
            pulumi.set(__self__, "origin_group_id", origin_group_id)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        IP address or Domain name of your origin and the port.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def backup(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the origin is used in its origin group as backup. A backup origin is used when one of active origins becomes unavailable.
        """
        return pulumi.get(self, "backup")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        The origin is enabled and used as a source for the CDN. Default `enabled`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="originGroupId")
    def origin_group_id(self) -> Optional[_builtins.int]:
        """
        The ID of a specific origin group.
        """
        return pulumi.get(self, "origin_group_id")


@pulumi.output_type
class CdnResourceOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHttpMethods":
            suggest = "allowed_http_methods"
        elif key == "browserCacheSettings":
            suggest = "browser_cache_settings"
        elif key == "cacheHttpHeaders":
            suggest = "cache_http_headers"
        elif key == "customHostHeader":
            suggest = "custom_host_header"
        elif key == "customServerName":
            suggest = "custom_server_name"
        elif key == "disableCache":
            suggest = "disable_cache"
        elif key == "disableProxyForceRanges":
            suggest = "disable_proxy_force_ranges"
        elif key == "edgeCacheSettings":
            suggest = "edge_cache_settings"
        elif key == "enableIpUrlSigning":
            suggest = "enable_ip_url_signing"
        elif key == "fetchedCompressed":
            suggest = "fetched_compressed"
        elif key == "forwardHostHeader":
            suggest = "forward_host_header"
        elif key == "gzipOn":
            suggest = "gzip_on"
        elif key == "ignoreCookie":
            suggest = "ignore_cookie"
        elif key == "ignoreQueryParams":
            suggest = "ignore_query_params"
        elif key == "ipAddressAcl":
            suggest = "ip_address_acl"
        elif key == "proxyCacheMethodsSet":
            suggest = "proxy_cache_methods_set"
        elif key == "queryParamsBlacklists":
            suggest = "query_params_blacklists"
        elif key == "queryParamsWhitelists":
            suggest = "query_params_whitelists"
        elif key == "redirectHttpToHttps":
            suggest = "redirect_http_to_https"
        elif key == "redirectHttpsToHttp":
            suggest = "redirect_https_to_http"
        elif key == "secureKey":
            suggest = "secure_key"
        elif key == "staticRequestHeaders":
            suggest = "static_request_headers"
        elif key == "staticResponseHeaders":
            suggest = "static_response_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnResourceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnResourceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnResourceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_http_methods: Optional[Sequence[_builtins.str]] = None,
                 browser_cache_settings: Optional[_builtins.int] = None,
                 cache_http_headers: Optional[Sequence[_builtins.str]] = None,
                 cors: Optional[Sequence[_builtins.str]] = None,
                 custom_host_header: Optional[_builtins.str] = None,
                 custom_server_name: Optional[_builtins.str] = None,
                 disable_cache: Optional[_builtins.bool] = None,
                 disable_proxy_force_ranges: Optional[_builtins.bool] = None,
                 edge_cache_settings: Optional[_builtins.int] = None,
                 enable_ip_url_signing: Optional[_builtins.bool] = None,
                 fetched_compressed: Optional[_builtins.bool] = None,
                 forward_host_header: Optional[_builtins.bool] = None,
                 gzip_on: Optional[_builtins.bool] = None,
                 ignore_cookie: Optional[_builtins.bool] = None,
                 ignore_query_params: Optional[_builtins.bool] = None,
                 ip_address_acl: Optional['outputs.CdnResourceOptionsIpAddressAcl'] = None,
                 proxy_cache_methods_set: Optional[_builtins.bool] = None,
                 query_params_blacklists: Optional[Sequence[_builtins.str]] = None,
                 query_params_whitelists: Optional[Sequence[_builtins.str]] = None,
                 redirect_http_to_https: Optional[_builtins.bool] = None,
                 redirect_https_to_http: Optional[_builtins.bool] = None,
                 secure_key: Optional[_builtins.str] = None,
                 slice: Optional[_builtins.bool] = None,
                 static_request_headers: Optional[Mapping[str, _builtins.str]] = None,
                 static_response_headers: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allowed_http_methods: HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        :param _builtins.int browser_cache_settings: Set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        :param Sequence[_builtins.str] cache_http_headers: List HTTP headers that must be included in responses to clients.
        :param Sequence[_builtins.str] cors: Parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        :param _builtins.str custom_host_header: Custom value for the Host header. Your server must be able to process requests with the chosen header.
        :param _builtins.str custom_server_name: Wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS.
        :param _builtins.bool disable_cache: Setup a cache status.
        :param _builtins.bool disable_proxy_force_ranges: Disabling proxy force ranges.
        :param _builtins.int edge_cache_settings: Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        :param _builtins.bool enable_ip_url_signing: Enable access limiting by IP addresses, option available only with setting secure_key.
        :param _builtins.bool fetched_compressed: Option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        :param _builtins.bool forward_host_header: Choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        :param _builtins.bool gzip_on: GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        :param _builtins.bool ignore_cookie: Set for ignoring cookie.
        :param _builtins.bool ignore_query_params: Files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        :param 'CdnResourceOptionsIpAddressAclArgs' ip_address_acl: IP address access control list. The list of specified IP addresses to be allowed or denied depending on acl policy type.
        :param _builtins.bool proxy_cache_methods_set: Allows caching for GET, HEAD and POST requests.
        :param Sequence[_builtins.str] query_params_blacklists: Files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        :param Sequence[_builtins.str] query_params_whitelists: Files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        :param _builtins.bool redirect_http_to_https: Set up a redirect from HTTP to HTTPS.
        :param _builtins.bool redirect_https_to_http: Set up a redirect from HTTPS to HTTP.
        :param _builtins.str secure_key: Set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        :param _builtins.bool slice: Files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        :param Mapping[str, _builtins.str] static_request_headers: Set up custom headers that CDN servers will send in requests to origins.
        :param Mapping[str, _builtins.str] static_response_headers: Set up a static response header. The header name must be lowercase.
        """
        if allowed_http_methods is not None:
            pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        if browser_cache_settings is not None:
            pulumi.set(__self__, "browser_cache_settings", browser_cache_settings)
        if cache_http_headers is not None:
            pulumi.set(__self__, "cache_http_headers", cache_http_headers)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if custom_host_header is not None:
            pulumi.set(__self__, "custom_host_header", custom_host_header)
        if custom_server_name is not None:
            pulumi.set(__self__, "custom_server_name", custom_server_name)
        if disable_cache is not None:
            pulumi.set(__self__, "disable_cache", disable_cache)
        if disable_proxy_force_ranges is not None:
            pulumi.set(__self__, "disable_proxy_force_ranges", disable_proxy_force_ranges)
        if edge_cache_settings is not None:
            pulumi.set(__self__, "edge_cache_settings", edge_cache_settings)
        if enable_ip_url_signing is not None:
            pulumi.set(__self__, "enable_ip_url_signing", enable_ip_url_signing)
        if fetched_compressed is not None:
            pulumi.set(__self__, "fetched_compressed", fetched_compressed)
        if forward_host_header is not None:
            pulumi.set(__self__, "forward_host_header", forward_host_header)
        if gzip_on is not None:
            pulumi.set(__self__, "gzip_on", gzip_on)
        if ignore_cookie is not None:
            pulumi.set(__self__, "ignore_cookie", ignore_cookie)
        if ignore_query_params is not None:
            pulumi.set(__self__, "ignore_query_params", ignore_query_params)
        if ip_address_acl is not None:
            pulumi.set(__self__, "ip_address_acl", ip_address_acl)
        if proxy_cache_methods_set is not None:
            pulumi.set(__self__, "proxy_cache_methods_set", proxy_cache_methods_set)
        if query_params_blacklists is not None:
            pulumi.set(__self__, "query_params_blacklists", query_params_blacklists)
        if query_params_whitelists is not None:
            pulumi.set(__self__, "query_params_whitelists", query_params_whitelists)
        if redirect_http_to_https is not None:
            pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        if redirect_https_to_http is not None:
            pulumi.set(__self__, "redirect_https_to_http", redirect_https_to_http)
        if secure_key is not None:
            pulumi.set(__self__, "secure_key", secure_key)
        if slice is not None:
            pulumi.set(__self__, "slice", slice)
        if static_request_headers is not None:
            pulumi.set(__self__, "static_request_headers", static_request_headers)
        if static_response_headers is not None:
            pulumi.set(__self__, "static_response_headers", static_response_headers)

    @_builtins.property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        return pulumi.get(self, "allowed_http_methods")

    @_builtins.property
    @pulumi.getter(name="browserCacheSettings")
    def browser_cache_settings(self) -> Optional[_builtins.int]:
        """
        Set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        return pulumi.get(self, "browser_cache_settings")

    @_builtins.property
    @pulumi.getter(name="cacheHttpHeaders")
    def cache_http_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List HTTP headers that must be included in responses to clients.
        """
        return pulumi.get(self, "cache_http_headers")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="customHostHeader")
    def custom_host_header(self) -> Optional[_builtins.str]:
        """
        Custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        return pulumi.get(self, "custom_host_header")

    @_builtins.property
    @pulumi.getter(name="customServerName")
    def custom_server_name(self) -> Optional[_builtins.str]:
        """
        Wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS.
        """
        return pulumi.get(self, "custom_server_name")

    @_builtins.property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> Optional[_builtins.bool]:
        """
        Setup a cache status.
        """
        return pulumi.get(self, "disable_cache")

    @_builtins.property
    @pulumi.getter(name="disableProxyForceRanges")
    def disable_proxy_force_ranges(self) -> Optional[_builtins.bool]:
        """
        Disabling proxy force ranges.
        """
        return pulumi.get(self, "disable_proxy_force_ranges")

    @_builtins.property
    @pulumi.getter(name="edgeCacheSettings")
    def edge_cache_settings(self) -> Optional[_builtins.int]:
        """
        Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        return pulumi.get(self, "edge_cache_settings")

    @_builtins.property
    @pulumi.getter(name="enableIpUrlSigning")
    def enable_ip_url_signing(self) -> Optional[_builtins.bool]:
        """
        Enable access limiting by IP addresses, option available only with setting secure_key.
        """
        return pulumi.get(self, "enable_ip_url_signing")

    @_builtins.property
    @pulumi.getter(name="fetchedCompressed")
    def fetched_compressed(self) -> Optional[_builtins.bool]:
        """
        Option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        return pulumi.get(self, "fetched_compressed")

    @_builtins.property
    @pulumi.getter(name="forwardHostHeader")
    def forward_host_header(self) -> Optional[_builtins.bool]:
        """
        Choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        return pulumi.get(self, "forward_host_header")

    @_builtins.property
    @pulumi.getter(name="gzipOn")
    def gzip_on(self) -> Optional[_builtins.bool]:
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        return pulumi.get(self, "gzip_on")

    @_builtins.property
    @pulumi.getter(name="ignoreCookie")
    def ignore_cookie(self) -> Optional[_builtins.bool]:
        """
        Set for ignoring cookie.
        """
        return pulumi.get(self, "ignore_cookie")

    @_builtins.property
    @pulumi.getter(name="ignoreQueryParams")
    def ignore_query_params(self) -> Optional[_builtins.bool]:
        """
        Files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        return pulumi.get(self, "ignore_query_params")

    @_builtins.property
    @pulumi.getter(name="ipAddressAcl")
    def ip_address_acl(self) -> Optional['outputs.CdnResourceOptionsIpAddressAcl']:
        """
        IP address access control list. The list of specified IP addresses to be allowed or denied depending on acl policy type.
        """
        return pulumi.get(self, "ip_address_acl")

    @_builtins.property
    @pulumi.getter(name="proxyCacheMethodsSet")
    def proxy_cache_methods_set(self) -> Optional[_builtins.bool]:
        """
        Allows caching for GET, HEAD and POST requests.
        """
        return pulumi.get(self, "proxy_cache_methods_set")

    @_builtins.property
    @pulumi.getter(name="queryParamsBlacklists")
    def query_params_blacklists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        return pulumi.get(self, "query_params_blacklists")

    @_builtins.property
    @pulumi.getter(name="queryParamsWhitelists")
    def query_params_whitelists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        return pulumi.get(self, "query_params_whitelists")

    @_builtins.property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> Optional[_builtins.bool]:
        """
        Set up a redirect from HTTP to HTTPS.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @_builtins.property
    @pulumi.getter(name="redirectHttpsToHttp")
    def redirect_https_to_http(self) -> Optional[_builtins.bool]:
        """
        Set up a redirect from HTTPS to HTTP.
        """
        return pulumi.get(self, "redirect_https_to_http")

    @_builtins.property
    @pulumi.getter(name="secureKey")
    def secure_key(self) -> Optional[_builtins.str]:
        """
        Set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        """
        return pulumi.get(self, "secure_key")

    @_builtins.property
    @pulumi.getter
    def slice(self) -> Optional[_builtins.bool]:
        """
        Files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        return pulumi.get(self, "slice")

    @_builtins.property
    @pulumi.getter(name="staticRequestHeaders")
    def static_request_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Set up custom headers that CDN servers will send in requests to origins.
        """
        return pulumi.get(self, "static_request_headers")

    @_builtins.property
    @pulumi.getter(name="staticResponseHeaders")
    def static_response_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Set up a static response header. The header name must be lowercase.
        """
        return pulumi.get(self, "static_response_headers")


@pulumi.output_type
class CdnResourceOptionsIpAddressAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptedValues":
            suggest = "excepted_values"
        elif key == "policyType":
            suggest = "policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnResourceOptionsIpAddressAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnResourceOptionsIpAddressAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnResourceOptionsIpAddressAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excepted_values: Optional[Sequence[_builtins.str]] = None,
                 policy_type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] excepted_values: The list of specified IP addresses to be allowed or denied depending on acl policy type.
        :param _builtins.str policy_type: The policy type for ACL. One of `allow` or `deny` values.
        """
        if excepted_values is not None:
            pulumi.set(__self__, "excepted_values", excepted_values)
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @_builtins.property
    @pulumi.getter(name="exceptedValues")
    def excepted_values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of specified IP addresses to be allowed or denied depending on acl policy type.
        """
        return pulumi.get(self, "excepted_values")

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[_builtins.str]:
        """
        The policy type for ACL. One of `allow` or `deny` values.
        """
        return pulumi.get(self, "policy_type")


@pulumi.output_type
class CdnResourceSslCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateManagerId":
            suggest = "certificate_manager_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnResourceSslCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnResourceSslCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnResourceSslCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 certificate_manager_id: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: SSL certificate type.
        :param _builtins.str certificate_manager_id: Certificate Manager ID.
        :param _builtins.str status: SSL certificate status.
        """
        pulumi.set(__self__, "type", type)
        if certificate_manager_id is not None:
            pulumi.set(__self__, "certificate_manager_id", certificate_manager_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        SSL certificate type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="certificateManagerId")
    def certificate_manager_id(self) -> Optional[_builtins.str]:
        """
        Certificate Manager ID.
        """
        return pulumi.get(self, "certificate_manager_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        SSL certificate status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CmCertificateChallenge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "dnsName":
            suggest = "dns_name"
        elif key == "dnsType":
            suggest = "dns_type"
        elif key == "dnsValue":
            suggest = "dns_value"
        elif key == "httpContent":
            suggest = "http_content"
        elif key == "httpUrl":
            suggest = "http_url"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmCertificateChallenge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmCertificateChallenge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmCertificateChallenge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 dns_name: Optional[_builtins.str] = None,
                 dns_type: Optional[_builtins.str] = None,
                 dns_value: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 http_content: Optional[_builtins.str] = None,
                 http_url: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Time the challenge was created.
        :param _builtins.str dns_name: DNS record name (only for DNS challenge).
        :param _builtins.str dns_type: DNS record type: `TXT` or `CNAME` (only for DNS challenge).
        :param _builtins.str dns_value: DNS record value (only for DNS challenge).
        :param _builtins.str domain: Validated domain.
        :param _builtins.str http_content: The content that should be made accessible with the given `http_url` (only for HTTP challenge).
        :param _builtins.str http_url: URL where the challenge content http_content should be placed (only for HTTP challenge).
        :param _builtins.str message: Current status message.
        :param _builtins.str type: Challenge type `DNS` or `HTTP`.
        :param _builtins.str updated_at: Last time the challenge was updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if dns_type is not None:
            pulumi.set(__self__, "dns_type", dns_type)
        if dns_value is not None:
            pulumi.set(__self__, "dns_value", dns_value)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if http_content is not None:
            pulumi.set(__self__, "http_content", http_content)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Time the challenge was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[_builtins.str]:
        """
        DNS record name (only for DNS challenge).
        """
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="dnsType")
    def dns_type(self) -> Optional[_builtins.str]:
        """
        DNS record type: `TXT` or `CNAME` (only for DNS challenge).
        """
        return pulumi.get(self, "dns_type")

    @_builtins.property
    @pulumi.getter(name="dnsValue")
    def dns_value(self) -> Optional[_builtins.str]:
        """
        DNS record value (only for DNS challenge).
        """
        return pulumi.get(self, "dns_value")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Validated domain.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="httpContent")
    def http_content(self) -> Optional[_builtins.str]:
        """
        The content that should be made accessible with the given `http_url` (only for HTTP challenge).
        """
        return pulumi.get(self, "http_content")

    @_builtins.property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[_builtins.str]:
        """
        URL where the challenge content http_content should be placed (only for HTTP challenge).
        """
        return pulumi.get(self, "http_url")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Current status message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Challenge type `DNS` or `HTTP`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Last time the challenge was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class CmCertificateManaged(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "challengeType":
            suggest = "challenge_type"
        elif key == "challengeCount":
            suggest = "challenge_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmCertificateManaged. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmCertificateManaged.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmCertificateManaged.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 challenge_type: _builtins.str,
                 challenge_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str challenge_type: Domain owner-check method. Possible values:
        :param _builtins.int challenge_count: Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.
        """
        pulumi.set(__self__, "challenge_type", challenge_type)
        if challenge_count is not None:
            pulumi.set(__self__, "challenge_count", challenge_count)

    @_builtins.property
    @pulumi.getter(name="challengeType")
    def challenge_type(self) -> _builtins.str:
        """
        Domain owner-check method. Possible values:
        """
        return pulumi.get(self, "challenge_type")

    @_builtins.property
    @pulumi.getter(name="challengeCount")
    def challenge_count(self) -> Optional[_builtins.int]:
        """
        Expected number of challenge count needed to validate certificate. Resource creation will fail if the specified value does not match the actual number of challenges received from issue provider. This argument is helpful for safe automatic resource creation for passing challenges for multi-domain certificates.
        """
        return pulumi.get(self, "challenge_count")


@pulumi.output_type
class CmCertificateSelfManaged(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyLockboxSecret":
            suggest = "private_key_lockbox_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmCertificateSelfManaged. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmCertificateSelfManaged.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmCertificateSelfManaged.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: _builtins.str,
                 private_key: Optional[_builtins.str] = None,
                 private_key_lockbox_secret: Optional['outputs.CmCertificateSelfManagedPrivateKeyLockboxSecret'] = None):
        """
        :param _builtins.str certificate: Certificate with chain.
        :param _builtins.str private_key: Private key of certificate.
        :param 'CmCertificateSelfManagedPrivateKeyLockboxSecretArgs' private_key_lockbox_secret: Lockbox secret specification for getting private key.
        """
        pulumi.set(__self__, "certificate", certificate)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_lockbox_secret is not None:
            pulumi.set(__self__, "private_key_lockbox_secret", private_key_lockbox_secret)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> _builtins.str:
        """
        Certificate with chain.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Private key of certificate.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyLockboxSecret")
    def private_key_lockbox_secret(self) -> Optional['outputs.CmCertificateSelfManagedPrivateKeyLockboxSecret']:
        """
        Lockbox secret specification for getting private key.
        """
        return pulumi.get(self, "private_key_lockbox_secret")


@pulumi.output_type
class CmCertificateSelfManagedPrivateKeyLockboxSecret(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 key: _builtins.str):
        """
        :param _builtins.str id: Lockbox secret Id.
        :param _builtins.str key: Key of the Lockbox secret, the value of which contains the private key of the certificate.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Lockbox secret Id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the Lockbox secret, the value of which contains the private key of the certificate.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class ComputeDiskDiskPlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskPlacementGroupId":
            suggest = "disk_placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeDiskDiskPlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeDiskDiskPlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeDiskDiskPlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_placement_group_id: _builtins.str):
        """
        :param _builtins.str disk_placement_group_id: Specifies Disk Placement Group id.
        """
        pulumi.set(__self__, "disk_placement_group_id", disk_placement_group_id)

    @_builtins.property
    @pulumi.getter(name="diskPlacementGroupId")
    def disk_placement_group_id(self) -> _builtins.str:
        """
        Specifies Disk Placement Group id.
        """
        return pulumi.get(self, "disk_placement_group_id")


@pulumi.output_type
class ComputeDiskHardwareGeneration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generation2Features":
            suggest = "generation2_features"
        elif key == "legacyFeatures":
            suggest = "legacy_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeDiskHardwareGeneration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeDiskHardwareGeneration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeDiskHardwareGeneration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generation2_features: Optional['outputs.ComputeDiskHardwareGenerationGeneration2Features'] = None,
                 legacy_features: Optional['outputs.ComputeDiskHardwareGenerationLegacyFeatures'] = None):
        """
        :param 'ComputeDiskHardwareGenerationGeneration2FeaturesArgs' generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param 'ComputeDiskHardwareGenerationLegacyFeaturesArgs' legacy_features: Defines the first known hardware generation and its features.
        """
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional['outputs.ComputeDiskHardwareGenerationGeneration2Features']:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional['outputs.ComputeDiskHardwareGenerationLegacyFeatures']:
        """
        Defines the first known hardware generation and its features.
        """
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class ComputeDiskHardwareGenerationGeneration2Features(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeDiskHardwareGenerationLegacyFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pciTopology":
            suggest = "pci_topology"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeDiskHardwareGenerationLegacyFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeDiskHardwareGenerationLegacyFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeDiskHardwareGenerationLegacyFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pci_topology: Optional[_builtins.str] = None):
        """
        :param _builtins.str pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[_builtins.str]:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class ComputeImageHardwareGeneration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generation2Features":
            suggest = "generation2_features"
        elif key == "legacyFeatures":
            suggest = "legacy_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeImageHardwareGeneration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeImageHardwareGeneration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeImageHardwareGeneration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generation2_features: Optional['outputs.ComputeImageHardwareGenerationGeneration2Features'] = None,
                 legacy_features: Optional['outputs.ComputeImageHardwareGenerationLegacyFeatures'] = None):
        """
        :param 'ComputeImageHardwareGenerationGeneration2FeaturesArgs' generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param 'ComputeImageHardwareGenerationLegacyFeaturesArgs' legacy_features: Defines the first known hardware generation and its features.
        """
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional['outputs.ComputeImageHardwareGenerationGeneration2Features']:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional['outputs.ComputeImageHardwareGenerationLegacyFeatures']:
        """
        Defines the first known hardware generation and its features.
        """
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class ComputeImageHardwareGenerationGeneration2Features(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeImageHardwareGenerationLegacyFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pciTopology":
            suggest = "pci_topology"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeImageHardwareGenerationLegacyFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeImageHardwareGenerationLegacyFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeImageHardwareGenerationLegacyFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pci_topology: Optional[_builtins.str] = None):
        """
        :param _builtins.str pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[_builtins.str]:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class ComputeInstanceBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_delete: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None,
                 initialize_params: Optional['outputs.ComputeInstanceBootDiskInitializeParams'] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.bool auto_delete: Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        :param _builtins.str device_name: Name that can be used to access an attached disk.
        :param _builtins.str disk_id: The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        :param 'ComputeInstanceBootDiskInitializeParamsArgs' initialize_params: Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. Either `image_id` or `snapshot_id` must be specified.
        :param _builtins.str mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name that can be used to access an attached disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.ComputeInstanceBootDiskInitializeParams']:
        """
        Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. Either `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeInstanceBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSize":
            suggest = "block_size"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int block_size: Block size of the disk, specified in bytes.
        :param _builtins.str description: Description of the boot disk.
        :param _builtins.str image_id: A disk image to initialize this disk from.
        :param _builtins.str kms_key_id: ID of KMS symmetric key used to encrypt disk.
        :param _builtins.str name: Name of the boot disk.
        :param _builtins.int size: Size of the disk in GB.
        :param _builtins.str snapshot_id: A snapshot to initialize this disk from.
        :param _builtins.str type: Disk type.
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[_builtins.int]:
        """
        Block size of the disk, specified in bytes.
        """
        return pulumi.get(self, "block_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        A disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        ID of KMS symmetric key used to encrypt disk.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the boot disk.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        A snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str filesystem_id: ID of the filesystem that should be attached.
        :param _builtins.str device_name: Name of the device representing the filesystem on the instance.
        :param _builtins.str mode: Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> _builtins.str:
        """
        ID of the filesystem that should be attached.
        """
        return pulumi.get(self, "filesystem_id")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name of the device representing the filesystem on the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeInstanceGroupAllocationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceTagsPools":
            suggest = "instance_tags_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupAllocationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupAllocationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupAllocationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zones: Sequence[_builtins.str],
                 instance_tags_pools: Optional[Sequence['outputs.ComputeInstanceGroupAllocationPolicyInstanceTagsPool']] = None):
        """
        :param Sequence[_builtins.str] zones: A list of [availability zones](https://yandex.cloud/docs/overview/concepts/geo-scope).
        :param Sequence['ComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs'] instance_tags_pools: Array of availability zone IDs with list of instance tags.
        """
        pulumi.set(__self__, "zones", zones)
        if instance_tags_pools is not None:
            pulumi.set(__self__, "instance_tags_pools", instance_tags_pools)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        A list of [availability zones](https://yandex.cloud/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zones")

    @_builtins.property
    @pulumi.getter(name="instanceTagsPools")
    def instance_tags_pools(self) -> Optional[Sequence['outputs.ComputeInstanceGroupAllocationPolicyInstanceTagsPool']]:
        """
        Array of availability zone IDs with list of instance tags.
        """
        return pulumi.get(self, "instance_tags_pools")


@pulumi.output_type
class ComputeInstanceGroupAllocationPolicyInstanceTagsPool(dict):
    def __init__(__self__, *,
                 tags: Sequence[_builtins.str],
                 zone: _builtins.str):
        """
        :param Sequence[_builtins.str] tags: List of tags for instances in zone.
        :param _builtins.str zone: Availability zone.
        """
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        List of tags for instances in zone.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ComputeInstanceGroupApplicationLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreHealthChecks":
            suggest = "ignore_health_checks"
        elif key == "maxOpeningTrafficDuration":
            suggest = "max_opening_traffic_duration"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "targetGroupDescription":
            suggest = "target_group_description"
        elif key == "targetGroupId":
            suggest = "target_group_id"
        elif key == "targetGroupLabels":
            suggest = "target_group_labels"
        elif key == "targetGroupName":
            suggest = "target_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupApplicationLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupApplicationLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupApplicationLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_health_checks: Optional[_builtins.bool] = None,
                 max_opening_traffic_duration: Optional[_builtins.int] = None,
                 status_message: Optional[_builtins.str] = None,
                 target_group_description: Optional[_builtins.str] = None,
                 target_group_id: Optional[_builtins.str] = None,
                 target_group_labels: Optional[Mapping[str, _builtins.str]] = None,
                 target_group_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool ignore_health_checks: Do not wait load balancer health checks.
        :param _builtins.int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param _builtins.str status_message: The status message of the instance.
        :param _builtins.str target_group_description: A description of the target group.
        :param _builtins.str target_group_id: The ID of the target group.
        :param Mapping[str, _builtins.str] target_group_labels: A set of key/value label pairs.
        :param _builtins.str target_group_name: The name of the target group.
        """
        if ignore_health_checks is not None:
            pulumi.set(__self__, "ignore_health_checks", ignore_health_checks)
        if max_opening_traffic_duration is not None:
            pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if target_group_description is not None:
            pulumi.set(__self__, "target_group_description", target_group_description)
        if target_group_id is not None:
            pulumi.set(__self__, "target_group_id", target_group_id)
        if target_group_labels is not None:
            pulumi.set(__self__, "target_group_labels", target_group_labels)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)

    @_builtins.property
    @pulumi.getter(name="ignoreHealthChecks")
    def ignore_health_checks(self) -> Optional[_builtins.bool]:
        """
        Do not wait load balancer health checks.
        """
        return pulumi.get(self, "ignore_health_checks")

    @_builtins.property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> Optional[_builtins.int]:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[_builtins.str]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> Optional[_builtins.str]:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @_builtins.property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @_builtins.property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[_builtins.str]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class ComputeInstanceGroupDeployPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExpansion":
            suggest = "max_expansion"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "maxCreating":
            suggest = "max_creating"
        elif key == "maxDeleting":
            suggest = "max_deleting"
        elif key == "startupDuration":
            suggest = "startup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupDeployPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupDeployPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupDeployPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_expansion: _builtins.int,
                 max_unavailable: _builtins.int,
                 max_creating: Optional[_builtins.int] = None,
                 max_deleting: Optional[_builtins.int] = None,
                 startup_duration: Optional[_builtins.int] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        :param _builtins.int max_unavailable: The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        :param _builtins.int max_creating: The maximum number of instances that can be created at the same time.
        :param _builtins.int max_deleting: The maximum number of instances that can be deleted at the same time.
        :param _builtins.int startup_duration: The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        :param _builtins.str strategy: Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        if max_creating is not None:
            pulumi.set(__self__, "max_creating", max_creating)
        if max_deleting is not None:
            pulumi.set(__self__, "max_deleting", max_deleting)
        if startup_duration is not None:
            pulumi.set(__self__, "startup_duration", startup_duration)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> _builtins.int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        """
        return pulumi.get(self, "max_expansion")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> _builtins.int:
        """
        The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="maxCreating")
    def max_creating(self) -> Optional[_builtins.int]:
        """
        The maximum number of instances that can be created at the same time.
        """
        return pulumi.get(self, "max_creating")

    @_builtins.property
    @pulumi.getter(name="maxDeleting")
    def max_deleting(self) -> Optional[_builtins.int]:
        """
        The maximum number of instances that can be deleted at the same time.
        """
        return pulumi.get(self, "max_deleting")

    @_builtins.property
    @pulumi.getter(name="startupDuration")
    def startup_duration(self) -> Optional[_builtins.int]:
        """
        The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        """
        return pulumi.get(self, "startup_duration")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ComputeInstanceGroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpOptions":
            suggest = "http_options"
        elif key == "tcpOptions":
            suggest = "tcp_options"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthy_threshold: Optional[_builtins.int] = None,
                 http_options: Optional['outputs.ComputeInstanceGroupHealthCheckHttpOptions'] = None,
                 interval: Optional[_builtins.int] = None,
                 tcp_options: Optional['outputs.ComputeInstanceGroupHealthCheckTcpOptions'] = None,
                 timeout: Optional[_builtins.int] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int healthy_threshold: The number of successful health checks before the managed instance is declared healthy.
        :param 'ComputeInstanceGroupHealthCheckHttpOptionsArgs' http_options: HTTP check options.
        :param _builtins.int interval: The interval to wait between health checks in seconds.
        :param 'ComputeInstanceGroupHealthCheckTcpOptionsArgs' tcp_options: TCP check options.
        :param _builtins.int timeout: The length of time to wait for a response before the health check times out in seconds.
        :param _builtins.int unhealthy_threshold: The number of failed health checks before the managed instance is declared unhealthy.
        """
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        The number of successful health checks before the managed instance is declared healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional['outputs.ComputeInstanceGroupHealthCheckHttpOptions']:
        """
        HTTP check options.
        """
        return pulumi.get(self, "http_options")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        The interval to wait between health checks in seconds.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional['outputs.ComputeInstanceGroupHealthCheckTcpOptions']:
        """
        TCP check options.
        """
        return pulumi.get(self, "tcp_options")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        The length of time to wait for a response before the health check times out in seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        The number of failed health checks before the managed instance is declared unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class ComputeInstanceGroupHealthCheckHttpOptions(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str path: The URL path used for health check requests.
        :param _builtins.int port: The port used for HTTP health checks.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The URL path used for health check requests.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used for HTTP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ComputeInstanceGroupHealthCheckTcpOptions(dict):
    def __init__(__self__, *,
                 port: _builtins.int):
        """
        :param _builtins.int port: The port used for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ComputeInstanceGroupInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceTag":
            suggest = "instance_tag"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "statusChangedAt":
            suggest = "status_changed_at"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 instance_tag: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 network_interfaces: Optional[Sequence['outputs.ComputeInstanceGroupInstanceNetworkInterface']] = None,
                 status: Optional[_builtins.str] = None,
                 status_changed_at: Optional[_builtins.str] = None,
                 status_message: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str fqdn: The Fully Qualified Domain Name.
        :param _builtins.str instance_id: The ID of the instance.
        :param _builtins.str instance_tag: Managed instance tag.
        :param _builtins.str name: The name of the managed instance.
        :param Sequence['ComputeInstanceGroupInstanceNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces attached to the managed instance.
        :param _builtins.str status: Status of the managed instance.
        :param _builtins.str status_changed_at: The timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format when the status of the managed instance was last changed.
        :param _builtins.str status_message: The status message of the instance.
        :param _builtins.str zone_id: The ID of the availability zone where the instance resides.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_tag is not None:
            pulumi.set(__self__, "instance_tag", instance_tag)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_changed_at is not None:
            pulumi.set(__self__, "status_changed_at", status_changed_at)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The Fully Qualified Domain Name.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        The ID of the instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceTag")
    def instance_tag(self) -> Optional[_builtins.str]:
        """
        Managed instance tag.
        """
        return pulumi.get(self, "instance_tag")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the managed instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceNetworkInterface']]:
        """
        An array with the network interfaces attached to the managed instance.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the managed instance.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusChangedAt")
    def status_changed_at(self) -> Optional[_builtins.str]:
        """
        The timestamp in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format when the status of the managed instance was last changed.
        """
        return pulumi.get(self, "status_changed_at")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[_builtins.str]:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        The ID of the availability zone where the instance resides.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "natIpVersion":
            suggest = "nat_ip_version"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: Optional[_builtins.int] = None,
                 ip_address: Optional[_builtins.str] = None,
                 ipv4: Optional[_builtins.bool] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 mac_address: Optional[_builtins.str] = None,
                 nat: Optional[_builtins.bool] = None,
                 nat_ip_address: Optional[_builtins.str] = None,
                 nat_ip_version: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int index: The index of the network interface as generated by the server.
        :param _builtins.str ip_address: The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
        :param _builtins.bool ipv4: `True` if IPv4 address allocated for the network interface.
        :param _builtins.bool ipv6: If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param _builtins.str ipv6_address: The private IPv6 address to assign to the instance.
        :param _builtins.str mac_address: The MAC address assigned to the network interface.
        :param _builtins.bool nat: The instance's public address for accessing the internet over NAT.
        :param _builtins.str nat_ip_address: The public IP address of the instance.
        :param _builtins.str nat_ip_version: The IP version for the public address.
        :param _builtins.str subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        """
        The index of the network interface as generated by the server.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        The private IP address to assign to the instance. If empty, the address is automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.bool]:
        """
        `True` if IPv4 address allocated for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        The private IPv6 address to assign to the instance.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[_builtins.str]:
        """
        The MAC address assigned to the network interface.
        """
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[_builtins.bool]:
        """
        The instance's public address for accessing the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[_builtins.str]:
        """
        The public IP address of the instance.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[_builtins.str]:
        """
        The IP version for the public address.
        """
        return pulumi.get(self, "nat_ip_version")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "metadataOptions":
            suggest = "metadata_options"
        elif key == "networkSettings":
            suggest = "network_settings"
        elif key == "placementPolicy":
            suggest = "placement_policy"
        elif key == "platformId":
            suggest = "platform_id"
        elif key == "schedulingPolicy":
            suggest = "scheduling_policy"
        elif key == "secondaryDisks":
            suggest = "secondary_disks"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk: 'outputs.ComputeInstanceGroupInstanceTemplateBootDisk',
                 network_interfaces: Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterface'],
                 resources: 'outputs.ComputeInstanceGroupInstanceTemplateResources',
                 description: Optional[_builtins.str] = None,
                 filesystems: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateFilesystem']] = None,
                 hostname: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 metadata_options: Optional['outputs.ComputeInstanceGroupInstanceTemplateMetadataOptions'] = None,
                 name: Optional[_builtins.str] = None,
                 network_settings: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkSetting']] = None,
                 placement_policy: Optional['outputs.ComputeInstanceGroupInstanceTemplatePlacementPolicy'] = None,
                 platform_id: Optional[_builtins.str] = None,
                 scheduling_policy: Optional['outputs.ComputeInstanceGroupInstanceTemplateSchedulingPolicy'] = None,
                 secondary_disks: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDisk']] = None,
                 service_account_id: Optional[_builtins.str] = None):
        """
        :param 'ComputeInstanceGroupInstanceTemplateBootDiskArgs' boot_disk: Boot disk specifications for the instance.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        :param 'ComputeInstanceGroupInstanceTemplateResourcesArgs' resources: Compute resource specifications for the instance.
        :param _builtins.str description: A description of the instance.
        :param Sequence['ComputeInstanceGroupInstanceTemplateFilesystemArgs'] filesystems: List of filesystems to attach to the instance.
        :param _builtins.str hostname: Hostname template for the instance. This field is used to generate the FQDN value of instance. The `hostname` must be unique within the network and region. If not specified, the hostname will be equal to `id` of the instance and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
               In order to be unique it must contain at least on of instance unique placeholders:
               * `{instance.short_id}`
               * {instance.index}
               * combination of `{instance.zone_id}` and `{instance.index_in_zone}`
               Example: `my-instance-{instance.index}`. If hostname is not set, `name` value will be used. It may also contain another placeholders, see `metadata` doc for full list.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs to assign to the instance.
        :param Mapping[str, _builtins.str] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param 'ComputeInstanceGroupInstanceTemplateMetadataOptionsArgs' metadata_options: Options allow user to configure access to managed instances metadata
        :param _builtins.str name: Name template of the instance.
               In order to be unique it must contain at least one of instance unique placeholders:*`{instance.short_id}`
               * `{instance.index}`
               * combination of `{instance.zone_id}` and`{instance.index_in_zone}`.
               Example: `my-instance-{instance.index}`.
               If not set, default name is used: `{instance_group.id}-{instance.short_id}`. It may also contain another placeholders, see `metadata` doc for full list.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkSettingArgs'] network_settings: Network acceleration type for instance.
        :param 'ComputeInstanceGroupInstanceTemplatePlacementPolicyArgs' placement_policy: The placement policy configuration.
        :param _builtins.str platform_id: The ID of the hardware platform configuration for the instance.
        :param 'ComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs' scheduling_policy: The scheduling policy configuration.
        :param Sequence['ComputeInstanceGroupInstanceTemplateSecondaryDiskArgs'] secondary_disks: A list of disks to attach to the instance.
        :param _builtins.str service_account_id: The ID of the service account authorized for this instance.
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_settings is not None:
            pulumi.set(__self__, "network_settings", network_settings)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        if secondary_disks is not None:
            pulumi.set(__self__, "secondary_disks", secondary_disks)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.ComputeInstanceGroupInstanceTemplateBootDisk':
        """
        Boot disk specifications for the instance.
        """
        return pulumi.get(self, "boot_disk")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterface']:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.ComputeInstanceGroupInstanceTemplateResources':
        """
        Compute resource specifications for the instance.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the instance.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def filesystems(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateFilesystem']]:
        """
        List of filesystems to attach to the instance.
        """
        return pulumi.get(self, "filesystems")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        Hostname template for the instance. This field is used to generate the FQDN value of instance. The `hostname` must be unique within the network and region. If not specified, the hostname will be equal to `id` of the instance and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
        In order to be unique it must contain at least on of instance unique placeholders:
        * `{instance.short_id}`
        * {instance.index}
        * combination of `{instance.zone_id}` and `{instance.index_in_zone}`
        Example: `my-instance-{instance.index}`. If hostname is not set, `name` value will be used. It may also contain another placeholders, see `metadata` doc for full list.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateMetadataOptions']:
        """
        Options allow user to configure access to managed instances metadata
        """
        return pulumi.get(self, "metadata_options")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name template of the instance.
        In order to be unique it must contain at least one of instance unique placeholders:*`{instance.short_id}`
        * `{instance.index}`
        * combination of `{instance.zone_id}` and`{instance.index_in_zone}`.
        Example: `my-instance-{instance.index}`.
        If not set, default name is used: `{instance_group.id}-{instance.short_id}`. It may also contain another placeholders, see `metadata` doc for full list.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkSettings")
    def network_settings(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkSetting']]:
        """
        Network acceleration type for instance.
        """
        return pulumi.get(self, "network_settings")

    @_builtins.property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplatePlacementPolicy']:
        """
        The placement policy configuration.
        """
        return pulumi.get(self, "placement_policy")

    @_builtins.property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[_builtins.str]:
        """
        The ID of the hardware platform configuration for the instance.
        """
        return pulumi.get(self, "platform_id")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateSchedulingPolicy']:
        """
        The scheduling policy configuration.
        """
        return pulumi.get(self, "scheduling_policy")

    @_builtins.property
    @pulumi.getter(name="secondaryDisks")
    def secondary_disks(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDisk']]:
        """
        A list of disks to attach to the instance.
        """
        return pulumi.get(self, "secondary_disks")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        The ID of the service account authorized for this instance.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None,
                 initialize_params: Optional['outputs.ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams'] = None,
                 mode: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: The ID of the existing disk (such as those managed by yandex_compute_disk) to attach as a boot disk.
        :param 'ComputeInstanceGroupInstanceTemplateBootDiskInitializeParamsArgs' initialize_params: Parameters for creating a disk alongside the instance.
               
               > `image_id` or `snapshot_id` must be specified.
        :param _builtins.str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        :param _builtins.str name: When set can be later used to change DiskSpec of actual disk.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        The ID of the existing disk (such as those managed by yandex_compute_disk) to attach as a boot disk.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams']:
        """
        Parameters for creating a disk alongside the instance.

        > `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        When set can be later used to change DiskSpec of actual disk.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: A description of the boot disk.
        :param _builtins.str image_id: The disk image to initialize this disk from.
        :param _builtins.int size: The size of the disk in GB.
        :param _builtins.str snapshot_id: The snapshot to initialize this disk from.
        :param _builtins.str type: The disk type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_id: _builtins.str,
                 device_name: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str filesystem_id: ID of the filesystem that should be attached.
        :param _builtins.str device_name: Name of the device representing the filesystem on the instance.
        :param _builtins.str mode: Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> _builtins.str:
        """
        ID of the filesystem that should be attached.
        """
        return pulumi.get(self, "filesystem_id")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name of the device representing the filesystem on the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsV1HttpEndpoint":
            suggest = "aws_v1_http_endpoint"
        elif key == "awsV1HttpToken":
            suggest = "aws_v1_http_token"
        elif key == "gceHttpEndpoint":
            suggest = "gce_http_endpoint"
        elif key == "gceHttpToken":
            suggest = "gce_http_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_v1_http_endpoint: Optional[_builtins.int] = None,
                 aws_v1_http_token: Optional[_builtins.int] = None,
                 gce_http_endpoint: Optional[_builtins.int] = None,
                 gce_http_token: Optional[_builtins.int] = None):
        """
        :param _builtins.int aws_v1_http_endpoint: Enables access to AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        :param _builtins.int aws_v1_http_token: Enables access to IAM credentials with AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        :param _builtins.int gce_http_endpoint: Enables access to GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        :param _builtins.int gce_http_token: Enables access to IAM credentials with GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        if aws_v1_http_endpoint is not None:
            pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        if aws_v1_http_token is not None:
            pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        if gce_http_endpoint is not None:
            pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        if gce_http_token is not None:
            pulumi.set(__self__, "gce_http_token", gce_http_token)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> Optional[_builtins.int]:
        """
        Enables access to AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> Optional[_builtins.int]:
        """
        Enables access to IAM credentials with AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "aws_v1_http_token")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> Optional[_builtins.int]:
        """
        Enables access to GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "gce_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> Optional[_builtins.int]:
        """
        Enables access to IAM credentials with GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "gce_http_token")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecords":
            suggest = "dns_records"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6DnsRecords":
            suggest = "ipv6_dns_records"
        elif key == "natDnsRecords":
            suggest = "nat_dns_records"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_records: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord']] = None,
                 ip_address: Optional[_builtins.str] = None,
                 ipv4: Optional[_builtins.bool] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 ipv6_dns_records: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord']] = None,
                 nat: Optional[_builtins.bool] = None,
                 nat_dns_records: Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord']] = None,
                 nat_ip_address: Optional[_builtins.str] = None,
                 network_id: Optional[_builtins.str] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs'] dns_records: List of DNS records.
        :param _builtins.str ip_address: Manual set static IP address.
        :param _builtins.bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param _builtins.bool ipv6: If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param _builtins.str ipv6_address: Manual set static IPv6 address.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of IPv6 DNS records.
        :param _builtins.bool nat: Flag for using NAT.
        :param Sequence['ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of NAT DNS records.
        :param _builtins.str nat_ip_address: A public address that can be used to access the internet over NAT. Use `variables` to set.
        :param _builtins.str network_id: The ID of the network.
        :param Sequence[_builtins.str] security_group_ids: Security group (SG) `IDs` for network interface.
        :param Sequence[_builtins.str] subnet_ids: The ID of the subnets to attach this interface to.
        """
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_dns_records is not None:
            pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord']]:
        """
        List of DNS records.
        """
        return pulumi.get(self, "dns_records")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.bool]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord']]:
        """
        List of IPv6 DNS records.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[_builtins.bool]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord']]:
        """
        List of NAT DNS records.
        """
        return pulumi.get(self, "nat_dns_records")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[_builtins.str]:
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[_builtins.str]:
        """
        The ID of the network.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security group (SG) `IDs` for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ID of the subnets to attach this interface to.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN (must have dot at the end).
        :param _builtins.str dns_zone_id: DNS zone id (if not set, private zone used).
        :param _builtins.bool ptr: When set to `true`, also create PTR DNS record.
        :param _builtins.int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN (must have dot at the end).
        :param _builtins.str dns_zone_id: DNS zone id (if not set, private zone used).
        :param _builtins.bool ptr: When set to `true`, also create PTR DNS record.
        :param _builtins.int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN (must have dot at the end).
        :param _builtins.str dns_zone_id: DNS zone id (if not set, private zone used).
        :param _builtins.bool ptr: When set to `true`, also create PTR DNS record.
        :param _builtins.int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateNetworkSetting(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplatePlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplatePlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: _builtins.str):
        """
        :param _builtins.str placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> _builtins.str:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores: _builtins.int,
                 memory: _builtins.float,
                 core_fraction: Optional[_builtins.int] = None,
                 gpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int cores: The number of CPU cores for the instance.
        :param _builtins.float memory: The memory size in GB.
        :param _builtins.int core_fraction: If provided, specifies baseline core performance as a percent.
        :param _builtins.int gpus: If provided, specifies the number of GPU devices for the instance.
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)

    @_builtins.property
    @pulumi.getter
    def cores(self) -> _builtins.int:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        The memory size in GB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[_builtins.int]:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> Optional[_builtins.int]:
        """
        If provided, specifies the number of GPU devices for the instance.
        """
        return pulumi.get(self, "gpus")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateSchedulingPolicy(dict):
    def __init__(__self__, *,
                 preemptible: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool preemptible: Specifies if the instance is preemptible. Defaults to `false`.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance is preemptible. Defaults to `false`.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateSecondaryDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateSecondaryDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None,
                 initialize_params: Optional['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams'] = None,
                 mode: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: ID of the existing disk. To set use variables.
        :param 'ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamsArgs' initialize_params: Parameters used for creating a disk alongside the instance.
               
               > `image_id` or `snapshot_id` must be specified.
        :param _builtins.str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        :param _builtins.str name: When set can be later used to change DiskSpec of actual disk.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional['outputs.ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams']:
        """
        Parameters used for creating a disk alongside the instance.

        > `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        When set can be later used to change DiskSpec of actual disk.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: A description of the boot disk.
        :param _builtins.str image_id: The disk image to initialize this disk from.
        :param _builtins.int size: The size of the disk in GB.
        :param _builtins.str snapshot_id: The snapshot to initialize this disk from.
        :param _builtins.str type: The disk type.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ComputeInstanceGroupLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreHealthChecks":
            suggest = "ignore_health_checks"
        elif key == "maxOpeningTrafficDuration":
            suggest = "max_opening_traffic_duration"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "targetGroupDescription":
            suggest = "target_group_description"
        elif key == "targetGroupId":
            suggest = "target_group_id"
        elif key == "targetGroupLabels":
            suggest = "target_group_labels"
        elif key == "targetGroupName":
            suggest = "target_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_health_checks: Optional[_builtins.bool] = None,
                 max_opening_traffic_duration: Optional[_builtins.int] = None,
                 status_message: Optional[_builtins.str] = None,
                 target_group_description: Optional[_builtins.str] = None,
                 target_group_id: Optional[_builtins.str] = None,
                 target_group_labels: Optional[Mapping[str, _builtins.str]] = None,
                 target_group_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool ignore_health_checks: Do not wait load balancer health checks.
        :param _builtins.int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param _builtins.str status_message: The status message of the target group.
        :param _builtins.str target_group_description: A description of the target group.
        :param _builtins.str target_group_id: The ID of the target group.
        :param Mapping[str, _builtins.str] target_group_labels: A set of key/value label pairs.
        :param _builtins.str target_group_name: The name of the target group.
        """
        if ignore_health_checks is not None:
            pulumi.set(__self__, "ignore_health_checks", ignore_health_checks)
        if max_opening_traffic_duration is not None:
            pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if target_group_description is not None:
            pulumi.set(__self__, "target_group_description", target_group_description)
        if target_group_id is not None:
            pulumi.set(__self__, "target_group_id", target_group_id)
        if target_group_labels is not None:
            pulumi.set(__self__, "target_group_labels", target_group_labels)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)

    @_builtins.property
    @pulumi.getter(name="ignoreHealthChecks")
    def ignore_health_checks(self) -> Optional[_builtins.bool]:
        """
        Do not wait load balancer health checks.
        """
        return pulumi.get(self, "ignore_health_checks")

    @_builtins.property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> Optional[_builtins.int]:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[_builtins.str]:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> Optional[_builtins.str]:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @_builtins.property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @_builtins.property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[_builtins.str]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class ComputeInstanceGroupScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScale":
            suggest = "auto_scale"
        elif key == "fixedScale":
            suggest = "fixed_scale"
        elif key == "testAutoScale":
            suggest = "test_auto_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scale: Optional['outputs.ComputeInstanceGroupScalePolicyAutoScale'] = None,
                 fixed_scale: Optional['outputs.ComputeInstanceGroupScalePolicyFixedScale'] = None,
                 test_auto_scale: Optional['outputs.ComputeInstanceGroupScalePolicyTestAutoScale'] = None):
        """
        :param 'ComputeInstanceGroupScalePolicyAutoScaleArgs' auto_scale: The auto scaling policy of the instance group.
        :param 'ComputeInstanceGroupScalePolicyFixedScaleArgs' fixed_scale: The fixed scaling policy of the instance group.
        :param 'ComputeInstanceGroupScalePolicyTestAutoScaleArgs' test_auto_scale: The test auto scaling policy of the instance group. Use it to test how the auto scale works.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)
        if test_auto_scale is not None:
            pulumi.set(__self__, "test_auto_scale", test_auto_scale)

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional['outputs.ComputeInstanceGroupScalePolicyAutoScale']:
        """
        The auto scaling policy of the instance group.
        """
        return pulumi.get(self, "auto_scale")

    @_builtins.property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional['outputs.ComputeInstanceGroupScalePolicyFixedScale']:
        """
        The fixed scaling policy of the instance group.
        """
        return pulumi.get(self, "fixed_scale")

    @_builtins.property
    @pulumi.getter(name="testAutoScale")
    def test_auto_scale(self) -> Optional['outputs.ComputeInstanceGroupScalePolicyTestAutoScale']:
        """
        The test auto scaling policy of the instance group. Use it to test how the auto scale works.
        """
        return pulumi.get(self, "test_auto_scale")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyAutoScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialSize":
            suggest = "initial_size"
        elif key == "measurementDuration":
            suggest = "measurement_duration"
        elif key == "autoScaleType":
            suggest = "auto_scale_type"
        elif key == "cpuUtilizationTarget":
            suggest = "cpu_utilization_target"
        elif key == "customRules":
            suggest = "custom_rules"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minZoneSize":
            suggest = "min_zone_size"
        elif key == "stabilizationDuration":
            suggest = "stabilization_duration"
        elif key == "warmupDuration":
            suggest = "warmup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyAutoScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyAutoScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyAutoScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_size: _builtins.int,
                 measurement_duration: _builtins.int,
                 auto_scale_type: Optional[_builtins.str] = None,
                 cpu_utilization_target: Optional[_builtins.float] = None,
                 custom_rules: Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyAutoScaleCustomRule']] = None,
                 max_size: Optional[_builtins.int] = None,
                 min_zone_size: Optional[_builtins.int] = None,
                 stabilization_duration: Optional[_builtins.int] = None,
                 warmup_duration: Optional[_builtins.int] = None):
        """
        :param _builtins.int initial_size: The initial number of instances in the instance group.
        :param _builtins.int measurement_duration: The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        :param _builtins.str auto_scale_type: Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        :param _builtins.float cpu_utilization_target: Target CPU load level.
        :param Sequence['ComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules.
        :param _builtins.int max_size: The maximum number of virtual machines in the group.
        :param _builtins.int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param _builtins.int stabilization_duration: The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param _builtins.int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        if auto_scale_type is not None:
            pulumi.set(__self__, "auto_scale_type", auto_scale_type)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @_builtins.property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> _builtins.int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @_builtins.property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> _builtins.int:
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @_builtins.property
    @pulumi.getter(name="autoScaleType")
    def auto_scale_type(self) -> Optional[_builtins.str]:
        """
        Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        return pulumi.get(self, "auto_scale_type")

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[_builtins.float]:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyAutoScaleCustomRule']]:
        """
        A list of custom rules.
        """
        return pulumi.get(self, "custom_rules")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[_builtins.int]:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @_builtins.property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[_builtins.int]:
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @_builtins.property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[_builtins.int]:
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyAutoScaleCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "folderId":
            suggest = "folder_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyAutoScaleCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyAutoScaleCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyAutoScaleCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 metric_type: _builtins.str,
                 rule_type: _builtins.str,
                 target: _builtins.float,
                 folder_id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: Name of the metric in Monitoring.
        :param _builtins.str metric_type: Type of metric, can be `GAUGE` or `COUNTER`. `GAUGE` metric reflects the value at particular time point. `COUNTER` metric exhibits a monotonous growth over time.
        :param _builtins.str rule_type: The metric rule type (UTILIZATION, WORKLOAD). UTILIZATION for metrics describing resource utilization per VM instance. WORKLOAD for metrics describing total workload on all VM instances.
        :param _builtins.float target: Target metric value by which Instance Groups calculates the number of required VM instances.
        :param _builtins.str folder_id: If specified, sets the folder id to fetch metrics from. By default, it is the ID of the folder the group belongs to.
        :param Mapping[str, _builtins.str] labels: Metrics [labels](https://yandex.cloud/en/docs/monitoring/concepts/data-model#label) from Monitoring.
        :param _builtins.str service: If specified, sets the service name to fetch metrics. The default value is `custom`. You can use a label to specify service metrics, e.g., `service` with the `compute` value for Compute Cloud.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "target", target)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Name of the metric in Monitoring.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Type of metric, can be `GAUGE` or `COUNTER`. `GAUGE` metric reflects the value at particular time point. `COUNTER` metric exhibits a monotonous growth over time.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        The metric rule type (UTILIZATION, WORKLOAD). UTILIZATION for metrics describing resource utilization per VM instance. WORKLOAD for metrics describing total workload on all VM instances.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Target metric value by which Instance Groups calculates the number of required VM instances.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        If specified, sets the folder id to fetch metrics from. By default, it is the ID of the folder the group belongs to.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Metrics [labels](https://yandex.cloud/en/docs/monitoring/concepts/data-model#label) from Monitoring.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        If specified, sets the service name to fetch metrics. The default value is `custom`. You can use a label to specify service metrics, e.g., `service` with the `compute` value for Compute Cloud.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyFixedScale(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        """
        :param _builtins.int size: The number of instances in the instance group.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The number of instances in the instance group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyTestAutoScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialSize":
            suggest = "initial_size"
        elif key == "measurementDuration":
            suggest = "measurement_duration"
        elif key == "autoScaleType":
            suggest = "auto_scale_type"
        elif key == "cpuUtilizationTarget":
            suggest = "cpu_utilization_target"
        elif key == "customRules":
            suggest = "custom_rules"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minZoneSize":
            suggest = "min_zone_size"
        elif key == "stabilizationDuration":
            suggest = "stabilization_duration"
        elif key == "warmupDuration":
            suggest = "warmup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyTestAutoScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_size: _builtins.int,
                 measurement_duration: _builtins.int,
                 auto_scale_type: Optional[_builtins.str] = None,
                 cpu_utilization_target: Optional[_builtins.float] = None,
                 custom_rules: Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule']] = None,
                 max_size: Optional[_builtins.int] = None,
                 min_zone_size: Optional[_builtins.int] = None,
                 stabilization_duration: Optional[_builtins.int] = None,
                 warmup_duration: Optional[_builtins.int] = None):
        """
        :param _builtins.int initial_size: The initial number of instances in the instance group.
        :param _builtins.int measurement_duration: The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        :param _builtins.str auto_scale_type: Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        :param _builtins.float cpu_utilization_target: Target CPU load level.
        :param Sequence['ComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules.
        :param _builtins.int max_size: The maximum number of virtual machines in the group.
        :param _builtins.int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param _builtins.int stabilization_duration: The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param _builtins.int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        if auto_scale_type is not None:
            pulumi.set(__self__, "auto_scale_type", auto_scale_type)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if custom_rules is not None:
            pulumi.set(__self__, "custom_rules", custom_rules)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_zone_size is not None:
            pulumi.set(__self__, "min_zone_size", min_zone_size)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @_builtins.property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> _builtins.int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @_builtins.property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> _builtins.int:
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @_builtins.property
    @pulumi.getter(name="autoScaleType")
    def auto_scale_type(self) -> Optional[_builtins.str]:
        """
        Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        return pulumi.get(self, "auto_scale_type")

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[_builtins.float]:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Optional[Sequence['outputs.ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule']]:
        """
        A list of custom rules.
        """
        return pulumi.get(self, "custom_rules")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> Optional[_builtins.int]:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @_builtins.property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[_builtins.int]:
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @_builtins.property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[_builtins.int]:
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricType":
            suggest = "metric_type"
        elif key == "ruleType":
            suggest = "rule_type"
        elif key == "folderId":
            suggest = "folder_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 metric_type: _builtins.str,
                 rule_type: _builtins.str,
                 target: _builtins.float,
                 folder_id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: The name of metric.
        :param _builtins.str metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param _builtins.str rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        :param _builtins.float target: Target metric value level.
        :param _builtins.str folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param Mapping[str, _builtins.str] labels: A map of labels of metric.
        :param _builtins.str service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "target", target)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ComputeInstanceHardwareGeneration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generation2Features":
            suggest = "generation2_features"
        elif key == "legacyFeatures":
            suggest = "legacy_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceHardwareGeneration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceHardwareGeneration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceHardwareGeneration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generation2_features: Optional[Sequence['outputs.ComputeInstanceHardwareGenerationGeneration2Feature']] = None,
                 legacy_features: Optional[Sequence['outputs.ComputeInstanceHardwareGenerationLegacyFeature']] = None):
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional[Sequence['outputs.ComputeInstanceHardwareGenerationGeneration2Feature']]:
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional[Sequence['outputs.ComputeInstanceHardwareGenerationLegacyFeature']]:
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class ComputeInstanceHardwareGenerationGeneration2Feature(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeInstanceHardwareGenerationLegacyFeature(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pciTopology":
            suggest = "pci_topology"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceHardwareGenerationLegacyFeature. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceHardwareGenerationLegacyFeature.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceHardwareGenerationLegacyFeature.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pci_topology: Optional[_builtins.str] = None):
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class ComputeInstanceLocalDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceLocalDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceLocalDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceLocalDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_bytes: _builtins.int,
                 device_name: Optional[_builtins.str] = None):
        """
        :param _builtins.int size_bytes: Size of the disk, specified in bytes.
        :param _builtins.str device_name: The name of the local disk device.
        """
        pulumi.set(__self__, "size_bytes", size_bytes)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)

    @_builtins.property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> _builtins.int:
        """
        Size of the disk, specified in bytes.
        """
        return pulumi.get(self, "size_bytes")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        The name of the local disk device.
        """
        return pulumi.get(self, "device_name")


@pulumi.output_type
class ComputeInstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsV1HttpEndpoint":
            suggest = "aws_v1_http_endpoint"
        elif key == "awsV1HttpToken":
            suggest = "aws_v1_http_token"
        elif key == "gceHttpEndpoint":
            suggest = "gce_http_endpoint"
        elif key == "gceHttpToken":
            suggest = "gce_http_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_v1_http_endpoint: Optional[_builtins.int] = None,
                 aws_v1_http_token: Optional[_builtins.int] = None,
                 gce_http_endpoint: Optional[_builtins.int] = None,
                 gce_http_token: Optional[_builtins.int] = None):
        if aws_v1_http_endpoint is not None:
            pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        if aws_v1_http_token is not None:
            pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        if gce_http_endpoint is not None:
            pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        if gce_http_token is not None:
            pulumi.set(__self__, "gce_http_token", gce_http_token)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "aws_v1_http_token")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "gce_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "gce_http_token")


@pulumi.output_type
class ComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "dnsRecords":
            suggest = "dns_records"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6DnsRecords":
            suggest = "ipv6_dns_records"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "natDnsRecords":
            suggest = "nat_dns_records"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "natIpVersion":
            suggest = "nat_ip_version"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 dns_records: Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceDnsRecord']] = None,
                 index: Optional[_builtins.int] = None,
                 ip_address: Optional[_builtins.str] = None,
                 ipv4: Optional[_builtins.bool] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 ipv6_dns_records: Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceIpv6DnsRecord']] = None,
                 mac_address: Optional[_builtins.str] = None,
                 nat: Optional[_builtins.bool] = None,
                 nat_dns_records: Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceNatDnsRecord']] = None,
                 nat_ip_address: Optional[_builtins.str] = None,
                 nat_ip_version: Optional[_builtins.str] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        :param Sequence['ComputeInstanceNetworkInterfaceDnsRecordArgs'] dns_records: List of configurations for creating ipv4 DNS records.
        :param _builtins.int index: Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        :param _builtins.str ip_address: The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        :param _builtins.bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param _builtins.bool ipv6: If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param _builtins.str ipv6_address: The private IPv6 address to assign to the instance.
        :param Sequence['ComputeInstanceNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of configurations for creating ipv6 DNS records.
        :param _builtins.bool nat: Provide a public address, for instance, to access the internet over NAT.
        :param Sequence['ComputeInstanceNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of configurations for creating ipv4 NAT DNS records.
        :param _builtins.str nat_ip_address: Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        :param Sequence[_builtins.str] security_group_ids: Security Group (SG) IDs for network interface.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if dns_records is not None:
            pulumi.set(__self__, "dns_records", dns_records)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_dns_records is not None:
            pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceDnsRecord']]:
        """
        List of configurations for creating ipv4 DNS records.
        """
        return pulumi.get(self, "dns_records")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        """
        Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.bool]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        The private IPv6 address to assign to the instance.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceIpv6DnsRecord']]:
        """
        List of configurations for creating ipv6 DNS records.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[_builtins.bool]:
        """
        Provide a public address, for instance, to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Optional[Sequence['outputs.ComputeInstanceNetworkInterfaceNatDnsRecord']]:
        """
        List of configurations for creating ipv4 NAT DNS records.
        """
        return pulumi.get(self, "nat_dns_records")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[_builtins.str]:
        """
        Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_ip_version")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security Group (SG) IDs for network interface.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class ComputeInstanceNetworkInterfaceDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterfaceDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterfaceDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterfaceDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN (must have a dot at the end).
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL in seconds.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL in seconds.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceNetworkInterfaceIpv6DnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterfaceIpv6DnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN (must have a dot at the end).
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL in seconds.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL in seconds.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstanceNetworkInterfaceNatDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterfaceNatDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterfaceNatDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN (must have a dot at the end).
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL in seconds.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL in seconds.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ComputeInstancePlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostAffinityRules":
            suggest = "host_affinity_rules"
        elif key == "placementGroupId":
            suggest = "placement_group_id"
        elif key == "placementGroupPartition":
            suggest = "placement_group_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstancePlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstancePlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstancePlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_affinity_rules: Optional[Sequence['outputs.ComputeInstancePlacementPolicyHostAffinityRule']] = None,
                 placement_group_id: Optional[_builtins.str] = None,
                 placement_group_partition: Optional[_builtins.int] = None):
        """
        :param Sequence['ComputeInstancePlacementPolicyHostAffinityRuleArgs'] host_affinity_rules: List of host affinity rules.
        :param _builtins.str placement_group_id: Specifies the id of the Placement Group to assign to the instance.
        """
        if host_affinity_rules is not None:
            pulumi.set(__self__, "host_affinity_rules", host_affinity_rules)
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @_builtins.property
    @pulumi.getter(name="hostAffinityRules")
    def host_affinity_rules(self) -> Optional[Sequence['outputs.ComputeInstancePlacementPolicyHostAffinityRule']]:
        """
        List of host affinity rules.
        """
        return pulumi.get(self, "host_affinity_rules")

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        return pulumi.get(self, "placement_group_id")

    @_builtins.property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "placement_group_partition")


@pulumi.output_type
class ComputeInstancePlacementPolicyHostAffinityRule(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 op: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        :param _builtins.str op: Affinity action. The only value supported is `IN`.
        :param Sequence[_builtins.str] values: List of values (host IDs or host group IDs).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Affinity label or one of reserved values - `yc.hostId`, `yc.hostGroupId`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        Affinity action. The only value supported is `IN`.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        List of values (host IDs or host group IDs).
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ComputeInstanceResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores: _builtins.int,
                 memory: _builtins.float,
                 core_fraction: Optional[_builtins.int] = None,
                 gpus: Optional[_builtins.int] = None):
        """
        :param _builtins.int cores: CPU cores for the instance.
        :param _builtins.float memory: Memory size in GB.
        :param _builtins.int core_fraction: If provided, specifies baseline performance for a core as a percent.
        :param _builtins.int gpus: If provided, specifies the number of GPU devices for the instance.
        """
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)

    @_builtins.property
    @pulumi.getter
    def cores(self) -> _builtins.int:
        """
        CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Memory size in GB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[_builtins.int]:
        """
        If provided, specifies baseline performance for a core as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> Optional[_builtins.int]:
        """
        If provided, specifies the number of GPU devices for the instance.
        """
        return pulumi.get(self, "gpus")


@pulumi.output_type
class ComputeInstanceSchedulingPolicy(dict):
    def __init__(__self__, *,
                 preemptible: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool preemptible: Specifies if the instance is preemptible. Defaults to `false`.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance is preemptible. Defaults to `false`.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class ComputeInstanceSecondaryDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskId":
            suggest = "disk_id"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceSecondaryDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceSecondaryDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceSecondaryDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_id: _builtins.str,
                 auto_delete: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk_id: ID of the disk that is attached to the instance.
        :param _builtins.bool auto_delete: Whether the disk is auto-deleted when the instance is deleted. The default value is `false`.
        :param _builtins.str device_name: Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        :param _builtins.str mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "disk_id", disk_id)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> _builtins.str:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is `false`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ComputeSnapshotHardwareGeneration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generation2Features":
            suggest = "generation2_features"
        elif key == "legacyFeatures":
            suggest = "legacy_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeSnapshotHardwareGeneration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeSnapshotHardwareGeneration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeSnapshotHardwareGeneration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generation2_features: Optional['outputs.ComputeSnapshotHardwareGenerationGeneration2Features'] = None,
                 legacy_features: Optional['outputs.ComputeSnapshotHardwareGenerationLegacyFeatures'] = None):
        """
        :param 'ComputeSnapshotHardwareGenerationGeneration2FeaturesArgs' generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param 'ComputeSnapshotHardwareGenerationLegacyFeaturesArgs' legacy_features: Defines the first known hardware generation and its features.
        """
        if generation2_features is not None:
            pulumi.set(__self__, "generation2_features", generation2_features)
        if legacy_features is not None:
            pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Optional['outputs.ComputeSnapshotHardwareGenerationGeneration2Features']:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Optional['outputs.ComputeSnapshotHardwareGenerationLegacyFeatures']:
        """
        Defines the first known hardware generation and its features.
        """
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class ComputeSnapshotHardwareGenerationGeneration2Features(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeSnapshotHardwareGenerationLegacyFeatures(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pciTopology":
            suggest = "pci_topology"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeSnapshotHardwareGenerationLegacyFeatures. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeSnapshotHardwareGenerationLegacyFeatures.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeSnapshotHardwareGenerationLegacyFeatures.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pci_topology: Optional[_builtins.str] = None):
        """
        :param _builtins.str pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        if pci_topology is not None:
            pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> Optional[_builtins.str]:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class ComputeSnapshotScheduleSchedulePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startAt":
            suggest = "start_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeSnapshotScheduleSchedulePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeSnapshotScheduleSchedulePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeSnapshotScheduleSchedulePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: Optional[_builtins.str] = None,
                 start_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: Cron expression to schedule snapshots (in cron format `" * ****"`).
        :param _builtins.str start_at: Time to start the snapshot schedule (in format RFC3339 `2006-01-02T15:04:05Z07:00`). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if start_at is not None:
            pulumi.set(__self__, "start_at", start_at)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Cron expression to schedule snapshots (in cron format `" * ****"`).
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> Optional[_builtins.str]:
        """
        Time to start the snapshot schedule (in format RFC3339 `2006-01-02T15:04:05Z07:00`). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
        return pulumi.get(self, "start_at")


@pulumi.output_type
class ComputeSnapshotScheduleSnapshotSpec(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str description: Description to assign to snapshots created by this snapshot schedule.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description to assign to snapshots created by this snapshot schedule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class ContainerRepositoryLifecyclePolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirePeriod":
            suggest = "expire_period"
        elif key == "retainedTop":
            suggest = "retained_top"
        elif key == "tagRegexp":
            suggest = "tag_regexp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerRepositoryLifecyclePolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerRepositoryLifecyclePolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerRepositoryLifecyclePolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 expire_period: Optional[_builtins.str] = None,
                 retained_top: Optional[_builtins.int] = None,
                 tag_regexp: Optional[_builtins.str] = None,
                 untagged: Optional[_builtins.bool] = None):
        """
        :param _builtins.str description: Description of the lifecycle policy.
        :param _builtins.str expire_period: The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        :param _builtins.int retained_top: The number of images to be retained even if the `expire_period` already expired.
        :param _builtins.str tag_regexp: Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        :param _builtins.bool untagged: If enabled, rules apply to untagged Docker images.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expire_period is not None:
            pulumi.set(__self__, "expire_period", expire_period)
        if retained_top is not None:
            pulumi.set(__self__, "retained_top", retained_top)
        if tag_regexp is not None:
            pulumi.set(__self__, "tag_regexp", tag_regexp)
        if untagged is not None:
            pulumi.set(__self__, "untagged", untagged)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the lifecycle policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expirePeriod")
    def expire_period(self) -> Optional[_builtins.str]:
        """
        The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        """
        return pulumi.get(self, "expire_period")

    @_builtins.property
    @pulumi.getter(name="retainedTop")
    def retained_top(self) -> Optional[_builtins.int]:
        """
        The number of images to be retained even if the `expire_period` already expired.
        """
        return pulumi.get(self, "retained_top")

    @_builtins.property
    @pulumi.getter(name="tagRegexp")
    def tag_regexp(self) -> Optional[_builtins.str]:
        """
        Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        """
        return pulumi.get(self, "tag_regexp")

    @_builtins.property
    @pulumi.getter
    def untagged(self) -> Optional[_builtins.bool]:
        """
        If enabled, rules apply to untagged Docker images.
        """
        return pulumi.get(self, "untagged")


@pulumi.output_type
class DataprocClusterClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subclusterSpecs":
            suggest = "subcluster_specs"
        elif key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subcluster_specs: Sequence['outputs.DataprocClusterClusterConfigSubclusterSpec'],
                 hadoop: Optional['outputs.DataprocClusterClusterConfigHadoop'] = None,
                 version_id: Optional[_builtins.str] = None):
        """
        :param Sequence['DataprocClusterClusterConfigSubclusterSpecArgs'] subcluster_specs: Configuration of the Yandex Data Processing subcluster.
        :param 'DataprocClusterClusterConfigHadoopArgs' hadoop: Yandex Data Processing specific options.
        :param _builtins.str version_id: Version of Yandex Data Processing image.
        """
        pulumi.set(__self__, "subcluster_specs", subcluster_specs)
        if hadoop is not None:
            pulumi.set(__self__, "hadoop", hadoop)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter(name="subclusterSpecs")
    def subcluster_specs(self) -> Sequence['outputs.DataprocClusterClusterConfigSubclusterSpec']:
        """
        Configuration of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "subcluster_specs")

    @_builtins.property
    @pulumi.getter
    def hadoop(self) -> Optional['outputs.DataprocClusterClusterConfigHadoop']:
        """
        Yandex Data Processing specific options.
        """
        return pulumi.get(self, "hadoop")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[_builtins.str]:
        """
        Version of Yandex Data Processing image.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class DataprocClusterClusterConfigHadoop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initializationActions":
            suggest = "initialization_actions"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigHadoop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigHadoop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigHadoop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initialization_actions: Optional[Sequence['outputs.DataprocClusterClusterConfigHadoopInitializationAction']] = None,
                 oslogin: Optional[_builtins.bool] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 services: Optional[Sequence[_builtins.str]] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence['DataprocClusterClusterConfigHadoopInitializationActionArgs'] initialization_actions: List of initialization scripts.
        :param _builtins.bool oslogin: Whether to enable authorization via OS Login.
        :param Mapping[str, _builtins.str] properties: A set of key/value pairs that are used to configure cluster services.
        :param Sequence[_builtins.str] services: List of services to run on Yandex Data Processing cluster.
        :param Sequence[_builtins.str] ssh_public_keys: List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://yandex.cloud/docs/data-proc/operations/connect).
        """
        if initialization_actions is not None:
            pulumi.set(__self__, "initialization_actions", initialization_actions)
        if oslogin is not None:
            pulumi.set(__self__, "oslogin", oslogin)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @_builtins.property
    @pulumi.getter(name="initializationActions")
    def initialization_actions(self) -> Optional[Sequence['outputs.DataprocClusterClusterConfigHadoopInitializationAction']]:
        """
        List of initialization scripts.
        """
        return pulumi.get(self, "initialization_actions")

    @_builtins.property
    @pulumi.getter
    def oslogin(self) -> Optional[_builtins.bool]:
        """
        Whether to enable authorization via OS Login.
        """
        return pulumi.get(self, "oslogin")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value pairs that are used to configure cluster services.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of services to run on Yandex Data Processing cluster.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://yandex.cloud/docs/data-proc/operations/connect).
        """
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class DataprocClusterClusterConfigHadoopInitializationAction(dict):
    def __init__(__self__, *,
                 uri: _builtins.str,
                 args: Optional[Sequence[_builtins.str]] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str uri: Script URI.
        :param Sequence[_builtins.str] args: List of arguments of the initialization script.
        :param _builtins.str timeout: Script execution timeout, in seconds.
        """
        pulumi.set(__self__, "uri", uri)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        Script URI.
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of arguments of the initialization script.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Script execution timeout, in seconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DataprocClusterClusterConfigSubclusterSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostsCount":
            suggest = "hosts_count"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "autoscalingConfig":
            suggest = "autoscaling_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigSubclusterSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigSubclusterSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigSubclusterSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts_count: _builtins.int,
                 name: _builtins.str,
                 resources: 'outputs.DataprocClusterClusterConfigSubclusterSpecResources',
                 role: _builtins.str,
                 subnet_id: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 autoscaling_config: Optional['outputs.DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig'] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int hosts_count: Number of hosts within Yandex Data Processing subcluster.
        :param _builtins.str name: Name of the Yandex Data Processing subcluster.
        :param 'DataprocClusterClusterConfigSubclusterSpecResourcesArgs' resources: Resources allocated to each host of the Yandex Data Processing subcluster.
        :param _builtins.str role: Role of the subcluster in the Yandex Data Processing cluster.
        :param _builtins.str subnet_id: The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        :param _builtins.bool assign_public_ip: If `true` then assign public IP addresses to the hosts of the subclusters.
        :param 'DataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs' autoscaling_config: Autoscaling configuration for compute subclusters.
        :param _builtins.str id: ID of the subcluster.
        """
        pulumi.set(__self__, "hosts_count", hosts_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if autoscaling_config is not None:
            pulumi.set(__self__, "autoscaling_config", autoscaling_config)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="hostsCount")
    def hosts_count(self) -> _builtins.int:
        """
        Number of hosts within Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "hosts_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.DataprocClusterClusterConfigSubclusterSpecResources':
        """
        Resources allocated to each host of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Role of the subcluster in the Yandex Data Processing cluster.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        If `true` then assign public IP addresses to the hosts of the subclusters.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="autoscalingConfig")
    def autoscaling_config(self) -> Optional['outputs.DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig']:
        """
        Autoscaling configuration for compute subclusters.
        """
        return pulumi.get(self, "autoscaling_config")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the subcluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHostsCount":
            suggest = "max_hosts_count"
        elif key == "cpuUtilizationTarget":
            suggest = "cpu_utilization_target"
        elif key == "decommissionTimeout":
            suggest = "decommission_timeout"
        elif key == "measurementDuration":
            suggest = "measurement_duration"
        elif key == "stabilizationDuration":
            suggest = "stabilization_duration"
        elif key == "warmupDuration":
            suggest = "warmup_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_hosts_count: _builtins.int,
                 cpu_utilization_target: Optional[_builtins.str] = None,
                 decommission_timeout: Optional[_builtins.str] = None,
                 measurement_duration: Optional[_builtins.str] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 stabilization_duration: Optional[_builtins.str] = None,
                 warmup_duration: Optional[_builtins.str] = None):
        """
        :param _builtins.int max_hosts_count: Maximum number of nodes in autoscaling subclusters.
        :param _builtins.str cpu_utilization_target: Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        :param _builtins.str decommission_timeout: Timeout to gracefully decommission nodes during downscaling. In seconds.
        :param _builtins.str measurement_duration: Time in seconds allotted for averaging metrics.
        :param _builtins.bool preemptible: Use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://yandex.cloud/docs/compute/concepts/preemptible-vm).
        :param _builtins.str stabilization_duration: Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        :param _builtins.str warmup_duration: The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        pulumi.set(__self__, "max_hosts_count", max_hosts_count)
        if cpu_utilization_target is not None:
            pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        if decommission_timeout is not None:
            pulumi.set(__self__, "decommission_timeout", decommission_timeout)
        if measurement_duration is not None:
            pulumi.set(__self__, "measurement_duration", measurement_duration)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if stabilization_duration is not None:
            pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        if warmup_duration is not None:
            pulumi.set(__self__, "warmup_duration", warmup_duration)

    @_builtins.property
    @pulumi.getter(name="maxHostsCount")
    def max_hosts_count(self) -> _builtins.int:
        """
        Maximum number of nodes in autoscaling subclusters.
        """
        return pulumi.get(self, "max_hosts_count")

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> Optional[_builtins.str]:
        """
        Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @_builtins.property
    @pulumi.getter(name="decommissionTimeout")
    def decommission_timeout(self) -> Optional[_builtins.str]:
        """
        Timeout to gracefully decommission nodes during downscaling. In seconds.
        """
        return pulumi.get(self, "decommission_timeout")

    @_builtins.property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> Optional[_builtins.str]:
        """
        Time in seconds allotted for averaging metrics.
        """
        return pulumi.get(self, "measurement_duration")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://yandex.cloud/docs/compute/concepts/preemptible-vm).
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> Optional[_builtins.str]:
        """
        Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        """
        return pulumi.get(self, "stabilization_duration")

    @_builtins.property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> Optional[_builtins.str]:
        """
        The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class DataprocClusterClusterConfigSubclusterSpecResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"
        elif key == "diskTypeId":
            suggest = "disk_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataprocClusterClusterConfigSubclusterSpecResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataprocClusterClusterConfigSubclusterSpecResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataprocClusterClusterConfigSubclusterSpecResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 resource_preset_id: _builtins.str,
                 disk_type_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://yandex.cloud/docs/data-proc/concepts/instance-types).
        :param _builtins.str disk_type_id: Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://yandex.cloud/docs/data-proc/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        return pulumi.get(self, "disk_type_id")


@pulumi.output_type
class DatatransferEndpointSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clickhouseSource":
            suggest = "clickhouse_source"
        elif key == "clickhouseTarget":
            suggest = "clickhouse_target"
        elif key == "kafkaSource":
            suggest = "kafka_source"
        elif key == "kafkaTarget":
            suggest = "kafka_target"
        elif key == "metrikaSource":
            suggest = "metrika_source"
        elif key == "mongoSource":
            suggest = "mongo_source"
        elif key == "mongoTarget":
            suggest = "mongo_target"
        elif key == "mysqlSource":
            suggest = "mysql_source"
        elif key == "mysqlTarget":
            suggest = "mysql_target"
        elif key == "postgresSource":
            suggest = "postgres_source"
        elif key == "postgresTarget":
            suggest = "postgres_target"
        elif key == "ydbSource":
            suggest = "ydb_source"
        elif key == "ydbTarget":
            suggest = "ydb_target"
        elif key == "ydsSource":
            suggest = "yds_source"
        elif key == "ydsTarget":
            suggest = "yds_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clickhouse_source: Optional['outputs.DatatransferEndpointSettingsClickhouseSource'] = None,
                 clickhouse_target: Optional['outputs.DatatransferEndpointSettingsClickhouseTarget'] = None,
                 kafka_source: Optional['outputs.DatatransferEndpointSettingsKafkaSource'] = None,
                 kafka_target: Optional['outputs.DatatransferEndpointSettingsKafkaTarget'] = None,
                 metrika_source: Optional['outputs.DatatransferEndpointSettingsMetrikaSource'] = None,
                 mongo_source: Optional['outputs.DatatransferEndpointSettingsMongoSource'] = None,
                 mongo_target: Optional['outputs.DatatransferEndpointSettingsMongoTarget'] = None,
                 mysql_source: Optional['outputs.DatatransferEndpointSettingsMysqlSource'] = None,
                 mysql_target: Optional['outputs.DatatransferEndpointSettingsMysqlTarget'] = None,
                 postgres_source: Optional['outputs.DatatransferEndpointSettingsPostgresSource'] = None,
                 postgres_target: Optional['outputs.DatatransferEndpointSettingsPostgresTarget'] = None,
                 ydb_source: Optional['outputs.DatatransferEndpointSettingsYdbSource'] = None,
                 ydb_target: Optional['outputs.DatatransferEndpointSettingsYdbTarget'] = None,
                 yds_source: Optional['outputs.DatatransferEndpointSettingsYdsSource'] = None,
                 yds_target: Optional['outputs.DatatransferEndpointSettingsYdsTarget'] = None):
        """
        :param 'DatatransferEndpointSettingsClickhouseSourceArgs' clickhouse_source: Settings specific to the ClickHouse source endpoint.
        :param 'DatatransferEndpointSettingsClickhouseTargetArgs' clickhouse_target: Settings specific to the ClickHouse target endpoint.
        :param 'DatatransferEndpointSettingsKafkaSourceArgs' kafka_source: Settings specific to the Kafka source endpoint.
        :param 'DatatransferEndpointSettingsKafkaTargetArgs' kafka_target: Settings specific to the Kafka target endpoint.
        :param 'DatatransferEndpointSettingsMetrikaSourceArgs' metrika_source: Settings specific to the Yandex Metrika source endpoint.
        :param 'DatatransferEndpointSettingsMongoSourceArgs' mongo_source: Settings specific to the MongoDB source endpoint.
        :param 'DatatransferEndpointSettingsMongoTargetArgs' mongo_target: Settings specific to the MongoDB target endpoint.
        :param 'DatatransferEndpointSettingsMysqlSourceArgs' mysql_source: Settings specific to the MySQL source endpoint.
        :param 'DatatransferEndpointSettingsMysqlTargetArgs' mysql_target: Settings specific to the MySQL target endpoint.
        :param 'DatatransferEndpointSettingsPostgresSourceArgs' postgres_source: Settings specific to the PostgreSQL source endpoint.
        :param 'DatatransferEndpointSettingsPostgresTargetArgs' postgres_target: Settings specific to the PostgreSQL target endpoint.
        :param 'DatatransferEndpointSettingsYdbSourceArgs' ydb_source: Settings specific to the YDB source endpoint.
        :param 'DatatransferEndpointSettingsYdbTargetArgs' ydb_target: Settings specific to the YDB target endpoint.
        :param 'DatatransferEndpointSettingsYdsSourceArgs' yds_source: Settings specific to the YDS source endpoint.
        :param 'DatatransferEndpointSettingsYdsTargetArgs' yds_target: Settings specific to the YDS target endpoint.
        """
        if clickhouse_source is not None:
            pulumi.set(__self__, "clickhouse_source", clickhouse_source)
        if clickhouse_target is not None:
            pulumi.set(__self__, "clickhouse_target", clickhouse_target)
        if kafka_source is not None:
            pulumi.set(__self__, "kafka_source", kafka_source)
        if kafka_target is not None:
            pulumi.set(__self__, "kafka_target", kafka_target)
        if metrika_source is not None:
            pulumi.set(__self__, "metrika_source", metrika_source)
        if mongo_source is not None:
            pulumi.set(__self__, "mongo_source", mongo_source)
        if mongo_target is not None:
            pulumi.set(__self__, "mongo_target", mongo_target)
        if mysql_source is not None:
            pulumi.set(__self__, "mysql_source", mysql_source)
        if mysql_target is not None:
            pulumi.set(__self__, "mysql_target", mysql_target)
        if postgres_source is not None:
            pulumi.set(__self__, "postgres_source", postgres_source)
        if postgres_target is not None:
            pulumi.set(__self__, "postgres_target", postgres_target)
        if ydb_source is not None:
            pulumi.set(__self__, "ydb_source", ydb_source)
        if ydb_target is not None:
            pulumi.set(__self__, "ydb_target", ydb_target)
        if yds_source is not None:
            pulumi.set(__self__, "yds_source", yds_source)
        if yds_target is not None:
            pulumi.set(__self__, "yds_target", yds_target)

    @_builtins.property
    @pulumi.getter(name="clickhouseSource")
    def clickhouse_source(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSource']:
        """
        Settings specific to the ClickHouse source endpoint.
        """
        return pulumi.get(self, "clickhouse_source")

    @_builtins.property
    @pulumi.getter(name="clickhouseTarget")
    def clickhouse_target(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTarget']:
        """
        Settings specific to the ClickHouse target endpoint.
        """
        return pulumi.get(self, "clickhouse_target")

    @_builtins.property
    @pulumi.getter(name="kafkaSource")
    def kafka_source(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSource']:
        """
        Settings specific to the Kafka source endpoint.
        """
        return pulumi.get(self, "kafka_source")

    @_builtins.property
    @pulumi.getter(name="kafkaTarget")
    def kafka_target(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTarget']:
        """
        Settings specific to the Kafka target endpoint.
        """
        return pulumi.get(self, "kafka_target")

    @_builtins.property
    @pulumi.getter(name="metrikaSource")
    def metrika_source(self) -> Optional['outputs.DatatransferEndpointSettingsMetrikaSource']:
        """
        Settings specific to the Yandex Metrika source endpoint.
        """
        return pulumi.get(self, "metrika_source")

    @_builtins.property
    @pulumi.getter(name="mongoSource")
    def mongo_source(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSource']:
        """
        Settings specific to the MongoDB source endpoint.
        """
        return pulumi.get(self, "mongo_source")

    @_builtins.property
    @pulumi.getter(name="mongoTarget")
    def mongo_target(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTarget']:
        """
        Settings specific to the MongoDB target endpoint.
        """
        return pulumi.get(self, "mongo_target")

    @_builtins.property
    @pulumi.getter(name="mysqlSource")
    def mysql_source(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSource']:
        """
        Settings specific to the MySQL source endpoint.
        """
        return pulumi.get(self, "mysql_source")

    @_builtins.property
    @pulumi.getter(name="mysqlTarget")
    def mysql_target(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTarget']:
        """
        Settings specific to the MySQL target endpoint.
        """
        return pulumi.get(self, "mysql_target")

    @_builtins.property
    @pulumi.getter(name="postgresSource")
    def postgres_source(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSource']:
        """
        Settings specific to the PostgreSQL source endpoint.
        """
        return pulumi.get(self, "postgres_source")

    @_builtins.property
    @pulumi.getter(name="postgresTarget")
    def postgres_target(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTarget']:
        """
        Settings specific to the PostgreSQL target endpoint.
        """
        return pulumi.get(self, "postgres_target")

    @_builtins.property
    @pulumi.getter(name="ydbSource")
    def ydb_source(self) -> Optional['outputs.DatatransferEndpointSettingsYdbSource']:
        """
        Settings specific to the YDB source endpoint.
        """
        return pulumi.get(self, "ydb_source")

    @_builtins.property
    @pulumi.getter(name="ydbTarget")
    def ydb_target(self) -> Optional['outputs.DatatransferEndpointSettingsYdbTarget']:
        """
        Settings specific to the YDB target endpoint.
        """
        return pulumi.get(self, "ydb_target")

    @_builtins.property
    @pulumi.getter(name="ydsSource")
    def yds_source(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSource']:
        """
        Settings specific to the YDS source endpoint.
        """
        return pulumi.get(self, "yds_source")

    @_builtins.property
    @pulumi.getter(name="ydsTarget")
    def yds_target(self) -> Optional['outputs.DatatransferEndpointSettingsYdsTarget']:
        """
        Settings specific to the YDS target endpoint.
        """
        return pulumi.get(self, "yds_target")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clickhouseClusterName":
            suggest = "clickhouse_cluster_name"
        elif key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clickhouse_cluster_name: Optional[_builtins.str] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnection'] = None,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsClickhouseSourceConnectionArgs' connection: Connection settings.
        :param Sequence[_builtins.str] exclude_tables: The list of tables that should not be transferred.
        :param Sequence[_builtins.str] include_tables: The list of tables that should be transferred. Leave empty if all tables should be transferred.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if clickhouse_cluster_name is not None:
            pulumi.set(__self__, "clickhouse_cluster_name", clickhouse_cluster_name)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="clickhouseClusterName")
    def clickhouse_cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "clickhouse_cluster_name")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of tables that should not be transferred.
        """
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of tables that should be transferred. Leave empty if all tables should be transferred.
        """
        return pulumi.get(self, "include_tables")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionOptions":
            suggest = "connection_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_options: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions'] = None):
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @_builtins.property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions']:
        return pulumi.get(self, "connection_options")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword'] = None,
                 user: Optional[_builtins.str] = None):
        if database is not None:
            pulumi.set(__self__, "database", database)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise']:
        return pulumi.get(self, "on_premise")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword']:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPort":
            suggest = "http_port"
        elif key == "nativePort":
            suggest = "native_port"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_port: Optional[_builtins.int] = None,
                 native_port: Optional[_builtins.int] = None,
                 shards: Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard']] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode'] = None):
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if native_port is not None:
            pulumi.set(__self__, "native_port", native_port)
        if shards is not None:
            pulumi.set(__self__, "shards", shards)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="nativePort")
    def native_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "native_port")

    @_builtins.property
    @pulumi.getter
    def shards(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard']]:
        return pulumi.get(self, "shards")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode']:
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard(dict):
    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 name: Optional[_builtins.str] = None):
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "altNames":
            suggest = "alt_names"
        elif key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "clickhouseClusterName":
            suggest = "clickhouse_cluster_name"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alt_names: Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseTargetAltName']] = None,
                 cleanup_policy: Optional[_builtins.str] = None,
                 clickhouse_cluster_name: Optional[_builtins.str] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnection'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 sharding: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetSharding'] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param Sequence['DatatransferEndpointSettingsClickhouseTargetAltNameArgs'] alt_names: Table renaming rules.
        :param _builtins.str cleanup_policy: How to clean collections when activating the transfer. One of `CLICKHOUSE_CLEANUP_POLICY_DISABLED` or `CLICKHOUSE_CLEANUP_POLICY_DROP`.
        :param _builtins.str clickhouse_cluster_name: Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        :param 'DatatransferEndpointSettingsClickhouseTargetConnectionArgs' connection: Connection settings.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param 'DatatransferEndpointSettingsClickhouseTargetShardingArgs' sharding: Shard selection rules for the data being transferred.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if alt_names is not None:
            pulumi.set(__self__, "alt_names", alt_names)
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if clickhouse_cluster_name is not None:
            pulumi.set(__self__, "clickhouse_cluster_name", clickhouse_cluster_name)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if sharding is not None:
            pulumi.set(__self__, "sharding", sharding)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="altNames")
    def alt_names(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseTargetAltName']]:
        """
        Table renaming rules.
        """
        return pulumi.get(self, "alt_names")

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        How to clean collections when activating the transfer. One of `CLICKHOUSE_CLEANUP_POLICY_DISABLED` or `CLICKHOUSE_CLEANUP_POLICY_DROP`.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter(name="clickhouseClusterName")
    def clickhouse_cluster_name(self) -> Optional[_builtins.str]:
        """
        Name of the ClickHouse cluster. For managed ClickHouse clusters defaults to managed cluster ID.
        """
        return pulumi.get(self, "clickhouse_cluster_name")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def sharding(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetSharding']:
        """
        Shard selection rules for the data being transferred.
        """
        return pulumi.get(self, "sharding")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetAltName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromName":
            suggest = "from_name"
        elif key == "toName":
            suggest = "to_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetAltName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetAltName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetAltName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_name: Optional[_builtins.str] = None,
                 to_name: Optional[_builtins.str] = None):
        if from_name is not None:
            pulumi.set(__self__, "from_name", from_name)
        if to_name is not None:
            pulumi.set(__self__, "to_name", to_name)

    @_builtins.property
    @pulumi.getter(name="fromName")
    def from_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "from_name")

    @_builtins.property
    @pulumi.getter(name="toName")
    def to_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "to_name")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionOptions":
            suggest = "connection_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_options: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions'] = None):
        """
        :param 'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsArgs' connection_options: Connection options.
        """
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @_builtins.property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions']:
        """
        Connection options.
        """
        return pulumi.get(self, "connection_options")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword'] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: Database name.
        :param _builtins.str mdb_cluster_id: Identifier of the Managed ClickHouse cluster.
        :param 'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseArgs' on_premise: Connection settings of the on-premise ClickHouse server.
        :param 'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPasswordArgs' password: Password for the database access.
        :param _builtins.str user: User for database access.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed ClickHouse cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise']:
        """
        Connection settings of the on-premise ClickHouse server.
        """
        return pulumi.get(self, "on_premise")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword']:
        """
        Password for the database access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        User for database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPort":
            suggest = "http_port"
        elif key == "nativePort":
            suggest = "native_port"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_port: Optional[_builtins.int] = None,
                 native_port: Optional[_builtins.int] = None,
                 shards: Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard']] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode'] = None):
        """
        :param _builtins.int http_port: TCP port number for the HTTP interface of the ClickHouse server.
        :param _builtins.int native_port: TCP port number for the native interface of the ClickHouse server.
        :param Sequence['DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShardArgs'] shards: The list of ClickHouse shards.
        :param 'DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection.
        """
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if native_port is not None:
            pulumi.set(__self__, "native_port", native_port)
        if shards is not None:
            pulumi.set(__self__, "shards", shards)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        TCP port number for the HTTP interface of the ClickHouse server.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="nativePort")
    def native_port(self) -> Optional[_builtins.int]:
        """
        TCP port number for the native interface of the ClickHouse server.
        """
        return pulumi.get(self, "native_port")

    @_builtins.property
    @pulumi.getter
    def shards(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard']]:
        """
        The list of ClickHouse shards.
        """
        return pulumi.get(self, "shards")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode']:
        """
        TLS settings for the server connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard(dict):
    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] hosts: List of ClickHouse server host names.
        :param _builtins.str name: Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of ClickHouse server host names.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Arbitrary shard name. This name may be used in `sharding` block to specify custom sharding rules.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        """
        :param _builtins.str raw: Password for the database access.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        """
        Password for the database access.
        """
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetSharding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnValueHash":
            suggest = "column_value_hash"
        elif key == "customMapping":
            suggest = "custom_mapping"
        elif key == "roundRobin":
            suggest = "round_robin"
        elif key == "transferId":
            suggest = "transfer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetSharding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetSharding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetSharding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_value_hash: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash'] = None,
                 custom_mapping: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping'] = None,
                 round_robin: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingRoundRobin'] = None,
                 transfer_id: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingTransferId'] = None):
        """
        :param 'DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHashArgs' column_value_hash: Shard data by the hash value of the specified column.
        :param 'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingArgs' custom_mapping: A custom shard mapping by the value of the specified column.
        :param 'DatatransferEndpointSettingsClickhouseTargetShardingRoundRobinArgs' round_robin: Distribute incoming rows between ClickHouse shards in a round-robin manner. Specify as an empty block to enable.
        :param 'DatatransferEndpointSettingsClickhouseTargetShardingTransferIdArgs' transfer_id: Shard data by ID of the transfer.
        """
        if column_value_hash is not None:
            pulumi.set(__self__, "column_value_hash", column_value_hash)
        if custom_mapping is not None:
            pulumi.set(__self__, "custom_mapping", custom_mapping)
        if round_robin is not None:
            pulumi.set(__self__, "round_robin", round_robin)
        if transfer_id is not None:
            pulumi.set(__self__, "transfer_id", transfer_id)

    @_builtins.property
    @pulumi.getter(name="columnValueHash")
    def column_value_hash(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash']:
        """
        Shard data by the hash value of the specified column.
        """
        return pulumi.get(self, "column_value_hash")

    @_builtins.property
    @pulumi.getter(name="customMapping")
    def custom_mapping(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping']:
        """
        A custom shard mapping by the value of the specified column.
        """
        return pulumi.get(self, "custom_mapping")

    @_builtins.property
    @pulumi.getter(name="roundRobin")
    def round_robin(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingRoundRobin']:
        """
        Distribute incoming rows between ClickHouse shards in a round-robin manner. Specify as an empty block to enable.
        """
        return pulumi.get(self, "round_robin")

    @_builtins.property
    @pulumi.getter(name="transferId")
    def transfer_id(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingTransferId']:
        """
        Shard data by ID of the transfer.
        """
        return pulumi.get(self, "transfer_id")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str column_name: The name of the column to calculate hash from.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[_builtins.str]:
        """
        The name of the column to calculate hash from.
        """
        return pulumi.get(self, "column_name")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[_builtins.str] = None,
                 mappings: Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping']] = None):
        """
        :param _builtins.str column_name: The name of the column to inspect when deciding the shard to chose for an incoming row.
        :param Sequence['DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingArgs'] mappings: The mapping of the specified column values to the shard names.
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[_builtins.str]:
        """
        The name of the column to inspect when deciding the shard to chose for an incoming row.
        """
        return pulumi.get(self, "column_name")

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping']]:
        """
        The mapping of the specified column values to the shard names.
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnValue":
            suggest = "column_value"
        elif key == "shardName":
            suggest = "shard_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_value: Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue'] = None,
                 shard_name: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValueArgs' column_value: The value of the column. Currently only the string columns are supported.
        :param _builtins.str shard_name: The name of the shard into which all the rows with the specified `column_value` will be written.
        """
        if column_value is not None:
            pulumi.set(__self__, "column_value", column_value)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)

    @_builtins.property
    @pulumi.getter(name="columnValue")
    def column_value(self) -> Optional['outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue']:
        """
        The value of the column. Currently only the string columns are supported.
        """
        return pulumi.get(self, "column_value")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[_builtins.str]:
        """
        The name of the shard into which all the rows with the specified `column_value` will be written.
        """
        return pulumi.get(self, "shard_name")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 string_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str string_value: The string value of the column.
        """
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[_builtins.str]:
        """
        The string value of the column.
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetShardingRoundRobin(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsClickhouseTargetShardingTransferId(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"
        elif key == "topicName":
            suggest = "topic_name"
        elif key == "topicNames":
            suggest = "topic_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuth'] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnection'] = None,
                 parser: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParser'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 topic_name: Optional[_builtins.str] = None,
                 topic_names: Optional[Sequence[_builtins.str]] = None,
                 transformer: Optional['outputs.DatatransferEndpointSettingsKafkaSourceTransformer'] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaSourceAuthArgs' auth: Authentication data.
        :param 'DatatransferEndpointSettingsKafkaSourceConnectionArgs' connection: Connection settings.
        :param 'DatatransferEndpointSettingsKafkaSourceParserArgs' parser: Data parsing parameters. If not set, the source messages are read in raw.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str topic_name: **Deprecated**. Please use `topic_names` instead.
        :param Sequence[_builtins.str] topic_names: The list of full source topic names.
        :param 'DatatransferEndpointSettingsKafkaSourceTransformerArgs' transformer: Transform data with a custom Cloud Function.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)
        if topic_names is not None:
            pulumi.set(__self__, "topic_names", topic_names)
        if transformer is not None:
            pulumi.set(__self__, "transformer", transformer)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuth']:
        """
        Authentication data.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def parser(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParser']:
        """
        Data parsing parameters. If not set, the source messages are read in raw.
        """
        return pulumi.get(self, "parser")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[_builtins.str]:
        """
        **Deprecated**. Please use `topic_names` instead.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="topicNames")
    def topic_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of full source topic names.
        """
        return pulumi.get(self, "topic_names")

    @_builtins.property
    @pulumi.getter
    def transformer(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceTransformer']:
        """
        Transform data with a custom Cloud Function.
        """
        return pulumi.get(self, "transformer")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAuth":
            suggest = "no_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_auth: Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuthNoAuth'] = None,
                 sasl: Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuthSasl'] = None):
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @_builtins.property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuthNoAuth']:
        return pulumi.get(self, "no_auth")

    @_builtins.property
    @pulumi.getter
    def sasl(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuthSasl']:
        return pulumi.get(self, "sasl")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceAuthNoAuth(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceAuthSasl(dict):
    def __init__(__self__, *,
                 mechanism: Optional[_builtins.str] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuthSaslPassword'] = None,
                 user: Optional[_builtins.str] = None):
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceAuthSaslPassword']:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceAuthSaslPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremise'] = None):
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremise']:
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerUrls":
            suggest = "broker_urls"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_urls: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode'] = None):
        if broker_urls is not None:
            pulumi.set(__self__, "broker_urls", broker_urls)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter(name="brokerUrls")
    def broker_urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "broker_urls")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode']:
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled'] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabledArgs' disabled: Empty block designating that the connection is not secured, i.e. plaintext connection.
        :param 'DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabledArgs' enabled: If this attribute is not an empty block, then TLS is used for the server connection.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabled']:
        """
        Empty block designating that the connection is not secured, i.e. plaintext connection.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled']:
        """
        If this attribute is not an empty block, then TLS is used for the server connection.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certificate: X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        X.509 certificate of the certificate authority which issued the server's certificate, in PEM format. If empty, the server's certificate must be signed by a well-known CA.
        """
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditTrailsV1Parser":
            suggest = "audit_trails_v1_parser"
        elif key == "cloudLoggingParser":
            suggest = "cloud_logging_parser"
        elif key == "jsonParser":
            suggest = "json_parser"
        elif key == "tskvParser":
            suggest = "tskv_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_trails_v1_parser: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1Parser'] = None,
                 cloud_logging_parser: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParser'] = None,
                 json_parser: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParser'] = None,
                 tskv_parser: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParser'] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1ParserArgs' audit_trails_v1_parser: Parse Audit Trails data. Empty struct.
        :param 'DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParserArgs' cloud_logging_parser: Parse Cloud Logging data. Empty struct.
        :param 'DatatransferEndpointSettingsKafkaSourceParserJsonParserArgs' json_parser: Parse data in `JSON` format.
        :param 'DatatransferEndpointSettingsKafkaSourceParserTskvParserArgs' tskv_parser: Parse data if `TSKV` format.
        """
        if audit_trails_v1_parser is not None:
            pulumi.set(__self__, "audit_trails_v1_parser", audit_trails_v1_parser)
        if cloud_logging_parser is not None:
            pulumi.set(__self__, "cloud_logging_parser", cloud_logging_parser)
        if json_parser is not None:
            pulumi.set(__self__, "json_parser", json_parser)
        if tskv_parser is not None:
            pulumi.set(__self__, "tskv_parser", tskv_parser)

    @_builtins.property
    @pulumi.getter(name="auditTrailsV1Parser")
    def audit_trails_v1_parser(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1Parser']:
        """
        Parse Audit Trails data. Empty struct.
        """
        return pulumi.get(self, "audit_trails_v1_parser")

    @_builtins.property
    @pulumi.getter(name="cloudLoggingParser")
    def cloud_logging_parser(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParser']:
        """
        Parse Cloud Logging data. Empty struct.
        """
        return pulumi.get(self, "cloud_logging_parser")

    @_builtins.property
    @pulumi.getter(name="jsonParser")
    def json_parser(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParser']:
        """
        Parse data in `JSON` format.
        """
        return pulumi.get(self, "json_parser")

    @_builtins.property
    @pulumi.getter(name="tskvParser")
    def tskv_parser(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParser']:
        """
        Parse data if `TSKV` format.
        """
        return pulumi.get(self, "tskv_parser")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1Parser(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParser(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addRestColumn":
            suggest = "add_rest_column"
        elif key == "dataSchema":
            suggest = "data_schema"
        elif key == "nullKeysAllowed":
            suggest = "null_keys_allowed"
        elif key == "unescapeStringValues":
            suggest = "unescape_string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceParserJsonParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserJsonParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserJsonParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_rest_column: Optional[_builtins.bool] = None,
                 data_schema: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema'] = None,
                 null_keys_allowed: Optional[_builtins.bool] = None,
                 unescape_string_values: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool add_rest_column: Add fields, that are not in the schema, into the _rest column.
        :param 'DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaArgs' data_schema: Data parsing scheme.
        :param _builtins.bool null_keys_allowed: Allow null keys. If `false` - null keys will be putted to unparsed data.
        :param _builtins.bool unescape_string_values: Allow unescape string values.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @_builtins.property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[_builtins.bool]:
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        return pulumi.get(self, "add_rest_column")

    @_builtins.property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema']:
        """
        Data parsing scheme.
        """
        return pulumi.get(self, "data_schema")

    @_builtins.property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[_builtins.bool]:
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data.
        """
        return pulumi.get(self, "null_keys_allowed")

    @_builtins.property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[_builtins.bool]:
        """
        Allow unescape string values.
        """
        return pulumi.get(self, "unescape_string_values")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonFields":
            suggest = "json_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFields'] = None,
                 json_fields: Optional[_builtins.str] = None):
        """
        :param _builtins.str json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFields']:
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[_builtins.str]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFields(dict):
    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsField']] = None):
        """
        :param Sequence['DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsFieldArgs'] fields: Description of the data schema in the array of `fields` structure.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsField']]:
        """
        Description of the data schema in the array of `fields` structure.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsField(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool key: Mark field as Primary Key.
        :param _builtins.str name: Field name.
        :param _builtins.str path: Path to the field.
        :param _builtins.bool required: Mark field as required.
        :param _builtins.str type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.bool]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addRestColumn":
            suggest = "add_rest_column"
        elif key == "dataSchema":
            suggest = "data_schema"
        elif key == "nullKeysAllowed":
            suggest = "null_keys_allowed"
        elif key == "unescapeStringValues":
            suggest = "unescape_string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceParserTskvParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserTskvParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserTskvParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_rest_column: Optional[_builtins.bool] = None,
                 data_schema: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema'] = None,
                 null_keys_allowed: Optional[_builtins.bool] = None,
                 unescape_string_values: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool add_rest_column: Add fields, that are not in the schema, into the _rest column.
        :param 'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaArgs' data_schema: Data parsing scheme.
        :param _builtins.bool null_keys_allowed: Allow null keys. If `false` - null keys will be putted to unparsed data.
        :param _builtins.bool unescape_string_values: Allow unescape string values.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @_builtins.property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[_builtins.bool]:
        """
        Add fields, that are not in the schema, into the _rest column.
        """
        return pulumi.get(self, "add_rest_column")

    @_builtins.property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema']:
        """
        Data parsing scheme.
        """
        return pulumi.get(self, "data_schema")

    @_builtins.property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[_builtins.bool]:
        """
        Allow null keys. If `false` - null keys will be putted to unparsed data.
        """
        return pulumi.get(self, "null_keys_allowed")

    @_builtins.property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[_builtins.bool]:
        """
        Allow unescape string values.
        """
        return pulumi.get(self, "unescape_string_values")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonFields":
            suggest = "json_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFields'] = None,
                 json_fields: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsArgs' fields: Description of the data schema in the array of `fields` structure.
        :param _builtins.str json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFields']:
        """
        Description of the data schema in the array of `fields` structure.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[_builtins.str]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFields(dict):
    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsField']] = None):
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsField']]:
        return pulumi.get(self, "fields")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsField(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool key: Mark field as Primary Key.
        :param _builtins.str name: Field name.
        :param _builtins.str path: Path to the field.
        :param _builtins.bool required: Mark field as required.
        :param _builtins.str type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.bool]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaSourceTransformer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferFlushInterval":
            suggest = "buffer_flush_interval"
        elif key == "bufferSize":
            suggest = "buffer_size"
        elif key == "cloudFunction":
            suggest = "cloud_function"
        elif key == "invocationTimeout":
            suggest = "invocation_timeout"
        elif key == "numberOfRetries":
            suggest = "number_of_retries"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaSourceTransformer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaSourceTransformer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaSourceTransformer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_flush_interval: Optional[_builtins.str] = None,
                 buffer_size: Optional[_builtins.str] = None,
                 cloud_function: Optional[_builtins.str] = None,
                 invocation_timeout: Optional[_builtins.str] = None,
                 number_of_retries: Optional[_builtins.int] = None,
                 service_account_id: Optional[_builtins.str] = None):
        if buffer_flush_interval is not None:
            pulumi.set(__self__, "buffer_flush_interval", buffer_flush_interval)
        if buffer_size is not None:
            pulumi.set(__self__, "buffer_size", buffer_size)
        if cloud_function is not None:
            pulumi.set(__self__, "cloud_function", cloud_function)
        if invocation_timeout is not None:
            pulumi.set(__self__, "invocation_timeout", invocation_timeout)
        if number_of_retries is not None:
            pulumi.set(__self__, "number_of_retries", number_of_retries)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="bufferFlushInterval")
    def buffer_flush_interval(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "buffer_flush_interval")

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "buffer_size")

    @_builtins.property
    @pulumi.getter(name="cloudFunction")
    def cloud_function(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloud_function")

    @_builtins.property
    @pulumi.getter(name="invocationTimeout")
    def invocation_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "invocation_timeout")

    @_builtins.property
    @pulumi.getter(name="numberOfRetries")
    def number_of_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "number_of_retries")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"
        elif key == "topicSettings":
            suggest = "topic_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuth'] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnection'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 serializer: Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializer'] = None,
                 topic_settings: Optional['outputs.DatatransferEndpointSettingsKafkaTargetTopicSettings'] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaTargetAuthArgs' auth: Authentication data.
        :param 'DatatransferEndpointSettingsKafkaTargetConnectionArgs' connection: Connection settings.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param 'DatatransferEndpointSettingsKafkaTargetSerializerArgs' serializer: Data serialization settings.
        :param 'DatatransferEndpointSettingsKafkaTargetTopicSettingsArgs' topic_settings: Target topic settings.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)
        if topic_settings is not None:
            pulumi.set(__self__, "topic_settings", topic_settings)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuth']:
        """
        Authentication data.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def serializer(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializer']:
        """
        Data serialization settings.
        """
        return pulumi.get(self, "serializer")

    @_builtins.property
    @pulumi.getter(name="topicSettings")
    def topic_settings(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetTopicSettings']:
        """
        Target topic settings.
        """
        return pulumi.get(self, "topic_settings")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAuth":
            suggest = "no_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_auth: Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuthNoAuth'] = None,
                 sasl: Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuthSasl'] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaTargetAuthNoAuthArgs' no_auth: Connection without authentication data.
        :param 'DatatransferEndpointSettingsKafkaTargetAuthSaslArgs' sasl: Authentication using sasl.
        """
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)

    @_builtins.property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuthNoAuth']:
        """
        Connection without authentication data.
        """
        return pulumi.get(self, "no_auth")

    @_builtins.property
    @pulumi.getter
    def sasl(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuthSasl']:
        """
        Authentication using sasl.
        """
        return pulumi.get(self, "sasl")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetAuthNoAuth(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetAuthSasl(dict):
    def __init__(__self__, *,
                 mechanism: Optional[_builtins.str] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuthSaslPassword'] = None,
                 user: Optional[_builtins.str] = None):
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetAuthSaslPassword']:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetAuthSaslPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremise'] = None):
        """
        :param _builtins.str cluster_id: Identifier of the Managed Kafka cluster.
        :param 'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise Kafka server.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed Kafka cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremise']:
        """
        Connection settings of the on-premise Kafka server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerUrls":
            suggest = "broker_urls"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_urls: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode'] = None):
        """
        :param Sequence[_builtins.str] broker_urls: List of Kafka broker URLs.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection.
        """
        if broker_urls is not None:
            pulumi.set(__self__, "broker_urls", broker_urls)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter(name="brokerUrls")
    def broker_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Kafka broker URLs.
        """
        return pulumi.get(self, "broker_urls")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetSerializer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializerAuto":
            suggest = "serializer_auto"
        elif key == "serializerDebezium":
            suggest = "serializer_debezium"
        elif key == "serializerJson":
            suggest = "serializer_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetSerializer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetSerializer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetSerializer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serializer_auto: Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerAuto'] = None,
                 serializer_debezium: Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium'] = None,
                 serializer_json: Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerJson'] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaTargetSerializerSerializerAutoArgs' serializer_auto: Empty block. Select data serialization format automatically.
        :param 'DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumArgs' serializer_debezium: Serialize data in json format.
        :param 'DatatransferEndpointSettingsKafkaTargetSerializerSerializerJsonArgs' serializer_json: Empty block. Serialize data in json format.
        """
        if serializer_auto is not None:
            pulumi.set(__self__, "serializer_auto", serializer_auto)
        if serializer_debezium is not None:
            pulumi.set(__self__, "serializer_debezium", serializer_debezium)
        if serializer_json is not None:
            pulumi.set(__self__, "serializer_json", serializer_json)

    @_builtins.property
    @pulumi.getter(name="serializerAuto")
    def serializer_auto(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerAuto']:
        """
        Empty block. Select data serialization format automatically.
        """
        return pulumi.get(self, "serializer_auto")

    @_builtins.property
    @pulumi.getter(name="serializerDebezium")
    def serializer_debezium(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium']:
        """
        Serialize data in json format.
        """
        return pulumi.get(self, "serializer_debezium")

    @_builtins.property
    @pulumi.getter(name="serializerJson")
    def serializer_json(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerJson']:
        """
        Empty block. Serialize data in json format.
        """
        return pulumi.get(self, "serializer_json")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerAuto(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializerParameters":
            suggest = "serializer_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serializer_parameters: Optional[Sequence['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameter']] = None):
        """
        :param Sequence['DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameterArgs'] serializer_parameters: A list of Debezium parameters set by the structure of the `key` and `value` string fields.
        """
        if serializer_parameters is not None:
            pulumi.set(__self__, "serializer_parameters", serializer_parameters)

    @_builtins.property
    @pulumi.getter(name="serializerParameters")
    def serializer_parameters(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameter']]:
        """
        A list of Debezium parameters set by the structure of the `key` and `value` string fields.
        """
        return pulumi.get(self, "serializer_parameters")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetSerializerSerializerJson(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetTopicSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicPrefix":
            suggest = "topic_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetTopicSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetTopicSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetTopicSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic: Optional['outputs.DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic'] = None,
                 topic_prefix: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsKafkaTargetTopicSettingsTopicArgs' topic: All messages will be sent to one topic.
        :param _builtins.str topic_prefix: Topic name prefix. Messages will be sent to topic with name \\n\\n.\\n\\n.\\n\\n.
        """
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if topic_prefix is not None:
            pulumi.set(__self__, "topic_prefix", topic_prefix)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional['outputs.DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic']:
        """
        All messages will be sent to one topic.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter(name="topicPrefix")
    def topic_prefix(self) -> Optional[_builtins.str]:
        """
        Topic name prefix. Messages will be sent to topic with name \\n\\n.\\n\\n.\\n\\n.
        """
        return pulumi.get(self, "topic_prefix")


@pulumi.output_type
class DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saveTxOrder":
            suggest = "save_tx_order"
        elif key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 save_tx_order: Optional[_builtins.bool] = None,
                 topic_name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool save_tx_order: Not to split events queue into separate per-table queues.
        :param _builtins.str topic_name: Full topic name.
        """
        if save_tx_order is not None:
            pulumi.set(__self__, "save_tx_order", save_tx_order)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter(name="saveTxOrder")
    def save_tx_order(self) -> Optional[_builtins.bool]:
        """
        Not to split events queue into separate per-table queues.
        """
        return pulumi.get(self, "save_tx_order")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[_builtins.str]:
        """
        Full topic name.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class DatatransferEndpointSettingsMetrikaSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "counterIds":
            suggest = "counter_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMetrikaSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMetrikaSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMetrikaSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counter_ids: Optional[Sequence[_builtins.int]] = None,
                 streams: Optional[Sequence['outputs.DatatransferEndpointSettingsMetrikaSourceStream']] = None,
                 token: Optional['outputs.DatatransferEndpointSettingsMetrikaSourceToken'] = None):
        if counter_ids is not None:
            pulumi.set(__self__, "counter_ids", counter_ids)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="counterIds")
    def counter_ids(self) -> Optional[Sequence[_builtins.int]]:
        return pulumi.get(self, "counter_ids")

    @_builtins.property
    @pulumi.getter
    def streams(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsMetrikaSourceStream']]:
        return pulumi.get(self, "streams")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional['outputs.DatatransferEndpointSettingsMetrikaSourceToken']:
        return pulumi.get(self, "token")


@pulumi.output_type
class DatatransferEndpointSettingsMetrikaSourceStream(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class DatatransferEndpointSettingsMetrikaSourceToken(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedCollections":
            suggest = "excluded_collections"
        elif key == "secondaryPreferredMode":
            suggest = "secondary_preferred_mode"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.DatatransferEndpointSettingsMongoSourceCollection']] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnection'] = None,
                 excluded_collections: Optional[Sequence['outputs.DatatransferEndpointSettingsMongoSourceExcludedCollection']] = None,
                 secondary_preferred_mode: Optional[_builtins.bool] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param Sequence['DatatransferEndpointSettingsMongoSourceCollectionArgs'] collections: The list of the MongoDB collections that should be transferred. If omitted, all available collections will be transferred.
        :param 'DatatransferEndpointSettingsMongoSourceConnectionArgs' connection: Connection settings.
        :param Sequence['DatatransferEndpointSettingsMongoSourceExcludedCollectionArgs'] excluded_collections: The list of the MongoDB collections that should not be transferred.
        :param _builtins.bool secondary_preferred_mode: Whether the secondary server should be preferred to the primary when copying data.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if excluded_collections is not None:
            pulumi.set(__self__, "excluded_collections", excluded_collections)
        if secondary_preferred_mode is not None:
            pulumi.set(__self__, "secondary_preferred_mode", secondary_preferred_mode)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsMongoSourceCollection']]:
        """
        The list of the MongoDB collections that should be transferred. If omitted, all available collections will be transferred.
        """
        return pulumi.get(self, "collections")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter(name="excludedCollections")
    def excluded_collections(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsMongoSourceExcludedCollection']]:
        """
        The list of the MongoDB collections that should not be transferred.
        """
        return pulumi.get(self, "excluded_collections")

    @_builtins.property
    @pulumi.getter(name="secondaryPreferredMode")
    def secondary_preferred_mode(self) -> Optional[_builtins.bool]:
        """
        Whether the secondary server should be preferred to the primary when copying data.
        """
        return pulumi.get(self, "secondary_preferred_mode")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSourceCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSourceCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSourceCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_name: Optional[_builtins.str] = None,
                 database_name: Optional[_builtins.str] = None):
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionOptions":
            suggest = "connection_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_options: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions'] = None):
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @_builtins.property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions']:
        return pulumi.get(self, "connection_options")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSource":
            suggest = "auth_source"
        elif key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_source: Optional[_builtins.str] = None,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword'] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_source: Name of the database associated with the credentials.
        :param _builtins.str mdb_cluster_id: Identifier of the Managed MongoDB cluster.
        :param 'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseArgs' on_premise: Connection settings of the on-premise MongoDB server.
        """
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[_builtins.str]:
        """
        Name of the database associated with the credentials.
        """
        return pulumi.get(self, "auth_source")

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed MongoDB cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise']:
        """
        Connection settings of the on-premise MongoDB server.
        """
        return pulumi.get(self, "on_premise")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword']:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaSet":
            suggest = "replica_set"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 replica_set: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode'] = None):
        """
        :param Sequence[_builtins.str] hosts: Host names of the replica set.
        :param _builtins.int port: TCP Port number.
        :param _builtins.str replica_set: Replica set name.
        :param 'DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[_builtins.str]:
        """
        Replica set name.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsMongoSourceExcludedCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoSourceExcludedCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoSourceExcludedCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoSourceExcludedCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_name: Optional[_builtins.str] = None,
                 database_name: Optional[_builtins.str] = None):
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnection'] = None,
                 database: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: How to clean collections when activating the transfer. One of `DISABLED`, `DROP` or `TRUNCATE`.
        :param 'DatatransferEndpointSettingsMongoTargetConnectionArgs' connection: Connection settings.
        :param _builtins.str database: If not empty, then all the data will be written to the database with the specified name; otherwise the database name is the same as in the source endpoint.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        How to clean collections when activating the transfer. One of `DISABLED`, `DROP` or `TRUNCATE`.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        If not empty, then all the data will be written to the database with the specified name; otherwise the database name is the same as in the source endpoint.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionOptions":
            suggest = "connection_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_options: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions'] = None):
        """
        :param 'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsArgs' connection_options: Connection options.
        """
        if connection_options is not None:
            pulumi.set(__self__, "connection_options", connection_options)

    @_builtins.property
    @pulumi.getter(name="connectionOptions")
    def connection_options(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions']:
        """
        Connection options.
        """
        return pulumi.get(self, "connection_options")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSource":
            suggest = "auth_source"
        elif key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_source: Optional[_builtins.str] = None,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword'] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_source: Name of the database associated with the credentials.
        :param _builtins.str mdb_cluster_id: Identifier of the Managed MongoDB cluster.
        :param 'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseArgs' on_premise: Connection settings of the on-premise MongoDB server.
        :param 'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPasswordArgs' password: Password for the database access.
        :param _builtins.str user: User for database access.
        """
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[_builtins.str]:
        """
        Name of the database associated with the credentials.
        """
        return pulumi.get(self, "auth_source")

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed MongoDB cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise']:
        """
        Connection settings of the on-premise MongoDB server.
        """
        return pulumi.get(self, "on_premise")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword']:
        """
        Password for the database access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        User for database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaSet":
            suggest = "replica_set"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 replica_set: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode'] = None):
        """
        :param Sequence[_builtins.str] hosts: Host names of the replica set.
        :param _builtins.int port: TCP Port number.
        :param _builtins.str replica_set: Replica set name.
        :param 'DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Host names of the replica set.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        TCP Port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[_builtins.str]:
        """
        Replica set name.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        """
        :param _builtins.str raw: Password for the database access.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        """
        Password for the database access.
        """
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTablesRegexes":
            suggest = "exclude_tables_regexes"
        elif key == "includeTablesRegexes":
            suggest = "include_tables_regexes"
        elif key == "objectTransferSettings":
            suggest = "object_transfer_settings"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceDatabase":
            suggest = "service_database"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnection'] = None,
                 database: Optional[_builtins.str] = None,
                 exclude_tables_regexes: Optional[Sequence[_builtins.str]] = None,
                 include_tables_regexes: Optional[Sequence[_builtins.str]] = None,
                 object_transfer_settings: Optional['outputs.DatatransferEndpointSettingsMysqlSourceObjectTransferSettings'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsMysqlSourcePassword'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_database: Optional[_builtins.str] = None,
                 timezone: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionArgs' connection: Connection settings.
        :param _builtins.str database: Name of the database to transfer.
        :param Sequence[_builtins.str] exclude_tables_regexes: Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        :param Sequence[_builtins.str] include_tables_regexes: List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        :param 'DatatransferEndpointSettingsMysqlSourceObjectTransferSettingsArgs' object_transfer_settings: Defines which database schema objects should be transferred, e.g. views, routines, etc. All of the attrubutes in the block are optional and should be either `BEFORE_DATA`, `AFTER_DATA` or `NEVER`.
        :param 'DatatransferEndpointSettingsMysqlSourcePasswordArgs' password: Password for the database access.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str timezone: Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: `local timezone`.
        :param _builtins.str user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if exclude_tables_regexes is not None:
            pulumi.set(__self__, "exclude_tables_regexes", exclude_tables_regexes)
        if include_tables_regexes is not None:
            pulumi.set(__self__, "include_tables_regexes", include_tables_regexes)
        if object_transfer_settings is not None:
            pulumi.set(__self__, "object_transfer_settings", object_transfer_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_database is not None:
            pulumi.set(__self__, "service_database", service_database)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="excludeTablesRegexes")
    def exclude_tables_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Opposite of `include_table_regex`. The tables matching the specified regular expressions will not be transferred.
        """
        return pulumi.get(self, "exclude_tables_regexes")

    @_builtins.property
    @pulumi.getter(name="includeTablesRegexes")
    def include_tables_regexes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of regular expressions of table names which should be transferred. A table name is formatted as schemaname.tablename. For example, a single regular expression may look like `^mydb.employees$`.
        """
        return pulumi.get(self, "include_tables_regexes")

    @_builtins.property
    @pulumi.getter(name="objectTransferSettings")
    def object_transfer_settings(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceObjectTransferSettings']:
        """
        Defines which database schema objects should be transferred, e.g. views, routines, etc. All of the attrubutes in the block are optional and should be either `BEFORE_DATA`, `AFTER_DATA` or `NEVER`.
        """
        return pulumi.get(self, "object_transfer_settings")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourcePassword']:
        """
        Password for the database access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceDatabase")
    def service_database(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_database")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: `local timezone`.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremise'] = None):
        """
        :param _builtins.str mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise MySQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremise']:
        """
        Connection settings of the on-premise MySQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSourceConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode'] = None):
        """
        :param Sequence[_builtins.str] hosts: List of host names of the MySQL server. Exactly one host is expected currently.
        :param _builtins.int port: Port for the database connection.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of host names of the MySQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourceObjectTransferSettings(dict):
    def __init__(__self__, *,
                 routine: Optional[_builtins.str] = None,
                 tables: Optional[_builtins.str] = None,
                 trigger: Optional[_builtins.str] = None,
                 view: Optional[_builtins.str] = None):
        if routine is not None:
            pulumi.set(__self__, "routine", routine)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @_builtins.property
    @pulumi.getter
    def routine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "routine")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trigger")

    @_builtins.property
    @pulumi.getter
    def view(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlSourcePassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        """
        :param _builtins.str raw: Password for the database access.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        """
        Password for the database access.
        """
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceDatabase":
            suggest = "service_database"
        elif key == "skipConstraintChecks":
            suggest = "skip_constraint_checks"
        elif key == "sqlMode":
            suggest = "sql_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnection'] = None,
                 database: Optional[_builtins.str] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsMysqlTargetPassword'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_database: Optional[_builtins.str] = None,
                 skip_constraint_checks: Optional[_builtins.bool] = None,
                 sql_mode: Optional[_builtins.str] = None,
                 timezone: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: How to clean tables when activating the transfer. One of `DISABLED`, `DROP` or `TRUNCATE`.
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionArgs' connection: Connection settings.
        :param _builtins.str database: Name of the database to transfer.
        :param 'DatatransferEndpointSettingsMysqlTargetPasswordArgs' password: Password for the database access.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str service_database: The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        :param _builtins.bool skip_constraint_checks: When `true`, disables foreign key checks. See [foreign*key*checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). `False` by default.
        :param _builtins.str sql_mode: [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to `NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION`.
        :param _builtins.str timezone: Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: `local timezone`.
        :param _builtins.str user: User for the database access.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_database is not None:
            pulumi.set(__self__, "service_database", service_database)
        if skip_constraint_checks is not None:
            pulumi.set(__self__, "skip_constraint_checks", skip_constraint_checks)
        if sql_mode is not None:
            pulumi.set(__self__, "sql_mode", sql_mode)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        How to clean tables when activating the transfer. One of `DISABLED`, `DROP` or `TRUNCATE`.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetPassword']:
        """
        Password for the database access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceDatabase")
    def service_database(self) -> Optional[_builtins.str]:
        """
        The name of the database where technical tables (`__tm_keeper`, `__tm_gtid_keeper`) will be created. Default is the value of the attribute `database`.
        """
        return pulumi.get(self, "service_database")

    @_builtins.property
    @pulumi.getter(name="skipConstraintChecks")
    def skip_constraint_checks(self) -> Optional[_builtins.bool]:
        """
        When `true`, disables foreign key checks. See [foreign*key*checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks). `False` by default.
        """
        return pulumi.get(self, "skip_constraint_checks")

    @_builtins.property
    @pulumi.getter(name="sqlMode")
    def sql_mode(self) -> Optional[_builtins.str]:
        """
        [sql_mode](https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html) to use when interacting with the server. Defaults to `NO_AUTO_VALUE_ON_ZERO,NO_DIR_IN_CREATE,NO_ENGINE_SUBSTITUTION`.
        """
        return pulumi.get(self, "sql_mode")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Timezone to use for parsing timestamps for saving source timezones. Accepts values from IANA timezone database. Default: `local timezone`.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremise'] = None):
        """
        :param _builtins.str mdb_cluster_id: Identifier of the Managed MySQL cluster.
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise MySQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed MySQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremise']:
        """
        Connection settings of the on-premise MySQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTargetConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode'] = None):
        """
        :param Sequence[_builtins.str] hosts: List of host names of the MySQL server. Exactly one host is expected currently.
        :param _builtins.int port: Port for the database connection.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of host names of the MySQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsMysqlTargetPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        """
        :param _builtins.str raw: Password for the database access.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        """
        Password for the database access.
        """
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"
        elif key == "objectTransferSettings":
            suggest = "object_transfer_settings"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceSchema":
            suggest = "service_schema"
        elif key == "slotGigabyteLagLimit":
            suggest = "slot_gigabyte_lag_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnection'] = None,
                 database: Optional[_builtins.str] = None,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None,
                 object_transfer_settings: Optional['outputs.DatatransferEndpointSettingsPostgresSourceObjectTransferSettings'] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsPostgresSourcePassword'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_schema: Optional[_builtins.str] = None,
                 slot_gigabyte_lag_limit: Optional[_builtins.int] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsPostgresSourceConnectionArgs' connection: Connection settings.
        :param _builtins.str database: Name of the database to transfer.
        :param Sequence[_builtins.str] exclude_tables: List of tables which will not be transfered, formatted as `schemaname.tablename`.
        :param Sequence[_builtins.str] include_tables: List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        :param 'DatatransferEndpointSettingsPostgresSourceObjectTransferSettingsArgs' object_transfer_settings: Defines which database schema objects should be transferred, e.g. views, functions, etc. All of the attributes in this block are optional and should be either `BEFORE_DATA`, `AFTER_DATA` or `NEVER`.
        :param 'DatatransferEndpointSettingsPostgresSourcePasswordArgs' password: Password for the database access.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str service_schema: Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema `public`.
        :param _builtins.int slot_gigabyte_lag_limit: Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. `Unlimited` by default.
        :param _builtins.str user: User for the database access.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)
        if object_transfer_settings is not None:
            pulumi.set(__self__, "object_transfer_settings", object_transfer_settings)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_schema is not None:
            pulumi.set(__self__, "service_schema", service_schema)
        if slot_gigabyte_lag_limit is not None:
            pulumi.set(__self__, "slot_gigabyte_lag_limit", slot_gigabyte_lag_limit)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tables which will not be transfered, formatted as `schemaname.tablename`.
        """
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tables to transfer, formatted as `schemaname.tablename`. If omitted or an empty list is specified, all tables will be transferred.
        """
        return pulumi.get(self, "include_tables")

    @_builtins.property
    @pulumi.getter(name="objectTransferSettings")
    def object_transfer_settings(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceObjectTransferSettings']:
        """
        Defines which database schema objects should be transferred, e.g. views, functions, etc. All of the attributes in this block are optional and should be either `BEFORE_DATA`, `AFTER_DATA` or `NEVER`.
        """
        return pulumi.get(self, "object_transfer_settings")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourcePassword']:
        """
        Password for the database access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceSchema")
    def service_schema(self) -> Optional[_builtins.str]:
        """
        Name of the database schema in which auxiliary tables needed for the transfer will be created. Empty `service_schema` implies schema `public`.
        """
        return pulumi.get(self, "service_schema")

    @_builtins.property
    @pulumi.getter(name="slotGigabyteLagLimit")
    def slot_gigabyte_lag_limit(self) -> Optional[_builtins.int]:
        """
        Maximum WAL size held by the replication slot, in gigabytes. Exceeding this limit will result in a replication failure and deletion of the replication slot. `Unlimited` by default.
        """
        return pulumi.get(self, "slot_gigabyte_lag_limit")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremise'] = None):
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremise']:
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode'] = None):
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode']:
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourceObjectTransferSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValues":
            suggest = "default_values"
        elif key == "fkConstraint":
            suggest = "fk_constraint"
        elif key == "materializedView":
            suggest = "materialized_view"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "sequenceOwnedBy":
            suggest = "sequence_owned_by"
        elif key == "sequenceSet":
            suggest = "sequence_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresSourceObjectTransferSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresSourceObjectTransferSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresSourceObjectTransferSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cast: Optional[_builtins.str] = None,
                 collation: Optional[_builtins.str] = None,
                 constraint: Optional[_builtins.str] = None,
                 default_values: Optional[_builtins.str] = None,
                 fk_constraint: Optional[_builtins.str] = None,
                 function: Optional[_builtins.str] = None,
                 index: Optional[_builtins.str] = None,
                 materialized_view: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None,
                 primary_key: Optional[_builtins.str] = None,
                 rule: Optional[_builtins.str] = None,
                 sequence: Optional[_builtins.str] = None,
                 sequence_owned_by: Optional[_builtins.str] = None,
                 sequence_set: Optional[_builtins.str] = None,
                 table: Optional[_builtins.str] = None,
                 trigger: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 view: Optional[_builtins.str] = None):
        if cast is not None:
            pulumi.set(__self__, "cast", cast)
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if constraint is not None:
            pulumi.set(__self__, "constraint", constraint)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if fk_constraint is not None:
            pulumi.set(__self__, "fk_constraint", fk_constraint)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if materialized_view is not None:
            pulumi.set(__self__, "materialized_view", materialized_view)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if sequence is not None:
            pulumi.set(__self__, "sequence", sequence)
        if sequence_owned_by is not None:
            pulumi.set(__self__, "sequence_owned_by", sequence_owned_by)
        if sequence_set is not None:
            pulumi.set(__self__, "sequence_set", sequence_set)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @_builtins.property
    @pulumi.getter
    def cast(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cast")

    @_builtins.property
    @pulumi.getter
    def collation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collation")

    @_builtins.property
    @pulumi.getter
    def constraint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "constraint")

    @_builtins.property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_values")

    @_builtins.property
    @pulumi.getter(name="fkConstraint")
    def fk_constraint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fk_constraint")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="materializedView")
    def materialized_view(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "materialized_view")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def sequence(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sequence")

    @_builtins.property
    @pulumi.getter(name="sequenceOwnedBy")
    def sequence_owned_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sequence_owned_by")

    @_builtins.property
    @pulumi.getter(name="sequenceSet")
    def sequence_set(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sequence_set")

    @_builtins.property
    @pulumi.getter
    def table(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trigger")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def view(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "view")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresSourcePassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        """
        :param _builtins.str raw: Password for the database access.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        """
        Password for the database access.
        """
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 connection: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnection'] = None,
                 database: Optional[_builtins.str] = None,
                 password: Optional['outputs.DatatransferEndpointSettingsPostgresTargetPassword'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionArgs' connection: Connection settings.
        :param _builtins.str database: Name of the database to transfer.
        :param 'DatatransferEndpointSettingsPostgresTargetPasswordArgs' password: Password for the database access.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str user: User for the database access.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnection']:
        """
        Connection settings.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Name of the database to transfer.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetPassword']:
        """
        Password for the database access.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        User for the database access.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mdbClusterId":
            suggest = "mdb_cluster_id"
        elif key == "onPremise":
            suggest = "on_premise"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTargetConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mdb_cluster_id: Optional[_builtins.str] = None,
                 on_premise: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremise'] = None):
        """
        :param _builtins.str mdb_cluster_id: Identifier of the Managed PostgreSQL cluster.
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseArgs' on_premise: Connection settings of the on-premise PostgreSQL server.
        """
        if mdb_cluster_id is not None:
            pulumi.set(__self__, "mdb_cluster_id", mdb_cluster_id)
        if on_premise is not None:
            pulumi.set(__self__, "on_premise", on_premise)

    @_builtins.property
    @pulumi.getter(name="mdbClusterId")
    def mdb_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Managed PostgreSQL cluster.
        """
        return pulumi.get(self, "mdb_cluster_id")

    @_builtins.property
    @pulumi.getter(name="onPremise")
    def on_premise(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremise']:
        """
        Connection settings of the on-premise PostgreSQL server.
        """
        return pulumi.get(self, "on_premise")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremise(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "tlsMode":
            suggest = "tls_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTargetConnectionOnPremise. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremise.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremise.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tls_mode: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode'] = None):
        """
        :param Sequence[_builtins.str] hosts: List of host names of the PostgreSQL server. Exactly one host is expected currently.
        :param _builtins.int port: Port for the database connection.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param 'DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeArgs' tls_mode: TLS settings for the server connection. Empty implies plaintext connection.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tls_mode is not None:
            pulumi.set(__self__, "tls_mode", tls_mode)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of host names of the PostgreSQL server. Exactly one host is expected currently.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the database connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tlsMode")
    def tls_mode(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode']:
        """
        TLS settings for the server connection. Empty implies plaintext connection.
        """
        return pulumi.get(self, "tls_mode")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled'] = None,
                 enabled: Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled']:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None):
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certificate")


@pulumi.output_type
class DatatransferEndpointSettingsPostgresTargetPassword(dict):
    def __init__(__self__, *,
                 raw: Optional[_builtins.str] = None):
        """
        :param _builtins.str raw: Password for the database access.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @_builtins.property
    @pulumi.getter
    def raw(self) -> Optional[_builtins.str]:
        """
        Password for the database access.
        """
        return pulumi.get(self, "raw")


@pulumi.output_type
class DatatransferEndpointSettingsYdbSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changefeedCustomName":
            suggest = "changefeed_custom_name"
        elif key == "saKeyContent":
            suggest = "sa_key_content"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdbSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdbSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdbSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 changefeed_custom_name: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 instance: Optional[_builtins.str] = None,
                 paths: Optional[Sequence[_builtins.str]] = None,
                 sa_key_content: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str changefeed_custom_name: Custom name for changefeed.
        :param _builtins.str database: Database path in YDB where tables are stored. Example: `/ru/transfer_manager/prod/data-transfer-yt`.
        :param _builtins.str instance: Instance of YDB. Example: `my-cute-ydb.yandex.cloud:2135`.
        :param Sequence[_builtins.str] paths: A list of paths which should be uploaded. When not specified, all available tables are uploaded.
        :param _builtins.str sa_key_content: Authentication key.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str service_account_id: Service account ID for interaction with database.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if changefeed_custom_name is not None:
            pulumi.set(__self__, "changefeed_custom_name", changefeed_custom_name)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if sa_key_content is not None:
            pulumi.set(__self__, "sa_key_content", sa_key_content)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="changefeedCustomName")
    def changefeed_custom_name(self) -> Optional[_builtins.str]:
        """
        Custom name for changefeed.
        """
        return pulumi.get(self, "changefeed_custom_name")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database path in YDB where tables are stored. Example: `/ru/transfer_manager/prod/data-transfer-yt`.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        """
        Instance of YDB. Example: `my-cute-ydb.yandex.cloud:2135`.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of paths which should be uploaded. When not specified, all available tables are uploaded.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="saKeyContent")
    def sa_key_content(self) -> Optional[_builtins.str]:
        """
        Authentication key.
        """
        return pulumi.get(self, "sa_key_content")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsYdbTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "defaultCompression":
            suggest = "default_compression"
        elif key == "isTableColumnOriented":
            suggest = "is_table_column_oriented"
        elif key == "saKeyContent":
            suggest = "sa_key_content"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdbTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdbTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdbTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 default_compression: Optional[_builtins.str] = None,
                 instance: Optional[_builtins.str] = None,
                 is_table_column_oriented: Optional[_builtins.bool] = None,
                 path: Optional[_builtins.str] = None,
                 sa_key_content: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: How to clean collections when activating the transfer. One of `YDB_CLEANUP_POLICY_DISABLED` or `YDB_CLEANUP_POLICY_DROP`.
        :param _builtins.str database: Database path in YDB where tables are stored. Example: `/ru/transfer_manager/prod/data-transfer-yt`.
        :param _builtins.str default_compression: Compression that will be used for default columns family on YDB table creation One of `YDB_DEFAULT_COMPRESSION_UNSPECIFIED`, `YDB_DEFAULT_COMPRESSION_DISABLED`, `YDB_DEFAULT_COMPRESSION_LZ4`.
        :param _builtins.str instance: Instance of YDB. Example: `my-cute-ydb.yandex.cloud:2135`.
        :param _builtins.bool is_table_column_oriented: Whether a column-oriented (i.e. OLAP) tables should be created. Default is `false` (create row-oriented OLTP tables).
        :param _builtins.str path: A path where resulting tables are stored.
        :param _builtins.str sa_key_content: Authentication key.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str service_account_id: Service account ID for interaction with database.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if default_compression is not None:
            pulumi.set(__self__, "default_compression", default_compression)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if is_table_column_oriented is not None:
            pulumi.set(__self__, "is_table_column_oriented", is_table_column_oriented)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if sa_key_content is not None:
            pulumi.set(__self__, "sa_key_content", sa_key_content)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        How to clean collections when activating the transfer. One of `YDB_CLEANUP_POLICY_DISABLED` or `YDB_CLEANUP_POLICY_DROP`.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database path in YDB where tables are stored. Example: `/ru/transfer_manager/prod/data-transfer-yt`.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="defaultCompression")
    def default_compression(self) -> Optional[_builtins.str]:
        """
        Compression that will be used for default columns family on YDB table creation One of `YDB_DEFAULT_COMPRESSION_UNSPECIFIED`, `YDB_DEFAULT_COMPRESSION_DISABLED`, `YDB_DEFAULT_COMPRESSION_LZ4`.
        """
        return pulumi.get(self, "default_compression")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional[_builtins.str]:
        """
        Instance of YDB. Example: `my-cute-ydb.yandex.cloud:2135`.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter(name="isTableColumnOriented")
    def is_table_column_oriented(self) -> Optional[_builtins.bool]:
        """
        Whether a column-oriented (i.e. OLAP) tables should be created. Default is `false` (create row-oriented OLTP tables).
        """
        return pulumi.get(self, "is_table_column_oriented")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        A path where resulting tables are stored.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="saKeyContent")
    def sa_key_content(self) -> Optional[_builtins.str]:
        """
        Authentication key.
        """
        return pulumi.get(self, "sa_key_content")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowTtlRewind":
            suggest = "allow_ttl_rewind"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "supportedCodecs":
            suggest = "supported_codecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_ttl_rewind: Optional[_builtins.bool] = None,
                 consumer: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 parser: Optional['outputs.DatatransferEndpointSettingsYdsSourceParser'] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 stream: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 supported_codecs: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool allow_ttl_rewind: Should continue working, if consumer read lag exceed TTL of topic.
        :param _builtins.str consumer: Consumer.
        :param _builtins.str database: Database name.
        :param _builtins.str endpoint: YDS Endpoint.
        :param 'DatatransferEndpointSettingsYdsSourceParserArgs' parser: Data parsing rules.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param _builtins.str service_account_id: Service account ID for interaction with database.
        :param _builtins.str stream: Stream.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        :param Sequence[_builtins.str] supported_codecs: List of supported compression codec.
        """
        if allow_ttl_rewind is not None:
            pulumi.set(__self__, "allow_ttl_rewind", allow_ttl_rewind)
        if consumer is not None:
            pulumi.set(__self__, "consumer", consumer)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if supported_codecs is not None:
            pulumi.set(__self__, "supported_codecs", supported_codecs)

    @_builtins.property
    @pulumi.getter(name="allowTtlRewind")
    def allow_ttl_rewind(self) -> Optional[_builtins.bool]:
        """
        Should continue working, if consumer read lag exceed TTL of topic.
        """
        return pulumi.get(self, "allow_ttl_rewind")

    @_builtins.property
    @pulumi.getter
    def consumer(self) -> Optional[_builtins.str]:
        """
        Consumer.
        """
        return pulumi.get(self, "consumer")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        YDS Endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def parser(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParser']:
        """
        Data parsing rules.
        """
        return pulumi.get(self, "parser")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter
    def stream(self) -> Optional[_builtins.str]:
        """
        Stream.
        """
        return pulumi.get(self, "stream")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="supportedCodecs")
    def supported_codecs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of supported compression codec.
        """
        return pulumi.get(self, "supported_codecs")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditTrailsV1Parser":
            suggest = "audit_trails_v1_parser"
        elif key == "cloudLoggingParser":
            suggest = "cloud_logging_parser"
        elif key == "jsonParser":
            suggest = "json_parser"
        elif key == "tskvParser":
            suggest = "tskv_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsSourceParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsSourceParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsSourceParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_trails_v1_parser: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1Parser'] = None,
                 cloud_logging_parser: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserCloudLoggingParser'] = None,
                 json_parser: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParser'] = None,
                 tskv_parser: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParser'] = None):
        """
        :param 'DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1ParserArgs' audit_trails_v1_parser: Parse Audit Trails data. Empty struct.
        :param 'DatatransferEndpointSettingsYdsSourceParserCloudLoggingParserArgs' cloud_logging_parser: Parse Cloud Logging data. Empty struct.
        :param 'DatatransferEndpointSettingsYdsSourceParserJsonParserArgs' json_parser: Parse data in json format.
        """
        if audit_trails_v1_parser is not None:
            pulumi.set(__self__, "audit_trails_v1_parser", audit_trails_v1_parser)
        if cloud_logging_parser is not None:
            pulumi.set(__self__, "cloud_logging_parser", cloud_logging_parser)
        if json_parser is not None:
            pulumi.set(__self__, "json_parser", json_parser)
        if tskv_parser is not None:
            pulumi.set(__self__, "tskv_parser", tskv_parser)

    @_builtins.property
    @pulumi.getter(name="auditTrailsV1Parser")
    def audit_trails_v1_parser(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1Parser']:
        """
        Parse Audit Trails data. Empty struct.
        """
        return pulumi.get(self, "audit_trails_v1_parser")

    @_builtins.property
    @pulumi.getter(name="cloudLoggingParser")
    def cloud_logging_parser(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserCloudLoggingParser']:
        """
        Parse Cloud Logging data. Empty struct.
        """
        return pulumi.get(self, "cloud_logging_parser")

    @_builtins.property
    @pulumi.getter(name="jsonParser")
    def json_parser(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParser']:
        """
        Parse data in json format.
        """
        return pulumi.get(self, "json_parser")

    @_builtins.property
    @pulumi.getter(name="tskvParser")
    def tskv_parser(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParser']:
        return pulumi.get(self, "tskv_parser")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1Parser(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserCloudLoggingParser(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserJsonParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addRestColumn":
            suggest = "add_rest_column"
        elif key == "dataSchema":
            suggest = "data_schema"
        elif key == "nullKeysAllowed":
            suggest = "null_keys_allowed"
        elif key == "unescapeStringValues":
            suggest = "unescape_string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsSourceParserJsonParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsSourceParserJsonParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsSourceParserJsonParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_rest_column: Optional[_builtins.bool] = None,
                 data_schema: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema'] = None,
                 null_keys_allowed: Optional[_builtins.bool] = None,
                 unescape_string_values: Optional[_builtins.bool] = None):
        """
        :param 'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaArgs' data_schema: Data parsing scheme.
        """
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @_builtins.property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "add_rest_column")

    @_builtins.property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema']:
        """
        Data parsing scheme.
        """
        return pulumi.get(self, "data_schema")

    @_builtins.property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "null_keys_allowed")

    @_builtins.property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "unescape_string_values")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonFields":
            suggest = "json_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFields'] = None,
                 json_fields: Optional[_builtins.str] = None):
        """
        :param 'DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsArgs' fields: Description of the data schema in the array of `fields` structure.
        :param _builtins.str json_fields: Description of the data schema as JSON specification.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFields']:
        """
        Description of the data schema in the array of `fields` structure.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[_builtins.str]:
        """
        Description of the data schema as JSON specification.
        """
        return pulumi.get(self, "json_fields")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFields(dict):
    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsField']] = None):
        """
        :param Sequence['DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsFieldArgs'] fields: Description of the data schema in the array of `fields` structure.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsField']]:
        """
        Description of the data schema in the array of `fields` structure.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsField(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool key: Mark field as Primary Key.
        :param _builtins.str name: Field name.
        :param _builtins.str path: Path to the field.
        :param _builtins.bool required: Mark field as required.
        :param _builtins.str type: Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.bool]:
        """
        Mark field as Primary Key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to the field.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Mark field as required.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Field type, one of: `INT64`, `INT32`, `INT16`, `INT8`, `UINT64`, `UINT32`, `UINT16`, `UINT8`, `DOUBLE`, `BOOLEAN`, `STRING`, `UTF8`, `ANY`, `DATETIME`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserTskvParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addRestColumn":
            suggest = "add_rest_column"
        elif key == "dataSchema":
            suggest = "data_schema"
        elif key == "nullKeysAllowed":
            suggest = "null_keys_allowed"
        elif key == "unescapeStringValues":
            suggest = "unescape_string_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsSourceParserTskvParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsSourceParserTskvParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsSourceParserTskvParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_rest_column: Optional[_builtins.bool] = None,
                 data_schema: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema'] = None,
                 null_keys_allowed: Optional[_builtins.bool] = None,
                 unescape_string_values: Optional[_builtins.bool] = None):
        if add_rest_column is not None:
            pulumi.set(__self__, "add_rest_column", add_rest_column)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if null_keys_allowed is not None:
            pulumi.set(__self__, "null_keys_allowed", null_keys_allowed)
        if unescape_string_values is not None:
            pulumi.set(__self__, "unescape_string_values", unescape_string_values)

    @_builtins.property
    @pulumi.getter(name="addRestColumn")
    def add_rest_column(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "add_rest_column")

    @_builtins.property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema']:
        return pulumi.get(self, "data_schema")

    @_builtins.property
    @pulumi.getter(name="nullKeysAllowed")
    def null_keys_allowed(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "null_keys_allowed")

    @_builtins.property
    @pulumi.getter(name="unescapeStringValues")
    def unescape_string_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "unescape_string_values")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonFields":
            suggest = "json_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFields'] = None,
                 json_fields: Optional[_builtins.str] = None):
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if json_fields is not None:
            pulumi.set(__self__, "json_fields", json_fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFields']:
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="jsonFields")
    def json_fields(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "json_fields")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFields(dict):
    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsField']] = None):
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsField']]:
        return pulumi.get(self, "fields")


@pulumi.output_type
class DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsField(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class DatatransferEndpointSettingsYdsTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saveTxOrder":
            suggest = "save_tx_order"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 save_tx_order: Optional[_builtins.bool] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 serializer: Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializer'] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 stream: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: Database.
        :param _builtins.str endpoint: YDS Endpoint.
        :param _builtins.bool save_tx_order: Save transaction order.
        :param Sequence[_builtins.str] security_groups: List of security groups that the transfer associated with this endpoint should use.
        :param 'DatatransferEndpointSettingsYdsTargetSerializerArgs' serializer: Data serialization format.
        :param _builtins.str service_account_id: Service account ID for interaction with database.
        :param _builtins.str stream: Stream.
        :param _builtins.str subnet_id: Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if save_tx_order is not None:
            pulumi.set(__self__, "save_tx_order", save_tx_order)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if serializer is not None:
            pulumi.set(__self__, "serializer", serializer)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        YDS Endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="saveTxOrder")
    def save_tx_order(self) -> Optional[_builtins.bool]:
        """
        Save transaction order.
        """
        return pulumi.get(self, "save_tx_order")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups that the transfer associated with this endpoint should use.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def serializer(self) -> Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializer']:
        """
        Data serialization format.
        """
        return pulumi.get(self, "serializer")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID for interaction with database.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter
    def stream(self) -> Optional[_builtins.str]:
        """
        Stream.
        """
        return pulumi.get(self, "stream")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the Yandex Cloud VPC subnetwork to user for accessing the database. If omitted, the server has to be accessible via Internet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class DatatransferEndpointSettingsYdsTargetSerializer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializerAuto":
            suggest = "serializer_auto"
        elif key == "serializerDebezium":
            suggest = "serializer_debezium"
        elif key == "serializerJson":
            suggest = "serializer_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsTargetSerializer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsTargetSerializer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsTargetSerializer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serializer_auto: Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerAuto'] = None,
                 serializer_debezium: Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium'] = None,
                 serializer_json: Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerJson'] = None):
        """
        :param 'DatatransferEndpointSettingsYdsTargetSerializerSerializerAutoArgs' serializer_auto: Empty block. Select data serialization format automatically.
        :param 'DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumArgs' serializer_debezium: Serialize data in json format.
        :param 'DatatransferEndpointSettingsYdsTargetSerializerSerializerJsonArgs' serializer_json: Empty block. Serialize data in json format.
        """
        if serializer_auto is not None:
            pulumi.set(__self__, "serializer_auto", serializer_auto)
        if serializer_debezium is not None:
            pulumi.set(__self__, "serializer_debezium", serializer_debezium)
        if serializer_json is not None:
            pulumi.set(__self__, "serializer_json", serializer_json)

    @_builtins.property
    @pulumi.getter(name="serializerAuto")
    def serializer_auto(self) -> Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerAuto']:
        """
        Empty block. Select data serialization format automatically.
        """
        return pulumi.get(self, "serializer_auto")

    @_builtins.property
    @pulumi.getter(name="serializerDebezium")
    def serializer_debezium(self) -> Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium']:
        """
        Serialize data in json format.
        """
        return pulumi.get(self, "serializer_debezium")

    @_builtins.property
    @pulumi.getter(name="serializerJson")
    def serializer_json(self) -> Optional['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerJson']:
        """
        Empty block. Serialize data in json format.
        """
        return pulumi.get(self, "serializer_json")


@pulumi.output_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerAuto(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializerParameters":
            suggest = "serializer_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serializer_parameters: Optional[Sequence['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameter']] = None):
        """
        :param Sequence['DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameterArgs'] serializer_parameters: A list of Debezium parameters set by the structure of the `key` and `value` string fields.
        """
        if serializer_parameters is not None:
            pulumi.set(__self__, "serializer_parameters", serializer_parameters)

    @_builtins.property
    @pulumi.getter(name="serializerParameters")
    def serializer_parameters(self) -> Optional[Sequence['outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameter']]:
        """
        A list of Debezium parameters set by the structure of the `key` and `value` string fields.
        """
        return pulumi.get(self, "serializer_parameters")


@pulumi.output_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DatatransferEndpointSettingsYdsTargetSerializerSerializerJson(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DatatransferTransferRuntime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ycRuntime":
            suggest = "yc_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferRuntime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferRuntime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferRuntime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 yc_runtime: Optional['outputs.DatatransferTransferRuntimeYcRuntime'] = None):
        """
        :param 'DatatransferTransferRuntimeYcRuntimeArgs' yc_runtime: YC Runtime parameters for the transfer.
        """
        if yc_runtime is not None:
            pulumi.set(__self__, "yc_runtime", yc_runtime)

    @_builtins.property
    @pulumi.getter(name="ycRuntime")
    def yc_runtime(self) -> Optional['outputs.DatatransferTransferRuntimeYcRuntime']:
        """
        YC Runtime parameters for the transfer.
        """
        return pulumi.get(self, "yc_runtime")


@pulumi.output_type
class DatatransferTransferRuntimeYcRuntime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobCount":
            suggest = "job_count"
        elif key == "uploadShardParams":
            suggest = "upload_shard_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferRuntimeYcRuntime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferRuntimeYcRuntime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferRuntimeYcRuntime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_count: Optional[_builtins.int] = None,
                 upload_shard_params: Optional['outputs.DatatransferTransferRuntimeYcRuntimeUploadShardParams'] = None):
        """
        :param _builtins.int job_count: Number of workers in parallel replication.
        :param 'DatatransferTransferRuntimeYcRuntimeUploadShardParamsArgs' upload_shard_params: Parallel snapshot parameters.
        """
        if job_count is not None:
            pulumi.set(__self__, "job_count", job_count)
        if upload_shard_params is not None:
            pulumi.set(__self__, "upload_shard_params", upload_shard_params)

    @_builtins.property
    @pulumi.getter(name="jobCount")
    def job_count(self) -> Optional[_builtins.int]:
        """
        Number of workers in parallel replication.
        """
        return pulumi.get(self, "job_count")

    @_builtins.property
    @pulumi.getter(name="uploadShardParams")
    def upload_shard_params(self) -> Optional['outputs.DatatransferTransferRuntimeYcRuntimeUploadShardParams']:
        """
        Parallel snapshot parameters.
        """
        return pulumi.get(self, "upload_shard_params")


@pulumi.output_type
class DatatransferTransferRuntimeYcRuntimeUploadShardParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobCount":
            suggest = "job_count"
        elif key == "processCount":
            suggest = "process_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferRuntimeYcRuntimeUploadShardParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferRuntimeYcRuntimeUploadShardParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferRuntimeYcRuntimeUploadShardParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_count: Optional[_builtins.int] = None,
                 process_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int job_count: Number of workers.
        :param _builtins.int process_count: Number of threads.
        """
        if job_count is not None:
            pulumi.set(__self__, "job_count", job_count)
        if process_count is not None:
            pulumi.set(__self__, "process_count", process_count)

    @_builtins.property
    @pulumi.getter(name="jobCount")
    def job_count(self) -> Optional[_builtins.int]:
        """
        Number of workers.
        """
        return pulumi.get(self, "job_count")

    @_builtins.property
    @pulumi.getter(name="processCount")
    def process_count(self) -> Optional[_builtins.int]:
        """
        Number of threads.
        """
        return pulumi.get(self, "process_count")


@pulumi.output_type
class DatatransferTransferTransformation(dict):
    def __init__(__self__, *,
                 transformers: Optional[Sequence['outputs.DatatransferTransferTransformationTransformer']] = None):
        """
        :param Sequence['DatatransferTransferTransformationTransformerArgs'] transformers: A list of transformers. You can specify exactly 1 transformer in each element of list.
        """
        if transformers is not None:
            pulumi.set(__self__, "transformers", transformers)

    @_builtins.property
    @pulumi.getter
    def transformers(self) -> Optional[Sequence['outputs.DatatransferTransferTransformationTransformer']]:
        """
        A list of transformers. You can specify exactly 1 transformer in each element of list.
        """
        return pulumi.get(self, "transformers")


@pulumi.output_type
class DatatransferTransferTransformationTransformer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "convertToString":
            suggest = "convert_to_string"
        elif key == "filterColumns":
            suggest = "filter_columns"
        elif key == "filterRows":
            suggest = "filter_rows"
        elif key == "maskField":
            suggest = "mask_field"
        elif key == "renameTables":
            suggest = "rename_tables"
        elif key == "replacePrimaryKey":
            suggest = "replace_primary_key"
        elif key == "sharderTransformer":
            suggest = "sharder_transformer"
        elif key == "tableSplitterTransformer":
            suggest = "table_splitter_transformer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convert_to_string: Optional['outputs.DatatransferTransferTransformationTransformerConvertToString'] = None,
                 filter_columns: Optional['outputs.DatatransferTransferTransformationTransformerFilterColumns'] = None,
                 filter_rows: Optional['outputs.DatatransferTransferTransformationTransformerFilterRows'] = None,
                 mask_field: Optional['outputs.DatatransferTransferTransformationTransformerMaskField'] = None,
                 rename_tables: Optional['outputs.DatatransferTransferTransformationTransformerRenameTables'] = None,
                 replace_primary_key: Optional['outputs.DatatransferTransferTransformationTransformerReplacePrimaryKey'] = None,
                 sharder_transformer: Optional['outputs.DatatransferTransferTransformationTransformerSharderTransformer'] = None,
                 table_splitter_transformer: Optional['outputs.DatatransferTransferTransformationTransformerTableSplitterTransformer'] = None):
        """
        :param 'DatatransferTransferTransformationTransformerConvertToStringArgs' convert_to_string: Convert column values to strings.
        :param 'DatatransferTransferTransformationTransformerFilterColumnsArgs' filter_columns: Set up a list of table columns to transfer.
        :param 'DatatransferTransferTransformationTransformerFilterRowsArgs' filter_rows: This filter only applies to transfers with queues (Apache Kafka) as a data source. When running a transfer, only the strings meeting the specified criteria remain in a changefeed.
        :param 'DatatransferTransferTransformationTransformerMaskFieldArgs' mask_field: Mask field transformer allows you to hash data.
        :param 'DatatransferTransferTransformationTransformerRenameTablesArgs' rename_tables: Set rules for renaming tables by specifying the current names of the tables in the source and new names for these tables in the target.
        :param 'DatatransferTransferTransformationTransformerReplacePrimaryKeyArgs' replace_primary_key: Override primary keys.
        :param 'DatatransferTransferTransformationTransformerSharderTransformerArgs' sharder_transformer: Set the number of shards for particular tables and a list of columns whose values will be used for calculating a hash to determine a shard.
        :param 'DatatransferTransferTransformationTransformerTableSplitterTransformerArgs' table_splitter_transformer: Splits the X table into multiple tables (X*1, X*2, ..., X*n) based on data.
        """
        if convert_to_string is not None:
            pulumi.set(__self__, "convert_to_string", convert_to_string)
        if filter_columns is not None:
            pulumi.set(__self__, "filter_columns", filter_columns)
        if filter_rows is not None:
            pulumi.set(__self__, "filter_rows", filter_rows)
        if mask_field is not None:
            pulumi.set(__self__, "mask_field", mask_field)
        if rename_tables is not None:
            pulumi.set(__self__, "rename_tables", rename_tables)
        if replace_primary_key is not None:
            pulumi.set(__self__, "replace_primary_key", replace_primary_key)
        if sharder_transformer is not None:
            pulumi.set(__self__, "sharder_transformer", sharder_transformer)
        if table_splitter_transformer is not None:
            pulumi.set(__self__, "table_splitter_transformer", table_splitter_transformer)

    @_builtins.property
    @pulumi.getter(name="convertToString")
    def convert_to_string(self) -> Optional['outputs.DatatransferTransferTransformationTransformerConvertToString']:
        """
        Convert column values to strings.
        """
        return pulumi.get(self, "convert_to_string")

    @_builtins.property
    @pulumi.getter(name="filterColumns")
    def filter_columns(self) -> Optional['outputs.DatatransferTransferTransformationTransformerFilterColumns']:
        """
        Set up a list of table columns to transfer.
        """
        return pulumi.get(self, "filter_columns")

    @_builtins.property
    @pulumi.getter(name="filterRows")
    def filter_rows(self) -> Optional['outputs.DatatransferTransferTransformationTransformerFilterRows']:
        """
        This filter only applies to transfers with queues (Apache Kafka) as a data source. When running a transfer, only the strings meeting the specified criteria remain in a changefeed.
        """
        return pulumi.get(self, "filter_rows")

    @_builtins.property
    @pulumi.getter(name="maskField")
    def mask_field(self) -> Optional['outputs.DatatransferTransferTransformationTransformerMaskField']:
        """
        Mask field transformer allows you to hash data.
        """
        return pulumi.get(self, "mask_field")

    @_builtins.property
    @pulumi.getter(name="renameTables")
    def rename_tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerRenameTables']:
        """
        Set rules for renaming tables by specifying the current names of the tables in the source and new names for these tables in the target.
        """
        return pulumi.get(self, "rename_tables")

    @_builtins.property
    @pulumi.getter(name="replacePrimaryKey")
    def replace_primary_key(self) -> Optional['outputs.DatatransferTransferTransformationTransformerReplacePrimaryKey']:
        """
        Override primary keys.
        """
        return pulumi.get(self, "replace_primary_key")

    @_builtins.property
    @pulumi.getter(name="sharderTransformer")
    def sharder_transformer(self) -> Optional['outputs.DatatransferTransferTransformationTransformerSharderTransformer']:
        """
        Set the number of shards for particular tables and a list of columns whose values will be used for calculating a hash to determine a shard.
        """
        return pulumi.get(self, "sharder_transformer")

    @_builtins.property
    @pulumi.getter(name="tableSplitterTransformer")
    def table_splitter_transformer(self) -> Optional['outputs.DatatransferTransferTransformationTransformerTableSplitterTransformer']:
        """
        Splits the X table into multiple tables (X*1, X*2, ..., X*n) based on data.
        """
        return pulumi.get(self, "table_splitter_transformer")


@pulumi.output_type
class DatatransferTransferTransformationTransformerConvertToString(dict):
    def __init__(__self__, *,
                 columns: Optional['outputs.DatatransferTransferTransformationTransformerConvertToStringColumns'] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerConvertToStringTables'] = None):
        """
        :param 'DatatransferTransferTransformationTransformerConvertToStringColumnsArgs' columns: List of the columns to transfer to the target tables using lists of included and excluded columns.
        :param 'DatatransferTransferTransformationTransformerConvertToStringTablesArgs' tables: Table filter.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional['outputs.DatatransferTransferTransformationTransformerConvertToStringColumns']:
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns.
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerConvertToStringTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerConvertToStringColumns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerConvertToStringColumns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerConvertToStringColumns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerConvertToStringColumns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] exclude_columns: List of columns that will be excluded to transfer.
        :param Sequence[_builtins.str] include_columns: List of columns that will be included to transfer.
        """
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of columns that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of columns that will be included to transfer.
        """
        return pulumi.get(self, "include_columns")


@pulumi.output_type
class DatatransferTransferTransformationTransformerConvertToStringTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerConvertToStringTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerConvertToStringTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerConvertToStringTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] exclude_tables: List of tables that will be excluded to transfer.
        :param Sequence[_builtins.str] include_tables: List of tables that will be included to transfer.
        """
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tables that will be excluded to transfer.
        """
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tables that will be included to transfer.
        """
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerFilterColumns(dict):
    def __init__(__self__, *,
                 columns: Optional['outputs.DatatransferTransferTransformationTransformerFilterColumnsColumns'] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerFilterColumnsTables'] = None):
        """
        :param 'DatatransferTransferTransformationTransformerFilterColumnsColumnsArgs' columns: List of the columns to transfer to the target tables using lists of included and excluded columns.
        :param 'DatatransferTransferTransformationTransformerFilterColumnsTablesArgs' tables: Table filter.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional['outputs.DatatransferTransferTransformationTransformerFilterColumnsColumns']:
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns.
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerFilterColumnsTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerFilterColumnsColumns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerFilterColumnsColumns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerFilterColumnsColumns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerFilterColumnsColumns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None):
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_columns")


@pulumi.output_type
class DatatransferTransferTransformationTransformerFilterColumnsTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerFilterColumnsTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerFilterColumnsTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerFilterColumnsTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerFilterRows(dict):
    def __init__(__self__, *,
                 filter: Optional[_builtins.str] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerFilterRowsTables'] = None):
        """
        :param _builtins.str filter: Filtering criterion. This can be comparison operators for numeric, string, and Boolean values, comparison to NULL, and checking whether a substring is part of a string. See details [here](https://yandex.cloud/docs/data-transfer/concepts/data-transformation#append-only-sources).
        :param 'DatatransferTransferTransformationTransformerFilterRowsTablesArgs' tables: Table filter.
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        Filtering criterion. This can be comparison operators for numeric, string, and Boolean values, comparison to NULL, and checking whether a substring is part of a string. See details [here](https://yandex.cloud/docs/data-transfer/concepts/data-transformation#append-only-sources).
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerFilterRowsTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerFilterRowsTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerFilterRowsTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerFilterRowsTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerFilterRowsTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerMaskField(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence[_builtins.str]] = None,
                 function: Optional['outputs.DatatransferTransferTransformationTransformerMaskFieldFunction'] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerMaskFieldTables'] = None):
        """
        :param Sequence[_builtins.str] columns: List of strings that specify the name of the column for data masking (a regular expression).
        :param 'DatatransferTransferTransformationTransformerMaskFieldFunctionArgs' function: Mask function.
        :param 'DatatransferTransferTransformationTransformerMaskFieldTablesArgs' tables: Table filter.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of strings that specify the name of the column for data masking (a regular expression).
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional['outputs.DatatransferTransferTransformationTransformerMaskFieldFunction']:
        """
        Mask function.
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerMaskFieldTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerMaskFieldFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maskFunctionHash":
            suggest = "mask_function_hash"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerMaskFieldFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerMaskFieldFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerMaskFieldFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mask_function_hash: Optional['outputs.DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash'] = None):
        """
        :param 'DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHashArgs' mask_function_hash: Hash mask function.
        """
        if mask_function_hash is not None:
            pulumi.set(__self__, "mask_function_hash", mask_function_hash)

    @_builtins.property
    @pulumi.getter(name="maskFunctionHash")
    def mask_function_hash(self) -> Optional['outputs.DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash']:
        """
        Hash mask function.
        """
        return pulumi.get(self, "mask_function_hash")


@pulumi.output_type
class DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userDefinedSalt":
            suggest = "user_defined_salt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_defined_salt: Optional[_builtins.str] = None):
        """
        :param _builtins.str user_defined_salt: This string will be used in the HMAC(sha256, salt) function applied to the column data.
        """
        if user_defined_salt is not None:
            pulumi.set(__self__, "user_defined_salt", user_defined_salt)

    @_builtins.property
    @pulumi.getter(name="userDefinedSalt")
    def user_defined_salt(self) -> Optional[_builtins.str]:
        """
        This string will be used in the HMAC(sha256, salt) function applied to the column data.
        """
        return pulumi.get(self, "user_defined_salt")


@pulumi.output_type
class DatatransferTransferTransformationTransformerMaskFieldTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerMaskFieldTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerMaskFieldTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerMaskFieldTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerRenameTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renameTables":
            suggest = "rename_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerRenameTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerRenameTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerRenameTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rename_tables: Optional[Sequence['outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTable']] = None):
        """
        :param Sequence['DatatransferTransferTransformationTransformerRenameTablesRenameTableArgs'] rename_tables: List of renaming rules.
        """
        if rename_tables is not None:
            pulumi.set(__self__, "rename_tables", rename_tables)

    @_builtins.property
    @pulumi.getter(name="renameTables")
    def rename_tables(self) -> Optional[Sequence['outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTable']]:
        """
        List of renaming rules.
        """
        return pulumi.get(self, "rename_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerRenameTablesRenameTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newName":
            suggest = "new_name"
        elif key == "originalName":
            suggest = "original_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerRenameTablesRenameTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerRenameTablesRenameTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerRenameTablesRenameTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 new_name: Optional['outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName'] = None,
                 original_name: Optional['outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName'] = None):
        """
        :param 'DatatransferTransferTransformationTransformerRenameTablesRenameTableNewNameArgs' new_name: Specify the new names for this table in the target.
        :param 'DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalNameArgs' original_name: Specify the current names of the table in the source.
        """
        if new_name is not None:
            pulumi.set(__self__, "new_name", new_name)
        if original_name is not None:
            pulumi.set(__self__, "original_name", original_name)

    @_builtins.property
    @pulumi.getter(name="newName")
    def new_name(self) -> Optional['outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName']:
        """
        Specify the new names for this table in the target.
        """
        return pulumi.get(self, "new_name")

    @_builtins.property
    @pulumi.getter(name="originalName")
    def original_name(self) -> Optional['outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName']:
        """
        Specify the current names of the table in the source.
        """
        return pulumi.get(self, "original_name")


@pulumi.output_type
class DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameSpace":
            suggest = "name_space"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 name_space: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_space is not None:
            pulumi.set(__self__, "name_space", name_space)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameSpace")
    def name_space(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name_space")


@pulumi.output_type
class DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameSpace":
            suggest = "name_space"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 name_space: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_space is not None:
            pulumi.set(__self__, "name_space", name_space)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameSpace")
    def name_space(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name_space")


@pulumi.output_type
class DatatransferTransferTransformationTransformerReplacePrimaryKey(dict):
    def __init__(__self__, *,
                 keys: Optional[Sequence[_builtins.str]] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerReplacePrimaryKeyTables'] = None):
        """
        :param Sequence[_builtins.str] keys: List of columns to be used as primary keys.
        :param 'DatatransferTransferTransformationTransformerReplacePrimaryKeyTablesArgs' tables: Table filter.
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of columns to be used as primary keys.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerReplacePrimaryKeyTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerReplacePrimaryKeyTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerReplacePrimaryKeyTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerReplacePrimaryKeyTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerReplacePrimaryKeyTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerSharderTransformer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shardsCount":
            suggest = "shards_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerSharderTransformer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerSharderTransformer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerSharderTransformer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional['outputs.DatatransferTransferTransformationTransformerSharderTransformerColumns'] = None,
                 shards_count: Optional[_builtins.int] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerSharderTransformerTables'] = None):
        """
        :param 'DatatransferTransferTransformationTransformerSharderTransformerColumnsArgs' columns: List of the columns to transfer to the target tables using lists of included and excluded columns.
        :param _builtins.int shards_count: Number of shards.
        :param 'DatatransferTransferTransformationTransformerSharderTransformerTablesArgs' tables: Table filter.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if shards_count is not None:
            pulumi.set(__self__, "shards_count", shards_count)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional['outputs.DatatransferTransferTransformationTransformerSharderTransformerColumns']:
        """
        List of the columns to transfer to the target tables using lists of included and excluded columns.
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter(name="shardsCount")
    def shards_count(self) -> Optional[_builtins.int]:
        """
        Number of shards.
        """
        return pulumi.get(self, "shards_count")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerSharderTransformerTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerSharderTransformerColumns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerSharderTransformerColumns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerSharderTransformerColumns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerSharderTransformerColumns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None):
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_columns")


@pulumi.output_type
class DatatransferTransferTransformationTransformerSharderTransformerTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerSharderTransformerTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerSharderTransformerTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerSharderTransformerTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerTableSplitterTransformer(dict):
    def __init__(__self__, *,
                 columns: Optional[Sequence[_builtins.str]] = None,
                 splitter: Optional[_builtins.str] = None,
                 tables: Optional['outputs.DatatransferTransferTransformationTransformerTableSplitterTransformerTables'] = None):
        """
        :param Sequence[_builtins.str] columns: List of strings that specify the columns in the tables to be partitioned.
        :param _builtins.str splitter: Specify the split string to be used for merging components in a new table name.
        :param 'DatatransferTransferTransformationTransformerTableSplitterTransformerTablesArgs' tables: Table filter.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if splitter is not None:
            pulumi.set(__self__, "splitter", splitter)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of strings that specify the columns in the tables to be partitioned.
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def splitter(self) -> Optional[_builtins.str]:
        """
        Specify the split string to be used for merging components in a new table name.
        """
        return pulumi.get(self, "splitter")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional['outputs.DatatransferTransferTransformationTransformerTableSplitterTransformerTables']:
        """
        Table filter.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class DatatransferTransferTransformationTransformerTableSplitterTransformerTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeTables":
            suggest = "exclude_tables"
        elif key == "includeTables":
            suggest = "include_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatatransferTransferTransformationTransformerTableSplitterTransformerTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatatransferTransferTransformationTransformerTableSplitterTransformerTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatatransferTransferTransformationTransformerTableSplitterTransformerTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_tables: Optional[Sequence[_builtins.str]] = None,
                 include_tables: Optional[Sequence[_builtins.str]] = None):
        if exclude_tables is not None:
            pulumi.set(__self__, "exclude_tables", exclude_tables)
        if include_tables is not None:
            pulumi.set(__self__, "include_tables", include_tables)

    @_builtins.property
    @pulumi.getter(name="excludeTables")
    def exclude_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_tables")

    @_builtins.property
    @pulumi.getter(name="includeTables")
    def include_tables(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_tables")


@pulumi.output_type
class FunctionAsyncInvocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retriesCount":
            suggest = "retries_count"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "ymqFailureTarget":
            suggest = "ymq_failure_target"
        elif key == "ymqSuccessTarget":
            suggest = "ymq_success_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAsyncInvocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAsyncInvocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAsyncInvocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retries_count: Optional[_builtins.int] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 ymq_failure_target: Optional['outputs.FunctionAsyncInvocationYmqFailureTarget'] = None,
                 ymq_success_target: Optional['outputs.FunctionAsyncInvocationYmqSuccessTarget'] = None):
        """
        :param _builtins.int retries_count: Maximum number of retries for async invocation.
        :param _builtins.str service_account_id: Service account used for async invocation.
        :param 'FunctionAsyncInvocationYmqFailureTargetArgs' ymq_failure_target: Target for unsuccessful async invocation.
        :param 'FunctionAsyncInvocationYmqSuccessTargetArgs' ymq_success_target: Target for successful async invocation.
        """
        if retries_count is not None:
            pulumi.set(__self__, "retries_count", retries_count)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if ymq_failure_target is not None:
            pulumi.set(__self__, "ymq_failure_target", ymq_failure_target)
        if ymq_success_target is not None:
            pulumi.set(__self__, "ymq_success_target", ymq_success_target)

    @_builtins.property
    @pulumi.getter(name="retriesCount")
    def retries_count(self) -> Optional[_builtins.int]:
        """
        Maximum number of retries for async invocation.
        """
        return pulumi.get(self, "retries_count")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account used for async invocation.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="ymqFailureTarget")
    def ymq_failure_target(self) -> Optional['outputs.FunctionAsyncInvocationYmqFailureTarget']:
        """
        Target for unsuccessful async invocation.
        """
        return pulumi.get(self, "ymq_failure_target")

    @_builtins.property
    @pulumi.getter(name="ymqSuccessTarget")
    def ymq_success_target(self) -> Optional['outputs.FunctionAsyncInvocationYmqSuccessTarget']:
        """
        Target for successful async invocation.
        """
        return pulumi.get(self, "ymq_success_target")


@pulumi.output_type
class FunctionAsyncInvocationYmqFailureTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAsyncInvocationYmqFailureTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAsyncInvocationYmqFailureTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAsyncInvocationYmqFailureTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str arn: YMQ ARN.
        :param _builtins.str service_account_id: Service account used for writing result to queue.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        YMQ ARN.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account used for writing result to queue.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class FunctionAsyncInvocationYmqSuccessTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAsyncInvocationYmqSuccessTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAsyncInvocationYmqSuccessTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAsyncInvocationYmqSuccessTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str arn: YMQ ARN.
        :param _builtins.str service_account_id: Service account used for writing result to queue.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        YMQ ARN.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account used for writing result to queue.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class FunctionConnectivity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionConnectivity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionConnectivity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionConnectivity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: _builtins.str):
        """
        :param _builtins.str network_id: Network the version will have access to. It's essential to specify network with subnets in all availability zones.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network the version will have access to. It's essential to specify network with subnets in all availability zones.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class FunctionContent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zipFilename":
            suggest = "zip_filename"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zip_filename: _builtins.str):
        """
        :param _builtins.str zip_filename: Filename to zip archive for the version.
        """
        pulumi.set(__self__, "zip_filename", zip_filename)

    @_builtins.property
    @pulumi.getter(name="zipFilename")
    def zip_filename(self) -> _builtins.str:
        """
        Filename to zip archive for the version.
        """
        return pulumi.get(self, "zip_filename")


@pulumi.output_type
class FunctionLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderId":
            suggest = "folder_id"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 log_group_id: Optional[_builtins.str] = None,
                 min_level: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Is logging from function disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Is logging from function disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[_builtins.str]:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class FunctionMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsV1HttpEndpoint":
            suggest = "aws_v1_http_endpoint"
        elif key == "gceHttpEndpoint":
            suggest = "gce_http_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_v1_http_endpoint: Optional[_builtins.int] = None,
                 gce_http_endpoint: Optional[_builtins.int] = None):
        """
        :param _builtins.int aws_v1_http_endpoint: Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        :param _builtins.int gce_http_endpoint: Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        if aws_v1_http_endpoint is not None:
            pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        if gce_http_endpoint is not None:
            pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> Optional[_builtins.int]:
        """
        Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> Optional[_builtins.int]:
        """
        Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "gce_http_endpoint")


@pulumi.output_type
class FunctionMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ephemeralDisk":
            suggest = "ephemeral_disk"
        elif key == "objectStorage":
            suggest = "object_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 ephemeral_disk: Optional['outputs.FunctionMountEphemeralDisk'] = None,
                 mode: Optional[_builtins.str] = None,
                 object_storage: Optional['outputs.FunctionMountObjectStorage'] = None):
        """
        :param _builtins.str name: Name of the mount point. The directory where the target is mounted will be accessible at the `/function/storage/<mounts.0.name>` path.
        :param 'FunctionMountEphemeralDiskArgs' ephemeral_disk: One of the available mount types. Disk available during the function execution time.
        :param _builtins.str mode: Mounts accessibility mode. Valid values are `ro` and `rw`.
        :param 'FunctionMountObjectStorageArgs' object_storage: One of the available mount types. Object storage as a mount.
        """
        pulumi.set(__self__, "name", name)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the mount point. The directory where the target is mounted will be accessible at the `/function/storage/<mounts.0.name>` path.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional['outputs.FunctionMountEphemeralDisk']:
        """
        One of the available mount types. Disk available during the function execution time.
        """
        return pulumi.get(self, "ephemeral_disk")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional['outputs.FunctionMountObjectStorage']:
        """
        One of the available mount types. Object storage as a mount.
        """
        return pulumi.get(self, "object_storage")


@pulumi.output_type
class FunctionMountEphemeralDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"
        elif key == "blockSizeKb":
            suggest = "block_size_kb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionMountEphemeralDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionMountEphemeralDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionMountEphemeralDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: _builtins.int,
                 block_size_kb: Optional[_builtins.int] = None):
        """
        :param _builtins.int size_gb: Size of the ephemeral disk in GB.
        :param _builtins.int block_size_kb: Optional block size of the ephemeral disk in KB.
        """
        pulumi.set(__self__, "size_gb", size_gb)
        if block_size_kb is not None:
            pulumi.set(__self__, "block_size_kb", block_size_kb)

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        """
        Size of the ephemeral disk in GB.
        """
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> Optional[_builtins.int]:
        """
        Optional block size of the ephemeral disk in KB.
        """
        return pulumi.get(self, "block_size_kb")


@pulumi.output_type
class FunctionMountObjectStorage(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class FunctionPackage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectName":
            suggest = "object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionPackage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionPackage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionPackage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 object_name: _builtins.str,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: Name of the bucket that stores the code for the version.
        :param _builtins.str object_name: Name of the object in the bucket that stores the code for the version.
        :param _builtins.str sha256: SHA256 hash of the version deployment package.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "object_name", object_name)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Name of the bucket that stores the code for the version.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="objectName")
    def object_name(self) -> _builtins.str:
        """
        Name of the object in the bucket that stores the code for the version.
        """
        return pulumi.get(self, "object_name")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        SHA256 hash of the version deployment package.
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class FunctionScalingPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "zoneInstancesLimit":
            suggest = "zone_instances_limit"
        elif key == "zoneRequestsLimit":
            suggest = "zone_requests_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionScalingPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionScalingPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionScalingPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: _builtins.str,
                 zone_instances_limit: Optional[_builtins.int] = None,
                 zone_requests_limit: Optional[_builtins.int] = None):
        """
        :param _builtins.str tag: Yandex Cloud Function version tag for Yandex Cloud Function scaling policy.
        :param _builtins.int zone_instances_limit: Max number of instances in one zone for Yandex Cloud Function with tag.
        :param _builtins.int zone_requests_limit: Max number of requests in one zone for Yandex Cloud Function with tag.
        """
        pulumi.set(__self__, "tag", tag)
        if zone_instances_limit is not None:
            pulumi.set(__self__, "zone_instances_limit", zone_instances_limit)
        if zone_requests_limit is not None:
            pulumi.set(__self__, "zone_requests_limit", zone_requests_limit)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Yandex Cloud Function version tag for Yandex Cloud Function scaling policy.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="zoneInstancesLimit")
    def zone_instances_limit(self) -> Optional[_builtins.int]:
        """
        Max number of instances in one zone for Yandex Cloud Function with tag.
        """
        return pulumi.get(self, "zone_instances_limit")

    @_builtins.property
    @pulumi.getter(name="zoneRequestsLimit")
    def zone_requests_limit(self) -> Optional[_builtins.int]:
        """
        Max number of requests in one zone for Yandex Cloud Function with tag.
        """
        return pulumi.get(self, "zone_requests_limit")


@pulumi.output_type
class FunctionSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariable":
            suggest = "environment_variable"
        elif key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_variable: _builtins.str,
                 id: _builtins.str,
                 key: _builtins.str,
                 version_id: _builtins.str):
        """
        :param _builtins.str environment_variable: Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        :param _builtins.str id: Secret's ID.
        :param _builtins.str key: Secret's entries key which value will be stored in environment variable.
        :param _builtins.str version_id: Secret's version ID.
        """
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> _builtins.str:
        """
        Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment_variable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Secret's ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Secret's entries key which value will be stored in environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Secret's version ID.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class FunctionStorageMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPointName":
            suggest = "mount_point_name"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionStorageMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionStorageMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionStorageMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 mount_point_name: _builtins.str,
                 prefix: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str mount_point_name: Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        :param _builtins.bool read_only: Mount the bucket in read-only mode.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_name", mount_point_name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="mountPointName")
    def mount_point_name(self) -> _builtins.str:
        """
        Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path.
        """
        return pulumi.get(self, "mount_point_name")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Mount the bucket in read-only mode.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class FunctionTriggerContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryAttempts":
            suggest = "retry_attempts"
        elif key == "retryInterval":
            suggest = "retry_interval"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 path: Optional[_builtins.str] = None,
                 retry_attempts: Optional[_builtins.str] = None,
                 retry_interval: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Yandex Cloud Serverless Container ID for Yandex Cloud Functions Trigger.
        :param _builtins.str path: Path for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        :param _builtins.str retry_attempts: Retry attempts for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        :param _builtins.str retry_interval: Retry interval in seconds for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "id", id)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if retry_attempts is not None:
            pulumi.set(__self__, "retry_attempts", retry_attempts)
        if retry_interval is not None:
            pulumi.set(__self__, "retry_interval", retry_interval)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Yandex Cloud Serverless Container ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> Optional[_builtins.str]:
        """
        Retry attempts for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_attempts")

    @_builtins.property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[_builtins.str]:
        """
        Retry interval in seconds for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_interval")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class FunctionTriggerContainerRegistry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "registryId":
            suggest = "registry_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "createImage":
            suggest = "create_image"
        elif key == "createImageTag":
            suggest = "create_image_tag"
        elif key == "deleteImage":
            suggest = "delete_image"
        elif key == "deleteImageTag":
            suggest = "delete_image_tag"
        elif key == "imageName":
            suggest = "image_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerContainerRegistry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerContainerRegistry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerContainerRegistry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 registry_id: _builtins.str,
                 batch_size: Optional[_builtins.str] = None,
                 create_image: Optional[_builtins.bool] = None,
                 create_image_tag: Optional[_builtins.bool] = None,
                 delete_image: Optional[_builtins.bool] = None,
                 delete_image_tag: Optional[_builtins.bool] = None,
                 image_name: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str registry_id: Container Registry ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.bool create_image: Boolean flag for setting `create image` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool create_image_tag: Boolean flag for setting `create image tag` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool delete_image: Boolean flag for setting `delete image` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool delete_image_tag: Boolean flag for setting `delete image tag` event for Yandex Cloud Functions Trigger.
        :param _builtins.str image_name: Image name filter setting for Yandex Cloud Functions Trigger.
        :param _builtins.str tag: Image tag filter setting for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "registry_id", registry_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if create_image is not None:
            pulumi.set(__self__, "create_image", create_image)
        if create_image_tag is not None:
            pulumi.set(__self__, "create_image_tag", create_image_tag)
        if delete_image is not None:
            pulumi.set(__self__, "delete_image", delete_image)
        if delete_image_tag is not None:
            pulumi.set(__self__, "delete_image_tag", delete_image_tag)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> _builtins.str:
        """
        Container Registry ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "registry_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="createImage")
    def create_image(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `create image` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "create_image")

    @_builtins.property
    @pulumi.getter(name="createImageTag")
    def create_image_tag(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `create image tag` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "create_image_tag")

    @_builtins.property
    @pulumi.getter(name="deleteImage")
    def delete_image(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `delete image` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "delete_image")

    @_builtins.property
    @pulumi.getter(name="deleteImageTag")
    def delete_image_tag(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `delete image tag` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "delete_image_tag")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[_builtins.str]:
        """
        Image name filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Image tag filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class FunctionTriggerDataStreams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerDataStreams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerDataStreams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerDataStreams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 database: _builtins.str,
                 service_account_id: _builtins.str,
                 stream_name: _builtins.str,
                 batch_size: Optional[_builtins.str] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str database: Stream database for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID to access data stream for Yandex Cloud Functions Trigger.
        :param _builtins.str stream_name: Stream name for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Stream database for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account ID to access data stream for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Stream name for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "stream_name")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")


@pulumi.output_type
class FunctionTriggerDlq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueId":
            suggest = "queue_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerDlq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerDlq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerDlq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_id: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str queue_id: ID of Dead Letter Queue for Trigger (Queue ARN).
        :param _builtins.str service_account_id: Service Account ID for Dead Letter Queue for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.str:
        """
        ID of Dead Letter Queue for Trigger (Queue ARN).
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service Account ID for Dead Letter Queue for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class FunctionTriggerFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryAttempts":
            suggest = "retry_attempts"
        elif key == "retryInterval":
            suggest = "retry_interval"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 retry_attempts: Optional[_builtins.str] = None,
                 retry_interval: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Yandex Cloud Function ID.
        :param _builtins.str retry_attempts: Retry attempts for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        :param _builtins.str retry_interval: Retry interval in seconds for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID for Yandex Cloud Function.
        :param _builtins.str tag: Tag for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "id", id)
        if retry_attempts is not None:
            pulumi.set(__self__, "retry_attempts", retry_attempts)
        if retry_interval is not None:
            pulumi.set(__self__, "retry_interval", retry_interval)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Yandex Cloud Function ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> Optional[_builtins.str]:
        """
        Retry attempts for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_attempts")

    @_builtins.property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[_builtins.str]:
        """
        Retry interval in seconds for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_interval")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID for Yandex Cloud Function.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Tag for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class FunctionTriggerIot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "registryId":
            suggest = "registry_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "deviceId":
            suggest = "device_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerIot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerIot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerIot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 registry_id: _builtins.str,
                 batch_size: Optional[_builtins.str] = None,
                 device_id: Optional[_builtins.str] = None,
                 topic: Optional[_builtins.str] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str registry_id: IoT Registry ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str device_id: IoT Device ID for Yandex Cloud Functions Trigger.
        :param _builtins.str topic: IoT Topic for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "registry_id", registry_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> _builtins.str:
        """
        IoT Registry ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "registry_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[_builtins.str]:
        """
        IoT Device ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[_builtins.str]:
        """
        IoT Topic for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class FunctionTriggerLogGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "logGroupIds":
            suggest = "log_group_ids"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerLogGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerLogGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerLogGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 log_group_ids: Sequence[_builtins.str],
                 batch_size: Optional[_builtins.str] = None):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "log_group_ids", log_group_ids)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="logGroupIds")
    def log_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "log_group_ids")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "batch_size")


@pulumi.output_type
class FunctionTriggerLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "resourceIds":
            suggest = "resource_ids"
        elif key == "resourceTypes":
            suggest = "resource_types"
        elif key == "streamNames":
            suggest = "stream_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 group_id: _builtins.str,
                 batch_size: Optional[_builtins.str] = None,
                 levels: Optional[Sequence[_builtins.str]] = None,
                 resource_ids: Optional[Sequence[_builtins.str]] = None,
                 resource_types: Optional[Sequence[_builtins.str]] = None,
                 stream_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str group_id: Logging group ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] levels: Logging level filter setting for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] resource_ids: Resource ID filter setting for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] resource_types: Resource type filter setting for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] stream_names: Logging stream name filter setting for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "group_id", group_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if levels is not None:
            pulumi.set(__self__, "levels", levels)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if stream_names is not None:
            pulumi.set(__self__, "stream_names", stream_names)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Logging group ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter
    def levels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Logging level filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "levels")

    @_builtins.property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Resource ID filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "resource_ids")

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Resource type filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "resource_types")

    @_builtins.property
    @pulumi.getter(name="streamNames")
    def stream_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Logging stream name filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "stream_names")


@pulumi.output_type
class FunctionTriggerMail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "attachmentsBucketId":
            suggest = "attachments_bucket_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerMail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerMail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerMail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 attachments_bucket_id: Optional[_builtins.str] = None,
                 batch_size: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str attachments_bucket_id: Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID to access object storage for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        if attachments_bucket_id is not None:
            pulumi.set(__self__, "attachments_bucket_id", attachments_bucket_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="attachmentsBucketId")
    def attachments_bucket_id(self) -> Optional[_builtins.str]:
        """
        Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "attachments_bucket_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account ID to access object storage for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class FunctionTriggerMessageQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "queueId":
            suggest = "queue_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "visibilityTimeout":
            suggest = "visibility_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerMessageQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerMessageQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerMessageQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 queue_id: _builtins.str,
                 service_account_id: _builtins.str,
                 batch_size: Optional[_builtins.str] = None,
                 visibility_timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str queue_id: Message Queue ID for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Message Queue Service Account ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str visibility_timeout: Visibility timeout for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.str:
        """
        Message Queue ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Message Queue Service Account ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[_builtins.str]:
        """
        Visibility timeout for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class FunctionTriggerObjectStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchCutoff":
            suggest = "batch_cutoff"
        elif key == "bucketId":
            suggest = "bucket_id"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerObjectStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerObjectStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerObjectStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 bucket_id: _builtins.str,
                 batch_size: Optional[_builtins.str] = None,
                 create: Optional[_builtins.bool] = None,
                 delete: Optional[_builtins.bool] = None,
                 prefix: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None,
                 update: Optional[_builtins.bool] = None):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str bucket_id: Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.bool create: Boolean flag for setting `create` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool delete: Boolean flag for setting `delete` event for Yandex Cloud Functions Trigger.
        :param _builtins.str prefix: Prefix for Object Storage for Yandex Cloud Functions Trigger.
        :param _builtins.str suffix: Suffix for Object Storage for Yandex Cloud Functions Trigger.
        :param _builtins.bool update: Boolean flag for setting `update` event for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "bucket_id", bucket_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="bucketId")
    def bucket_id(self) -> _builtins.str:
        """
        Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "bucket_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.str]:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `create` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `delete` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix for Object Storage for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        """
        Suffix for Object Storage for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "suffix")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.bool]:
        """
        Boolean flag for setting `update` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class FunctionTriggerTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 payload: Optional[_builtins.str] = None):
        """
        :param _builtins.str cron_expression: Cron expression for timer for Yandex Cloud Functions Trigger.
        :param _builtins.str payload: Payload to be passed to function.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        Cron expression for timer for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        Payload to be passed to function.
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class IamServiceAccountApiKeyOutputToLockbox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryForSecretKey":
            suggest = "entry_for_secret_key"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamServiceAccountApiKeyOutputToLockbox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamServiceAccountApiKeyOutputToLockbox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamServiceAccountApiKeyOutputToLockbox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_for_secret_key: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str entry_for_secret_key: entry that will store the value of secret_key
        :param _builtins.str secret_id: ID of the Lockbox secret where to store the sensible values.
        """
        pulumi.set(__self__, "entry_for_secret_key", entry_for_secret_key)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="entryForSecretKey")
    def entry_for_secret_key(self) -> _builtins.str:
        """
        entry that will store the value of secret_key
        """
        return pulumi.get(self, "entry_for_secret_key")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        ID of the Lockbox secret where to store the sensible values.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class IamServiceAccountKeyOutputToLockbox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryForPrivateKey":
            suggest = "entry_for_private_key"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamServiceAccountKeyOutputToLockbox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamServiceAccountKeyOutputToLockbox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamServiceAccountKeyOutputToLockbox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_for_private_key: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str entry_for_private_key: entry that will store the value of private_key
        :param _builtins.str secret_id: ID of the Lockbox secret where to store the sensible values.
        """
        pulumi.set(__self__, "entry_for_private_key", entry_for_private_key)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="entryForPrivateKey")
    def entry_for_private_key(self) -> _builtins.str:
        """
        entry that will store the value of private_key
        """
        return pulumi.get(self, "entry_for_private_key")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        ID of the Lockbox secret where to store the sensible values.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class IamServiceAccountStaticAccessKeyOutputToLockbox(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryForAccessKey":
            suggest = "entry_for_access_key"
        elif key == "entryForSecretKey":
            suggest = "entry_for_secret_key"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamServiceAccountStaticAccessKeyOutputToLockbox. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamServiceAccountStaticAccessKeyOutputToLockbox.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamServiceAccountStaticAccessKeyOutputToLockbox.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_for_access_key: _builtins.str,
                 entry_for_secret_key: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str entry_for_access_key: entry that will store the value of access_key
        :param _builtins.str entry_for_secret_key: entry that will store the value of secret_key
        :param _builtins.str secret_id: ID of the Lockbox secret where to store the sensible values.
        """
        pulumi.set(__self__, "entry_for_access_key", entry_for_access_key)
        pulumi.set(__self__, "entry_for_secret_key", entry_for_secret_key)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="entryForAccessKey")
    def entry_for_access_key(self) -> _builtins.str:
        """
        entry that will store the value of access_key
        """
        return pulumi.get(self, "entry_for_access_key")

    @_builtins.property
    @pulumi.getter(name="entryForSecretKey")
    def entry_for_secret_key(self) -> _builtins.str:
        """
        entry that will store the value of secret_key
        """
        return pulumi.get(self, "entry_for_secret_key")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        ID of the Lockbox secret where to store the sensible values.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class IotCoreBrokerLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderId":
            suggest = "folder_id"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IotCoreBrokerLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IotCoreBrokerLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IotCoreBrokerLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 log_group_id: Optional[_builtins.str] = None,
                 min_level: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Is logging for broker disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Is logging for broker disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[_builtins.str]:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class IotCoreRegistryLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderId":
            suggest = "folder_id"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IotCoreRegistryLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IotCoreRegistryLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IotCoreRegistryLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 log_group_id: Optional[_builtins.str] = None,
                 min_level: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Is logging for registry disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Is logging for registry disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[_builtins.str]:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class KubernetesClusterKmsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKmsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKmsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKmsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_id: KMS key ID.
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        KMS key ID.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class KubernetesClusterMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"
        elif key == "etcdClusterSize":
            suggest = "etcd_cluster_size"
        elif key == "externalV4Address":
            suggest = "external_v4_address"
        elif key == "externalV4Endpoint":
            suggest = "external_v4_endpoint"
        elif key == "externalV6Address":
            suggest = "external_v6_address"
        elif key == "externalV6Endpoint":
            suggest = "external_v6_endpoint"
        elif key == "internalV4Address":
            suggest = "internal_v4_address"
        elif key == "internalV4Endpoint":
            suggest = "internal_v4_endpoint"
        elif key == "maintenancePolicy":
            suggest = "maintenance_policy"
        elif key == "masterLocations":
            suggest = "master_locations"
        elif key == "masterLogging":
            suggest = "master_logging"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "scalePolicy":
            suggest = "scale_policy"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "versionInfos":
            suggest = "version_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[_builtins.str] = None,
                 etcd_cluster_size: Optional[_builtins.int] = None,
                 external_v4_address: Optional[_builtins.str] = None,
                 external_v4_endpoint: Optional[_builtins.str] = None,
                 external_v6_address: Optional[_builtins.str] = None,
                 external_v6_endpoint: Optional[_builtins.str] = None,
                 internal_v4_address: Optional[_builtins.str] = None,
                 internal_v4_endpoint: Optional[_builtins.str] = None,
                 maintenance_policy: Optional['outputs.KubernetesClusterMasterMaintenancePolicy'] = None,
                 master_locations: Optional[Sequence['outputs.KubernetesClusterMasterMasterLocation']] = None,
                 master_logging: Optional['outputs.KubernetesClusterMasterMasterLogging'] = None,
                 public_ip: Optional[_builtins.bool] = None,
                 regional: Optional['outputs.KubernetesClusterMasterRegional'] = None,
                 scale_policy: Optional['outputs.KubernetesClusterMasterScalePolicy'] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 version: Optional[_builtins.str] = None,
                 version_infos: Optional[Sequence['outputs.KubernetesClusterMasterVersionInfo']] = None,
                 zonal: Optional['outputs.KubernetesClusterMasterZonal'] = None):
        """
        :param _builtins.str cluster_ca_certificate: PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        :param _builtins.int etcd_cluster_size: Number of etcd clusters that will be used for the Kubernetes master.
        :param _builtins.str external_v4_address: An IPv4 external network address that is assigned to the master.
        :param _builtins.str external_v4_endpoint: External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param _builtins.str external_v6_address: An IPv6 external network address that is assigned to the master.
        :param _builtins.str external_v6_endpoint: External IPv6 endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param _builtins.str internal_v4_address: An IPv4 internal network address that is assigned to the master.
        :param _builtins.str internal_v4_endpoint: Internal endpoint that can be used to connect to the master from cloud networks.
        :param 'KubernetesClusterMasterMaintenancePolicyArgs' maintenance_policy: Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually.
        :param Sequence['KubernetesClusterMasterMasterLocationArgs'] master_locations: Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated in place. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend.
        :param 'KubernetesClusterMasterMasterLoggingArgs' master_logging: Master Logging options.
        :param _builtins.bool public_ip: When `true`, Kubernetes master will have visible ipv4 address.
        :param 'KubernetesClusterMasterRegionalArgs' regional: Initialize parameters for Regional Master (highly available master).
        :param 'KubernetesClusterMasterScalePolicyArgs' scale_policy: Scale policy of the master.
        :param Sequence[_builtins.str] security_group_ids: The list of security groups applied to resource or their components.
        :param _builtins.str version: Version of Kubernetes that will be used for master.
        :param Sequence['KubernetesClusterMasterVersionInfoArgs'] version_infos: Information about cluster version.
        :param 'KubernetesClusterMasterZonalArgs' zonal: Initialize parameters for Zonal Master (single node master).
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if external_v4_address is not None:
            pulumi.set(__self__, "external_v4_address", external_v4_address)
        if external_v4_endpoint is not None:
            pulumi.set(__self__, "external_v4_endpoint", external_v4_endpoint)
        if external_v6_address is not None:
            pulumi.set(__self__, "external_v6_address", external_v6_address)
        if external_v6_endpoint is not None:
            pulumi.set(__self__, "external_v6_endpoint", external_v6_endpoint)
        if internal_v4_address is not None:
            pulumi.set(__self__, "internal_v4_address", internal_v4_address)
        if internal_v4_endpoint is not None:
            pulumi.set(__self__, "internal_v4_endpoint", internal_v4_endpoint)
        if maintenance_policy is not None:
            pulumi.set(__self__, "maintenance_policy", maintenance_policy)
        if master_locations is not None:
            pulumi.set(__self__, "master_locations", master_locations)
        if master_logging is not None:
            pulumi.set(__self__, "master_logging", master_logging)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if regional is not None:
            pulumi.set(__self__, "regional", regional)
        if scale_policy is not None:
            pulumi.set(__self__, "scale_policy", scale_policy)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_infos is not None:
            pulumi.set(__self__, "version_infos", version_infos)
        if zonal is not None:
            pulumi.set(__self__, "zonal", zonal)

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[_builtins.str]:
        """
        PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[_builtins.int]:
        """
        Number of etcd clusters that will be used for the Kubernetes master.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @_builtins.property
    @pulumi.getter(name="externalV4Address")
    def external_v4_address(self) -> Optional[_builtins.str]:
        """
        An IPv4 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v4_address")

    @_builtins.property
    @pulumi.getter(name="externalV4Endpoint")
    def external_v4_endpoint(self) -> Optional[_builtins.str]:
        """
        External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v4_endpoint")

    @_builtins.property
    @pulumi.getter(name="externalV6Address")
    def external_v6_address(self) -> Optional[_builtins.str]:
        """
        An IPv6 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v6_address")

    @_builtins.property
    @pulumi.getter(name="externalV6Endpoint")
    def external_v6_endpoint(self) -> Optional[_builtins.str]:
        """
        External IPv6 endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v6_endpoint")

    @_builtins.property
    @pulumi.getter(name="internalV4Address")
    def internal_v4_address(self) -> Optional[_builtins.str]:
        """
        An IPv4 internal network address that is assigned to the master.
        """
        return pulumi.get(self, "internal_v4_address")

    @_builtins.property
    @pulumi.getter(name="internalV4Endpoint")
    def internal_v4_endpoint(self) -> Optional[_builtins.str]:
        """
        Internal endpoint that can be used to connect to the master from cloud networks.
        """
        return pulumi.get(self, "internal_v4_endpoint")

    @_builtins.property
    @pulumi.getter(name="maintenancePolicy")
    def maintenance_policy(self) -> Optional['outputs.KubernetesClusterMasterMaintenancePolicy']:
        """
        Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually.
        """
        return pulumi.get(self, "maintenance_policy")

    @_builtins.property
    @pulumi.getter(name="masterLocations")
    def master_locations(self) -> Optional[Sequence['outputs.KubernetesClusterMasterMasterLocation']]:
        """
        Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated in place. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend.
        """
        return pulumi.get(self, "master_locations")

    @_builtins.property
    @pulumi.getter(name="masterLogging")
    def master_logging(self) -> Optional['outputs.KubernetesClusterMasterMasterLogging']:
        """
        Master Logging options.
        """
        return pulumi.get(self, "master_logging")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.bool]:
        """
        When `true`, Kubernetes master will have visible ipv4 address.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def regional(self) -> Optional['outputs.KubernetesClusterMasterRegional']:
        """
        Initialize parameters for Regional Master (highly available master).
        """
        return pulumi.get(self, "regional")

    @_builtins.property
    @pulumi.getter(name="scalePolicy")
    def scale_policy(self) -> Optional['outputs.KubernetesClusterMasterScalePolicy']:
        """
        Scale policy of the master.
        """
        return pulumi.get(self, "scale_policy")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of security groups applied to resource or their components.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of Kubernetes that will be used for master.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionInfos")
    def version_infos(self) -> Optional[Sequence['outputs.KubernetesClusterMasterVersionInfo']]:
        """
        Information about cluster version.
        """
        return pulumi.get(self, "version_infos")

    @_builtins.property
    @pulumi.getter
    def zonal(self) -> Optional['outputs.KubernetesClusterMasterZonal']:
        """
        Initialize parameters for Zonal Master (single node master).
        """
        return pulumi.get(self, "zonal")


@pulumi.output_type
class KubernetesClusterMasterMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoUpgrade":
            suggest = "auto_upgrade"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_upgrade: _builtins.bool,
                 maintenance_windows: Optional[Sequence['outputs.KubernetesClusterMasterMaintenancePolicyMaintenanceWindow']] = None):
        """
        :param _builtins.bool auto_upgrade: Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        :param Sequence['KubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> _builtins.bool:
        """
        Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_upgrade")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.KubernetesClusterMasterMaintenancePolicyMaintenanceWindow']]:
        """
        This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class KubernetesClusterMasterMaintenancePolicyMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterMaintenancePolicyMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.str,
                 start_time: _builtins.str,
                 day: Optional[_builtins.str] = None):
        """
        :param _builtins.str duration: The duration of the day of week you want to update.
        :param _builtins.str start_time: The start time of the day of week you want to update.
        :param _builtins.str day: The day of the week which you want to update.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        if day is not None:
            pulumi.set(__self__, "day", day)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        The duration of the day of week you want to update.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the day of week you want to update.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        The day of the week which you want to update.
        """
        return pulumi.get(self, "day")


@pulumi.output_type
class KubernetesClusterMasterMasterLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterMasterLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterMasterLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterMasterLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet.
        :param _builtins.str zone: ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesClusterMasterMasterLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "clusterAutoscalerEnabled":
            suggest = "cluster_autoscaler_enabled"
        elif key == "eventsEnabled":
            suggest = "events_enabled"
        elif key == "folderId":
            suggest = "folder_id"
        elif key == "kubeApiserverEnabled":
            suggest = "kube_apiserver_enabled"
        elif key == "logGroupId":
            suggest = "log_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterMasterLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterMasterLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterMasterLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_enabled: Optional[_builtins.bool] = None,
                 cluster_autoscaler_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 events_enabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 kube_apiserver_enabled: Optional[_builtins.bool] = None,
                 log_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool audit_enabled: Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        :param _builtins.bool cluster_autoscaler_enabled: Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        :param _builtins.bool enabled: Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://yandex.cloud/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        :param _builtins.bool events_enabled: Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        :param _builtins.str folder_id: The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
        :param _builtins.bool kube_apiserver_enabled: Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        :param _builtins.str log_group_id: Log group where cluster stores cluster system logs, like audit, events, or control plane logs.
        """
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if cluster_autoscaler_enabled is not None:
            pulumi.set(__self__, "cluster_autoscaler_enabled", cluster_autoscaler_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if events_enabled is not None:
            pulumi.set(__self__, "events_enabled", events_enabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if kube_apiserver_enabled is not None:
            pulumi.set(__self__, "kube_apiserver_enabled", kube_apiserver_enabled)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="clusterAutoscalerEnabled")
    def cluster_autoscaler_enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "cluster_autoscaler_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://yandex.cloud/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="eventsEnabled")
    def events_enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "events_enabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="kubeApiserverEnabled")
    def kube_apiserver_enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "kube_apiserver_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log group where cluster stores cluster system logs, like audit, events, or control plane logs.
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class KubernetesClusterMasterRegional(dict):
    def __init__(__self__, *,
                 region: _builtins.str,
                 locations: Optional[Sequence['outputs.KubernetesClusterMasterRegionalLocation']] = None):
        """
        :param _builtins.str region: Name of availability region (e.g. `ru-central1`), where master instances will be allocated.
        :param Sequence['KubernetesClusterMasterRegionalLocationArgs'] locations: Array of locations, where master instances will be allocated.
        """
        pulumi.set(__self__, "region", region)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of availability region (e.g. `ru-central1`), where master instances will be allocated.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.KubernetesClusterMasterRegionalLocation']]:
        """
        Array of locations, where master instances will be allocated.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class KubernetesClusterMasterRegionalLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterRegionalLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterRegionalLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterRegionalLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet.
        :param _builtins.str zone: ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesClusterMasterScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScale":
            suggest = "auto_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scale: Optional['outputs.KubernetesClusterMasterScalePolicyAutoScale'] = None):
        """
        :param 'KubernetesClusterMasterScalePolicyAutoScaleArgs' auto_scale: Autoscaled master instance resources.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional['outputs.KubernetesClusterMasterScalePolicyAutoScale']:
        """
        Autoscaled master instance resources.
        """
        return pulumi.get(self, "auto_scale")


@pulumi.output_type
class KubernetesClusterMasterScalePolicyAutoScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minResourcePresetId":
            suggest = "min_resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterScalePolicyAutoScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterScalePolicyAutoScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterScalePolicyAutoScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_resource_preset_id: _builtins.str):
        """
        :param _builtins.str min_resource_preset_id: Minimal resource preset ID.
        """
        pulumi.set(__self__, "min_resource_preset_id", min_resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="minResourcePresetId")
    def min_resource_preset_id(self) -> _builtins.str:
        """
        Minimal resource preset ID.
        """
        return pulumi.get(self, "min_resource_preset_id")


@pulumi.output_type
class KubernetesClusterMasterVersionInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentVersion":
            suggest = "current_version"
        elif key == "newRevisionAvailable":
            suggest = "new_revision_available"
        elif key == "newRevisionSummary":
            suggest = "new_revision_summary"
        elif key == "versionDeprecated":
            suggest = "version_deprecated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterVersionInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterVersionInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterVersionInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_version: Optional[_builtins.str] = None,
                 new_revision_available: Optional[_builtins.bool] = None,
                 new_revision_summary: Optional[_builtins.str] = None,
                 version_deprecated: Optional[_builtins.bool] = None):
        """
        :param _builtins.str current_version: Current Kubernetes version, major.minor (e.g. 1.30).
        :param _builtins.bool new_revision_available: Boolean flag. Newer revisions may include Kubernetes patches (e.g `1.30.1` > `1.30.2`) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or node
        :param _builtins.str new_revision_summary: Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        :param _builtins.bool version_deprecated: Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if new_revision_available is not None:
            pulumi.set(__self__, "new_revision_available", new_revision_available)
        if new_revision_summary is not None:
            pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        if version_deprecated is not None:
            pulumi.set(__self__, "version_deprecated", version_deprecated)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[_builtins.str]:
        """
        Current Kubernetes version, major.minor (e.g. 1.30).
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> Optional[_builtins.bool]:
        """
        Boolean flag. Newer revisions may include Kubernetes patches (e.g `1.30.1` > `1.30.2`) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or node
        """
        return pulumi.get(self, "new_revision_available")

    @_builtins.property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> Optional[_builtins.str]:
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @_builtins.property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> Optional[_builtins.bool]:
        """
        Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class KubernetesClusterMasterZonal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMasterZonal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMasterZonal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMasterZonal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet. If no ID is specified, and there only one subnet in specified zone, an address in this subnet will be allocated.
        :param _builtins.str zone: ID of the availability zone.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet. If no ID is specified, and there only one subnet in specified zone, an address in this subnet will be allocated.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesClusterNetworkImplementation(dict):
    def __init__(__self__, *,
                 cilium: Optional['outputs.KubernetesClusterNetworkImplementationCilium'] = None):
        """
        :param 'KubernetesClusterNetworkImplementationCiliumArgs' cilium: Cilium network implementation configuration. No options exist.
        """
        if cilium is not None:
            pulumi.set(__self__, "cilium", cilium)

    @_builtins.property
    @pulumi.getter
    def cilium(self) -> Optional['outputs.KubernetesClusterNetworkImplementationCilium']:
        """
        Cilium network implementation configuration. No options exist.
        """
        return pulumi.get(self, "cilium")


@pulumi.output_type
class KubernetesClusterNetworkImplementationCilium(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class KubernetesClusterWorkloadIdentityFederation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jwksUri":
            suggest = "jwks_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterWorkloadIdentityFederation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterWorkloadIdentityFederation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterWorkloadIdentityFederation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 issuer: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Identifies whether Workload Identity Federation is enabled.
        :param _builtins.str issuer: Issuer URI for Kubernetes service account tokens.
        :param _builtins.str jwks_uri: JSON Web Key Set URI used to verify token signatures.
        """
        pulumi.set(__self__, "enabled", enabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Identifies whether Workload Identity Federation is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        Issuer URI for Kubernetes service account tokens.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        JSON Web Key Set URI used to verify token signatures.
        """
        return pulumi.get(self, "jwks_uri")


@pulumi.output_type
class KubernetesNodeGroupAllocationPolicy(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence['outputs.KubernetesNodeGroupAllocationPolicyLocation']] = None):
        """
        :param Sequence['KubernetesNodeGroupAllocationPolicyLocationArgs'] locations: Repeated field, that specify subnets (zones), that will be used by node group compute instances. Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.KubernetesNodeGroupAllocationPolicyLocation']]:
        """
        Repeated field, that specify subnets (zones), that will be used by node group compute instances. Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class KubernetesNodeGroupAllocationPolicyLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupAllocationPolicyLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupAllocationPolicyLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupAllocationPolicyLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet, that will be used by one compute instance in node group.
        :param _builtins.str zone: ID of the availability zone where for one compute instance in node group.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    @_utilities.deprecated("""The 'subnet_id' field has been deprecated. Please use 'subnet_ids under network_interface' instead.""")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet, that will be used by one compute instance in node group.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        ID of the availability zone where for one compute instance in node group.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class KubernetesNodeGroupDeployPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExpansion":
            suggest = "max_expansion"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupDeployPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupDeployPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupDeployPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_expansion: _builtins.int,
                 max_unavailable: _builtins.int):
        """
        :param _builtins.int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        :param _builtins.int max_unavailable: The maximum number of running instances that can be taken offline during update.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> _builtins.int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        """
        return pulumi.get(self, "max_expansion")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> _builtins.int:
        """
        The maximum number of running instances that can be taken offline during update.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "containerNetwork":
            suggest = "container_network"
        elif key == "containerRuntime":
            suggest = "container_runtime"
        elif key == "gpuSettings":
            suggest = "gpu_settings"
        elif key == "networkAccelerationType":
            suggest = "network_acceleration_type"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "placementPolicy":
            suggest = "placement_policy"
        elif key == "platformId":
            suggest = "platform_id"
        elif key == "schedulingPolicy":
            suggest = "scheduling_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk: Optional['outputs.KubernetesNodeGroupInstanceTemplateBootDisk'] = None,
                 container_network: Optional['outputs.KubernetesNodeGroupInstanceTemplateContainerNetwork'] = None,
                 container_runtime: Optional['outputs.KubernetesNodeGroupInstanceTemplateContainerRuntime'] = None,
                 gpu_settings: Optional['outputs.KubernetesNodeGroupInstanceTemplateGpuSettings'] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 nat: Optional[_builtins.bool] = None,
                 network_acceleration_type: Optional[_builtins.str] = None,
                 network_interfaces: Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterface']] = None,
                 placement_policy: Optional['outputs.KubernetesNodeGroupInstanceTemplatePlacementPolicy'] = None,
                 platform_id: Optional[_builtins.str] = None,
                 resources: Optional['outputs.KubernetesNodeGroupInstanceTemplateResources'] = None,
                 scheduling_policy: Optional['outputs.KubernetesNodeGroupInstanceTemplateSchedulingPolicy'] = None):
        """
        :param 'KubernetesNodeGroupInstanceTemplateBootDiskArgs' boot_disk: The specifications for boot disks that will be attached to the instance.
        :param 'KubernetesNodeGroupInstanceTemplateContainerNetworkArgs' container_network: Container network configuration.
        :param 'KubernetesNodeGroupInstanceTemplateContainerRuntimeArgs' container_runtime: Container runtime configuration.
        :param 'KubernetesNodeGroupInstanceTemplateGpuSettingsArgs' gpu_settings: GPU settings.
        :param Mapping[str, _builtins.str] labels: Labels that will be assigned to compute nodes (instances), created by the Node Group.
        :param Mapping[str, _builtins.str] metadata: The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key `user-data` won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.
        :param _builtins.str name: Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
               * `{instance.short_id}
               * `{instance.index}`
               * combination of `{instance.zone_id}` and `{instance.index_in_zone}`
               
               Example: `my-instance-{instance.index}`.
               If not set, default is used: `{instance_group.id}-{instance.short_id}`. It may also contain another placeholders, see [Compute Instance group metadata doc](https://yandex.cloud/docs/compute/instancegroup/api-ref/grpc/InstanceGroup) for full list.
        :param _builtins.bool nat: Enables NAT for node group compute instances.
        :param _builtins.str network_acceleration_type: Type of network acceleration. Values: `standard`, `software_accelerated`.
        :param Sequence['KubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces that will be attached to the instance.
        :param 'KubernetesNodeGroupInstanceTemplatePlacementPolicyArgs' placement_policy: The placement policy configuration.
        :param _builtins.str platform_id: The ID of the hardware platform configuration for the node group compute instances.
        :param 'KubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs' scheduling_policy: The scheduling policy for the instances in node group.
        """
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if container_network is not None:
            pulumi.set(__self__, "container_network", container_network)
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if gpu_settings is not None:
            pulumi.set(__self__, "gpu_settings", gpu_settings)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if network_acceleration_type is not None:
            pulumi.set(__self__, "network_acceleration_type", network_acceleration_type)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)

    @_builtins.property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateBootDisk']:
        """
        The specifications for boot disks that will be attached to the instance.
        """
        return pulumi.get(self, "boot_disk")

    @_builtins.property
    @pulumi.getter(name="containerNetwork")
    def container_network(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateContainerNetwork']:
        """
        Container network configuration.
        """
        return pulumi.get(self, "container_network")

    @_builtins.property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateContainerRuntime']:
        """
        Container runtime configuration.
        """
        return pulumi.get(self, "container_runtime")

    @_builtins.property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateGpuSettings']:
        """
        GPU settings.
        """
        return pulumi.get(self, "gpu_settings")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels that will be assigned to compute nodes (instances), created by the Node Group.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key `user-data` won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
        * `{instance.short_id}
        * `{instance.index}`
        * combination of `{instance.zone_id}` and `{instance.index_in_zone}`

        Example: `my-instance-{instance.index}`.
        If not set, default is used: `{instance_group.id}-{instance.short_id}`. It may also contain another placeholders, see [Compute Instance group metadata doc](https://yandex.cloud/docs/compute/instancegroup/api-ref/grpc/InstanceGroup) for full list.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'nat' field has been deprecated. Please use 'nat under network_interface' instead.""")
    def nat(self) -> Optional[_builtins.bool]:
        """
        Enables NAT for node group compute instances.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="networkAccelerationType")
    def network_acceleration_type(self) -> Optional[_builtins.str]:
        """
        Type of network acceleration. Values: `standard`, `software_accelerated`.
        """
        return pulumi.get(self, "network_acceleration_type")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterface']]:
        """
        An array with the network interfaces that will be attached to the instance.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplatePlacementPolicy']:
        """
        The placement policy configuration.
        """
        return pulumi.get(self, "placement_policy")

    @_builtins.property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[_builtins.str]:
        """
        The ID of the hardware platform configuration for the node group compute instances.
        """
        return pulumi.get(self, "platform_id")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateResources']:
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional['outputs.KubernetesNodeGroupInstanceTemplateSchedulingPolicy']:
        """
        The scheduling policy for the instances in node group.
        """
        return pulumi.get(self, "scheduling_policy")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateBootDisk(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int size: The size of the disk in GB. Allowed minimal size: 64 GB.
        :param _builtins.str type: The disk type.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in GB. Allowed minimal size: 64 GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateContainerNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podMtu":
            suggest = "pod_mtu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateContainerNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateContainerNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateContainerNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_mtu: Optional[_builtins.int] = None):
        """
        :param _builtins.int pod_mtu: MTU for pods.
        """
        if pod_mtu is not None:
            pulumi.set(__self__, "pod_mtu", pod_mtu)

    @_builtins.property
    @pulumi.getter(name="podMtu")
    def pod_mtu(self) -> Optional[_builtins.int]:
        """
        MTU for pods.
        """
        return pulumi.get(self, "pod_mtu")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateContainerRuntime(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Type of container runtime. Values: `docker`, `containerd`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateGpuSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuClusterId":
            suggest = "gpu_cluster_id"
        elif key == "gpuEnvironment":
            suggest = "gpu_environment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateGpuSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateGpuSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateGpuSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gpu_cluster_id: Optional[_builtins.str] = None,
                 gpu_environment: Optional[_builtins.str] = None):
        """
        :param _builtins.str gpu_cluster_id: GPU cluster id.
        :param _builtins.str gpu_environment: GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
        if gpu_cluster_id is not None:
            pulumi.set(__self__, "gpu_cluster_id", gpu_cluster_id)
        if gpu_environment is not None:
            pulumi.set(__self__, "gpu_environment", gpu_environment)

    @_builtins.property
    @pulumi.getter(name="gpuClusterId")
    def gpu_cluster_id(self) -> Optional[_builtins.str]:
        """
        GPU cluster id.
        """
        return pulumi.get(self, "gpu_cluster_id")

    @_builtins.property
    @pulumi.getter(name="gpuEnvironment")
    def gpu_environment(self) -> Optional[_builtins.str]:
        """
        GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
        return pulumi.get(self, "gpu_environment")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "ipv4DnsRecords":
            suggest = "ipv4_dns_records"
        elif key == "ipv6DnsRecords":
            suggest = "ipv6_dns_records"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_ids: Sequence[_builtins.str],
                 ipv4: Optional[_builtins.bool] = None,
                 ipv4_dns_records: Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord']] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 ipv6_dns_records: Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord']] = None,
                 nat: Optional[_builtins.bool] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] subnet_ids: The IDs of the subnets.
        :param _builtins.bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param Sequence['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs'] ipv4_dns_records: List of configurations for creating ipv4 DNS records.
        :param _builtins.bool ipv6: If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param Sequence['KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of configurations for creating ipv6 DNS records.
        :param _builtins.bool nat: A public address that can be used to access the internet over NAT.
        :param Sequence[_builtins.str] security_group_ids: Security group IDs for network interface.
        """
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv4_dns_records is not None:
            pulumi.set(__self__, "ipv4_dns_records", ipv4_dns_records)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_dns_records is not None:
            pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.bool]:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter(name="ipv4DnsRecords")
    def ipv4_dns_records(self) -> Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord']]:
        """
        List of configurations for creating ipv4 DNS records.
        """
        return pulumi.get(self, "ipv4_dns_records")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Optional[Sequence['outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord']]:
        """
        List of configurations for creating ipv6 DNS records.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[_builtins.bool]:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security group IDs for network interface.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN.
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL (in seconds).
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL (in seconds).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 dns_zone_id: Optional[_builtins.str] = None,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: DNS record FQDN.
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL (in seconds).
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if dns_zone_id is not None:
            pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> Optional[_builtins.str]:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        DNS record TTL (in seconds).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplatePlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplatePlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplatePlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: _builtins.str):
        """
        :param _builtins.str placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> _builtins.str:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupInstanceTemplateResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupInstanceTemplateResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupInstanceTemplateResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_fraction: Optional[_builtins.int] = None,
                 cores: Optional[_builtins.int] = None,
                 gpus: Optional[_builtins.int] = None,
                 memory: Optional[_builtins.float] = None):
        """
        :param _builtins.int core_fraction: Baseline core performance as a percent.
        :param _builtins.int cores: Number of CPU cores allocated to the instance.
        :param _builtins.int gpus: Number of GPU cores allocated to the instance.
        :param _builtins.float memory: The memory size allocated to the instance.
        """
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[_builtins.int]:
        """
        Baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> Optional[_builtins.int]:
        """
        Number of CPU cores allocated to the instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> Optional[_builtins.int]:
        """
        Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "gpus")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.float]:
        """
        The memory size allocated to the instance.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class KubernetesNodeGroupInstanceTemplateSchedulingPolicy(dict):
    def __init__(__self__, *,
                 preemptible: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool preemptible: Specifies if the instance is preemptible. Defaults to `false`.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance is preemptible. Defaults to `false`.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class KubernetesNodeGroupMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRepair":
            suggest = "auto_repair"
        elif key == "autoUpgrade":
            suggest = "auto_upgrade"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_repair: _builtins.bool,
                 auto_upgrade: _builtins.bool,
                 maintenance_windows: Optional[Sequence['outputs.KubernetesNodeGroupMaintenancePolicyMaintenanceWindow']] = None):
        """
        :param _builtins.bool auto_repair: Flag that specifies if node group can be repaired automatically. When omitted, default value is `true`.
        :param _builtins.bool auto_upgrade: Flag specifies if node group can be upgraded automatically. When omitted, default value is `true`.
        :param Sequence['KubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
               
               To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.
               
               To allow maintenance only on specific days of week, please provide list of elements, with all fields set. Only one time interval is allowed for each day of week. Please see `my_node_group` config example.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> _builtins.bool:
        """
        Flag that specifies if node group can be repaired automatically. When omitted, default value is `true`.
        """
        return pulumi.get(self, "auto_repair")

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> _builtins.bool:
        """
        Flag specifies if node group can be upgraded automatically. When omitted, default value is `true`.
        """
        return pulumi.get(self, "auto_upgrade")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.KubernetesNodeGroupMaintenancePolicyMaintenanceWindow']]:
        """
        Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.

        To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`.

        To allow maintenance only on specific days of week, please provide list of elements, with all fields set. Only one time interval is allowed for each day of week. Please see `my_node_group` config example.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class KubernetesNodeGroupMaintenancePolicyMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupMaintenancePolicyMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupMaintenancePolicyMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.str,
                 start_time: _builtins.str,
                 day: Optional[_builtins.str] = None):
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)
        if day is not None:
            pulumi.set(__self__, "day", day)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "day")


@pulumi.output_type
class KubernetesNodeGroupScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScale":
            suggest = "auto_scale"
        elif key == "fixedScale":
            suggest = "fixed_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scale: Optional['outputs.KubernetesNodeGroupScalePolicyAutoScale'] = None,
                 fixed_scale: Optional['outputs.KubernetesNodeGroupScalePolicyFixedScale'] = None):
        """
        :param 'KubernetesNodeGroupScalePolicyAutoScaleArgs' auto_scale: Scale policy for an autoscaled node group.
        :param 'KubernetesNodeGroupScalePolicyFixedScaleArgs' fixed_scale: Scale policy for a fixed scale node group.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional['outputs.KubernetesNodeGroupScalePolicyAutoScale']:
        """
        Scale policy for an autoscaled node group.
        """
        return pulumi.get(self, "auto_scale")

    @_builtins.property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional['outputs.KubernetesNodeGroupScalePolicyFixedScale']:
        """
        Scale policy for a fixed scale node group.
        """
        return pulumi.get(self, "fixed_scale")


@pulumi.output_type
class KubernetesNodeGroupScalePolicyAutoScale(dict):
    def __init__(__self__, *,
                 initial: _builtins.int,
                 max: _builtins.int,
                 min: _builtins.int):
        """
        :param _builtins.int initial: Initial number of instances in the node group.
        :param _builtins.int max: Maximum number of instances in the node group.
        :param _builtins.int min: Minimum number of instances in the node group.
        """
        pulumi.set(__self__, "initial", initial)
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def initial(self) -> _builtins.int:
        """
        Initial number of instances in the node group.
        """
        return pulumi.get(self, "initial")

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        """
        Maximum number of instances in the node group.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        Minimum number of instances in the node group.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class KubernetesNodeGroupScalePolicyFixedScale(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.int size: The number of instances in the node group.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class KubernetesNodeGroupVersionInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentVersion":
            suggest = "current_version"
        elif key == "newRevisionAvailable":
            suggest = "new_revision_available"
        elif key == "newRevisionSummary":
            suggest = "new_revision_summary"
        elif key == "versionDeprecated":
            suggest = "version_deprecated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodeGroupVersionInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodeGroupVersionInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodeGroupVersionInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_version: Optional[_builtins.str] = None,
                 new_revision_available: Optional[_builtins.bool] = None,
                 new_revision_summary: Optional[_builtins.str] = None,
                 version_deprecated: Optional[_builtins.bool] = None):
        """
        :param _builtins.str current_version: Current Kubernetes version, major.minor (e.g. `1.30`).
        :param _builtins.bool new_revision_available: True/false flag. Newer revisions may include Kubernetes patches (e.g `1.30.1` > `1.30.2`) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        :param _builtins.str new_revision_summary: Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        :param _builtins.bool version_deprecated: True/false flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if new_revision_available is not None:
            pulumi.set(__self__, "new_revision_available", new_revision_available)
        if new_revision_summary is not None:
            pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        if version_deprecated is not None:
            pulumi.set(__self__, "version_deprecated", version_deprecated)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[_builtins.str]:
        """
        Current Kubernetes version, major.minor (e.g. `1.30`).
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> Optional[_builtins.bool]:
        """
        True/false flag. Newer revisions may include Kubernetes patches (e.g `1.30.1` > `1.30.2`) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or nodes.
        """
        return pulumi.get(self, "new_revision_available")

    @_builtins.property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> Optional[_builtins.str]:
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @_builtins.property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> Optional[_builtins.bool]:
        """
        True/false flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupId":
            suggest = "target_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerAttachedTargetGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthchecks: Sequence['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheck'],
                 target_group_id: _builtins.str):
        """
        :param Sequence['LbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs'] healthchecks: A HealthCheck resource.
        :param _builtins.str target_group_id: ID of the target group.
        """
        pulumi.set(__self__, "healthchecks", healthchecks)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @_builtins.property
    @pulumi.getter
    def healthchecks(self) -> Sequence['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheck']:
        """
        A HealthCheck resource.
        """
        return pulumi.get(self, "healthchecks")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> _builtins.str:
        """
        ID of the target group.
        """
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpOptions":
            suggest = "http_options"
        elif key == "tcpOptions":
            suggest = "tcp_options"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerAttachedTargetGroupHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroupHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerAttachedTargetGroupHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 healthy_threshold: Optional[_builtins.int] = None,
                 http_options: Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions'] = None,
                 interval: Optional[_builtins.int] = None,
                 tcp_options: Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions'] = None,
                 timeout: Optional[_builtins.int] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        :param _builtins.int healthy_threshold: Number of successful health checks required in order to set the `HEALTHY` status for the target.
        :param 'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionsArgs' http_options: Options for HTTP health check.
        :param _builtins.int interval: The interval between health checks. The default is 2 seconds.
        :param 'LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionsArgs' tcp_options: Options for TCP health check.
        :param _builtins.int timeout: Timeout for a target to return a response for the health check. The default is 1 second.
        :param _builtins.int unhealthy_threshold: Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        pulumi.set(__self__, "name", name)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of successful health checks required in order to set the `HEALTHY` status for the target.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions']:
        """
        Options for HTTP health check.
        """
        return pulumi.get(self, "http_options")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.int]:
        """
        The interval between health checks. The default is 2 seconds.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional['outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions']:
        """
        Options for TCP health check.
        """
        return pulumi.get(self, "tcp_options")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Timeout for a target to return a response for the health check. The default is 1 second.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions(dict):
    def __init__(__self__, *,
                 port: _builtins.int,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: Port to use for HTTP health checks.
        :param _builtins.str path: URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        pulumi.set(__self__, "port", port)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port to use for HTTP health checks.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions(dict):
    def __init__(__self__, *,
                 port: _builtins.int):
        """
        :param _builtins.int port: Port to use for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port to use for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class LbNetworkLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalAddressSpec":
            suggest = "external_address_spec"
        elif key == "internalAddressSpec":
            suggest = "internal_address_spec"
        elif key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 port: _builtins.int,
                 external_address_spec: Optional['outputs.LbNetworkLoadBalancerListenerExternalAddressSpec'] = None,
                 internal_address_spec: Optional['outputs.LbNetworkLoadBalancerListenerInternalAddressSpec'] = None,
                 protocol: Optional[_builtins.str] = None,
                 target_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of the listener. The name must be unique for each listener on a single load balancer.
        :param _builtins.int port: Port for incoming traffic.
        :param 'LbNetworkLoadBalancerListenerExternalAddressSpecArgs' external_address_spec: External IP address specification.
        :param 'LbNetworkLoadBalancerListenerInternalAddressSpecArgs' internal_address_spec: Internal IP address specification.
        :param _builtins.str protocol: Protocol for incoming traffic. TCP or UDP and the default is TCP.
        :param _builtins.int target_port: Port of a target. The default is the same as listener's port.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if external_address_spec is not None:
            pulumi.set(__self__, "external_address_spec", external_address_spec)
        if internal_address_spec is not None:
            pulumi.set(__self__, "internal_address_spec", internal_address_spec)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the listener. The name must be unique for each listener on a single load balancer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="externalAddressSpec")
    def external_address_spec(self) -> Optional['outputs.LbNetworkLoadBalancerListenerExternalAddressSpec']:
        """
        External IP address specification.
        """
        return pulumi.get(self, "external_address_spec")

    @_builtins.property
    @pulumi.getter(name="internalAddressSpec")
    def internal_address_spec(self) -> Optional['outputs.LbNetworkLoadBalancerListenerInternalAddressSpec']:
        """
        Internal IP address specification.
        """
        return pulumi.get(self, "internal_address_spec")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol for incoming traffic. TCP or UDP and the default is TCP.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        Port of a target. The default is the same as listener's port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class LbNetworkLoadBalancerListenerExternalAddressSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipVersion":
            suggest = "ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerListenerExternalAddressSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerListenerExternalAddressSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerListenerExternalAddressSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 ip_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: External IP address for a listener. IP address will be allocated if it wasn't been set.
        :param _builtins.str ip_version: IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        External IP address for a listener. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[_builtins.str]:
        """
        IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class LbNetworkLoadBalancerListenerInternalAddressSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ipVersion":
            suggest = "ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbNetworkLoadBalancerListenerInternalAddressSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbNetworkLoadBalancerListenerInternalAddressSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbNetworkLoadBalancerListenerInternalAddressSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 ip_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: ID of the subnet to which the internal IP address belongs.
        :param _builtins.str address: Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        :param _builtins.str ip_version: IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet to which the internal IP address belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[_builtins.str]:
        """
        IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class LbTargetGroupTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbTargetGroupTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbTargetGroupTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbTargetGroupTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str address: IP address of the target.
        :param _builtins.str subnet_id: ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IP address of the target.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LoadtestingAgentComputeInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "computedLabels":
            suggest = "computed_labels"
        elif key == "computedMetadata":
            suggest = "computed_metadata"
        elif key == "platformId":
            suggest = "platform_id"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadtestingAgentComputeInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadtestingAgentComputeInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadtestingAgentComputeInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_disk: 'outputs.LoadtestingAgentComputeInstanceBootDisk',
                 network_interfaces: Sequence['outputs.LoadtestingAgentComputeInstanceNetworkInterface'],
                 resources: 'outputs.LoadtestingAgentComputeInstanceResources',
                 service_account_id: _builtins.str,
                 computed_labels: Optional[Mapping[str, _builtins.str]] = None,
                 computed_metadata: Optional[Mapping[str, _builtins.str]] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 platform_id: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param 'LoadtestingAgentComputeInstanceBootDiskArgs' boot_disk: Boot disk specifications for the instance.
        :param Sequence['LoadtestingAgentComputeInstanceNetworkInterfaceArgs'] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        :param 'LoadtestingAgentComputeInstanceResourcesArgs' resources: Compute resource specifications for the instance.
        :param _builtins.str service_account_id: The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        :param Mapping[str, _builtins.str] computed_labels: The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        :param Mapping[str, _builtins.str] computed_metadata: The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs to assign to the instance.
        :param Mapping[str, _builtins.str] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param _builtins.str platform_id: The Compute platform for virtual machine.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if computed_labels is not None:
            pulumi.set(__self__, "computed_labels", computed_labels)
        if computed_metadata is not None:
            pulumi.set(__self__, "computed_metadata", computed_metadata)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if platform_id is not None:
            pulumi.set(__self__, "platform_id", platform_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.LoadtestingAgentComputeInstanceBootDisk':
        """
        Boot disk specifications for the instance.
        """
        return pulumi.get(self, "boot_disk")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.LoadtestingAgentComputeInstanceNetworkInterface']:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.LoadtestingAgentComputeInstanceResources':
        """
        Compute resource specifications for the instance.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="computedLabels")
    def computed_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        """
        return pulumi.get(self, "computed_labels")

    @_builtins.property
    @pulumi.getter(name="computedMetadata")
    def computed_metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        """
        return pulumi.get(self, "computed_metadata")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> Optional[_builtins.str]:
        """
        The Compute platform for virtual machine.
        """
        return pulumi.get(self, "platform_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class LoadtestingAgentComputeInstanceBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initializeParams":
            suggest = "initialize_params"
        elif key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "diskId":
            suggest = "disk_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadtestingAgentComputeInstanceBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadtestingAgentComputeInstanceBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadtestingAgentComputeInstanceBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initialize_params: 'outputs.LoadtestingAgentComputeInstanceBootDiskInitializeParams',
                 auto_delete: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 disk_id: Optional[_builtins.str] = None):
        """
        :param 'LoadtestingAgentComputeInstanceBootDiskInitializeParamsArgs' initialize_params: Parameters for creating a disk alongside the instance.
        :param _builtins.bool auto_delete: Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        :param _builtins.str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: The ID of created disk.
        """
        pulumi.set(__self__, "initialize_params", initialize_params)
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> 'outputs.LoadtestingAgentComputeInstanceBootDiskInitializeParams':
        """
        Parameters for creating a disk alongside the instance.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[_builtins.str]:
        """
        The ID of created disk.
        """
        return pulumi.get(self, "disk_id")


@pulumi.output_type
class LoadtestingAgentComputeInstanceBootDiskInitializeParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSize":
            suggest = "block_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadtestingAgentComputeInstanceBootDiskInitializeParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadtestingAgentComputeInstanceBootDiskInitializeParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadtestingAgentComputeInstanceBootDiskInitializeParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int block_size: Block size of the disk, specified in bytes.
        :param _builtins.str description: A description of the boot disk.
        :param _builtins.str name: A name of the boot disk.
        :param _builtins.int size: The size of the disk in GB. Defaults to 15 GB.
        :param _builtins.str type: The disk type.
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[_builtins.int]:
        """
        Block size of the disk, specified in bytes.
        """
        return pulumi.get(self, "block_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A name of the boot disk.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The size of the disk in GB. Defaults to 15 GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LoadtestingAgentComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "natIpAddress":
            suggest = "nat_ip_address"
        elif key == "natIpVersion":
            suggest = "nat_ip_version"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadtestingAgentComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadtestingAgentComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadtestingAgentComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 index: Optional[_builtins.int] = None,
                 ip_address: Optional[_builtins.str] = None,
                 ipv4: Optional[_builtins.bool] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 ipv6_address: Optional[_builtins.str] = None,
                 mac_address: Optional[_builtins.str] = None,
                 nat: Optional[_builtins.bool] = None,
                 nat_ip_address: Optional[_builtins.str] = None,
                 nat_ip_version: Optional[_builtins.str] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        :param _builtins.str ip_address: Manual set static IP address.
        :param _builtins.bool ipv4: Flag for allocating IPv4 address for the network interface.
        :param _builtins.bool ipv6: Flag for allocating IPv6 address for the network interface.
        :param _builtins.str ipv6_address: Manual set static IPv6 address.
        :param _builtins.bool nat: Flag for using NAT.
        :param _builtins.str nat_ip_address: A public address that can be used to access the internet over NAT.
        :param Sequence[_builtins.str] security_group_ids: Security group ids for network interface.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)
        if nat_ip_address is not None:
            pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        if nat_ip_version is not None:
            pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.bool]:
        """
        Flag for allocating IPv4 address for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        Flag for allocating IPv6 address for the network interface.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[_builtins.bool]:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> Optional[_builtins.str]:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nat_ip_version")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class LoadtestingAgentComputeInstanceResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreFraction":
            suggest = "core_fraction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadtestingAgentComputeInstanceResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadtestingAgentComputeInstanceResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadtestingAgentComputeInstanceResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_fraction: Optional[_builtins.int] = None,
                 cores: Optional[_builtins.int] = None,
                 memory: Optional[_builtins.float] = None):
        """
        :param _builtins.int core_fraction: If provided, specifies baseline core performance as a percent.
        :param _builtins.int cores: The number of CPU cores for the instance. Defaults to 2 cores.
        :param _builtins.float memory: The memory size in GB. Defaults to 2 GB.
        """
        if core_fraction is not None:
            pulumi.set(__self__, "core_fraction", core_fraction)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> Optional[_builtins.int]:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> Optional[_builtins.int]:
        """
        The number of CPU cores for the instance. Defaults to 2 cores.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.float]:
        """
        The memory size in GB. Defaults to 2 GB.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class LoadtestingAgentLogSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupId":
            suggest = "log_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadtestingAgentLogSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadtestingAgentLogSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadtestingAgentLogSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_group_id: The ID of cloud logging group to which the load testing agent sends logs.
        """
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of cloud logging group to which the load testing agent sends logs.
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class LockboxSecretPasswordPayloadSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordKey":
            suggest = "password_key"
        elif key == "excludedPunctuation":
            suggest = "excluded_punctuation"
        elif key == "includeDigits":
            suggest = "include_digits"
        elif key == "includeLowercase":
            suggest = "include_lowercase"
        elif key == "includePunctuation":
            suggest = "include_punctuation"
        elif key == "includeUppercase":
            suggest = "include_uppercase"
        elif key == "includedPunctuation":
            suggest = "included_punctuation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LockboxSecretPasswordPayloadSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LockboxSecretPasswordPayloadSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LockboxSecretPasswordPayloadSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_key: _builtins.str,
                 excluded_punctuation: Optional[_builtins.str] = None,
                 include_digits: Optional[_builtins.bool] = None,
                 include_lowercase: Optional[_builtins.bool] = None,
                 include_punctuation: Optional[_builtins.bool] = None,
                 include_uppercase: Optional[_builtins.bool] = None,
                 included_punctuation: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None):
        """
        :param _builtins.str password_key: The key with which the generated password will be placed in the secret version.
        :param _builtins.str excluded_punctuation: String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        :param _builtins.bool include_digits: Use digits in the generated password. Default is true.
        :param _builtins.bool include_lowercase: Use lowercase letters in the generated password. Default is true.
        :param _builtins.bool include_punctuation: Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        :param _builtins.bool include_uppercase: Use capital letters in the generated password. Default is true.
        :param _builtins.str included_punctuation: String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        :param _builtins.int length: Length of generated password. Default is `36`.
        """
        pulumi.set(__self__, "password_key", password_key)
        if excluded_punctuation is not None:
            pulumi.set(__self__, "excluded_punctuation", excluded_punctuation)
        if include_digits is not None:
            pulumi.set(__self__, "include_digits", include_digits)
        if include_lowercase is not None:
            pulumi.set(__self__, "include_lowercase", include_lowercase)
        if include_punctuation is not None:
            pulumi.set(__self__, "include_punctuation", include_punctuation)
        if include_uppercase is not None:
            pulumi.set(__self__, "include_uppercase", include_uppercase)
        if included_punctuation is not None:
            pulumi.set(__self__, "included_punctuation", included_punctuation)
        if length is not None:
            pulumi.set(__self__, "length", length)

    @_builtins.property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> _builtins.str:
        """
        The key with which the generated password will be placed in the secret version.
        """
        return pulumi.get(self, "password_key")

    @_builtins.property
    @pulumi.getter(name="excludedPunctuation")
    def excluded_punctuation(self) -> Optional[_builtins.str]:
        """
        String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        """
        return pulumi.get(self, "excluded_punctuation")

    @_builtins.property
    @pulumi.getter(name="includeDigits")
    def include_digits(self) -> Optional[_builtins.bool]:
        """
        Use digits in the generated password. Default is true.
        """
        return pulumi.get(self, "include_digits")

    @_builtins.property
    @pulumi.getter(name="includeLowercase")
    def include_lowercase(self) -> Optional[_builtins.bool]:
        """
        Use lowercase letters in the generated password. Default is true.
        """
        return pulumi.get(self, "include_lowercase")

    @_builtins.property
    @pulumi.getter(name="includePunctuation")
    def include_punctuation(self) -> Optional[_builtins.bool]:
        """
        Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        """
        return pulumi.get(self, "include_punctuation")

    @_builtins.property
    @pulumi.getter(name="includeUppercase")
    def include_uppercase(self) -> Optional[_builtins.bool]:
        """
        Use capital letters in the generated password. Default is true.
        """
        return pulumi.get(self, "include_uppercase")

    @_builtins.property
    @pulumi.getter(name="includedPunctuation")
    def included_punctuation(self) -> Optional[_builtins.str]:
        """
        String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        """
        return pulumi.get(self, "included_punctuation")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        Length of generated password. Default is `36`.
        """
        return pulumi.get(self, "length")


@pulumi.output_type
class LockboxSecretVersionEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textValue":
            suggest = "text_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LockboxSecretVersionEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LockboxSecretVersionEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LockboxSecretVersionEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 command: Optional['outputs.LockboxSecretVersionEntryCommand'] = None,
                 text_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the entry.
        :param 'LockboxSecretVersionEntryCommandArgs' command: The command that generates the text value of the entry.
        :param _builtins.str text_value: The text value of the entry.
        """
        pulumi.set(__self__, "key", key)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the entry.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional['outputs.LockboxSecretVersionEntryCommand']:
        """
        The command that generates the text value of the entry.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[_builtins.str]:
        """
        The text value of the entry.
        """
        return pulumi.get(self, "text_value")


@pulumi.output_type
class LockboxSecretVersionEntryCommand(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 args: Optional[Sequence[_builtins.str]] = None,
                 env: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str path: The path to the script or command to execute.
        :param Sequence[_builtins.str] args: List of arguments to be passed to the script/command.
        :param Mapping[str, _builtins.str] env: Map of environment variables to set before calling the script/command.
        """
        pulumi.set(__self__, "path", path)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if env is not None:
            pulumi.set(__self__, "env", env)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to the script or command to execute.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of arguments to be passed to the script/command.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of environment variables to set before calling the script/command.
        """
        return pulumi.get(self, "env")


@pulumi.output_type
class MdbClickhouseClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "dataTransfer":
            suggest = "data_transfer"
        elif key == "webSql":
            suggest = "web_sql"
        elif key == "yandexQuery":
            suggest = "yandex_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 metrika: Optional[_builtins.bool] = None,
                 serverless: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None,
                 yandex_query: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for DataLens.
        :param _builtins.bool data_transfer: Allow access for DataTransfer.
        :param _builtins.bool metrika: Allow access for Yandex.Metrika.
        :param _builtins.bool serverless: Allow access for Serverless.
        :param _builtins.bool web_sql: Allow access for Web SQL.
        :param _builtins.bool yandex_query: Allow access for YandexQuery.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if metrika is not None:
            pulumi.set(__self__, "metrika", metrika)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)
        if yandex_query is not None:
            pulumi.set(__self__, "yandex_query", yandex_query)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for DataLens.
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for DataTransfer.
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter
    def metrika(self) -> Optional[_builtins.bool]:
        """
        Allow access for Yandex.Metrika.
        """
        return pulumi.get(self, "metrika")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> Optional[_builtins.bool]:
        """
        Allow access for Serverless.
        """
        return pulumi.get(self, "serverless")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allow access for Web SQL.
        """
        return pulumi.get(self, "web_sql")

    @_builtins.property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> Optional[_builtins.bool]:
        """
        Allow access for YandexQuery.
        """
        return pulumi.get(self, "yandex_query")


@pulumi.output_type
class MdbClickhouseClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbClickhouseClusterClickhouse(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.MdbClickhouseClusterClickhouseConfig'] = None,
                 resources: Optional['outputs.MdbClickhouseClusterClickhouseResources'] = None):
        """
        :param 'MdbClickhouseClusterClickhouseConfigArgs' config: ClickHouse server parameters. For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/settings-list).
        :param 'MdbClickhouseClusterClickhouseResourcesArgs' resources: Resources allocated to hosts of the ClickHouse subcluster.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfig']:
        """
        ClickHouse server parameters. For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/settings-list).
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbClickhouseClusterClickhouseResources']:
        """
        Resources allocated to hosts of the ClickHouse subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "asynchronousInsertLogEnabled":
            suggest = "asynchronous_insert_log_enabled"
        elif key == "asynchronousInsertLogRetentionSize":
            suggest = "asynchronous_insert_log_retention_size"
        elif key == "asynchronousInsertLogRetentionTime":
            suggest = "asynchronous_insert_log_retention_time"
        elif key == "asynchronousMetricLogEnabled":
            suggest = "asynchronous_metric_log_enabled"
        elif key == "asynchronousMetricLogRetentionSize":
            suggest = "asynchronous_metric_log_retention_size"
        elif key == "asynchronousMetricLogRetentionTime":
            suggest = "asynchronous_metric_log_retention_time"
        elif key == "backgroundBufferFlushSchedulePoolSize":
            suggest = "background_buffer_flush_schedule_pool_size"
        elif key == "backgroundCommonPoolSize":
            suggest = "background_common_pool_size"
        elif key == "backgroundDistributedSchedulePoolSize":
            suggest = "background_distributed_schedule_pool_size"
        elif key == "backgroundFetchesPoolSize":
            suggest = "background_fetches_pool_size"
        elif key == "backgroundMergesMutationsConcurrencyRatio":
            suggest = "background_merges_mutations_concurrency_ratio"
        elif key == "backgroundMessageBrokerSchedulePoolSize":
            suggest = "background_message_broker_schedule_pool_size"
        elif key == "backgroundMovePoolSize":
            suggest = "background_move_pool_size"
        elif key == "backgroundPoolSize":
            suggest = "background_pool_size"
        elif key == "backgroundSchedulePoolSize":
            suggest = "background_schedule_pool_size"
        elif key == "defaultDatabase":
            suggest = "default_database"
        elif key == "dictionariesLazyLoad":
            suggest = "dictionaries_lazy_load"
        elif key == "geobaseEnabled":
            suggest = "geobase_enabled"
        elif key == "geobaseUri":
            suggest = "geobase_uri"
        elif key == "graphiteRollups":
            suggest = "graphite_rollups"
        elif key == "jdbcBridge":
            suggest = "jdbc_bridge"
        elif key == "kafkaTopics":
            suggest = "kafka_topics"
        elif key == "keepAliveTimeout":
            suggest = "keep_alive_timeout"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "markCacheSize":
            suggest = "mark_cache_size"
        elif key == "maxConcurrentQueries":
            suggest = "max_concurrent_queries"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPartitionSizeToDrop":
            suggest = "max_partition_size_to_drop"
        elif key == "maxTableSizeToDrop":
            suggest = "max_table_size_to_drop"
        elif key == "mergeTree":
            suggest = "merge_tree"
        elif key == "metricLogEnabled":
            suggest = "metric_log_enabled"
        elif key == "metricLogRetentionSize":
            suggest = "metric_log_retention_size"
        elif key == "metricLogRetentionTime":
            suggest = "metric_log_retention_time"
        elif key == "opentelemetrySpanLogEnabled":
            suggest = "opentelemetry_span_log_enabled"
        elif key == "opentelemetrySpanLogRetentionSize":
            suggest = "opentelemetry_span_log_retention_size"
        elif key == "opentelemetrySpanLogRetentionTime":
            suggest = "opentelemetry_span_log_retention_time"
        elif key == "partLogRetentionSize":
            suggest = "part_log_retention_size"
        elif key == "partLogRetentionTime":
            suggest = "part_log_retention_time"
        elif key == "queryCache":
            suggest = "query_cache"
        elif key == "queryLogRetentionSize":
            suggest = "query_log_retention_size"
        elif key == "queryLogRetentionTime":
            suggest = "query_log_retention_time"
        elif key == "queryMaskingRules":
            suggest = "query_masking_rules"
        elif key == "queryThreadLogEnabled":
            suggest = "query_thread_log_enabled"
        elif key == "queryThreadLogRetentionSize":
            suggest = "query_thread_log_retention_size"
        elif key == "queryThreadLogRetentionTime":
            suggest = "query_thread_log_retention_time"
        elif key == "queryViewsLogEnabled":
            suggest = "query_views_log_enabled"
        elif key == "queryViewsLogRetentionSize":
            suggest = "query_views_log_retention_size"
        elif key == "queryViewsLogRetentionTime":
            suggest = "query_views_log_retention_time"
        elif key == "sessionLogEnabled":
            suggest = "session_log_enabled"
        elif key == "sessionLogRetentionSize":
            suggest = "session_log_retention_size"
        elif key == "sessionLogRetentionTime":
            suggest = "session_log_retention_time"
        elif key == "textLogEnabled":
            suggest = "text_log_enabled"
        elif key == "textLogLevel":
            suggest = "text_log_level"
        elif key == "textLogRetentionSize":
            suggest = "text_log_retention_size"
        elif key == "textLogRetentionTime":
            suggest = "text_log_retention_time"
        elif key == "totalMemoryProfilerStep":
            suggest = "total_memory_profiler_step"
        elif key == "traceLogEnabled":
            suggest = "trace_log_enabled"
        elif key == "traceLogRetentionSize":
            suggest = "trace_log_retention_size"
        elif key == "traceLogRetentionTime":
            suggest = "trace_log_retention_time"
        elif key == "uncompressedCacheSize":
            suggest = "uncompressed_cache_size"
        elif key == "zookeeperLogEnabled":
            suggest = "zookeeper_log_enabled"
        elif key == "zookeeperLogRetentionSize":
            suggest = "zookeeper_log_retention_size"
        elif key == "zookeeperLogRetentionTime":
            suggest = "zookeeper_log_retention_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asynchronous_insert_log_enabled: Optional[_builtins.bool] = None,
                 asynchronous_insert_log_retention_size: Optional[_builtins.int] = None,
                 asynchronous_insert_log_retention_time: Optional[_builtins.int] = None,
                 asynchronous_metric_log_enabled: Optional[_builtins.bool] = None,
                 asynchronous_metric_log_retention_size: Optional[_builtins.int] = None,
                 asynchronous_metric_log_retention_time: Optional[_builtins.int] = None,
                 background_buffer_flush_schedule_pool_size: Optional[_builtins.int] = None,
                 background_common_pool_size: Optional[_builtins.int] = None,
                 background_distributed_schedule_pool_size: Optional[_builtins.int] = None,
                 background_fetches_pool_size: Optional[_builtins.int] = None,
                 background_merges_mutations_concurrency_ratio: Optional[_builtins.int] = None,
                 background_message_broker_schedule_pool_size: Optional[_builtins.int] = None,
                 background_move_pool_size: Optional[_builtins.int] = None,
                 background_pool_size: Optional[_builtins.int] = None,
                 background_schedule_pool_size: Optional[_builtins.int] = None,
                 compressions: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigCompression']] = None,
                 default_database: Optional[_builtins.str] = None,
                 dictionaries_lazy_load: Optional[_builtins.bool] = None,
                 geobase_enabled: Optional[_builtins.bool] = None,
                 geobase_uri: Optional[_builtins.str] = None,
                 graphite_rollups: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollup']] = None,
                 jdbc_bridge: Optional['outputs.MdbClickhouseClusterClickhouseConfigJdbcBridge'] = None,
                 kafka: Optional['outputs.MdbClickhouseClusterClickhouseConfigKafka'] = None,
                 kafka_topics: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopic']] = None,
                 keep_alive_timeout: Optional[_builtins.int] = None,
                 log_level: Optional[_builtins.str] = None,
                 mark_cache_size: Optional[_builtins.int] = None,
                 max_concurrent_queries: Optional[_builtins.int] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_partition_size_to_drop: Optional[_builtins.int] = None,
                 max_table_size_to_drop: Optional[_builtins.int] = None,
                 merge_tree: Optional['outputs.MdbClickhouseClusterClickhouseConfigMergeTree'] = None,
                 metric_log_enabled: Optional[_builtins.bool] = None,
                 metric_log_retention_size: Optional[_builtins.int] = None,
                 metric_log_retention_time: Optional[_builtins.int] = None,
                 opentelemetry_span_log_enabled: Optional[_builtins.bool] = None,
                 opentelemetry_span_log_retention_size: Optional[_builtins.int] = None,
                 opentelemetry_span_log_retention_time: Optional[_builtins.int] = None,
                 part_log_retention_size: Optional[_builtins.int] = None,
                 part_log_retention_time: Optional[_builtins.int] = None,
                 query_cache: Optional['outputs.MdbClickhouseClusterClickhouseConfigQueryCache'] = None,
                 query_log_retention_size: Optional[_builtins.int] = None,
                 query_log_retention_time: Optional[_builtins.int] = None,
                 query_masking_rules: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigQueryMaskingRule']] = None,
                 query_thread_log_enabled: Optional[_builtins.bool] = None,
                 query_thread_log_retention_size: Optional[_builtins.int] = None,
                 query_thread_log_retention_time: Optional[_builtins.int] = None,
                 query_views_log_enabled: Optional[_builtins.bool] = None,
                 query_views_log_retention_size: Optional[_builtins.int] = None,
                 query_views_log_retention_time: Optional[_builtins.int] = None,
                 rabbitmq: Optional['outputs.MdbClickhouseClusterClickhouseConfigRabbitmq'] = None,
                 session_log_enabled: Optional[_builtins.bool] = None,
                 session_log_retention_size: Optional[_builtins.int] = None,
                 session_log_retention_time: Optional[_builtins.int] = None,
                 text_log_enabled: Optional[_builtins.bool] = None,
                 text_log_level: Optional[_builtins.str] = None,
                 text_log_retention_size: Optional[_builtins.int] = None,
                 text_log_retention_time: Optional[_builtins.int] = None,
                 timezone: Optional[_builtins.str] = None,
                 total_memory_profiler_step: Optional[_builtins.int] = None,
                 trace_log_enabled: Optional[_builtins.bool] = None,
                 trace_log_retention_size: Optional[_builtins.int] = None,
                 trace_log_retention_time: Optional[_builtins.int] = None,
                 uncompressed_cache_size: Optional[_builtins.int] = None,
                 zookeeper_log_enabled: Optional[_builtins.bool] = None,
                 zookeeper_log_retention_size: Optional[_builtins.int] = None,
                 zookeeper_log_retention_time: Optional[_builtins.int] = None):
        """
        :param _builtins.bool asynchronous_insert_log_enabled: Enable or disable asynchronous_insert_log system table.
        :param _builtins.int asynchronous_insert_log_retention_size: The maximum size that asynchronous_insert_log can grow to before old data will be removed.
        :param _builtins.int asynchronous_insert_log_retention_time: The maximum time that asynchronous_insert_log records will be retained before removal.
        :param _builtins.bool asynchronous_metric_log_enabled: Enable or disable asynchronous_metric_log system table.
        :param _builtins.int asynchronous_metric_log_retention_size: The maximum size that asynchronous_metric_log can grow to before old data will be removed.
        :param _builtins.int asynchronous_metric_log_retention_time: The maximum time that asynchronous_metric_log records will be retained before removal.
        :param _builtins.int background_buffer_flush_schedule_pool_size: The maximum number of threads that will be used for performing flush operations for Buffer-engine tables in the background.
        :param _builtins.int background_common_pool_size: The maximum number of threads that will be used for performing a variety of operations (mostly garbage collection) for MergeTree-engine tables in a background.
        :param _builtins.int background_distributed_schedule_pool_size: The maximum number of threads that will be used for executing distributed sends.
        :param _builtins.int background_fetches_pool_size: The maximum number of threads that will be used for fetching data parts from another replica for MergeTree-engine tables in a background.
        :param _builtins.int background_merges_mutations_concurrency_ratio: Sets a ratio between the number of threads and the number of background merges and mutations that can be executed concurrently.
        :param _builtins.int background_message_broker_schedule_pool_size: The maximum number of threads that will be used for executing background operations for message streaming.
        :param _builtins.int background_move_pool_size: The maximum number of threads that will be used for moving data parts to another disk or volume for MergeTree-engine tables in a background.
        :param _builtins.int background_pool_size: Sets the number of threads performing background merges and mutations for MergeTree-engine tables.
        :param _builtins.int background_schedule_pool_size: The maximum number of threads that will be used for constantly executing some lightweight periodic operations for replicated tables, Kafka streaming, and DNS cache updates.
        :param Sequence['MdbClickhouseClusterClickhouseConfigCompressionArgs'] compressions: Data compression configuration.
        :param _builtins.str default_database: Default database name.
        :param _builtins.bool dictionaries_lazy_load: Lazy loading of dictionaries. If true, then each dictionary is loaded on the first use.
        :param _builtins.bool geobase_enabled: Enable or disable geobase.
        :param _builtins.str geobase_uri: Address of the archive with the user geobase in Object Storage.
        :param Sequence['MdbClickhouseClusterClickhouseConfigGraphiteRollupArgs'] graphite_rollups: Graphite rollup configuration.
        :param 'MdbClickhouseClusterClickhouseConfigJdbcBridgeArgs' jdbc_bridge: JDBC bridge configuration.
        :param 'MdbClickhouseClusterClickhouseConfigKafkaArgs' kafka: Kafka connection configuration.
        :param Sequence['MdbClickhouseClusterClickhouseConfigKafkaTopicArgs'] kafka_topics: Kafka topic connection configuration.
        :param _builtins.int keep_alive_timeout: The number of seconds that ClickHouse waits for incoming requests for HTTP protocol before closing the connection.
        :param _builtins.str log_level: Logging level.
        :param _builtins.int mark_cache_size: Maximum size of cache for marks
        :param _builtins.int max_concurrent_queries: Limit on total number of concurrently executed queries.
        :param _builtins.int max_connections: Max server connections.
        :param _builtins.int max_partition_size_to_drop: Restriction on dropping partitions.
        :param _builtins.int max_table_size_to_drop: Restriction on deleting tables.
        :param 'MdbClickhouseClusterClickhouseConfigMergeTreeArgs' merge_tree: MergeTree engine configuration.
        :param _builtins.bool metric_log_enabled: Enable or disable metric_log system table.
        :param _builtins.int metric_log_retention_size: The maximum size that metric_log can grow to before old data will be removed.
        :param _builtins.int metric_log_retention_time: The maximum time that metric_log records will be retained before removal.
        :param _builtins.bool opentelemetry_span_log_enabled: Enable or disable opentelemetry_span_log system table.
        :param _builtins.int opentelemetry_span_log_retention_size: The maximum size that opentelemetry_span_log can grow to before old data will be removed.
        :param _builtins.int opentelemetry_span_log_retention_time: The maximum time that opentelemetry_span_log records will be retained before removal.
        :param _builtins.int part_log_retention_size: The maximum size that part_log can grow to before old data will be removed.
        :param _builtins.int part_log_retention_time: The maximum time that part_log records will be retained before removal.
        :param 'MdbClickhouseClusterClickhouseConfigQueryCacheArgs' query_cache: Query cache configuration.
        :param _builtins.int query_log_retention_size: The maximum size that query_log can grow to before old data will be removed.
        :param _builtins.int query_log_retention_time: The maximum time that query_log records will be retained before removal.
        :param Sequence['MdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs'] query_masking_rules: Query masking rules configuration.
        :param _builtins.bool query_thread_log_enabled: Enable or disable query_thread_log system table.
        :param _builtins.int query_thread_log_retention_size: The maximum size that query_thread_log can grow to before old data will be removed.
        :param _builtins.int query_thread_log_retention_time: The maximum time that query_thread_log records will be retained before removal.
        :param _builtins.bool query_views_log_enabled: Enable or disable query_views_log system table.
        :param _builtins.int query_views_log_retention_size: The maximum size that query_views_log can grow to before old data will be removed.
        :param _builtins.int query_views_log_retention_time: The maximum time that query_views_log records will be retained before removal.
        :param 'MdbClickhouseClusterClickhouseConfigRabbitmqArgs' rabbitmq: RabbitMQ connection configuration.
        :param _builtins.bool session_log_enabled: Enable or disable session_log system table.
        :param _builtins.int session_log_retention_size: The maximum size that session_log can grow to before old data will be removed.
        :param _builtins.int session_log_retention_time: The maximum time that session_log records will be retained before removal.
        :param _builtins.bool text_log_enabled: Enable or disable text_log system table.
        :param _builtins.str text_log_level: Logging level for text_log system table.
        :param _builtins.int text_log_retention_size: The maximum size that text_log can grow to before old data will be removed.
        :param _builtins.int text_log_retention_time: The maximum time that text_log records will be retained before removal.
        :param _builtins.str timezone: The server's time zone.
        :param _builtins.int total_memory_profiler_step: Whenever server memory usage becomes larger than every next step in number of bytes the memory profiler will collect the allocating stack trace.
        :param _builtins.bool trace_log_enabled: Enable or disable trace_log system table.
        :param _builtins.int trace_log_retention_size: The maximum size that trace_log can grow to before old data will be removed.
        :param _builtins.int trace_log_retention_time: The maximum time that trace_log records will be retained before removal.
        :param _builtins.int uncompressed_cache_size: Cache size (in bytes) for uncompressed data used by table engines from the MergeTree family. Zero means disabled.
        :param _builtins.bool zookeeper_log_enabled: Enable or disable zookeeper_log system table.
        :param _builtins.int zookeeper_log_retention_size: The maximum size that zookeeper_log can grow to before old data will be removed.
        :param _builtins.int zookeeper_log_retention_time: The maximum time that zookeeper_log records will be retained before removal.
        """
        if asynchronous_insert_log_enabled is not None:
            pulumi.set(__self__, "asynchronous_insert_log_enabled", asynchronous_insert_log_enabled)
        if asynchronous_insert_log_retention_size is not None:
            pulumi.set(__self__, "asynchronous_insert_log_retention_size", asynchronous_insert_log_retention_size)
        if asynchronous_insert_log_retention_time is not None:
            pulumi.set(__self__, "asynchronous_insert_log_retention_time", asynchronous_insert_log_retention_time)
        if asynchronous_metric_log_enabled is not None:
            pulumi.set(__self__, "asynchronous_metric_log_enabled", asynchronous_metric_log_enabled)
        if asynchronous_metric_log_retention_size is not None:
            pulumi.set(__self__, "asynchronous_metric_log_retention_size", asynchronous_metric_log_retention_size)
        if asynchronous_metric_log_retention_time is not None:
            pulumi.set(__self__, "asynchronous_metric_log_retention_time", asynchronous_metric_log_retention_time)
        if background_buffer_flush_schedule_pool_size is not None:
            pulumi.set(__self__, "background_buffer_flush_schedule_pool_size", background_buffer_flush_schedule_pool_size)
        if background_common_pool_size is not None:
            pulumi.set(__self__, "background_common_pool_size", background_common_pool_size)
        if background_distributed_schedule_pool_size is not None:
            pulumi.set(__self__, "background_distributed_schedule_pool_size", background_distributed_schedule_pool_size)
        if background_fetches_pool_size is not None:
            pulumi.set(__self__, "background_fetches_pool_size", background_fetches_pool_size)
        if background_merges_mutations_concurrency_ratio is not None:
            pulumi.set(__self__, "background_merges_mutations_concurrency_ratio", background_merges_mutations_concurrency_ratio)
        if background_message_broker_schedule_pool_size is not None:
            pulumi.set(__self__, "background_message_broker_schedule_pool_size", background_message_broker_schedule_pool_size)
        if background_move_pool_size is not None:
            pulumi.set(__self__, "background_move_pool_size", background_move_pool_size)
        if background_pool_size is not None:
            pulumi.set(__self__, "background_pool_size", background_pool_size)
        if background_schedule_pool_size is not None:
            pulumi.set(__self__, "background_schedule_pool_size", background_schedule_pool_size)
        if compressions is not None:
            pulumi.set(__self__, "compressions", compressions)
        if default_database is not None:
            pulumi.set(__self__, "default_database", default_database)
        if dictionaries_lazy_load is not None:
            pulumi.set(__self__, "dictionaries_lazy_load", dictionaries_lazy_load)
        if geobase_enabled is not None:
            pulumi.set(__self__, "geobase_enabled", geobase_enabled)
        if geobase_uri is not None:
            pulumi.set(__self__, "geobase_uri", geobase_uri)
        if graphite_rollups is not None:
            pulumi.set(__self__, "graphite_rollups", graphite_rollups)
        if jdbc_bridge is not None:
            pulumi.set(__self__, "jdbc_bridge", jdbc_bridge)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kafka_topics is not None:
            pulumi.set(__self__, "kafka_topics", kafka_topics)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if mark_cache_size is not None:
            pulumi.set(__self__, "mark_cache_size", mark_cache_size)
        if max_concurrent_queries is not None:
            pulumi.set(__self__, "max_concurrent_queries", max_concurrent_queries)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_partition_size_to_drop is not None:
            pulumi.set(__self__, "max_partition_size_to_drop", max_partition_size_to_drop)
        if max_table_size_to_drop is not None:
            pulumi.set(__self__, "max_table_size_to_drop", max_table_size_to_drop)
        if merge_tree is not None:
            pulumi.set(__self__, "merge_tree", merge_tree)
        if metric_log_enabled is not None:
            pulumi.set(__self__, "metric_log_enabled", metric_log_enabled)
        if metric_log_retention_size is not None:
            pulumi.set(__self__, "metric_log_retention_size", metric_log_retention_size)
        if metric_log_retention_time is not None:
            pulumi.set(__self__, "metric_log_retention_time", metric_log_retention_time)
        if opentelemetry_span_log_enabled is not None:
            pulumi.set(__self__, "opentelemetry_span_log_enabled", opentelemetry_span_log_enabled)
        if opentelemetry_span_log_retention_size is not None:
            pulumi.set(__self__, "opentelemetry_span_log_retention_size", opentelemetry_span_log_retention_size)
        if opentelemetry_span_log_retention_time is not None:
            pulumi.set(__self__, "opentelemetry_span_log_retention_time", opentelemetry_span_log_retention_time)
        if part_log_retention_size is not None:
            pulumi.set(__self__, "part_log_retention_size", part_log_retention_size)
        if part_log_retention_time is not None:
            pulumi.set(__self__, "part_log_retention_time", part_log_retention_time)
        if query_cache is not None:
            pulumi.set(__self__, "query_cache", query_cache)
        if query_log_retention_size is not None:
            pulumi.set(__self__, "query_log_retention_size", query_log_retention_size)
        if query_log_retention_time is not None:
            pulumi.set(__self__, "query_log_retention_time", query_log_retention_time)
        if query_masking_rules is not None:
            pulumi.set(__self__, "query_masking_rules", query_masking_rules)
        if query_thread_log_enabled is not None:
            pulumi.set(__self__, "query_thread_log_enabled", query_thread_log_enabled)
        if query_thread_log_retention_size is not None:
            pulumi.set(__self__, "query_thread_log_retention_size", query_thread_log_retention_size)
        if query_thread_log_retention_time is not None:
            pulumi.set(__self__, "query_thread_log_retention_time", query_thread_log_retention_time)
        if query_views_log_enabled is not None:
            pulumi.set(__self__, "query_views_log_enabled", query_views_log_enabled)
        if query_views_log_retention_size is not None:
            pulumi.set(__self__, "query_views_log_retention_size", query_views_log_retention_size)
        if query_views_log_retention_time is not None:
            pulumi.set(__self__, "query_views_log_retention_time", query_views_log_retention_time)
        if rabbitmq is not None:
            pulumi.set(__self__, "rabbitmq", rabbitmq)
        if session_log_enabled is not None:
            pulumi.set(__self__, "session_log_enabled", session_log_enabled)
        if session_log_retention_size is not None:
            pulumi.set(__self__, "session_log_retention_size", session_log_retention_size)
        if session_log_retention_time is not None:
            pulumi.set(__self__, "session_log_retention_time", session_log_retention_time)
        if text_log_enabled is not None:
            pulumi.set(__self__, "text_log_enabled", text_log_enabled)
        if text_log_level is not None:
            pulumi.set(__self__, "text_log_level", text_log_level)
        if text_log_retention_size is not None:
            pulumi.set(__self__, "text_log_retention_size", text_log_retention_size)
        if text_log_retention_time is not None:
            pulumi.set(__self__, "text_log_retention_time", text_log_retention_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if total_memory_profiler_step is not None:
            pulumi.set(__self__, "total_memory_profiler_step", total_memory_profiler_step)
        if trace_log_enabled is not None:
            pulumi.set(__self__, "trace_log_enabled", trace_log_enabled)
        if trace_log_retention_size is not None:
            pulumi.set(__self__, "trace_log_retention_size", trace_log_retention_size)
        if trace_log_retention_time is not None:
            pulumi.set(__self__, "trace_log_retention_time", trace_log_retention_time)
        if uncompressed_cache_size is not None:
            pulumi.set(__self__, "uncompressed_cache_size", uncompressed_cache_size)
        if zookeeper_log_enabled is not None:
            pulumi.set(__self__, "zookeeper_log_enabled", zookeeper_log_enabled)
        if zookeeper_log_retention_size is not None:
            pulumi.set(__self__, "zookeeper_log_retention_size", zookeeper_log_retention_size)
        if zookeeper_log_retention_time is not None:
            pulumi.set(__self__, "zookeeper_log_retention_time", zookeeper_log_retention_time)

    @_builtins.property
    @pulumi.getter(name="asynchronousInsertLogEnabled")
    def asynchronous_insert_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable asynchronous_insert_log system table.
        """
        return pulumi.get(self, "asynchronous_insert_log_enabled")

    @_builtins.property
    @pulumi.getter(name="asynchronousInsertLogRetentionSize")
    def asynchronous_insert_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that asynchronous_insert_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "asynchronous_insert_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="asynchronousInsertLogRetentionTime")
    def asynchronous_insert_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that asynchronous_insert_log records will be retained before removal.
        """
        return pulumi.get(self, "asynchronous_insert_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="asynchronousMetricLogEnabled")
    def asynchronous_metric_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable asynchronous_metric_log system table.
        """
        return pulumi.get(self, "asynchronous_metric_log_enabled")

    @_builtins.property
    @pulumi.getter(name="asynchronousMetricLogRetentionSize")
    def asynchronous_metric_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that asynchronous_metric_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "asynchronous_metric_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="asynchronousMetricLogRetentionTime")
    def asynchronous_metric_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that asynchronous_metric_log records will be retained before removal.
        """
        return pulumi.get(self, "asynchronous_metric_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="backgroundBufferFlushSchedulePoolSize")
    def background_buffer_flush_schedule_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for performing flush operations for Buffer-engine tables in the background.
        """
        return pulumi.get(self, "background_buffer_flush_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundCommonPoolSize")
    def background_common_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for performing a variety of operations (mostly garbage collection) for MergeTree-engine tables in a background.
        """
        return pulumi.get(self, "background_common_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundDistributedSchedulePoolSize")
    def background_distributed_schedule_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for executing distributed sends.
        """
        return pulumi.get(self, "background_distributed_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundFetchesPoolSize")
    def background_fetches_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for fetching data parts from another replica for MergeTree-engine tables in a background.
        """
        return pulumi.get(self, "background_fetches_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundMergesMutationsConcurrencyRatio")
    def background_merges_mutations_concurrency_ratio(self) -> Optional[_builtins.int]:
        """
        Sets a ratio between the number of threads and the number of background merges and mutations that can be executed concurrently.
        """
        return pulumi.get(self, "background_merges_mutations_concurrency_ratio")

    @_builtins.property
    @pulumi.getter(name="backgroundMessageBrokerSchedulePoolSize")
    def background_message_broker_schedule_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for executing background operations for message streaming.
        """
        return pulumi.get(self, "background_message_broker_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundMovePoolSize")
    def background_move_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for moving data parts to another disk or volume for MergeTree-engine tables in a background.
        """
        return pulumi.get(self, "background_move_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundPoolSize")
    def background_pool_size(self) -> Optional[_builtins.int]:
        """
        Sets the number of threads performing background merges and mutations for MergeTree-engine tables.
        """
        return pulumi.get(self, "background_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundSchedulePoolSize")
    def background_schedule_pool_size(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads that will be used for constantly executing some lightweight periodic operations for replicated tables, Kafka streaming, and DNS cache updates.
        """
        return pulumi.get(self, "background_schedule_pool_size")

    @_builtins.property
    @pulumi.getter
    def compressions(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigCompression']]:
        """
        Data compression configuration.
        """
        return pulumi.get(self, "compressions")

    @_builtins.property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> Optional[_builtins.str]:
        """
        Default database name.
        """
        return pulumi.get(self, "default_database")

    @_builtins.property
    @pulumi.getter(name="dictionariesLazyLoad")
    def dictionaries_lazy_load(self) -> Optional[_builtins.bool]:
        """
        Lazy loading of dictionaries. If true, then each dictionary is loaded on the first use.
        """
        return pulumi.get(self, "dictionaries_lazy_load")

    @_builtins.property
    @pulumi.getter(name="geobaseEnabled")
    def geobase_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable geobase.
        """
        return pulumi.get(self, "geobase_enabled")

    @_builtins.property
    @pulumi.getter(name="geobaseUri")
    def geobase_uri(self) -> Optional[_builtins.str]:
        """
        Address of the archive with the user geobase in Object Storage.
        """
        return pulumi.get(self, "geobase_uri")

    @_builtins.property
    @pulumi.getter(name="graphiteRollups")
    def graphite_rollups(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollup']]:
        """
        Graphite rollup configuration.
        """
        return pulumi.get(self, "graphite_rollups")

    @_builtins.property
    @pulumi.getter(name="jdbcBridge")
    def jdbc_bridge(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigJdbcBridge']:
        """
        JDBC bridge configuration.
        """
        return pulumi.get(self, "jdbc_bridge")

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigKafka']:
        """
        Kafka connection configuration.
        """
        return pulumi.get(self, "kafka")

    @_builtins.property
    @pulumi.getter(name="kafkaTopics")
    def kafka_topics(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopic']]:
        """
        Kafka topic connection configuration.
        """
        return pulumi.get(self, "kafka_topics")

    @_builtins.property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[_builtins.int]:
        """
        The number of seconds that ClickHouse waits for incoming requests for HTTP protocol before closing the connection.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[_builtins.str]:
        """
        Logging level.
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="markCacheSize")
    def mark_cache_size(self) -> Optional[_builtins.int]:
        """
        Maximum size of cache for marks
        """
        return pulumi.get(self, "mark_cache_size")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentQueries")
    def max_concurrent_queries(self) -> Optional[_builtins.int]:
        """
        Limit on total number of concurrently executed queries.
        """
        return pulumi.get(self, "max_concurrent_queries")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        Max server connections.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPartitionSizeToDrop")
    def max_partition_size_to_drop(self) -> Optional[_builtins.int]:
        """
        Restriction on dropping partitions.
        """
        return pulumi.get(self, "max_partition_size_to_drop")

    @_builtins.property
    @pulumi.getter(name="maxTableSizeToDrop")
    def max_table_size_to_drop(self) -> Optional[_builtins.int]:
        """
        Restriction on deleting tables.
        """
        return pulumi.get(self, "max_table_size_to_drop")

    @_builtins.property
    @pulumi.getter(name="mergeTree")
    def merge_tree(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigMergeTree']:
        """
        MergeTree engine configuration.
        """
        return pulumi.get(self, "merge_tree")

    @_builtins.property
    @pulumi.getter(name="metricLogEnabled")
    def metric_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable metric_log system table.
        """
        return pulumi.get(self, "metric_log_enabled")

    @_builtins.property
    @pulumi.getter(name="metricLogRetentionSize")
    def metric_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that metric_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "metric_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="metricLogRetentionTime")
    def metric_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that metric_log records will be retained before removal.
        """
        return pulumi.get(self, "metric_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="opentelemetrySpanLogEnabled")
    def opentelemetry_span_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable opentelemetry_span_log system table.
        """
        return pulumi.get(self, "opentelemetry_span_log_enabled")

    @_builtins.property
    @pulumi.getter(name="opentelemetrySpanLogRetentionSize")
    def opentelemetry_span_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that opentelemetry_span_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "opentelemetry_span_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="opentelemetrySpanLogRetentionTime")
    def opentelemetry_span_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that opentelemetry_span_log records will be retained before removal.
        """
        return pulumi.get(self, "opentelemetry_span_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="partLogRetentionSize")
    def part_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that part_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "part_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="partLogRetentionTime")
    def part_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that part_log records will be retained before removal.
        """
        return pulumi.get(self, "part_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="queryCache")
    def query_cache(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigQueryCache']:
        """
        Query cache configuration.
        """
        return pulumi.get(self, "query_cache")

    @_builtins.property
    @pulumi.getter(name="queryLogRetentionSize")
    def query_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that query_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "query_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="queryLogRetentionTime")
    def query_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that query_log records will be retained before removal.
        """
        return pulumi.get(self, "query_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="queryMaskingRules")
    def query_masking_rules(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigQueryMaskingRule']]:
        """
        Query masking rules configuration.
        """
        return pulumi.get(self, "query_masking_rules")

    @_builtins.property
    @pulumi.getter(name="queryThreadLogEnabled")
    def query_thread_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable query_thread_log system table.
        """
        return pulumi.get(self, "query_thread_log_enabled")

    @_builtins.property
    @pulumi.getter(name="queryThreadLogRetentionSize")
    def query_thread_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that query_thread_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "query_thread_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="queryThreadLogRetentionTime")
    def query_thread_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that query_thread_log records will be retained before removal.
        """
        return pulumi.get(self, "query_thread_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="queryViewsLogEnabled")
    def query_views_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable query_views_log system table.
        """
        return pulumi.get(self, "query_views_log_enabled")

    @_builtins.property
    @pulumi.getter(name="queryViewsLogRetentionSize")
    def query_views_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that query_views_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "query_views_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="queryViewsLogRetentionTime")
    def query_views_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that query_views_log records will be retained before removal.
        """
        return pulumi.get(self, "query_views_log_retention_time")

    @_builtins.property
    @pulumi.getter
    def rabbitmq(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigRabbitmq']:
        """
        RabbitMQ connection configuration.
        """
        return pulumi.get(self, "rabbitmq")

    @_builtins.property
    @pulumi.getter(name="sessionLogEnabled")
    def session_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable session_log system table.
        """
        return pulumi.get(self, "session_log_enabled")

    @_builtins.property
    @pulumi.getter(name="sessionLogRetentionSize")
    def session_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that session_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "session_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="sessionLogRetentionTime")
    def session_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that session_log records will be retained before removal.
        """
        return pulumi.get(self, "session_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="textLogEnabled")
    def text_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable text_log system table.
        """
        return pulumi.get(self, "text_log_enabled")

    @_builtins.property
    @pulumi.getter(name="textLogLevel")
    def text_log_level(self) -> Optional[_builtins.str]:
        """
        Logging level for text_log system table.
        """
        return pulumi.get(self, "text_log_level")

    @_builtins.property
    @pulumi.getter(name="textLogRetentionSize")
    def text_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that text_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "text_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="textLogRetentionTime")
    def text_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that text_log records will be retained before removal.
        """
        return pulumi.get(self, "text_log_retention_time")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        The server's time zone.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="totalMemoryProfilerStep")
    def total_memory_profiler_step(self) -> Optional[_builtins.int]:
        """
        Whenever server memory usage becomes larger than every next step in number of bytes the memory profiler will collect the allocating stack trace.
        """
        return pulumi.get(self, "total_memory_profiler_step")

    @_builtins.property
    @pulumi.getter(name="traceLogEnabled")
    def trace_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable trace_log system table.
        """
        return pulumi.get(self, "trace_log_enabled")

    @_builtins.property
    @pulumi.getter(name="traceLogRetentionSize")
    def trace_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that trace_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "trace_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="traceLogRetentionTime")
    def trace_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that trace_log records will be retained before removal.
        """
        return pulumi.get(self, "trace_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="uncompressedCacheSize")
    def uncompressed_cache_size(self) -> Optional[_builtins.int]:
        """
        Cache size (in bytes) for uncompressed data used by table engines from the MergeTree family. Zero means disabled.
        """
        return pulumi.get(self, "uncompressed_cache_size")

    @_builtins.property
    @pulumi.getter(name="zookeeperLogEnabled")
    def zookeeper_log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable zookeeper_log system table.
        """
        return pulumi.get(self, "zookeeper_log_enabled")

    @_builtins.property
    @pulumi.getter(name="zookeeperLogRetentionSize")
    def zookeeper_log_retention_size(self) -> Optional[_builtins.int]:
        """
        The maximum size that zookeeper_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "zookeeper_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="zookeeperLogRetentionTime")
    def zookeeper_log_retention_time(self) -> Optional[_builtins.int]:
        """
        The maximum time that zookeeper_log records will be retained before removal.
        """
        return pulumi.get(self, "zookeeper_log_retention_time")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minPartSize":
            suggest = "min_part_size"
        elif key == "minPartSizeRatio":
            suggest = "min_part_size_ratio"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 min_part_size: _builtins.int,
                 min_part_size_ratio: _builtins.float,
                 level: Optional[_builtins.int] = None):
        """
        :param _builtins.str method: Compression method. Two methods are available: `LZ4` and `zstd`.
        :param _builtins.int min_part_size: Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        :param _builtins.float min_part_size_ratio: Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        :param _builtins.int level: Compression level for `ZSTD` method.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "min_part_size", min_part_size)
        pulumi.set(__self__, "min_part_size_ratio", min_part_size_ratio)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Compression method. Two methods are available: `LZ4` and `zstd`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="minPartSize")
    def min_part_size(self) -> _builtins.int:
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        return pulumi.get(self, "min_part_size")

    @_builtins.property
    @pulumi.getter(name="minPartSizeRatio")
    def min_part_size_ratio(self) -> _builtins.float:
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        return pulumi.get(self, "min_part_size_ratio")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.int]:
        """
        Compression level for `ZSTD` method.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathColumnName":
            suggest = "path_column_name"
        elif key == "timeColumnName":
            suggest = "time_column_name"
        elif key == "valueColumnName":
            suggest = "value_column_name"
        elif key == "versionColumnName":
            suggest = "version_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigGraphiteRollup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigGraphiteRollup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigGraphiteRollup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 path_column_name: Optional[_builtins.str] = None,
                 patterns: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern']] = None,
                 time_column_name: Optional[_builtins.str] = None,
                 value_column_name: Optional[_builtins.str] = None,
                 version_column_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Graphite rollup configuration name.
        :param _builtins.str path_column_name: The name of the column storing the metric name (Graphite sensor). Default value: Path.
        :param Sequence['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs'] patterns: Set of thinning rules.
        :param _builtins.str time_column_name: The name of the column storing the time of measuring the metric. Default value: Time.
        :param _builtins.str value_column_name: The name of the column storing the value of the metric at the time set in `time_column_name`. Default value: Value.
        :param _builtins.str version_column_name: The name of the column storing the version of the metric. Default value: Timestamp.
        """
        pulumi.set(__self__, "name", name)
        if path_column_name is not None:
            pulumi.set(__self__, "path_column_name", path_column_name)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if time_column_name is not None:
            pulumi.set(__self__, "time_column_name", time_column_name)
        if value_column_name is not None:
            pulumi.set(__self__, "value_column_name", value_column_name)
        if version_column_name is not None:
            pulumi.set(__self__, "version_column_name", version_column_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pathColumnName")
    def path_column_name(self) -> Optional[_builtins.str]:
        """
        The name of the column storing the metric name (Graphite sensor). Default value: Path.
        """
        return pulumi.get(self, "path_column_name")

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern']]:
        """
        Set of thinning rules.
        """
        return pulumi.get(self, "patterns")

    @_builtins.property
    @pulumi.getter(name="timeColumnName")
    def time_column_name(self) -> Optional[_builtins.str]:
        """
        The name of the column storing the time of measuring the metric. Default value: Time.
        """
        return pulumi.get(self, "time_column_name")

    @_builtins.property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> Optional[_builtins.str]:
        """
        The name of the column storing the value of the metric at the time set in `time_column_name`. Default value: Value.
        """
        return pulumi.get(self, "value_column_name")

    @_builtins.property
    @pulumi.getter(name="versionColumnName")
    def version_column_name(self) -> Optional[_builtins.str]:
        """
        The name of the column storing the version of the metric. Default value: Timestamp.
        """
        return pulumi.get(self, "version_column_name")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern(dict):
    def __init__(__self__, *,
                 function: _builtins.str,
                 regexp: Optional[_builtins.str] = None,
                 retentions: Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention']] = None):
        """
        :param _builtins.str function: Aggregation function name.
        :param _builtins.str regexp: Regular expression that the metric name must match.
        :param Sequence['MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs'] retentions: Retain parameters.
        """
        pulumi.set(__self__, "function", function)
        if regexp is not None:
            pulumi.set(__self__, "regexp", regexp)
        if retentions is not None:
            pulumi.set(__self__, "retentions", retentions)

    @_builtins.property
    @pulumi.getter
    def function(self) -> _builtins.str:
        """
        Aggregation function name.
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def regexp(self) -> Optional[_builtins.str]:
        """
        Regular expression that the metric name must match.
        """
        return pulumi.get(self, "regexp")

    @_builtins.property
    @pulumi.getter
    def retentions(self) -> Optional[Sequence['outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention']]:
        """
        Retain parameters.
        """
        return pulumi.get(self, "retentions")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention(dict):
    def __init__(__self__, *,
                 age: _builtins.int,
                 precision: _builtins.int):
        """
        :param _builtins.int age: Minimum data age in seconds.
        :param _builtins.int precision: Accuracy of determining the age of the data in seconds.
        """
        pulumi.set(__self__, "age", age)
        pulumi.set(__self__, "precision", precision)

    @_builtins.property
    @pulumi.getter
    def age(self) -> _builtins.int:
        """
        Minimum data age in seconds.
        """
        return pulumi.get(self, "age")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.int:
        """
        Accuracy of determining the age of the data in seconds.
        """
        return pulumi.get(self, "precision")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigJdbcBridge(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str host: Host of jdbc bridge.
        :param _builtins.int port: Port of jdbc bridge. Default value: 9019.
        """
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host of jdbc bridge.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port of jdbc bridge. Default value: 9019.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoOffsetReset":
            suggest = "auto_offset_reset"
        elif key == "enableSslCertificateVerification":
            suggest = "enable_ssl_certificate_verification"
        elif key == "maxPollIntervalMs":
            suggest = "max_poll_interval_ms"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPassword":
            suggest = "sasl_password"
        elif key == "saslUsername":
            suggest = "sasl_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"
        elif key == "sessionTimeoutMs":
            suggest = "session_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_offset_reset: Optional[_builtins.str] = None,
                 debug: Optional[_builtins.str] = None,
                 enable_ssl_certificate_verification: Optional[_builtins.bool] = None,
                 max_poll_interval_ms: Optional[_builtins.int] = None,
                 sasl_mechanism: Optional[_builtins.str] = None,
                 sasl_password: Optional[_builtins.str] = None,
                 sasl_username: Optional[_builtins.str] = None,
                 security_protocol: Optional[_builtins.str] = None,
                 session_timeout_ms: Optional[_builtins.int] = None):
        """
        :param _builtins.str auto_offset_reset: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param _builtins.str debug: A comma-separated list of debug contexts to enable.
        :param _builtins.bool enable_ssl_certificate_verification: Enable verification of SSL certificates.
        :param _builtins.int max_poll_interval_ms: Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param _builtins.str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param _builtins.str sasl_password: User password on kafka server.
        :param _builtins.str sasl_username: Username on kafka server.
        :param _builtins.str security_protocol: Security protocol used to connect to kafka server.
        :param _builtins.int session_timeout_ms: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        if auto_offset_reset is not None:
            pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if enable_ssl_certificate_verification is not None:
            pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        if max_poll_interval_ms is not None:
            pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @_builtins.property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> Optional[_builtins.str]:
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[_builtins.str]:
        """
        A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> Optional[_builtins.bool]:
        """
        Enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> Optional[_builtins.int]:
        """
        Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[_builtins.str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[_builtins.str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[_builtins.str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[_builtins.str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[_builtins.int]:
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigKafkaTopic(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 settings: Optional['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopicSettings'] = None):
        """
        :param _builtins.str name: Kafka topic name.
        :param 'MdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs' settings: Kafka connection settings.
        """
        pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Kafka topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional['outputs.MdbClickhouseClusterClickhouseConfigKafkaTopicSettings']:
        """
        Kafka connection settings.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigKafkaTopicSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoOffsetReset":
            suggest = "auto_offset_reset"
        elif key == "enableSslCertificateVerification":
            suggest = "enable_ssl_certificate_verification"
        elif key == "maxPollIntervalMs":
            suggest = "max_poll_interval_ms"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPassword":
            suggest = "sasl_password"
        elif key == "saslUsername":
            suggest = "sasl_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"
        elif key == "sessionTimeoutMs":
            suggest = "session_timeout_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigKafkaTopicSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigKafkaTopicSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigKafkaTopicSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_offset_reset: Optional[_builtins.str] = None,
                 debug: Optional[_builtins.str] = None,
                 enable_ssl_certificate_verification: Optional[_builtins.bool] = None,
                 max_poll_interval_ms: Optional[_builtins.int] = None,
                 sasl_mechanism: Optional[_builtins.str] = None,
                 sasl_password: Optional[_builtins.str] = None,
                 sasl_username: Optional[_builtins.str] = None,
                 security_protocol: Optional[_builtins.str] = None,
                 session_timeout_ms: Optional[_builtins.int] = None):
        """
        :param _builtins.str auto_offset_reset: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param _builtins.str debug: A comma-separated list of debug contexts to enable.
        :param _builtins.bool enable_ssl_certificate_verification: Enable verification of SSL certificates.
        :param _builtins.int max_poll_interval_ms: Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param _builtins.str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param _builtins.str sasl_password: User password on kafka server.
        :param _builtins.str sasl_username: Username on kafka server.
        :param _builtins.str security_protocol: Security protocol used to connect to kafka server.
        :param _builtins.int session_timeout_ms: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        if auto_offset_reset is not None:
            pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if enable_ssl_certificate_verification is not None:
            pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        if max_poll_interval_ms is not None:
            pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if session_timeout_ms is not None:
            pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @_builtins.property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> Optional[_builtins.str]:
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[_builtins.str]:
        """
        A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> Optional[_builtins.bool]:
        """
        Enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> Optional[_builtins.int]:
        """
        Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[_builtins.str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[_builtins.str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[_builtins.str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[_builtins.str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> Optional[_builtins.int]:
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigMergeTree(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowRemoteFsZeroCopyReplication":
            suggest = "allow_remote_fs_zero_copy_replication"
        elif key == "checkSampleColumnIsCorrect":
            suggest = "check_sample_column_is_correct"
        elif key == "cleanupDelayPeriod":
            suggest = "cleanup_delay_period"
        elif key == "inactivePartsToDelayInsert":
            suggest = "inactive_parts_to_delay_insert"
        elif key == "inactivePartsToThrowInsert":
            suggest = "inactive_parts_to_throw_insert"
        elif key == "maxAvgPartSizeForTooManyParts":
            suggest = "max_avg_part_size_for_too_many_parts"
        elif key == "maxBytesToMergeAtMaxSpaceInPool":
            suggest = "max_bytes_to_merge_at_max_space_in_pool"
        elif key == "maxBytesToMergeAtMinSpaceInPool":
            suggest = "max_bytes_to_merge_at_min_space_in_pool"
        elif key == "maxCleanupDelayPeriod":
            suggest = "max_cleanup_delay_period"
        elif key == "maxMergeSelectingSleepMs":
            suggest = "max_merge_selecting_sleep_ms"
        elif key == "maxNumberOfMergesWithTtlInPool":
            suggest = "max_number_of_merges_with_ttl_in_pool"
        elif key == "maxPartsInTotal":
            suggest = "max_parts_in_total"
        elif key == "maxReplicatedMergesInQueue":
            suggest = "max_replicated_merges_in_queue"
        elif key == "mergeMaxBlockSize":
            suggest = "merge_max_block_size"
        elif key == "mergeSelectingSleepMs":
            suggest = "merge_selecting_sleep_ms"
        elif key == "mergeWithRecompressionTtlTimeout":
            suggest = "merge_with_recompression_ttl_timeout"
        elif key == "mergeWithTtlTimeout":
            suggest = "merge_with_ttl_timeout"
        elif key == "minAgeToForceMergeOnPartitionOnly":
            suggest = "min_age_to_force_merge_on_partition_only"
        elif key == "minAgeToForceMergeSeconds":
            suggest = "min_age_to_force_merge_seconds"
        elif key == "minBytesForWidePart":
            suggest = "min_bytes_for_wide_part"
        elif key == "minRowsForWidePart":
            suggest = "min_rows_for_wide_part"
        elif key == "numberOfFreeEntriesInPoolToExecuteMutation":
            suggest = "number_of_free_entries_in_pool_to_execute_mutation"
        elif key == "numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge":
            suggest = "number_of_free_entries_in_pool_to_lower_max_size_of_merge"
        elif key == "partsToDelayInsert":
            suggest = "parts_to_delay_insert"
        elif key == "partsToThrowInsert":
            suggest = "parts_to_throw_insert"
        elif key == "replicatedDeduplicationWindow":
            suggest = "replicated_deduplication_window"
        elif key == "replicatedDeduplicationWindowSeconds":
            suggest = "replicated_deduplication_window_seconds"
        elif key == "ttlOnlyDropParts":
            suggest = "ttl_only_drop_parts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigMergeTree. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigMergeTree.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigMergeTree.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_remote_fs_zero_copy_replication: Optional[_builtins.bool] = None,
                 check_sample_column_is_correct: Optional[_builtins.bool] = None,
                 cleanup_delay_period: Optional[_builtins.int] = None,
                 inactive_parts_to_delay_insert: Optional[_builtins.int] = None,
                 inactive_parts_to_throw_insert: Optional[_builtins.int] = None,
                 max_avg_part_size_for_too_many_parts: Optional[_builtins.int] = None,
                 max_bytes_to_merge_at_max_space_in_pool: Optional[_builtins.int] = None,
                 max_bytes_to_merge_at_min_space_in_pool: Optional[_builtins.int] = None,
                 max_cleanup_delay_period: Optional[_builtins.int] = None,
                 max_merge_selecting_sleep_ms: Optional[_builtins.int] = None,
                 max_number_of_merges_with_ttl_in_pool: Optional[_builtins.int] = None,
                 max_parts_in_total: Optional[_builtins.int] = None,
                 max_replicated_merges_in_queue: Optional[_builtins.int] = None,
                 merge_max_block_size: Optional[_builtins.int] = None,
                 merge_selecting_sleep_ms: Optional[_builtins.int] = None,
                 merge_with_recompression_ttl_timeout: Optional[_builtins.int] = None,
                 merge_with_ttl_timeout: Optional[_builtins.int] = None,
                 min_age_to_force_merge_on_partition_only: Optional[_builtins.bool] = None,
                 min_age_to_force_merge_seconds: Optional[_builtins.int] = None,
                 min_bytes_for_wide_part: Optional[_builtins.int] = None,
                 min_rows_for_wide_part: Optional[_builtins.int] = None,
                 number_of_free_entries_in_pool_to_execute_mutation: Optional[_builtins.int] = None,
                 number_of_free_entries_in_pool_to_lower_max_size_of_merge: Optional[_builtins.int] = None,
                 parts_to_delay_insert: Optional[_builtins.int] = None,
                 parts_to_throw_insert: Optional[_builtins.int] = None,
                 replicated_deduplication_window: Optional[_builtins.int] = None,
                 replicated_deduplication_window_seconds: Optional[_builtins.int] = None,
                 ttl_only_drop_parts: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_remote_fs_zero_copy_replication: When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        :param _builtins.bool check_sample_column_is_correct: Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        :param _builtins.int cleanup_delay_period: Minimum period to clean old queue logs, blocks hashes and parts.
        :param _builtins.int inactive_parts_to_delay_insert: If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        :param _builtins.int inactive_parts_to_throw_insert: If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the `Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts` exception.
        :param _builtins.int max_avg_part_size_for_too_many_parts: The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        :param _builtins.int max_bytes_to_merge_at_max_space_in_pool: The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        :param _builtins.int max_bytes_to_merge_at_min_space_in_pool: Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        :param _builtins.int max_cleanup_delay_period: Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        :param _builtins.int max_merge_selecting_sleep_ms: Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        :param _builtins.int max_number_of_merges_with_ttl_in_pool: When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        :param _builtins.int max_parts_in_total: Maximum number of parts in all partitions.
        :param _builtins.int max_replicated_merges_in_queue: Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        :param _builtins.int merge_max_block_size: The number of rows that are read from the merged parts into memory. Default value: 8192.
        :param _builtins.int merge_selecting_sleep_ms: Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        :param _builtins.int merge_with_recompression_ttl_timeout: Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        :param _builtins.int merge_with_ttl_timeout: Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        :param _builtins.bool min_age_to_force_merge_on_partition_only: Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        :param _builtins.int min_age_to_force_merge_seconds: Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        :param _builtins.int min_bytes_for_wide_part: Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param _builtins.int min_rows_for_wide_part: Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param _builtins.int number_of_free_entries_in_pool_to_execute_mutation: When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid `Too many parts`. Default value: 20.
        :param _builtins.int number_of_free_entries_in_pool_to_lower_max_size_of_merge: Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        :param _builtins.int parts_to_delay_insert: Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table
        :param _builtins.int parts_to_throw_insert: Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        :param _builtins.int replicated_deduplication_window: Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        :param _builtins.int replicated_deduplication_window_seconds: Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        :param _builtins.bool ttl_only_drop_parts: Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        if allow_remote_fs_zero_copy_replication is not None:
            pulumi.set(__self__, "allow_remote_fs_zero_copy_replication", allow_remote_fs_zero_copy_replication)
        if check_sample_column_is_correct is not None:
            pulumi.set(__self__, "check_sample_column_is_correct", check_sample_column_is_correct)
        if cleanup_delay_period is not None:
            pulumi.set(__self__, "cleanup_delay_period", cleanup_delay_period)
        if inactive_parts_to_delay_insert is not None:
            pulumi.set(__self__, "inactive_parts_to_delay_insert", inactive_parts_to_delay_insert)
        if inactive_parts_to_throw_insert is not None:
            pulumi.set(__self__, "inactive_parts_to_throw_insert", inactive_parts_to_throw_insert)
        if max_avg_part_size_for_too_many_parts is not None:
            pulumi.set(__self__, "max_avg_part_size_for_too_many_parts", max_avg_part_size_for_too_many_parts)
        if max_bytes_to_merge_at_max_space_in_pool is not None:
            pulumi.set(__self__, "max_bytes_to_merge_at_max_space_in_pool", max_bytes_to_merge_at_max_space_in_pool)
        if max_bytes_to_merge_at_min_space_in_pool is not None:
            pulumi.set(__self__, "max_bytes_to_merge_at_min_space_in_pool", max_bytes_to_merge_at_min_space_in_pool)
        if max_cleanup_delay_period is not None:
            pulumi.set(__self__, "max_cleanup_delay_period", max_cleanup_delay_period)
        if max_merge_selecting_sleep_ms is not None:
            pulumi.set(__self__, "max_merge_selecting_sleep_ms", max_merge_selecting_sleep_ms)
        if max_number_of_merges_with_ttl_in_pool is not None:
            pulumi.set(__self__, "max_number_of_merges_with_ttl_in_pool", max_number_of_merges_with_ttl_in_pool)
        if max_parts_in_total is not None:
            pulumi.set(__self__, "max_parts_in_total", max_parts_in_total)
        if max_replicated_merges_in_queue is not None:
            pulumi.set(__self__, "max_replicated_merges_in_queue", max_replicated_merges_in_queue)
        if merge_max_block_size is not None:
            pulumi.set(__self__, "merge_max_block_size", merge_max_block_size)
        if merge_selecting_sleep_ms is not None:
            pulumi.set(__self__, "merge_selecting_sleep_ms", merge_selecting_sleep_ms)
        if merge_with_recompression_ttl_timeout is not None:
            pulumi.set(__self__, "merge_with_recompression_ttl_timeout", merge_with_recompression_ttl_timeout)
        if merge_with_ttl_timeout is not None:
            pulumi.set(__self__, "merge_with_ttl_timeout", merge_with_ttl_timeout)
        if min_age_to_force_merge_on_partition_only is not None:
            pulumi.set(__self__, "min_age_to_force_merge_on_partition_only", min_age_to_force_merge_on_partition_only)
        if min_age_to_force_merge_seconds is not None:
            pulumi.set(__self__, "min_age_to_force_merge_seconds", min_age_to_force_merge_seconds)
        if min_bytes_for_wide_part is not None:
            pulumi.set(__self__, "min_bytes_for_wide_part", min_bytes_for_wide_part)
        if min_rows_for_wide_part is not None:
            pulumi.set(__self__, "min_rows_for_wide_part", min_rows_for_wide_part)
        if number_of_free_entries_in_pool_to_execute_mutation is not None:
            pulumi.set(__self__, "number_of_free_entries_in_pool_to_execute_mutation", number_of_free_entries_in_pool_to_execute_mutation)
        if number_of_free_entries_in_pool_to_lower_max_size_of_merge is not None:
            pulumi.set(__self__, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", number_of_free_entries_in_pool_to_lower_max_size_of_merge)
        if parts_to_delay_insert is not None:
            pulumi.set(__self__, "parts_to_delay_insert", parts_to_delay_insert)
        if parts_to_throw_insert is not None:
            pulumi.set(__self__, "parts_to_throw_insert", parts_to_throw_insert)
        if replicated_deduplication_window is not None:
            pulumi.set(__self__, "replicated_deduplication_window", replicated_deduplication_window)
        if replicated_deduplication_window_seconds is not None:
            pulumi.set(__self__, "replicated_deduplication_window_seconds", replicated_deduplication_window_seconds)
        if ttl_only_drop_parts is not None:
            pulumi.set(__self__, "ttl_only_drop_parts", ttl_only_drop_parts)

    @_builtins.property
    @pulumi.getter(name="allowRemoteFsZeroCopyReplication")
    def allow_remote_fs_zero_copy_replication(self) -> Optional[_builtins.bool]:
        """
        When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        """
        return pulumi.get(self, "allow_remote_fs_zero_copy_replication")

    @_builtins.property
    @pulumi.getter(name="checkSampleColumnIsCorrect")
    def check_sample_column_is_correct(self) -> Optional[_builtins.bool]:
        """
        Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        """
        return pulumi.get(self, "check_sample_column_is_correct")

    @_builtins.property
    @pulumi.getter(name="cleanupDelayPeriod")
    def cleanup_delay_period(self) -> Optional[_builtins.int]:
        """
        Minimum period to clean old queue logs, blocks hashes and parts.
        """
        return pulumi.get(self, "cleanup_delay_period")

    @_builtins.property
    @pulumi.getter(name="inactivePartsToDelayInsert")
    def inactive_parts_to_delay_insert(self) -> Optional[_builtins.int]:
        """
        If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        """
        return pulumi.get(self, "inactive_parts_to_delay_insert")

    @_builtins.property
    @pulumi.getter(name="inactivePartsToThrowInsert")
    def inactive_parts_to_throw_insert(self) -> Optional[_builtins.int]:
        """
        If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the `Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts` exception.
        """
        return pulumi.get(self, "inactive_parts_to_throw_insert")

    @_builtins.property
    @pulumi.getter(name="maxAvgPartSizeForTooManyParts")
    def max_avg_part_size_for_too_many_parts(self) -> Optional[_builtins.int]:
        """
        The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        """
        return pulumi.get(self, "max_avg_part_size_for_too_many_parts")

    @_builtins.property
    @pulumi.getter(name="maxBytesToMergeAtMaxSpaceInPool")
    def max_bytes_to_merge_at_max_space_in_pool(self) -> Optional[_builtins.int]:
        """
        The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_max_space_in_pool")

    @_builtins.property
    @pulumi.getter(name="maxBytesToMergeAtMinSpaceInPool")
    def max_bytes_to_merge_at_min_space_in_pool(self) -> Optional[_builtins.int]:
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_min_space_in_pool")

    @_builtins.property
    @pulumi.getter(name="maxCleanupDelayPeriod")
    def max_cleanup_delay_period(self) -> Optional[_builtins.int]:
        """
        Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        """
        return pulumi.get(self, "max_cleanup_delay_period")

    @_builtins.property
    @pulumi.getter(name="maxMergeSelectingSleepMs")
    def max_merge_selecting_sleep_ms(self) -> Optional[_builtins.int]:
        """
        Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        """
        return pulumi.get(self, "max_merge_selecting_sleep_ms")

    @_builtins.property
    @pulumi.getter(name="maxNumberOfMergesWithTtlInPool")
    def max_number_of_merges_with_ttl_in_pool(self) -> Optional[_builtins.int]:
        """
        When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        """
        return pulumi.get(self, "max_number_of_merges_with_ttl_in_pool")

    @_builtins.property
    @pulumi.getter(name="maxPartsInTotal")
    def max_parts_in_total(self) -> Optional[_builtins.int]:
        """
        Maximum number of parts in all partitions.
        """
        return pulumi.get(self, "max_parts_in_total")

    @_builtins.property
    @pulumi.getter(name="maxReplicatedMergesInQueue")
    def max_replicated_merges_in_queue(self) -> Optional[_builtins.int]:
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        return pulumi.get(self, "max_replicated_merges_in_queue")

    @_builtins.property
    @pulumi.getter(name="mergeMaxBlockSize")
    def merge_max_block_size(self) -> Optional[_builtins.int]:
        """
        The number of rows that are read from the merged parts into memory. Default value: 8192.
        """
        return pulumi.get(self, "merge_max_block_size")

    @_builtins.property
    @pulumi.getter(name="mergeSelectingSleepMs")
    def merge_selecting_sleep_ms(self) -> Optional[_builtins.int]:
        """
        Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        """
        return pulumi.get(self, "merge_selecting_sleep_ms")

    @_builtins.property
    @pulumi.getter(name="mergeWithRecompressionTtlTimeout")
    def merge_with_recompression_ttl_timeout(self) -> Optional[_builtins.int]:
        """
        Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_recompression_ttl_timeout")

    @_builtins.property
    @pulumi.getter(name="mergeWithTtlTimeout")
    def merge_with_ttl_timeout(self) -> Optional[_builtins.int]:
        """
        Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_ttl_timeout")

    @_builtins.property
    @pulumi.getter(name="minAgeToForceMergeOnPartitionOnly")
    def min_age_to_force_merge_on_partition_only(self) -> Optional[_builtins.bool]:
        """
        Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        """
        return pulumi.get(self, "min_age_to_force_merge_on_partition_only")

    @_builtins.property
    @pulumi.getter(name="minAgeToForceMergeSeconds")
    def min_age_to_force_merge_seconds(self) -> Optional[_builtins.int]:
        """
        Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        """
        return pulumi.get(self, "min_age_to_force_merge_seconds")

    @_builtins.property
    @pulumi.getter(name="minBytesForWidePart")
    def min_bytes_for_wide_part(self) -> Optional[_builtins.int]:
        """
        Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_bytes_for_wide_part")

    @_builtins.property
    @pulumi.getter(name="minRowsForWidePart")
    def min_rows_for_wide_part(self) -> Optional[_builtins.int]:
        """
        Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_rows_for_wide_part")

    @_builtins.property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToExecuteMutation")
    def number_of_free_entries_in_pool_to_execute_mutation(self) -> Optional[_builtins.int]:
        """
        When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid `Too many parts`. Default value: 20.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_execute_mutation")

    @_builtins.property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge")
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self) -> Optional[_builtins.int]:
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge")

    @_builtins.property
    @pulumi.getter(name="partsToDelayInsert")
    def parts_to_delay_insert(self) -> Optional[_builtins.int]:
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table
        """
        return pulumi.get(self, "parts_to_delay_insert")

    @_builtins.property
    @pulumi.getter(name="partsToThrowInsert")
    def parts_to_throw_insert(self) -> Optional[_builtins.int]:
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        return pulumi.get(self, "parts_to_throw_insert")

    @_builtins.property
    @pulumi.getter(name="replicatedDeduplicationWindow")
    def replicated_deduplication_window(self) -> Optional[_builtins.int]:
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window")

    @_builtins.property
    @pulumi.getter(name="replicatedDeduplicationWindowSeconds")
    def replicated_deduplication_window_seconds(self) -> Optional[_builtins.int]:
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window_seconds")

    @_builtins.property
    @pulumi.getter(name="ttlOnlyDropParts")
    def ttl_only_drop_parts(self) -> Optional[_builtins.bool]:
        """
        Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        return pulumi.get(self, "ttl_only_drop_parts")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigQueryCache(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxEntries":
            suggest = "max_entries"
        elif key == "maxEntrySizeInBytes":
            suggest = "max_entry_size_in_bytes"
        elif key == "maxEntrySizeInRows":
            suggest = "max_entry_size_in_rows"
        elif key == "maxSizeInBytes":
            suggest = "max_size_in_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseConfigQueryCache. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseConfigQueryCache.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseConfigQueryCache.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_entries: Optional[_builtins.int] = None,
                 max_entry_size_in_bytes: Optional[_builtins.int] = None,
                 max_entry_size_in_rows: Optional[_builtins.int] = None,
                 max_size_in_bytes: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_entries: The maximum number of SELECT query results stored in the cache. Default value: 1024.
        :param _builtins.int max_entry_size_in_bytes: The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        :param _builtins.int max_entry_size_in_rows: The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        :param _builtins.int max_size_in_bytes: The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        if max_entries is not None:
            pulumi.set(__self__, "max_entries", max_entries)
        if max_entry_size_in_bytes is not None:
            pulumi.set(__self__, "max_entry_size_in_bytes", max_entry_size_in_bytes)
        if max_entry_size_in_rows is not None:
            pulumi.set(__self__, "max_entry_size_in_rows", max_entry_size_in_rows)
        if max_size_in_bytes is not None:
            pulumi.set(__self__, "max_size_in_bytes", max_size_in_bytes)

    @_builtins.property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> Optional[_builtins.int]:
        """
        The maximum number of SELECT query results stored in the cache. Default value: 1024.
        """
        return pulumi.get(self, "max_entries")

    @_builtins.property
    @pulumi.getter(name="maxEntrySizeInBytes")
    def max_entry_size_in_bytes(self) -> Optional[_builtins.int]:
        """
        The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        """
        return pulumi.get(self, "max_entry_size_in_bytes")

    @_builtins.property
    @pulumi.getter(name="maxEntrySizeInRows")
    def max_entry_size_in_rows(self) -> Optional[_builtins.int]:
        """
        The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        """
        return pulumi.get(self, "max_entry_size_in_rows")

    @_builtins.property
    @pulumi.getter(name="maxSizeInBytes")
    def max_size_in_bytes(self) -> Optional[_builtins.int]:
        """
        The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        return pulumi.get(self, "max_size_in_bytes")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigQueryMaskingRule(dict):
    def __init__(__self__, *,
                 regexp: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 replace: Optional[_builtins.str] = None):
        """
        :param _builtins.str regexp: RE2 compatible regular expression.
        :param _builtins.str name: Name for the rule.
        :param _builtins.str replace: Substitution string for sensitive data. Default value: six asterisks.
        """
        pulumi.set(__self__, "regexp", regexp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter
    def regexp(self) -> _builtins.str:
        """
        RE2 compatible regular expression.
        """
        return pulumi.get(self, "regexp")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name for the rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> Optional[_builtins.str]:
        """
        Substitution string for sensitive data. Default value: six asterisks.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class MdbClickhouseClusterClickhouseConfigRabbitmq(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None,
                 vhost: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: RabbitMQ user password.
        :param _builtins.str username: RabbitMQ username.
        :param _builtins.str vhost: RabbitMQ vhost. Default: `\\`.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        RabbitMQ username.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[_builtins.str]:
        """
        RabbitMQ vhost. Default: `\\`.
        """
        return pulumi.get(self, "vhost")


@pulumi.output_type
class MdbClickhouseClusterClickhouseResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterClickhouseResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterClickhouseResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterClickhouseResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ClickHouse host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a ClickHouse host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbClickhouseClusterCloudStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCacheEnabled":
            suggest = "data_cache_enabled"
        elif key == "dataCacheMaxSize":
            suggest = "data_cache_max_size"
        elif key == "moveFactor":
            suggest = "move_factor"
        elif key == "preferNotToMerge":
            suggest = "prefer_not_to_merge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterCloudStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterCloudStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterCloudStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 data_cache_enabled: Optional[_builtins.bool] = None,
                 data_cache_max_size: Optional[_builtins.int] = None,
                 move_factor: Optional[_builtins.float] = None,
                 prefer_not_to_merge: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        :param _builtins.bool data_cache_enabled: Enables temporary storage in the cluster repository of data requested from the object repository.
        :param _builtins.int data_cache_max_size: Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        :param _builtins.float move_factor: Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        :param _builtins.bool prefer_not_to_merge: Disables merging of data parts in `Yandex Object Storage`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if data_cache_enabled is not None:
            pulumi.set(__self__, "data_cache_enabled", data_cache_enabled)
        if data_cache_max_size is not None:
            pulumi.set(__self__, "data_cache_max_size", data_cache_max_size)
        if move_factor is not None:
            pulumi.set(__self__, "move_factor", move_factor)
        if prefer_not_to_merge is not None:
            pulumi.set(__self__, "prefer_not_to_merge", prefer_not_to_merge)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="dataCacheEnabled")
    def data_cache_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables temporary storage in the cluster repository of data requested from the object repository.
        """
        return pulumi.get(self, "data_cache_enabled")

    @_builtins.property
    @pulumi.getter(name="dataCacheMaxSize")
    def data_cache_max_size(self) -> Optional[_builtins.int]:
        """
        Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        """
        return pulumi.get(self, "data_cache_max_size")

    @_builtins.property
    @pulumi.getter(name="moveFactor")
    def move_factor(self) -> Optional[_builtins.float]:
        """
        Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        """
        return pulumi.get(self, "move_factor")

    @_builtins.property
    @pulumi.getter(name="preferNotToMerge")
    def prefer_not_to_merge(self) -> Optional[_builtins.bool]:
        """
        Disables merging of data parts in `Yandex Object Storage`.
        """
        return pulumi.get(self, "prefer_not_to_merge")


@pulumi.output_type
class MdbClickhouseClusterDatabase(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbClickhouseClusterFormatSchema(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 uri: _builtins.str):
        """
        :param _builtins.str name: The name of the format schema.
        :param _builtins.str type: Type of the format schema.
        :param _builtins.str uri: Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the format schema.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the format schema.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class MdbClickhouseClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "shardName":
            suggest = "shard_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 zone: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None,
                 shard_name: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str shard_name: The name of the shard to which the host belongs.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[_builtins.str]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbClickhouseClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbClickhouseClusterMlModel(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 uri: _builtins.str):
        """
        :param _builtins.str name: The name of the ml model.
        :param _builtins.str type: Type of the model.
        :param _builtins.str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the ml model.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the model.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class MdbClickhouseClusterShard(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 resources: Optional['outputs.MdbClickhouseClusterShardResources'] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: The name of shard.
        :param 'MdbClickhouseClusterShardResourcesArgs' resources: Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster.
        :param _builtins.int weight: The weight of shard.
        """
        pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of shard.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbClickhouseClusterShardResources']:
        """
        Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        The weight of shard.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class MdbClickhouseClusterShardGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shardNames":
            suggest = "shard_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterShardGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterShardGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterShardGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 shard_names: Sequence[_builtins.str],
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the shard group, used as cluster name in Distributed tables.
        :param Sequence[_builtins.str] shard_names: List of shards names that belong to the shard group.
        :param _builtins.str description: Description of the shard group.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "shard_names", shard_names)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the shard group, used as cluster name in Distributed tables.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="shardNames")
    def shard_names(self) -> Sequence[_builtins.str]:
        """
        List of shards names that belong to the shard group.
        """
        return pulumi.get(self, "shard_names")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the shard group.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class MdbClickhouseClusterShardResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterShardResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterShardResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterShardResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ClickHouse host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a ClickHouse host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbClickhouseClusterUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionManager":
            suggest = "connection_manager"
        elif key == "generatePassword":
            suggest = "generate_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 connection_manager: Optional[Mapping[str, _builtins.str]] = None,
                 generate_password: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 permissions: Optional[Sequence['outputs.MdbClickhouseClusterUserPermission']] = None,
                 quotas: Optional[Sequence['outputs.MdbClickhouseClusterUserQuota']] = None,
                 settings: Optional['outputs.MdbClickhouseClusterUserSettings'] = None):
        """
        :param _builtins.str name: The name of the user.
        :param Mapping[str, _builtins.str] connection_manager: Connection Manager connection configuration. Filled in by the server automatically.
        :param _builtins.bool generate_password: Generate password using Connection Manager. Allowed values: `true` or `false`. It's used only during user creation and is ignored during updating.
               
               > **Must specify either password or generate_password**.
        :param _builtins.str password: The password of the user.
        :param Sequence['MdbClickhouseClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        :param Sequence['MdbClickhouseClusterUserQuotaArgs'] quotas: Set of user quotas.
        :param 'MdbClickhouseClusterUserSettingsArgs' settings: Custom settings for user.
        """
        pulumi.set(__self__, "name", name)
        if connection_manager is not None:
            pulumi.set(__self__, "connection_manager", connection_manager)
        if generate_password is not None:
            pulumi.set(__self__, "generate_password", generate_password)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if quotas is not None:
            pulumi.set(__self__, "quotas", quotas)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="connectionManager")
    def connection_manager(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Connection Manager connection configuration. Filled in by the server automatically.
        """
        return pulumi.get(self, "connection_manager")

    @_builtins.property
    @pulumi.getter(name="generatePassword")
    def generate_password(self) -> Optional[_builtins.bool]:
        """
        Generate password using Connection Manager. Allowed values: `true` or `false`. It's used only during user creation and is ignored during updating.

        > **Must specify either password or generate_password**.
        """
        return pulumi.get(self, "generate_password")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbClickhouseClusterUserPermission']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def quotas(self) -> Optional[Sequence['outputs.MdbClickhouseClusterUserQuota']]:
        """
        Set of user quotas.
        """
        return pulumi.get(self, "quotas")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional['outputs.MdbClickhouseClusterUserSettings']:
        """
        Custom settings for user.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class MdbClickhouseClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class MdbClickhouseClusterUserQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDuration":
            suggest = "interval_duration"
        elif key == "executionTime":
            suggest = "execution_time"
        elif key == "readRows":
            suggest = "read_rows"
        elif key == "resultRows":
            suggest = "result_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUserQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUserQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUserQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_duration: _builtins.int,
                 errors: Optional[_builtins.int] = None,
                 execution_time: Optional[_builtins.int] = None,
                 queries: Optional[_builtins.int] = None,
                 read_rows: Optional[_builtins.int] = None,
                 result_rows: Optional[_builtins.int] = None):
        """
        :param _builtins.int interval_duration: Duration of interval for quota in milliseconds.
        :param _builtins.int errors: The number of queries that threw exception.
        :param _builtins.int execution_time: The total query execution time, in milliseconds (wall time).
        :param _builtins.int queries: The total number of queries.
        :param _builtins.int read_rows: The total number of source rows read from tables for running the query, on all remote servers.
        :param _builtins.int result_rows: The total number of rows given as the result.
        """
        pulumi.set(__self__, "interval_duration", interval_duration)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if execution_time is not None:
            pulumi.set(__self__, "execution_time", execution_time)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if read_rows is not None:
            pulumi.set(__self__, "read_rows", read_rows)
        if result_rows is not None:
            pulumi.set(__self__, "result_rows", result_rows)

    @_builtins.property
    @pulumi.getter(name="intervalDuration")
    def interval_duration(self) -> _builtins.int:
        """
        Duration of interval for quota in milliseconds.
        """
        return pulumi.get(self, "interval_duration")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[_builtins.int]:
        """
        The number of queries that threw exception.
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> Optional[_builtins.int]:
        """
        The total query execution time, in milliseconds (wall time).
        """
        return pulumi.get(self, "execution_time")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[_builtins.int]:
        """
        The total number of queries.
        """
        return pulumi.get(self, "queries")

    @_builtins.property
    @pulumi.getter(name="readRows")
    def read_rows(self) -> Optional[_builtins.int]:
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        return pulumi.get(self, "read_rows")

    @_builtins.property
    @pulumi.getter(name="resultRows")
    def result_rows(self) -> Optional[_builtins.int]:
        """
        The total number of rows given as the result.
        """
        return pulumi.get(self, "result_rows")


@pulumi.output_type
class MdbClickhouseClusterUserSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addHttpCorsHeader":
            suggest = "add_http_cors_header"
        elif key == "allowDdl":
            suggest = "allow_ddl"
        elif key == "allowIntrospectionFunctions":
            suggest = "allow_introspection_functions"
        elif key == "allowSuspiciousLowCardinalityTypes":
            suggest = "allow_suspicious_low_cardinality_types"
        elif key == "anyJoinDistinctRightTableKeys":
            suggest = "any_join_distinct_right_table_keys"
        elif key == "asyncInsert":
            suggest = "async_insert"
        elif key == "asyncInsertBusyTimeout":
            suggest = "async_insert_busy_timeout"
        elif key == "asyncInsertMaxDataSize":
            suggest = "async_insert_max_data_size"
        elif key == "asyncInsertStaleTimeout":
            suggest = "async_insert_stale_timeout"
        elif key == "asyncInsertThreads":
            suggest = "async_insert_threads"
        elif key == "asyncInsertUseAdaptiveBusyTimeout":
            suggest = "async_insert_use_adaptive_busy_timeout"
        elif key == "cancelHttpReadonlyQueriesOnClientClose":
            suggest = "cancel_http_readonly_queries_on_client_close"
        elif key == "compileExpressions":
            suggest = "compile_expressions"
        elif key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "connectTimeoutWithFailover":
            suggest = "connect_timeout_with_failover"
        elif key == "countDistinctImplementation":
            suggest = "count_distinct_implementation"
        elif key == "dataTypeDefaultNullable":
            suggest = "data_type_default_nullable"
        elif key == "dateTimeInputFormat":
            suggest = "date_time_input_format"
        elif key == "dateTimeOutputFormat":
            suggest = "date_time_output_format"
        elif key == "deduplicateBlocksInDependentMaterializedViews":
            suggest = "deduplicate_blocks_in_dependent_materialized_views"
        elif key == "distinctOverflowMode":
            suggest = "distinct_overflow_mode"
        elif key == "distributedAggregationMemoryEfficient":
            suggest = "distributed_aggregation_memory_efficient"
        elif key == "distributedDdlTaskTimeout":
            suggest = "distributed_ddl_task_timeout"
        elif key == "distributedProductMode":
            suggest = "distributed_product_mode"
        elif key == "doNotMergeAcrossPartitionsSelectFinal":
            suggest = "do_not_merge_across_partitions_select_final"
        elif key == "emptyResultForAggregationByEmptySet":
            suggest = "empty_result_for_aggregation_by_empty_set"
        elif key == "enableAnalyzer":
            suggest = "enable_analyzer"
        elif key == "enableHttpCompression":
            suggest = "enable_http_compression"
        elif key == "enableReadsFromQueryCache":
            suggest = "enable_reads_from_query_cache"
        elif key == "enableWritesToQueryCache":
            suggest = "enable_writes_to_query_cache"
        elif key == "fallbackToStaleReplicasForDistributedQueries":
            suggest = "fallback_to_stale_replicas_for_distributed_queries"
        elif key == "flattenNested":
            suggest = "flatten_nested"
        elif key == "forceIndexByDate":
            suggest = "force_index_by_date"
        elif key == "forcePrimaryKey":
            suggest = "force_primary_key"
        elif key == "formatAvroSchemaRegistryUrl":
            suggest = "format_avro_schema_registry_url"
        elif key == "formatRegexp":
            suggest = "format_regexp"
        elif key == "formatRegexpSkipUnmatched":
            suggest = "format_regexp_skip_unmatched"
        elif key == "groupByOverflowMode":
            suggest = "group_by_overflow_mode"
        elif key == "groupByTwoLevelThreshold":
            suggest = "group_by_two_level_threshold"
        elif key == "groupByTwoLevelThresholdBytes":
            suggest = "group_by_two_level_threshold_bytes"
        elif key == "hedgedConnectionTimeoutMs":
            suggest = "hedged_connection_timeout_ms"
        elif key == "httpConnectionTimeout":
            suggest = "http_connection_timeout"
        elif key == "httpHeadersProgressInterval":
            suggest = "http_headers_progress_interval"
        elif key == "httpMaxFieldNameSize":
            suggest = "http_max_field_name_size"
        elif key == "httpMaxFieldValueSize":
            suggest = "http_max_field_value_size"
        elif key == "httpReceiveTimeout":
            suggest = "http_receive_timeout"
        elif key == "httpSendTimeout":
            suggest = "http_send_timeout"
        elif key == "idleConnectionTimeout":
            suggest = "idle_connection_timeout"
        elif key == "ignoreMaterializedViewsWithDroppedTargetTable":
            suggest = "ignore_materialized_views_with_dropped_target_table"
        elif key == "inputFormatDefaultsForOmittedFields":
            suggest = "input_format_defaults_for_omitted_fields"
        elif key == "inputFormatImportNestedJson":
            suggest = "input_format_import_nested_json"
        elif key == "inputFormatNullAsDefault":
            suggest = "input_format_null_as_default"
        elif key == "inputFormatParallelParsing":
            suggest = "input_format_parallel_parsing"
        elif key == "inputFormatValuesInterpretExpressions":
            suggest = "input_format_values_interpret_expressions"
        elif key == "inputFormatWithNamesUseHeader":
            suggest = "input_format_with_names_use_header"
        elif key == "insertKeeperMaxRetries":
            suggest = "insert_keeper_max_retries"
        elif key == "insertNullAsDefault":
            suggest = "insert_null_as_default"
        elif key == "insertQuorum":
            suggest = "insert_quorum"
        elif key == "insertQuorumParallel":
            suggest = "insert_quorum_parallel"
        elif key == "insertQuorumTimeout":
            suggest = "insert_quorum_timeout"
        elif key == "joinAlgorithms":
            suggest = "join_algorithms"
        elif key == "joinOverflowMode":
            suggest = "join_overflow_mode"
        elif key == "joinUseNulls":
            suggest = "join_use_nulls"
        elif key == "joinedSubqueryRequiresAlias":
            suggest = "joined_subquery_requires_alias"
        elif key == "loadBalancing":
            suggest = "load_balancing"
        elif key == "localFilesystemReadMethod":
            suggest = "local_filesystem_read_method"
        elif key == "logProcessorsProfiles":
            suggest = "log_processors_profiles"
        elif key == "logQueriesProbability":
            suggest = "log_queries_probability"
        elif key == "logQueryThreads":
            suggest = "log_query_threads"
        elif key == "logQueryViews":
            suggest = "log_query_views"
        elif key == "lowCardinalityAllowInNativeFormat":
            suggest = "low_cardinality_allow_in_native_format"
        elif key == "maxAstDepth":
            suggest = "max_ast_depth"
        elif key == "maxAstElements":
            suggest = "max_ast_elements"
        elif key == "maxBlockSize":
            suggest = "max_block_size"
        elif key == "maxBytesBeforeExternalGroupBy":
            suggest = "max_bytes_before_external_group_by"
        elif key == "maxBytesBeforeExternalSort":
            suggest = "max_bytes_before_external_sort"
        elif key == "maxBytesInDistinct":
            suggest = "max_bytes_in_distinct"
        elif key == "maxBytesInJoin":
            suggest = "max_bytes_in_join"
        elif key == "maxBytesInSet":
            suggest = "max_bytes_in_set"
        elif key == "maxBytesToRead":
            suggest = "max_bytes_to_read"
        elif key == "maxBytesToSort":
            suggest = "max_bytes_to_sort"
        elif key == "maxBytesToTransfer":
            suggest = "max_bytes_to_transfer"
        elif key == "maxColumnsToRead":
            suggest = "max_columns_to_read"
        elif key == "maxConcurrentQueriesForUser":
            suggest = "max_concurrent_queries_for_user"
        elif key == "maxExecutionTime":
            suggest = "max_execution_time"
        elif key == "maxExpandedAstElements":
            suggest = "max_expanded_ast_elements"
        elif key == "maxFinalThreads":
            suggest = "max_final_threads"
        elif key == "maxHttpGetRedirects":
            suggest = "max_http_get_redirects"
        elif key == "maxInsertBlockSize":
            suggest = "max_insert_block_size"
        elif key == "maxInsertThreads":
            suggest = "max_insert_threads"
        elif key == "maxMemoryUsage":
            suggest = "max_memory_usage"
        elif key == "maxMemoryUsageForUser":
            suggest = "max_memory_usage_for_user"
        elif key == "maxNetworkBandwidth":
            suggest = "max_network_bandwidth"
        elif key == "maxNetworkBandwidthForUser":
            suggest = "max_network_bandwidth_for_user"
        elif key == "maxParserDepth":
            suggest = "max_parser_depth"
        elif key == "maxQuerySize":
            suggest = "max_query_size"
        elif key == "maxReadBufferSize":
            suggest = "max_read_buffer_size"
        elif key == "maxReplicaDelayForDistributedQueries":
            suggest = "max_replica_delay_for_distributed_queries"
        elif key == "maxResultBytes":
            suggest = "max_result_bytes"
        elif key == "maxResultRows":
            suggest = "max_result_rows"
        elif key == "maxRowsInDistinct":
            suggest = "max_rows_in_distinct"
        elif key == "maxRowsInJoin":
            suggest = "max_rows_in_join"
        elif key == "maxRowsInSet":
            suggest = "max_rows_in_set"
        elif key == "maxRowsToGroupBy":
            suggest = "max_rows_to_group_by"
        elif key == "maxRowsToRead":
            suggest = "max_rows_to_read"
        elif key == "maxRowsToSort":
            suggest = "max_rows_to_sort"
        elif key == "maxRowsToTransfer":
            suggest = "max_rows_to_transfer"
        elif key == "maxTemporaryColumns":
            suggest = "max_temporary_columns"
        elif key == "maxTemporaryDataOnDiskSizeForQuery":
            suggest = "max_temporary_data_on_disk_size_for_query"
        elif key == "maxTemporaryDataOnDiskSizeForUser":
            suggest = "max_temporary_data_on_disk_size_for_user"
        elif key == "maxTemporaryNonConstColumns":
            suggest = "max_temporary_non_const_columns"
        elif key == "maxThreads":
            suggest = "max_threads"
        elif key == "memoryOvercommitRatioDenominator":
            suggest = "memory_overcommit_ratio_denominator"
        elif key == "memoryOvercommitRatioDenominatorForUser":
            suggest = "memory_overcommit_ratio_denominator_for_user"
        elif key == "memoryProfilerSampleProbability":
            suggest = "memory_profiler_sample_probability"
        elif key == "memoryProfilerStep":
            suggest = "memory_profiler_step"
        elif key == "memoryUsageOvercommitMaxWaitMicroseconds":
            suggest = "memory_usage_overcommit_max_wait_microseconds"
        elif key == "mergeTreeMaxBytesToUseCache":
            suggest = "merge_tree_max_bytes_to_use_cache"
        elif key == "mergeTreeMaxRowsToUseCache":
            suggest = "merge_tree_max_rows_to_use_cache"
        elif key == "mergeTreeMinBytesForConcurrentRead":
            suggest = "merge_tree_min_bytes_for_concurrent_read"
        elif key == "mergeTreeMinRowsForConcurrentRead":
            suggest = "merge_tree_min_rows_for_concurrent_read"
        elif key == "minBytesToUseDirectIo":
            suggest = "min_bytes_to_use_direct_io"
        elif key == "minCountToCompile":
            suggest = "min_count_to_compile"
        elif key == "minCountToCompileExpression":
            suggest = "min_count_to_compile_expression"
        elif key == "minExecutionSpeed":
            suggest = "min_execution_speed"
        elif key == "minExecutionSpeedBytes":
            suggest = "min_execution_speed_bytes"
        elif key == "minInsertBlockSizeBytes":
            suggest = "min_insert_block_size_bytes"
        elif key == "minInsertBlockSizeRows":
            suggest = "min_insert_block_size_rows"
        elif key == "outputFormatJsonQuote64bitIntegers":
            suggest = "output_format_json_quote64bit_integers"
        elif key == "outputFormatJsonQuoteDenormals":
            suggest = "output_format_json_quote_denormals"
        elif key == "preferLocalhostReplica":
            suggest = "prefer_localhost_replica"
        elif key == "queryCacheMaxEntries":
            suggest = "query_cache_max_entries"
        elif key == "queryCacheMaxSizeInBytes":
            suggest = "query_cache_max_size_in_bytes"
        elif key == "queryCacheMinQueryDuration":
            suggest = "query_cache_min_query_duration"
        elif key == "queryCacheMinQueryRuns":
            suggest = "query_cache_min_query_runs"
        elif key == "queryCacheShareBetweenUsers":
            suggest = "query_cache_share_between_users"
        elif key == "queryCacheTag":
            suggest = "query_cache_tag"
        elif key == "queryCacheTtl":
            suggest = "query_cache_ttl"
        elif key == "quotaMode":
            suggest = "quota_mode"
        elif key == "readOverflowMode":
            suggest = "read_overflow_mode"
        elif key == "receiveTimeout":
            suggest = "receive_timeout"
        elif key == "remoteFilesystemReadMethod":
            suggest = "remote_filesystem_read_method"
        elif key == "replicationAlterPartitionsSync":
            suggest = "replication_alter_partitions_sync"
        elif key == "resultOverflowMode":
            suggest = "result_overflow_mode"
        elif key == "s3UseAdaptiveTimeouts":
            suggest = "s3_use_adaptive_timeouts"
        elif key == "selectSequentialConsistency":
            suggest = "select_sequential_consistency"
        elif key == "sendProgressInHttpHeaders":
            suggest = "send_progress_in_http_headers"
        elif key == "sendTimeout":
            suggest = "send_timeout"
        elif key == "setOverflowMode":
            suggest = "set_overflow_mode"
        elif key == "skipUnavailableShards":
            suggest = "skip_unavailable_shards"
        elif key == "sortOverflowMode":
            suggest = "sort_overflow_mode"
        elif key == "timeoutBeforeCheckingExecutionSpeed":
            suggest = "timeout_before_checking_execution_speed"
        elif key == "timeoutOverflowMode":
            suggest = "timeout_overflow_mode"
        elif key == "transferOverflowMode":
            suggest = "transfer_overflow_mode"
        elif key == "transformNullIn":
            suggest = "transform_null_in"
        elif key == "useHedgedRequests":
            suggest = "use_hedged_requests"
        elif key == "useQueryCache":
            suggest = "use_query_cache"
        elif key == "useUncompressedCache":
            suggest = "use_uncompressed_cache"
        elif key == "waitForAsyncInsert":
            suggest = "wait_for_async_insert"
        elif key == "waitForAsyncInsertTimeout":
            suggest = "wait_for_async_insert_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterUserSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterUserSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterUserSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_http_cors_header: Optional[_builtins.bool] = None,
                 allow_ddl: Optional[_builtins.bool] = None,
                 allow_introspection_functions: Optional[_builtins.bool] = None,
                 allow_suspicious_low_cardinality_types: Optional[_builtins.bool] = None,
                 any_join_distinct_right_table_keys: Optional[_builtins.bool] = None,
                 async_insert: Optional[_builtins.bool] = None,
                 async_insert_busy_timeout: Optional[_builtins.int] = None,
                 async_insert_max_data_size: Optional[_builtins.int] = None,
                 async_insert_stale_timeout: Optional[_builtins.int] = None,
                 async_insert_threads: Optional[_builtins.int] = None,
                 async_insert_use_adaptive_busy_timeout: Optional[_builtins.bool] = None,
                 cancel_http_readonly_queries_on_client_close: Optional[_builtins.bool] = None,
                 compile: Optional[_builtins.bool] = None,
                 compile_expressions: Optional[_builtins.bool] = None,
                 connect_timeout: Optional[_builtins.int] = None,
                 connect_timeout_with_failover: Optional[_builtins.int] = None,
                 count_distinct_implementation: Optional[_builtins.str] = None,
                 data_type_default_nullable: Optional[_builtins.bool] = None,
                 date_time_input_format: Optional[_builtins.str] = None,
                 date_time_output_format: Optional[_builtins.str] = None,
                 deduplicate_blocks_in_dependent_materialized_views: Optional[_builtins.bool] = None,
                 distinct_overflow_mode: Optional[_builtins.str] = None,
                 distributed_aggregation_memory_efficient: Optional[_builtins.bool] = None,
                 distributed_ddl_task_timeout: Optional[_builtins.int] = None,
                 distributed_product_mode: Optional[_builtins.str] = None,
                 do_not_merge_across_partitions_select_final: Optional[_builtins.bool] = None,
                 empty_result_for_aggregation_by_empty_set: Optional[_builtins.bool] = None,
                 enable_analyzer: Optional[_builtins.bool] = None,
                 enable_http_compression: Optional[_builtins.bool] = None,
                 enable_reads_from_query_cache: Optional[_builtins.bool] = None,
                 enable_writes_to_query_cache: Optional[_builtins.bool] = None,
                 fallback_to_stale_replicas_for_distributed_queries: Optional[_builtins.bool] = None,
                 flatten_nested: Optional[_builtins.bool] = None,
                 force_index_by_date: Optional[_builtins.bool] = None,
                 force_primary_key: Optional[_builtins.bool] = None,
                 format_avro_schema_registry_url: Optional[_builtins.str] = None,
                 format_regexp: Optional[_builtins.str] = None,
                 format_regexp_skip_unmatched: Optional[_builtins.bool] = None,
                 group_by_overflow_mode: Optional[_builtins.str] = None,
                 group_by_two_level_threshold: Optional[_builtins.int] = None,
                 group_by_two_level_threshold_bytes: Optional[_builtins.int] = None,
                 hedged_connection_timeout_ms: Optional[_builtins.int] = None,
                 http_connection_timeout: Optional[_builtins.int] = None,
                 http_headers_progress_interval: Optional[_builtins.int] = None,
                 http_max_field_name_size: Optional[_builtins.int] = None,
                 http_max_field_value_size: Optional[_builtins.int] = None,
                 http_receive_timeout: Optional[_builtins.int] = None,
                 http_send_timeout: Optional[_builtins.int] = None,
                 idle_connection_timeout: Optional[_builtins.int] = None,
                 ignore_materialized_views_with_dropped_target_table: Optional[_builtins.bool] = None,
                 input_format_defaults_for_omitted_fields: Optional[_builtins.bool] = None,
                 input_format_import_nested_json: Optional[_builtins.bool] = None,
                 input_format_null_as_default: Optional[_builtins.bool] = None,
                 input_format_parallel_parsing: Optional[_builtins.bool] = None,
                 input_format_values_interpret_expressions: Optional[_builtins.bool] = None,
                 input_format_with_names_use_header: Optional[_builtins.bool] = None,
                 insert_keeper_max_retries: Optional[_builtins.int] = None,
                 insert_null_as_default: Optional[_builtins.bool] = None,
                 insert_quorum: Optional[_builtins.int] = None,
                 insert_quorum_parallel: Optional[_builtins.bool] = None,
                 insert_quorum_timeout: Optional[_builtins.int] = None,
                 join_algorithms: Optional[Sequence[_builtins.str]] = None,
                 join_overflow_mode: Optional[_builtins.str] = None,
                 join_use_nulls: Optional[_builtins.bool] = None,
                 joined_subquery_requires_alias: Optional[_builtins.bool] = None,
                 load_balancing: Optional[_builtins.str] = None,
                 local_filesystem_read_method: Optional[_builtins.str] = None,
                 log_processors_profiles: Optional[_builtins.bool] = None,
                 log_queries_probability: Optional[_builtins.float] = None,
                 log_query_threads: Optional[_builtins.bool] = None,
                 log_query_views: Optional[_builtins.bool] = None,
                 low_cardinality_allow_in_native_format: Optional[_builtins.bool] = None,
                 max_ast_depth: Optional[_builtins.int] = None,
                 max_ast_elements: Optional[_builtins.int] = None,
                 max_block_size: Optional[_builtins.int] = None,
                 max_bytes_before_external_group_by: Optional[_builtins.int] = None,
                 max_bytes_before_external_sort: Optional[_builtins.int] = None,
                 max_bytes_in_distinct: Optional[_builtins.int] = None,
                 max_bytes_in_join: Optional[_builtins.int] = None,
                 max_bytes_in_set: Optional[_builtins.int] = None,
                 max_bytes_to_read: Optional[_builtins.int] = None,
                 max_bytes_to_sort: Optional[_builtins.int] = None,
                 max_bytes_to_transfer: Optional[_builtins.int] = None,
                 max_columns_to_read: Optional[_builtins.int] = None,
                 max_concurrent_queries_for_user: Optional[_builtins.int] = None,
                 max_execution_time: Optional[_builtins.int] = None,
                 max_expanded_ast_elements: Optional[_builtins.int] = None,
                 max_final_threads: Optional[_builtins.int] = None,
                 max_http_get_redirects: Optional[_builtins.int] = None,
                 max_insert_block_size: Optional[_builtins.int] = None,
                 max_insert_threads: Optional[_builtins.int] = None,
                 max_memory_usage: Optional[_builtins.int] = None,
                 max_memory_usage_for_user: Optional[_builtins.int] = None,
                 max_network_bandwidth: Optional[_builtins.int] = None,
                 max_network_bandwidth_for_user: Optional[_builtins.int] = None,
                 max_parser_depth: Optional[_builtins.int] = None,
                 max_query_size: Optional[_builtins.int] = None,
                 max_read_buffer_size: Optional[_builtins.int] = None,
                 max_replica_delay_for_distributed_queries: Optional[_builtins.int] = None,
                 max_result_bytes: Optional[_builtins.int] = None,
                 max_result_rows: Optional[_builtins.int] = None,
                 max_rows_in_distinct: Optional[_builtins.int] = None,
                 max_rows_in_join: Optional[_builtins.int] = None,
                 max_rows_in_set: Optional[_builtins.int] = None,
                 max_rows_to_group_by: Optional[_builtins.int] = None,
                 max_rows_to_read: Optional[_builtins.int] = None,
                 max_rows_to_sort: Optional[_builtins.int] = None,
                 max_rows_to_transfer: Optional[_builtins.int] = None,
                 max_temporary_columns: Optional[_builtins.int] = None,
                 max_temporary_data_on_disk_size_for_query: Optional[_builtins.int] = None,
                 max_temporary_data_on_disk_size_for_user: Optional[_builtins.int] = None,
                 max_temporary_non_const_columns: Optional[_builtins.int] = None,
                 max_threads: Optional[_builtins.int] = None,
                 memory_overcommit_ratio_denominator: Optional[_builtins.int] = None,
                 memory_overcommit_ratio_denominator_for_user: Optional[_builtins.int] = None,
                 memory_profiler_sample_probability: Optional[_builtins.float] = None,
                 memory_profiler_step: Optional[_builtins.int] = None,
                 memory_usage_overcommit_max_wait_microseconds: Optional[_builtins.int] = None,
                 merge_tree_max_bytes_to_use_cache: Optional[_builtins.int] = None,
                 merge_tree_max_rows_to_use_cache: Optional[_builtins.int] = None,
                 merge_tree_min_bytes_for_concurrent_read: Optional[_builtins.int] = None,
                 merge_tree_min_rows_for_concurrent_read: Optional[_builtins.int] = None,
                 min_bytes_to_use_direct_io: Optional[_builtins.int] = None,
                 min_count_to_compile: Optional[_builtins.int] = None,
                 min_count_to_compile_expression: Optional[_builtins.int] = None,
                 min_execution_speed: Optional[_builtins.int] = None,
                 min_execution_speed_bytes: Optional[_builtins.int] = None,
                 min_insert_block_size_bytes: Optional[_builtins.int] = None,
                 min_insert_block_size_rows: Optional[_builtins.int] = None,
                 output_format_json_quote64bit_integers: Optional[_builtins.bool] = None,
                 output_format_json_quote_denormals: Optional[_builtins.bool] = None,
                 prefer_localhost_replica: Optional[_builtins.bool] = None,
                 priority: Optional[_builtins.int] = None,
                 query_cache_max_entries: Optional[_builtins.int] = None,
                 query_cache_max_size_in_bytes: Optional[_builtins.int] = None,
                 query_cache_min_query_duration: Optional[_builtins.int] = None,
                 query_cache_min_query_runs: Optional[_builtins.int] = None,
                 query_cache_share_between_users: Optional[_builtins.bool] = None,
                 query_cache_tag: Optional[_builtins.str] = None,
                 query_cache_ttl: Optional[_builtins.int] = None,
                 quota_mode: Optional[_builtins.str] = None,
                 read_overflow_mode: Optional[_builtins.str] = None,
                 readonly: Optional[_builtins.int] = None,
                 receive_timeout: Optional[_builtins.int] = None,
                 remote_filesystem_read_method: Optional[_builtins.str] = None,
                 replication_alter_partitions_sync: Optional[_builtins.int] = None,
                 result_overflow_mode: Optional[_builtins.str] = None,
                 s3_use_adaptive_timeouts: Optional[_builtins.bool] = None,
                 select_sequential_consistency: Optional[_builtins.bool] = None,
                 send_progress_in_http_headers: Optional[_builtins.bool] = None,
                 send_timeout: Optional[_builtins.int] = None,
                 set_overflow_mode: Optional[_builtins.str] = None,
                 skip_unavailable_shards: Optional[_builtins.bool] = None,
                 sort_overflow_mode: Optional[_builtins.str] = None,
                 timeout_before_checking_execution_speed: Optional[_builtins.int] = None,
                 timeout_overflow_mode: Optional[_builtins.str] = None,
                 transfer_overflow_mode: Optional[_builtins.str] = None,
                 transform_null_in: Optional[_builtins.bool] = None,
                 use_hedged_requests: Optional[_builtins.bool] = None,
                 use_query_cache: Optional[_builtins.bool] = None,
                 use_uncompressed_cache: Optional[_builtins.bool] = None,
                 wait_for_async_insert: Optional[_builtins.bool] = None,
                 wait_for_async_insert_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool add_http_cors_header: Include CORS headers in HTTP responses.
        :param _builtins.bool allow_ddl: Allows or denies DDL queries.
        :param _builtins.bool allow_introspection_functions: Enables introspections functions for query profiling.
        :param _builtins.bool allow_suspicious_low_cardinality_types: Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        :param _builtins.bool any_join_distinct_right_table_keys: Enables legacy ClickHouse server behavior in ANY INNER|LEFT JOIN operations.
        :param _builtins.bool async_insert: Enables asynchronous inserts. Disabled by default.
        :param _builtins.int async_insert_busy_timeout: The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        :param _builtins.int async_insert_max_data_size: The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        :param _builtins.int async_insert_stale_timeout: The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        :param _builtins.int async_insert_threads: The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        :param _builtins.bool async_insert_use_adaptive_busy_timeout: If it is set to true, use adaptive busy timeout for asynchronous inserts.
        :param _builtins.bool cancel_http_readonly_queries_on_client_close: Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        :param _builtins.bool compile: Enable compilation of queries.
        :param _builtins.bool compile_expressions: Turn on expression compilation.
        :param _builtins.int connect_timeout: Connect timeout in milliseconds on the socket used for communicating with the client.
        :param _builtins.int connect_timeout_with_failover: The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        :param _builtins.str count_distinct_implementation: Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        :param _builtins.bool data_type_default_nullable: Allows data types without explicit modifiers NULL or NOT NULL in column definition will be Nullable.
        :param _builtins.str date_time_input_format: Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        :param _builtins.str date_time_output_format: Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        :param _builtins.bool deduplicate_blocks_in_dependent_materialized_views: Enables or disables the deduplication check for materialized views that receive data from `Replicated` tables.
        :param _builtins.str distinct_overflow_mode: Sets behavior on overflow when using DISTINCT. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool distributed_aggregation_memory_efficient: Determine the behavior of distributed subqueries.
        :param _builtins.int distributed_ddl_task_timeout: Timeout for DDL queries, in milliseconds.
        :param _builtins.str distributed_product_mode: Changes the behavior of distributed subqueries.
        :param _builtins.bool do_not_merge_across_partitions_select_final: Enable or disable independent processing of partitions for **SELECT** queries with **FINAL**.
        :param _builtins.bool empty_result_for_aggregation_by_empty_set: Allows to return empty result.
        :param _builtins.bool enable_analyzer: Enable new query analyzer.
        :param _builtins.bool enable_http_compression: Enables or disables data compression in the response to an HTTP request.
        :param _builtins.bool enable_reads_from_query_cache: If turned on, results of SELECT queries are retrieved from the query cache.
        :param _builtins.bool enable_writes_to_query_cache: If turned on, results of SELECT queries are stored in the query cache.
        :param _builtins.bool fallback_to_stale_replicas_for_distributed_queries: Forces a query to an out-of-date replica if updated data is not available.
        :param _builtins.bool flatten_nested: Sets the data format of a nested columns.
        :param _builtins.bool force_index_by_date: Disables query execution if the index cant be used by date.
        :param _builtins.bool force_primary_key: Disables query execution if indexing by the primary key is not possible.
        :param _builtins.str format_avro_schema_registry_url: Avro schema registry URL.
        :param _builtins.str format_regexp: Regular expression (for Regexp format).
        :param _builtins.bool format_regexp_skip_unmatched: Skip lines unmatched by regular expression.
        :param _builtins.str group_by_overflow_mode: Sets behavior on overflow while GROUP BY operation. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
               * `any` - perform approximate GROUP BY operation by continuing aggregation for the keys that got into the set, but dont add new keys to the set.
        :param _builtins.int group_by_two_level_threshold: Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        :param _builtins.int group_by_two_level_threshold_bytes: Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        :param _builtins.int hedged_connection_timeout_ms: Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        :param _builtins.int http_connection_timeout: Timeout for HTTP connection in milliseconds.
        :param _builtins.int http_headers_progress_interval: Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        :param _builtins.int http_max_field_name_size: Maximum length of field name in HTTP header.
        :param _builtins.int http_max_field_value_size: Maximum length of field value in HTTP header.
        :param _builtins.int http_receive_timeout: Timeout for HTTP connection in milliseconds.
        :param _builtins.int http_send_timeout: Timeout for HTTP connection in milliseconds.
        :param _builtins.int idle_connection_timeout: Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        :param _builtins.bool ignore_materialized_views_with_dropped_target_table: Ignore materialized views with dropped target table during pushing to views.
        :param _builtins.bool input_format_defaults_for_omitted_fields: When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        :param _builtins.bool input_format_import_nested_json: Enables or disables the insertion of JSON data with nested objects.
        :param _builtins.bool input_format_null_as_default: Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        :param _builtins.bool input_format_parallel_parsing: Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        :param _builtins.bool input_format_values_interpret_expressions: Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        :param _builtins.bool input_format_with_names_use_header: Enables or disables checking the column order when inserting data.
        :param _builtins.int insert_keeper_max_retries: The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        :param _builtins.bool insert_null_as_default: Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        :param _builtins.int insert_quorum: Enables the quorum writes.
        :param _builtins.bool insert_quorum_parallel: Enables or disables parallelism for quorum INSERT queries.
        :param _builtins.int insert_quorum_timeout: Write to a quorum timeout in milliseconds.
        :param Sequence[_builtins.str] join_algorithms: Specifies which JOIN algorithm is used. Possible values:
               * `hash` - hash join algorithm is used. The most generic implementation that supports all combinations of kind and strictness and multiple join keys that are combined with OR in the JOIN ON section.
               * `parallel_hash` - a variation of hash join that splits the data into buckets and builds several hash tables instead of one concurrently to speed up this process.
               * `partial_merge` - a variation of the sort-merge algorithm, where only the right table is fully sorted.
               * `direct` - this algorithm can be applied when the storage for the right table supports key-value requests.
               * `auto` - when set to auto, hash join is tried first, and the algorithm is switched on the fly to another algorithm if the memory limit is violated.
               * `full_sorting_merge` - sort-merge algorithm with full sorting joined tables before joining.
               * `prefer_partial_merge` - clickHouse always tries to use partial_merge join if possible, otherwise, it uses hash. Deprecated, same as partial_merge,hash.
        :param _builtins.str join_overflow_mode: Sets behavior on overflow in JOIN. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool join_use_nulls: Sets the type of JOIN behavior. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        :param _builtins.bool joined_subquery_requires_alias: Require aliases for subselects and table functions in FROM that more than one table is present.
        :param _builtins.str load_balancing: Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        :param _builtins.str local_filesystem_read_method: Method of reading data from local filesystem. Possible values:
               * `read` - abort query execution, return an error.
               * `pread` - abort query execution, return an error.
               * `pread_threadpool` - stop query execution, return partial result. If the parameter is set to 0 (default), no hops is allowed.
        :param _builtins.bool log_processors_profiles: Enabled or disable logging of processors level profiling data to the the system.log_processors_profiles table.
        :param _builtins.float log_queries_probability: Log queries with the specified probability.
        :param _builtins.bool log_query_threads: Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: `true`.
        :param _builtins.bool log_query_views: Enables or disables query views logging to the the system.query_views_log table.
        :param _builtins.bool low_cardinality_allow_in_native_format: Allows or restricts using the LowCardinality data type with the Native format.
        :param _builtins.int max_ast_depth: Maximum abstract syntax tree depth.
        :param _builtins.int max_ast_elements: Maximum abstract syntax tree elements.
        :param _builtins.int max_block_size: A recommendation for what size of the block (in a count of rows) to load from tables.
        :param _builtins.int max_bytes_before_external_group_by: Limit in bytes for using memory for GROUP BY before using swap on disk.
        :param _builtins.int max_bytes_before_external_sort: This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        :param _builtins.int max_bytes_in_distinct: Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        :param _builtins.int max_bytes_in_join: Limit on maximum size of the hash table for JOIN, in bytes.
        :param _builtins.int max_bytes_in_set: Limit on the number of bytes in the set resulting from the execution of the IN section.
        :param _builtins.int max_bytes_to_read: Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        :param _builtins.int max_bytes_to_sort: Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        :param _builtins.int max_bytes_to_transfer: Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param _builtins.int max_columns_to_read: Limits the maximum number of columns that can be read from a table in a single query.
        :param _builtins.int max_concurrent_queries_for_user: The maximum number of concurrent requests per user. Default value: 0 (no limit).
        :param _builtins.int max_execution_time: Limits the maximum query execution time in milliseconds.
        :param _builtins.int max_expanded_ast_elements: Maximum abstract syntax tree depth after after expansion of aliases.
        :param _builtins.int max_final_threads: Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        :param _builtins.int max_http_get_redirects: Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        :param _builtins.int max_insert_block_size: The size of blocks (in a count of rows) to form for insertion into a table.
        :param _builtins.int max_insert_threads: The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        :param _builtins.int max_memory_usage: Limits the maximum memory usage (in bytes) for processing queries on a single server.
        :param _builtins.int max_memory_usage_for_user: Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        :param _builtins.int max_network_bandwidth: Limits the speed of the data exchange over the network in bytes per second.
        :param _builtins.int max_network_bandwidth_for_user: Limits the speed of the data exchange over the network in bytes per second.
        :param _builtins.int max_parser_depth: Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        :param _builtins.int max_query_size: The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        :param _builtins.int max_read_buffer_size: The maximum size of the buffer to read from the filesystem.
        :param _builtins.int max_replica_delay_for_distributed_queries: Disables lagging replicas for distributed queries.
        :param _builtins.int max_result_bytes: Limits the number of bytes in the result.
        :param _builtins.int max_result_rows: Limits the number of rows in the result.
        :param _builtins.int max_rows_in_distinct: Limits the maximum number of different rows when using DISTINCT.
        :param _builtins.int max_rows_in_join: Limit on maximum size of the hash table for JOIN, in rows.
        :param _builtins.int max_rows_in_set: Limit on the number of rows in the set resulting from the execution of the IN section.
        :param _builtins.int max_rows_to_group_by: Limits the maximum number of unique keys received from aggregation function.
        :param _builtins.int max_rows_to_read: Limits the maximum number of rows that can be read from a table when running a query.
        :param _builtins.int max_rows_to_sort: Limits the maximum number of rows that can be read from a table for sorting.
        :param _builtins.int max_rows_to_transfer: Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param _builtins.int max_temporary_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        :param _builtins.int max_temporary_data_on_disk_size_for_query: The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        :param _builtins.int max_temporary_data_on_disk_size_for_user: The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        :param _builtins.int max_temporary_non_const_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        :param _builtins.int max_threads: The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        :param _builtins.int memory_overcommit_ratio_denominator: It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param _builtins.int memory_overcommit_ratio_denominator_for_user: It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param _builtins.float memory_profiler_sample_probability: Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        :param _builtins.int memory_profiler_step: Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        :param _builtins.int memory_usage_overcommit_max_wait_microseconds: Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        :param _builtins.int merge_tree_max_bytes_to_use_cache: If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        :param _builtins.int merge_tree_max_rows_to_use_cache: If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        :param _builtins.int merge_tree_min_bytes_for_concurrent_read: If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        :param _builtins.int merge_tree_min_rows_for_concurrent_read: If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        :param _builtins.int min_bytes_to_use_direct_io: The minimum data volume required for using direct I/O access to the storage disk.
        :param _builtins.int min_count_to_compile: How many times to potentially use a compiled chunk of code before running compilation.
        :param _builtins.int min_count_to_compile_expression: A query waits for expression compilation process to complete prior to continuing execution.
        :param _builtins.int min_execution_speed: Minimal execution speed in rows per second.
        :param _builtins.int min_execution_speed_bytes: Minimal execution speed in bytes per second.
        :param _builtins.int min_insert_block_size_bytes: Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        :param _builtins.int min_insert_block_size_rows: Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        :param _builtins.bool output_format_json_quote64bit_integers: If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        :param _builtins.bool output_format_json_quote_denormals: Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        :param _builtins.bool prefer_localhost_replica: Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        :param _builtins.int priority: Query priority.
        :param _builtins.int query_cache_max_entries: The maximum number of query results the current user may store in the query cache. 0 means unlimited.
        :param _builtins.int query_cache_max_size_in_bytes: The maximum amount of memory (in bytes) the current user may allocate in the query cache. 0 means unlimited.
        :param _builtins.int query_cache_min_query_duration: Minimum duration in milliseconds a query needs to run for its result to be stored in the query cache.
        :param _builtins.int query_cache_min_query_runs: Minimum number of times a SELECT query must run before its result is stored in the query cache.
        :param _builtins.bool query_cache_share_between_users: If turned on, the result of SELECT queries cached in the query cache can be read by other users. It is not recommended to enable this setting due to security reasons.
        :param _builtins.str query_cache_tag: A string which acts as a label for query cache entries. The same queries with different tags are considered different by the query cache.
        :param _builtins.int query_cache_ttl: After this time in seconds entries in the query cache become stale.
        :param _builtins.str quota_mode: Quota accounting mode.
        :param _builtins.str read_overflow_mode: Sets behavior on overflow while read. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.int readonly: Restricts permissions for reading data, write data and change settings queries.
        :param _builtins.int receive_timeout: Receive timeout in milliseconds on the socket used for communicating with the client.
        :param _builtins.str remote_filesystem_read_method: Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        :param _builtins.int replication_alter_partitions_sync: For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        :param _builtins.str result_overflow_mode: Sets behavior on overflow in result. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool s3_use_adaptive_timeouts: Enables or disables adaptive timeouts for S3 requests.
        :param _builtins.bool select_sequential_consistency: Enables or disables sequential consistency for SELECT queries.
        :param _builtins.bool send_progress_in_http_headers: Enables or disables `X-ClickHouse-Progress` HTTP response headers in clickhouse-server responses.
        :param _builtins.int send_timeout: Send timeout in milliseconds on the socket used for communicating with the client.
        :param _builtins.str set_overflow_mode: Sets behavior on overflow in the set resulting. Possible values:
                 * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool skip_unavailable_shards: Enables or disables silently skipping of unavailable shards.
        :param _builtins.str sort_overflow_mode: Sets behavior on overflow while sort. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.int timeout_before_checking_execution_speed: Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        :param _builtins.str timeout_overflow_mode: Sets behavior on overflow. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.str transfer_overflow_mode: Sets behavior on overflow. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool transform_null_in: Enables equality of NULL values for IN operator.
        :param _builtins.bool use_hedged_requests: Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        :param _builtins.bool use_query_cache: If turned on, SELECT queries may utilize the query cache.
        :param _builtins.bool use_uncompressed_cache: Whether to use a cache of uncompressed blocks.
        :param _builtins.bool wait_for_async_insert: Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        :param _builtins.int wait_for_async_insert_timeout: The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        if add_http_cors_header is not None:
            pulumi.set(__self__, "add_http_cors_header", add_http_cors_header)
        if allow_ddl is not None:
            pulumi.set(__self__, "allow_ddl", allow_ddl)
        if allow_introspection_functions is not None:
            pulumi.set(__self__, "allow_introspection_functions", allow_introspection_functions)
        if allow_suspicious_low_cardinality_types is not None:
            pulumi.set(__self__, "allow_suspicious_low_cardinality_types", allow_suspicious_low_cardinality_types)
        if any_join_distinct_right_table_keys is not None:
            pulumi.set(__self__, "any_join_distinct_right_table_keys", any_join_distinct_right_table_keys)
        if async_insert is not None:
            pulumi.set(__self__, "async_insert", async_insert)
        if async_insert_busy_timeout is not None:
            pulumi.set(__self__, "async_insert_busy_timeout", async_insert_busy_timeout)
        if async_insert_max_data_size is not None:
            pulumi.set(__self__, "async_insert_max_data_size", async_insert_max_data_size)
        if async_insert_stale_timeout is not None:
            pulumi.set(__self__, "async_insert_stale_timeout", async_insert_stale_timeout)
        if async_insert_threads is not None:
            pulumi.set(__self__, "async_insert_threads", async_insert_threads)
        if async_insert_use_adaptive_busy_timeout is not None:
            pulumi.set(__self__, "async_insert_use_adaptive_busy_timeout", async_insert_use_adaptive_busy_timeout)
        if cancel_http_readonly_queries_on_client_close is not None:
            pulumi.set(__self__, "cancel_http_readonly_queries_on_client_close", cancel_http_readonly_queries_on_client_close)
        if compile is not None:
            pulumi.set(__self__, "compile", compile)
        if compile_expressions is not None:
            pulumi.set(__self__, "compile_expressions", compile_expressions)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if connect_timeout_with_failover is not None:
            pulumi.set(__self__, "connect_timeout_with_failover", connect_timeout_with_failover)
        if count_distinct_implementation is not None:
            pulumi.set(__self__, "count_distinct_implementation", count_distinct_implementation)
        if data_type_default_nullable is not None:
            pulumi.set(__self__, "data_type_default_nullable", data_type_default_nullable)
        if date_time_input_format is not None:
            pulumi.set(__self__, "date_time_input_format", date_time_input_format)
        if date_time_output_format is not None:
            pulumi.set(__self__, "date_time_output_format", date_time_output_format)
        if deduplicate_blocks_in_dependent_materialized_views is not None:
            pulumi.set(__self__, "deduplicate_blocks_in_dependent_materialized_views", deduplicate_blocks_in_dependent_materialized_views)
        if distinct_overflow_mode is not None:
            pulumi.set(__self__, "distinct_overflow_mode", distinct_overflow_mode)
        if distributed_aggregation_memory_efficient is not None:
            pulumi.set(__self__, "distributed_aggregation_memory_efficient", distributed_aggregation_memory_efficient)
        if distributed_ddl_task_timeout is not None:
            pulumi.set(__self__, "distributed_ddl_task_timeout", distributed_ddl_task_timeout)
        if distributed_product_mode is not None:
            pulumi.set(__self__, "distributed_product_mode", distributed_product_mode)
        if do_not_merge_across_partitions_select_final is not None:
            pulumi.set(__self__, "do_not_merge_across_partitions_select_final", do_not_merge_across_partitions_select_final)
        if empty_result_for_aggregation_by_empty_set is not None:
            pulumi.set(__self__, "empty_result_for_aggregation_by_empty_set", empty_result_for_aggregation_by_empty_set)
        if enable_analyzer is not None:
            pulumi.set(__self__, "enable_analyzer", enable_analyzer)
        if enable_http_compression is not None:
            pulumi.set(__self__, "enable_http_compression", enable_http_compression)
        if enable_reads_from_query_cache is not None:
            pulumi.set(__self__, "enable_reads_from_query_cache", enable_reads_from_query_cache)
        if enable_writes_to_query_cache is not None:
            pulumi.set(__self__, "enable_writes_to_query_cache", enable_writes_to_query_cache)
        if fallback_to_stale_replicas_for_distributed_queries is not None:
            pulumi.set(__self__, "fallback_to_stale_replicas_for_distributed_queries", fallback_to_stale_replicas_for_distributed_queries)
        if flatten_nested is not None:
            pulumi.set(__self__, "flatten_nested", flatten_nested)
        if force_index_by_date is not None:
            pulumi.set(__self__, "force_index_by_date", force_index_by_date)
        if force_primary_key is not None:
            pulumi.set(__self__, "force_primary_key", force_primary_key)
        if format_avro_schema_registry_url is not None:
            pulumi.set(__self__, "format_avro_schema_registry_url", format_avro_schema_registry_url)
        if format_regexp is not None:
            pulumi.set(__self__, "format_regexp", format_regexp)
        if format_regexp_skip_unmatched is not None:
            pulumi.set(__self__, "format_regexp_skip_unmatched", format_regexp_skip_unmatched)
        if group_by_overflow_mode is not None:
            pulumi.set(__self__, "group_by_overflow_mode", group_by_overflow_mode)
        if group_by_two_level_threshold is not None:
            pulumi.set(__self__, "group_by_two_level_threshold", group_by_two_level_threshold)
        if group_by_two_level_threshold_bytes is not None:
            pulumi.set(__self__, "group_by_two_level_threshold_bytes", group_by_two_level_threshold_bytes)
        if hedged_connection_timeout_ms is not None:
            pulumi.set(__self__, "hedged_connection_timeout_ms", hedged_connection_timeout_ms)
        if http_connection_timeout is not None:
            pulumi.set(__self__, "http_connection_timeout", http_connection_timeout)
        if http_headers_progress_interval is not None:
            pulumi.set(__self__, "http_headers_progress_interval", http_headers_progress_interval)
        if http_max_field_name_size is not None:
            pulumi.set(__self__, "http_max_field_name_size", http_max_field_name_size)
        if http_max_field_value_size is not None:
            pulumi.set(__self__, "http_max_field_value_size", http_max_field_value_size)
        if http_receive_timeout is not None:
            pulumi.set(__self__, "http_receive_timeout", http_receive_timeout)
        if http_send_timeout is not None:
            pulumi.set(__self__, "http_send_timeout", http_send_timeout)
        if idle_connection_timeout is not None:
            pulumi.set(__self__, "idle_connection_timeout", idle_connection_timeout)
        if ignore_materialized_views_with_dropped_target_table is not None:
            pulumi.set(__self__, "ignore_materialized_views_with_dropped_target_table", ignore_materialized_views_with_dropped_target_table)
        if input_format_defaults_for_omitted_fields is not None:
            pulumi.set(__self__, "input_format_defaults_for_omitted_fields", input_format_defaults_for_omitted_fields)
        if input_format_import_nested_json is not None:
            pulumi.set(__self__, "input_format_import_nested_json", input_format_import_nested_json)
        if input_format_null_as_default is not None:
            pulumi.set(__self__, "input_format_null_as_default", input_format_null_as_default)
        if input_format_parallel_parsing is not None:
            pulumi.set(__self__, "input_format_parallel_parsing", input_format_parallel_parsing)
        if input_format_values_interpret_expressions is not None:
            pulumi.set(__self__, "input_format_values_interpret_expressions", input_format_values_interpret_expressions)
        if input_format_with_names_use_header is not None:
            pulumi.set(__self__, "input_format_with_names_use_header", input_format_with_names_use_header)
        if insert_keeper_max_retries is not None:
            pulumi.set(__self__, "insert_keeper_max_retries", insert_keeper_max_retries)
        if insert_null_as_default is not None:
            pulumi.set(__self__, "insert_null_as_default", insert_null_as_default)
        if insert_quorum is not None:
            pulumi.set(__self__, "insert_quorum", insert_quorum)
        if insert_quorum_parallel is not None:
            pulumi.set(__self__, "insert_quorum_parallel", insert_quorum_parallel)
        if insert_quorum_timeout is not None:
            pulumi.set(__self__, "insert_quorum_timeout", insert_quorum_timeout)
        if join_algorithms is not None:
            pulumi.set(__self__, "join_algorithms", join_algorithms)
        if join_overflow_mode is not None:
            pulumi.set(__self__, "join_overflow_mode", join_overflow_mode)
        if join_use_nulls is not None:
            pulumi.set(__self__, "join_use_nulls", join_use_nulls)
        if joined_subquery_requires_alias is not None:
            pulumi.set(__self__, "joined_subquery_requires_alias", joined_subquery_requires_alias)
        if load_balancing is not None:
            pulumi.set(__self__, "load_balancing", load_balancing)
        if local_filesystem_read_method is not None:
            pulumi.set(__self__, "local_filesystem_read_method", local_filesystem_read_method)
        if log_processors_profiles is not None:
            pulumi.set(__self__, "log_processors_profiles", log_processors_profiles)
        if log_queries_probability is not None:
            pulumi.set(__self__, "log_queries_probability", log_queries_probability)
        if log_query_threads is not None:
            pulumi.set(__self__, "log_query_threads", log_query_threads)
        if log_query_views is not None:
            pulumi.set(__self__, "log_query_views", log_query_views)
        if low_cardinality_allow_in_native_format is not None:
            pulumi.set(__self__, "low_cardinality_allow_in_native_format", low_cardinality_allow_in_native_format)
        if max_ast_depth is not None:
            pulumi.set(__self__, "max_ast_depth", max_ast_depth)
        if max_ast_elements is not None:
            pulumi.set(__self__, "max_ast_elements", max_ast_elements)
        if max_block_size is not None:
            pulumi.set(__self__, "max_block_size", max_block_size)
        if max_bytes_before_external_group_by is not None:
            pulumi.set(__self__, "max_bytes_before_external_group_by", max_bytes_before_external_group_by)
        if max_bytes_before_external_sort is not None:
            pulumi.set(__self__, "max_bytes_before_external_sort", max_bytes_before_external_sort)
        if max_bytes_in_distinct is not None:
            pulumi.set(__self__, "max_bytes_in_distinct", max_bytes_in_distinct)
        if max_bytes_in_join is not None:
            pulumi.set(__self__, "max_bytes_in_join", max_bytes_in_join)
        if max_bytes_in_set is not None:
            pulumi.set(__self__, "max_bytes_in_set", max_bytes_in_set)
        if max_bytes_to_read is not None:
            pulumi.set(__self__, "max_bytes_to_read", max_bytes_to_read)
        if max_bytes_to_sort is not None:
            pulumi.set(__self__, "max_bytes_to_sort", max_bytes_to_sort)
        if max_bytes_to_transfer is not None:
            pulumi.set(__self__, "max_bytes_to_transfer", max_bytes_to_transfer)
        if max_columns_to_read is not None:
            pulumi.set(__self__, "max_columns_to_read", max_columns_to_read)
        if max_concurrent_queries_for_user is not None:
            pulumi.set(__self__, "max_concurrent_queries_for_user", max_concurrent_queries_for_user)
        if max_execution_time is not None:
            pulumi.set(__self__, "max_execution_time", max_execution_time)
        if max_expanded_ast_elements is not None:
            pulumi.set(__self__, "max_expanded_ast_elements", max_expanded_ast_elements)
        if max_final_threads is not None:
            pulumi.set(__self__, "max_final_threads", max_final_threads)
        if max_http_get_redirects is not None:
            pulumi.set(__self__, "max_http_get_redirects", max_http_get_redirects)
        if max_insert_block_size is not None:
            pulumi.set(__self__, "max_insert_block_size", max_insert_block_size)
        if max_insert_threads is not None:
            pulumi.set(__self__, "max_insert_threads", max_insert_threads)
        if max_memory_usage is not None:
            pulumi.set(__self__, "max_memory_usage", max_memory_usage)
        if max_memory_usage_for_user is not None:
            pulumi.set(__self__, "max_memory_usage_for_user", max_memory_usage_for_user)
        if max_network_bandwidth is not None:
            pulumi.set(__self__, "max_network_bandwidth", max_network_bandwidth)
        if max_network_bandwidth_for_user is not None:
            pulumi.set(__self__, "max_network_bandwidth_for_user", max_network_bandwidth_for_user)
        if max_parser_depth is not None:
            pulumi.set(__self__, "max_parser_depth", max_parser_depth)
        if max_query_size is not None:
            pulumi.set(__self__, "max_query_size", max_query_size)
        if max_read_buffer_size is not None:
            pulumi.set(__self__, "max_read_buffer_size", max_read_buffer_size)
        if max_replica_delay_for_distributed_queries is not None:
            pulumi.set(__self__, "max_replica_delay_for_distributed_queries", max_replica_delay_for_distributed_queries)
        if max_result_bytes is not None:
            pulumi.set(__self__, "max_result_bytes", max_result_bytes)
        if max_result_rows is not None:
            pulumi.set(__self__, "max_result_rows", max_result_rows)
        if max_rows_in_distinct is not None:
            pulumi.set(__self__, "max_rows_in_distinct", max_rows_in_distinct)
        if max_rows_in_join is not None:
            pulumi.set(__self__, "max_rows_in_join", max_rows_in_join)
        if max_rows_in_set is not None:
            pulumi.set(__self__, "max_rows_in_set", max_rows_in_set)
        if max_rows_to_group_by is not None:
            pulumi.set(__self__, "max_rows_to_group_by", max_rows_to_group_by)
        if max_rows_to_read is not None:
            pulumi.set(__self__, "max_rows_to_read", max_rows_to_read)
        if max_rows_to_sort is not None:
            pulumi.set(__self__, "max_rows_to_sort", max_rows_to_sort)
        if max_rows_to_transfer is not None:
            pulumi.set(__self__, "max_rows_to_transfer", max_rows_to_transfer)
        if max_temporary_columns is not None:
            pulumi.set(__self__, "max_temporary_columns", max_temporary_columns)
        if max_temporary_data_on_disk_size_for_query is not None:
            pulumi.set(__self__, "max_temporary_data_on_disk_size_for_query", max_temporary_data_on_disk_size_for_query)
        if max_temporary_data_on_disk_size_for_user is not None:
            pulumi.set(__self__, "max_temporary_data_on_disk_size_for_user", max_temporary_data_on_disk_size_for_user)
        if max_temporary_non_const_columns is not None:
            pulumi.set(__self__, "max_temporary_non_const_columns", max_temporary_non_const_columns)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if memory_overcommit_ratio_denominator is not None:
            pulumi.set(__self__, "memory_overcommit_ratio_denominator", memory_overcommit_ratio_denominator)
        if memory_overcommit_ratio_denominator_for_user is not None:
            pulumi.set(__self__, "memory_overcommit_ratio_denominator_for_user", memory_overcommit_ratio_denominator_for_user)
        if memory_profiler_sample_probability is not None:
            pulumi.set(__self__, "memory_profiler_sample_probability", memory_profiler_sample_probability)
        if memory_profiler_step is not None:
            pulumi.set(__self__, "memory_profiler_step", memory_profiler_step)
        if memory_usage_overcommit_max_wait_microseconds is not None:
            pulumi.set(__self__, "memory_usage_overcommit_max_wait_microseconds", memory_usage_overcommit_max_wait_microseconds)
        if merge_tree_max_bytes_to_use_cache is not None:
            pulumi.set(__self__, "merge_tree_max_bytes_to_use_cache", merge_tree_max_bytes_to_use_cache)
        if merge_tree_max_rows_to_use_cache is not None:
            pulumi.set(__self__, "merge_tree_max_rows_to_use_cache", merge_tree_max_rows_to_use_cache)
        if merge_tree_min_bytes_for_concurrent_read is not None:
            pulumi.set(__self__, "merge_tree_min_bytes_for_concurrent_read", merge_tree_min_bytes_for_concurrent_read)
        if merge_tree_min_rows_for_concurrent_read is not None:
            pulumi.set(__self__, "merge_tree_min_rows_for_concurrent_read", merge_tree_min_rows_for_concurrent_read)
        if min_bytes_to_use_direct_io is not None:
            pulumi.set(__self__, "min_bytes_to_use_direct_io", min_bytes_to_use_direct_io)
        if min_count_to_compile is not None:
            pulumi.set(__self__, "min_count_to_compile", min_count_to_compile)
        if min_count_to_compile_expression is not None:
            pulumi.set(__self__, "min_count_to_compile_expression", min_count_to_compile_expression)
        if min_execution_speed is not None:
            pulumi.set(__self__, "min_execution_speed", min_execution_speed)
        if min_execution_speed_bytes is not None:
            pulumi.set(__self__, "min_execution_speed_bytes", min_execution_speed_bytes)
        if min_insert_block_size_bytes is not None:
            pulumi.set(__self__, "min_insert_block_size_bytes", min_insert_block_size_bytes)
        if min_insert_block_size_rows is not None:
            pulumi.set(__self__, "min_insert_block_size_rows", min_insert_block_size_rows)
        if output_format_json_quote64bit_integers is not None:
            pulumi.set(__self__, "output_format_json_quote64bit_integers", output_format_json_quote64bit_integers)
        if output_format_json_quote_denormals is not None:
            pulumi.set(__self__, "output_format_json_quote_denormals", output_format_json_quote_denormals)
        if prefer_localhost_replica is not None:
            pulumi.set(__self__, "prefer_localhost_replica", prefer_localhost_replica)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if query_cache_max_entries is not None:
            pulumi.set(__self__, "query_cache_max_entries", query_cache_max_entries)
        if query_cache_max_size_in_bytes is not None:
            pulumi.set(__self__, "query_cache_max_size_in_bytes", query_cache_max_size_in_bytes)
        if query_cache_min_query_duration is not None:
            pulumi.set(__self__, "query_cache_min_query_duration", query_cache_min_query_duration)
        if query_cache_min_query_runs is not None:
            pulumi.set(__self__, "query_cache_min_query_runs", query_cache_min_query_runs)
        if query_cache_share_between_users is not None:
            pulumi.set(__self__, "query_cache_share_between_users", query_cache_share_between_users)
        if query_cache_tag is not None:
            pulumi.set(__self__, "query_cache_tag", query_cache_tag)
        if query_cache_ttl is not None:
            pulumi.set(__self__, "query_cache_ttl", query_cache_ttl)
        if quota_mode is not None:
            pulumi.set(__self__, "quota_mode", quota_mode)
        if read_overflow_mode is not None:
            pulumi.set(__self__, "read_overflow_mode", read_overflow_mode)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if receive_timeout is not None:
            pulumi.set(__self__, "receive_timeout", receive_timeout)
        if remote_filesystem_read_method is not None:
            pulumi.set(__self__, "remote_filesystem_read_method", remote_filesystem_read_method)
        if replication_alter_partitions_sync is not None:
            pulumi.set(__self__, "replication_alter_partitions_sync", replication_alter_partitions_sync)
        if result_overflow_mode is not None:
            pulumi.set(__self__, "result_overflow_mode", result_overflow_mode)
        if s3_use_adaptive_timeouts is not None:
            pulumi.set(__self__, "s3_use_adaptive_timeouts", s3_use_adaptive_timeouts)
        if select_sequential_consistency is not None:
            pulumi.set(__self__, "select_sequential_consistency", select_sequential_consistency)
        if send_progress_in_http_headers is not None:
            pulumi.set(__self__, "send_progress_in_http_headers", send_progress_in_http_headers)
        if send_timeout is not None:
            pulumi.set(__self__, "send_timeout", send_timeout)
        if set_overflow_mode is not None:
            pulumi.set(__self__, "set_overflow_mode", set_overflow_mode)
        if skip_unavailable_shards is not None:
            pulumi.set(__self__, "skip_unavailable_shards", skip_unavailable_shards)
        if sort_overflow_mode is not None:
            pulumi.set(__self__, "sort_overflow_mode", sort_overflow_mode)
        if timeout_before_checking_execution_speed is not None:
            pulumi.set(__self__, "timeout_before_checking_execution_speed", timeout_before_checking_execution_speed)
        if timeout_overflow_mode is not None:
            pulumi.set(__self__, "timeout_overflow_mode", timeout_overflow_mode)
        if transfer_overflow_mode is not None:
            pulumi.set(__self__, "transfer_overflow_mode", transfer_overflow_mode)
        if transform_null_in is not None:
            pulumi.set(__self__, "transform_null_in", transform_null_in)
        if use_hedged_requests is not None:
            pulumi.set(__self__, "use_hedged_requests", use_hedged_requests)
        if use_query_cache is not None:
            pulumi.set(__self__, "use_query_cache", use_query_cache)
        if use_uncompressed_cache is not None:
            pulumi.set(__self__, "use_uncompressed_cache", use_uncompressed_cache)
        if wait_for_async_insert is not None:
            pulumi.set(__self__, "wait_for_async_insert", wait_for_async_insert)
        if wait_for_async_insert_timeout is not None:
            pulumi.set(__self__, "wait_for_async_insert_timeout", wait_for_async_insert_timeout)

    @_builtins.property
    @pulumi.getter(name="addHttpCorsHeader")
    def add_http_cors_header(self) -> Optional[_builtins.bool]:
        """
        Include CORS headers in HTTP responses.
        """
        return pulumi.get(self, "add_http_cors_header")

    @_builtins.property
    @pulumi.getter(name="allowDdl")
    def allow_ddl(self) -> Optional[_builtins.bool]:
        """
        Allows or denies DDL queries.
        """
        return pulumi.get(self, "allow_ddl")

    @_builtins.property
    @pulumi.getter(name="allowIntrospectionFunctions")
    def allow_introspection_functions(self) -> Optional[_builtins.bool]:
        """
        Enables introspections functions for query profiling.
        """
        return pulumi.get(self, "allow_introspection_functions")

    @_builtins.property
    @pulumi.getter(name="allowSuspiciousLowCardinalityTypes")
    def allow_suspicious_low_cardinality_types(self) -> Optional[_builtins.bool]:
        """
        Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        """
        return pulumi.get(self, "allow_suspicious_low_cardinality_types")

    @_builtins.property
    @pulumi.getter(name="anyJoinDistinctRightTableKeys")
    def any_join_distinct_right_table_keys(self) -> Optional[_builtins.bool]:
        """
        Enables legacy ClickHouse server behavior in ANY INNER|LEFT JOIN operations.
        """
        return pulumi.get(self, "any_join_distinct_right_table_keys")

    @_builtins.property
    @pulumi.getter(name="asyncInsert")
    def async_insert(self) -> Optional[_builtins.bool]:
        """
        Enables asynchronous inserts. Disabled by default.
        """
        return pulumi.get(self, "async_insert")

    @_builtins.property
    @pulumi.getter(name="asyncInsertBusyTimeout")
    def async_insert_busy_timeout(self) -> Optional[_builtins.int]:
        """
        The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        """
        return pulumi.get(self, "async_insert_busy_timeout")

    @_builtins.property
    @pulumi.getter(name="asyncInsertMaxDataSize")
    def async_insert_max_data_size(self) -> Optional[_builtins.int]:
        """
        The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        """
        return pulumi.get(self, "async_insert_max_data_size")

    @_builtins.property
    @pulumi.getter(name="asyncInsertStaleTimeout")
    def async_insert_stale_timeout(self) -> Optional[_builtins.int]:
        """
        The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        """
        return pulumi.get(self, "async_insert_stale_timeout")

    @_builtins.property
    @pulumi.getter(name="asyncInsertThreads")
    def async_insert_threads(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        """
        return pulumi.get(self, "async_insert_threads")

    @_builtins.property
    @pulumi.getter(name="asyncInsertUseAdaptiveBusyTimeout")
    def async_insert_use_adaptive_busy_timeout(self) -> Optional[_builtins.bool]:
        """
        If it is set to true, use adaptive busy timeout for asynchronous inserts.
        """
        return pulumi.get(self, "async_insert_use_adaptive_busy_timeout")

    @_builtins.property
    @pulumi.getter(name="cancelHttpReadonlyQueriesOnClientClose")
    def cancel_http_readonly_queries_on_client_close(self) -> Optional[_builtins.bool]:
        """
        Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        """
        return pulumi.get(self, "cancel_http_readonly_queries_on_client_close")

    @_builtins.property
    @pulumi.getter
    def compile(self) -> Optional[_builtins.bool]:
        """
        Enable compilation of queries.
        """
        return pulumi.get(self, "compile")

    @_builtins.property
    @pulumi.getter(name="compileExpressions")
    def compile_expressions(self) -> Optional[_builtins.bool]:
        """
        Turn on expression compilation.
        """
        return pulumi.get(self, "compile_expressions")

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[_builtins.int]:
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter(name="connectTimeoutWithFailover")
    def connect_timeout_with_failover(self) -> Optional[_builtins.int]:
        """
        The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        """
        return pulumi.get(self, "connect_timeout_with_failover")

    @_builtins.property
    @pulumi.getter(name="countDistinctImplementation")
    def count_distinct_implementation(self) -> Optional[_builtins.str]:
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        """
        return pulumi.get(self, "count_distinct_implementation")

    @_builtins.property
    @pulumi.getter(name="dataTypeDefaultNullable")
    def data_type_default_nullable(self) -> Optional[_builtins.bool]:
        """
        Allows data types without explicit modifiers NULL or NOT NULL in column definition will be Nullable.
        """
        return pulumi.get(self, "data_type_default_nullable")

    @_builtins.property
    @pulumi.getter(name="dateTimeInputFormat")
    def date_time_input_format(self) -> Optional[_builtins.str]:
        """
        Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        """
        return pulumi.get(self, "date_time_input_format")

    @_builtins.property
    @pulumi.getter(name="dateTimeOutputFormat")
    def date_time_output_format(self) -> Optional[_builtins.str]:
        """
        Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        """
        return pulumi.get(self, "date_time_output_format")

    @_builtins.property
    @pulumi.getter(name="deduplicateBlocksInDependentMaterializedViews")
    def deduplicate_blocks_in_dependent_materialized_views(self) -> Optional[_builtins.bool]:
        """
        Enables or disables the deduplication check for materialized views that receive data from `Replicated` tables.
        """
        return pulumi.get(self, "deduplicate_blocks_in_dependent_materialized_views")

    @_builtins.property
    @pulumi.getter(name="distinctOverflowMode")
    def distinct_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow when using DISTINCT. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "distinct_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="distributedAggregationMemoryEfficient")
    def distributed_aggregation_memory_efficient(self) -> Optional[_builtins.bool]:
        """
        Determine the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_aggregation_memory_efficient")

    @_builtins.property
    @pulumi.getter(name="distributedDdlTaskTimeout")
    def distributed_ddl_task_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout for DDL queries, in milliseconds.
        """
        return pulumi.get(self, "distributed_ddl_task_timeout")

    @_builtins.property
    @pulumi.getter(name="distributedProductMode")
    def distributed_product_mode(self) -> Optional[_builtins.str]:
        """
        Changes the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_product_mode")

    @_builtins.property
    @pulumi.getter(name="doNotMergeAcrossPartitionsSelectFinal")
    def do_not_merge_across_partitions_select_final(self) -> Optional[_builtins.bool]:
        """
        Enable or disable independent processing of partitions for **SELECT** queries with **FINAL**.
        """
        return pulumi.get(self, "do_not_merge_across_partitions_select_final")

    @_builtins.property
    @pulumi.getter(name="emptyResultForAggregationByEmptySet")
    def empty_result_for_aggregation_by_empty_set(self) -> Optional[_builtins.bool]:
        """
        Allows to return empty result.
        """
        return pulumi.get(self, "empty_result_for_aggregation_by_empty_set")

    @_builtins.property
    @pulumi.getter(name="enableAnalyzer")
    def enable_analyzer(self) -> Optional[_builtins.bool]:
        """
        Enable new query analyzer.
        """
        return pulumi.get(self, "enable_analyzer")

    @_builtins.property
    @pulumi.getter(name="enableHttpCompression")
    def enable_http_compression(self) -> Optional[_builtins.bool]:
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        return pulumi.get(self, "enable_http_compression")

    @_builtins.property
    @pulumi.getter(name="enableReadsFromQueryCache")
    def enable_reads_from_query_cache(self) -> Optional[_builtins.bool]:
        """
        If turned on, results of SELECT queries are retrieved from the query cache.
        """
        return pulumi.get(self, "enable_reads_from_query_cache")

    @_builtins.property
    @pulumi.getter(name="enableWritesToQueryCache")
    def enable_writes_to_query_cache(self) -> Optional[_builtins.bool]:
        """
        If turned on, results of SELECT queries are stored in the query cache.
        """
        return pulumi.get(self, "enable_writes_to_query_cache")

    @_builtins.property
    @pulumi.getter(name="fallbackToStaleReplicasForDistributedQueries")
    def fallback_to_stale_replicas_for_distributed_queries(self) -> Optional[_builtins.bool]:
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        return pulumi.get(self, "fallback_to_stale_replicas_for_distributed_queries")

    @_builtins.property
    @pulumi.getter(name="flattenNested")
    def flatten_nested(self) -> Optional[_builtins.bool]:
        """
        Sets the data format of a nested columns.
        """
        return pulumi.get(self, "flatten_nested")

    @_builtins.property
    @pulumi.getter(name="forceIndexByDate")
    def force_index_by_date(self) -> Optional[_builtins.bool]:
        """
        Disables query execution if the index cant be used by date.
        """
        return pulumi.get(self, "force_index_by_date")

    @_builtins.property
    @pulumi.getter(name="forcePrimaryKey")
    def force_primary_key(self) -> Optional[_builtins.bool]:
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        return pulumi.get(self, "force_primary_key")

    @_builtins.property
    @pulumi.getter(name="formatAvroSchemaRegistryUrl")
    def format_avro_schema_registry_url(self) -> Optional[_builtins.str]:
        """
        Avro schema registry URL.
        """
        return pulumi.get(self, "format_avro_schema_registry_url")

    @_builtins.property
    @pulumi.getter(name="formatRegexp")
    def format_regexp(self) -> Optional[_builtins.str]:
        """
        Regular expression (for Regexp format).
        """
        return pulumi.get(self, "format_regexp")

    @_builtins.property
    @pulumi.getter(name="formatRegexpSkipUnmatched")
    def format_regexp_skip_unmatched(self) -> Optional[_builtins.bool]:
        """
        Skip lines unmatched by regular expression.
        """
        return pulumi.get(self, "format_regexp_skip_unmatched")

    @_builtins.property
    @pulumi.getter(name="groupByOverflowMode")
    def group_by_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow while GROUP BY operation. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        * `any` - perform approximate GROUP BY operation by continuing aggregation for the keys that got into the set, but dont add new keys to the set.
        """
        return pulumi.get(self, "group_by_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="groupByTwoLevelThreshold")
    def group_by_two_level_threshold(self) -> Optional[_builtins.int]:
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold")

    @_builtins.property
    @pulumi.getter(name="groupByTwoLevelThresholdBytes")
    def group_by_two_level_threshold_bytes(self) -> Optional[_builtins.int]:
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold_bytes")

    @_builtins.property
    @pulumi.getter(name="hedgedConnectionTimeoutMs")
    def hedged_connection_timeout_ms(self) -> Optional[_builtins.int]:
        """
        Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        """
        return pulumi.get(self, "hedged_connection_timeout_ms")

    @_builtins.property
    @pulumi.getter(name="httpConnectionTimeout")
    def http_connection_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_connection_timeout")

    @_builtins.property
    @pulumi.getter(name="httpHeadersProgressInterval")
    def http_headers_progress_interval(self) -> Optional[_builtins.int]:
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        return pulumi.get(self, "http_headers_progress_interval")

    @_builtins.property
    @pulumi.getter(name="httpMaxFieldNameSize")
    def http_max_field_name_size(self) -> Optional[_builtins.int]:
        """
        Maximum length of field name in HTTP header.
        """
        return pulumi.get(self, "http_max_field_name_size")

    @_builtins.property
    @pulumi.getter(name="httpMaxFieldValueSize")
    def http_max_field_value_size(self) -> Optional[_builtins.int]:
        """
        Maximum length of field value in HTTP header.
        """
        return pulumi.get(self, "http_max_field_value_size")

    @_builtins.property
    @pulumi.getter(name="httpReceiveTimeout")
    def http_receive_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_receive_timeout")

    @_builtins.property
    @pulumi.getter(name="httpSendTimeout")
    def http_send_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_send_timeout")

    @_builtins.property
    @pulumi.getter(name="idleConnectionTimeout")
    def idle_connection_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        """
        return pulumi.get(self, "idle_connection_timeout")

    @_builtins.property
    @pulumi.getter(name="ignoreMaterializedViewsWithDroppedTargetTable")
    def ignore_materialized_views_with_dropped_target_table(self) -> Optional[_builtins.bool]:
        """
        Ignore materialized views with dropped target table during pushing to views.
        """
        return pulumi.get(self, "ignore_materialized_views_with_dropped_target_table")

    @_builtins.property
    @pulumi.getter(name="inputFormatDefaultsForOmittedFields")
    def input_format_defaults_for_omitted_fields(self) -> Optional[_builtins.bool]:
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        return pulumi.get(self, "input_format_defaults_for_omitted_fields")

    @_builtins.property
    @pulumi.getter(name="inputFormatImportNestedJson")
    def input_format_import_nested_json(self) -> Optional[_builtins.bool]:
        """
        Enables or disables the insertion of JSON data with nested objects.
        """
        return pulumi.get(self, "input_format_import_nested_json")

    @_builtins.property
    @pulumi.getter(name="inputFormatNullAsDefault")
    def input_format_null_as_default(self) -> Optional[_builtins.bool]:
        """
        Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        """
        return pulumi.get(self, "input_format_null_as_default")

    @_builtins.property
    @pulumi.getter(name="inputFormatParallelParsing")
    def input_format_parallel_parsing(self) -> Optional[_builtins.bool]:
        """
        Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        """
        return pulumi.get(self, "input_format_parallel_parsing")

    @_builtins.property
    @pulumi.getter(name="inputFormatValuesInterpretExpressions")
    def input_format_values_interpret_expressions(self) -> Optional[_builtins.bool]:
        """
        Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        """
        return pulumi.get(self, "input_format_values_interpret_expressions")

    @_builtins.property
    @pulumi.getter(name="inputFormatWithNamesUseHeader")
    def input_format_with_names_use_header(self) -> Optional[_builtins.bool]:
        """
        Enables or disables checking the column order when inserting data.
        """
        return pulumi.get(self, "input_format_with_names_use_header")

    @_builtins.property
    @pulumi.getter(name="insertKeeperMaxRetries")
    def insert_keeper_max_retries(self) -> Optional[_builtins.int]:
        """
        The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        """
        return pulumi.get(self, "insert_keeper_max_retries")

    @_builtins.property
    @pulumi.getter(name="insertNullAsDefault")
    def insert_null_as_default(self) -> Optional[_builtins.bool]:
        """
        Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        """
        return pulumi.get(self, "insert_null_as_default")

    @_builtins.property
    @pulumi.getter(name="insertQuorum")
    def insert_quorum(self) -> Optional[_builtins.int]:
        """
        Enables the quorum writes.
        """
        return pulumi.get(self, "insert_quorum")

    @_builtins.property
    @pulumi.getter(name="insertQuorumParallel")
    def insert_quorum_parallel(self) -> Optional[_builtins.bool]:
        """
        Enables or disables parallelism for quorum INSERT queries.
        """
        return pulumi.get(self, "insert_quorum_parallel")

    @_builtins.property
    @pulumi.getter(name="insertQuorumTimeout")
    def insert_quorum_timeout(self) -> Optional[_builtins.int]:
        """
        Write to a quorum timeout in milliseconds.
        """
        return pulumi.get(self, "insert_quorum_timeout")

    @_builtins.property
    @pulumi.getter(name="joinAlgorithms")
    def join_algorithms(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies which JOIN algorithm is used. Possible values:
        * `hash` - hash join algorithm is used. The most generic implementation that supports all combinations of kind and strictness and multiple join keys that are combined with OR in the JOIN ON section.
        * `parallel_hash` - a variation of hash join that splits the data into buckets and builds several hash tables instead of one concurrently to speed up this process.
        * `partial_merge` - a variation of the sort-merge algorithm, where only the right table is fully sorted.
        * `direct` - this algorithm can be applied when the storage for the right table supports key-value requests.
        * `auto` - when set to auto, hash join is tried first, and the algorithm is switched on the fly to another algorithm if the memory limit is violated.
        * `full_sorting_merge` - sort-merge algorithm with full sorting joined tables before joining.
        * `prefer_partial_merge` - clickHouse always tries to use partial_merge join if possible, otherwise, it uses hash. Deprecated, same as partial_merge,hash.
        """
        return pulumi.get(self, "join_algorithms")

    @_builtins.property
    @pulumi.getter(name="joinOverflowMode")
    def join_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow in JOIN. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "join_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="joinUseNulls")
    def join_use_nulls(self) -> Optional[_builtins.bool]:
        """
        Sets the type of JOIN behavior. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        return pulumi.get(self, "join_use_nulls")

    @_builtins.property
    @pulumi.getter(name="joinedSubqueryRequiresAlias")
    def joined_subquery_requires_alias(self) -> Optional[_builtins.bool]:
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        return pulumi.get(self, "joined_subquery_requires_alias")

    @_builtins.property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> Optional[_builtins.str]:
        """
        Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        """
        return pulumi.get(self, "load_balancing")

    @_builtins.property
    @pulumi.getter(name="localFilesystemReadMethod")
    def local_filesystem_read_method(self) -> Optional[_builtins.str]:
        """
        Method of reading data from local filesystem. Possible values:
        * `read` - abort query execution, return an error.
        * `pread` - abort query execution, return an error.
        * `pread_threadpool` - stop query execution, return partial result. If the parameter is set to 0 (default), no hops is allowed.
        """
        return pulumi.get(self, "local_filesystem_read_method")

    @_builtins.property
    @pulumi.getter(name="logProcessorsProfiles")
    def log_processors_profiles(self) -> Optional[_builtins.bool]:
        """
        Enabled or disable logging of processors level profiling data to the the system.log_processors_profiles table.
        """
        return pulumi.get(self, "log_processors_profiles")

    @_builtins.property
    @pulumi.getter(name="logQueriesProbability")
    def log_queries_probability(self) -> Optional[_builtins.float]:
        """
        Log queries with the specified probability.
        """
        return pulumi.get(self, "log_queries_probability")

    @_builtins.property
    @pulumi.getter(name="logQueryThreads")
    def log_query_threads(self) -> Optional[_builtins.bool]:
        """
        Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: `true`.
        """
        return pulumi.get(self, "log_query_threads")

    @_builtins.property
    @pulumi.getter(name="logQueryViews")
    def log_query_views(self) -> Optional[_builtins.bool]:
        """
        Enables or disables query views logging to the the system.query_views_log table.
        """
        return pulumi.get(self, "log_query_views")

    @_builtins.property
    @pulumi.getter(name="lowCardinalityAllowInNativeFormat")
    def low_cardinality_allow_in_native_format(self) -> Optional[_builtins.bool]:
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        return pulumi.get(self, "low_cardinality_allow_in_native_format")

    @_builtins.property
    @pulumi.getter(name="maxAstDepth")
    def max_ast_depth(self) -> Optional[_builtins.int]:
        """
        Maximum abstract syntax tree depth.
        """
        return pulumi.get(self, "max_ast_depth")

    @_builtins.property
    @pulumi.getter(name="maxAstElements")
    def max_ast_elements(self) -> Optional[_builtins.int]:
        """
        Maximum abstract syntax tree elements.
        """
        return pulumi.get(self, "max_ast_elements")

    @_builtins.property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> Optional[_builtins.int]:
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        return pulumi.get(self, "max_block_size")

    @_builtins.property
    @pulumi.getter(name="maxBytesBeforeExternalGroupBy")
    def max_bytes_before_external_group_by(self) -> Optional[_builtins.int]:
        """
        Limit in bytes for using memory for GROUP BY before using swap on disk.
        """
        return pulumi.get(self, "max_bytes_before_external_group_by")

    @_builtins.property
    @pulumi.getter(name="maxBytesBeforeExternalSort")
    def max_bytes_before_external_sort(self) -> Optional[_builtins.int]:
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        return pulumi.get(self, "max_bytes_before_external_sort")

    @_builtins.property
    @pulumi.getter(name="maxBytesInDistinct")
    def max_bytes_in_distinct(self) -> Optional[_builtins.int]:
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        return pulumi.get(self, "max_bytes_in_distinct")

    @_builtins.property
    @pulumi.getter(name="maxBytesInJoin")
    def max_bytes_in_join(self) -> Optional[_builtins.int]:
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        return pulumi.get(self, "max_bytes_in_join")

    @_builtins.property
    @pulumi.getter(name="maxBytesInSet")
    def max_bytes_in_set(self) -> Optional[_builtins.int]:
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_bytes_in_set")

    @_builtins.property
    @pulumi.getter(name="maxBytesToRead")
    def max_bytes_to_read(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_bytes_to_read")

    @_builtins.property
    @pulumi.getter(name="maxBytesToSort")
    def max_bytes_to_sort(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_bytes_to_sort")

    @_builtins.property
    @pulumi.getter(name="maxBytesToTransfer")
    def max_bytes_to_transfer(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_bytes_to_transfer")

    @_builtins.property
    @pulumi.getter(name="maxColumnsToRead")
    def max_columns_to_read(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        return pulumi.get(self, "max_columns_to_read")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentQueriesForUser")
    def max_concurrent_queries_for_user(self) -> Optional[_builtins.int]:
        """
        The maximum number of concurrent requests per user. Default value: 0 (no limit).
        """
        return pulumi.get(self, "max_concurrent_queries_for_user")

    @_builtins.property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> Optional[_builtins.int]:
        """
        Limits the maximum query execution time in milliseconds.
        """
        return pulumi.get(self, "max_execution_time")

    @_builtins.property
    @pulumi.getter(name="maxExpandedAstElements")
    def max_expanded_ast_elements(self) -> Optional[_builtins.int]:
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        return pulumi.get(self, "max_expanded_ast_elements")

    @_builtins.property
    @pulumi.getter(name="maxFinalThreads")
    def max_final_threads(self) -> Optional[_builtins.int]:
        """
        Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        """
        return pulumi.get(self, "max_final_threads")

    @_builtins.property
    @pulumi.getter(name="maxHttpGetRedirects")
    def max_http_get_redirects(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        """
        return pulumi.get(self, "max_http_get_redirects")

    @_builtins.property
    @pulumi.getter(name="maxInsertBlockSize")
    def max_insert_block_size(self) -> Optional[_builtins.int]:
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        return pulumi.get(self, "max_insert_block_size")

    @_builtins.property
    @pulumi.getter(name="maxInsertThreads")
    def max_insert_threads(self) -> Optional[_builtins.int]:
        """
        The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        """
        return pulumi.get(self, "max_insert_threads")

    @_builtins.property
    @pulumi.getter(name="maxMemoryUsage")
    def max_memory_usage(self) -> Optional[_builtins.int]:
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage")

    @_builtins.property
    @pulumi.getter(name="maxMemoryUsageForUser")
    def max_memory_usage_for_user(self) -> Optional[_builtins.int]:
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage_for_user")

    @_builtins.property
    @pulumi.getter(name="maxNetworkBandwidth")
    def max_network_bandwidth(self) -> Optional[_builtins.int]:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth")

    @_builtins.property
    @pulumi.getter(name="maxNetworkBandwidthForUser")
    def max_network_bandwidth_for_user(self) -> Optional[_builtins.int]:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth_for_user")

    @_builtins.property
    @pulumi.getter(name="maxParserDepth")
    def max_parser_depth(self) -> Optional[_builtins.int]:
        """
        Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        """
        return pulumi.get(self, "max_parser_depth")

    @_builtins.property
    @pulumi.getter(name="maxQuerySize")
    def max_query_size(self) -> Optional[_builtins.int]:
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        return pulumi.get(self, "max_query_size")

    @_builtins.property
    @pulumi.getter(name="maxReadBufferSize")
    def max_read_buffer_size(self) -> Optional[_builtins.int]:
        """
        The maximum size of the buffer to read from the filesystem.
        """
        return pulumi.get(self, "max_read_buffer_size")

    @_builtins.property
    @pulumi.getter(name="maxReplicaDelayForDistributedQueries")
    def max_replica_delay_for_distributed_queries(self) -> Optional[_builtins.int]:
        """
        Disables lagging replicas for distributed queries.
        """
        return pulumi.get(self, "max_replica_delay_for_distributed_queries")

    @_builtins.property
    @pulumi.getter(name="maxResultBytes")
    def max_result_bytes(self) -> Optional[_builtins.int]:
        """
        Limits the number of bytes in the result.
        """
        return pulumi.get(self, "max_result_bytes")

    @_builtins.property
    @pulumi.getter(name="maxResultRows")
    def max_result_rows(self) -> Optional[_builtins.int]:
        """
        Limits the number of rows in the result.
        """
        return pulumi.get(self, "max_result_rows")

    @_builtins.property
    @pulumi.getter(name="maxRowsInDistinct")
    def max_rows_in_distinct(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        return pulumi.get(self, "max_rows_in_distinct")

    @_builtins.property
    @pulumi.getter(name="maxRowsInJoin")
    def max_rows_in_join(self) -> Optional[_builtins.int]:
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        return pulumi.get(self, "max_rows_in_join")

    @_builtins.property
    @pulumi.getter(name="maxRowsInSet")
    def max_rows_in_set(self) -> Optional[_builtins.int]:
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_rows_in_set")

    @_builtins.property
    @pulumi.getter(name="maxRowsToGroupBy")
    def max_rows_to_group_by(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        return pulumi.get(self, "max_rows_to_group_by")

    @_builtins.property
    @pulumi.getter(name="maxRowsToRead")
    def max_rows_to_read(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_rows_to_read")

    @_builtins.property
    @pulumi.getter(name="maxRowsToSort")
    def max_rows_to_sort(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_rows_to_sort")

    @_builtins.property
    @pulumi.getter(name="maxRowsToTransfer")
    def max_rows_to_transfer(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_rows_to_transfer")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryColumns")
    def max_temporary_columns(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        return pulumi.get(self, "max_temporary_columns")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForQuery")
    def max_temporary_data_on_disk_size_for_query(self) -> Optional[_builtins.int]:
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_query")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForUser")
    def max_temporary_data_on_disk_size_for_user(self) -> Optional[_builtins.int]:
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_user")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryNonConstColumns")
    def max_temporary_non_const_columns(self) -> Optional[_builtins.int]:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        return pulumi.get(self, "max_temporary_non_const_columns")

    @_builtins.property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[_builtins.int]:
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        return pulumi.get(self, "max_threads")

    @_builtins.property
    @pulumi.getter(name="memoryOvercommitRatioDenominator")
    def memory_overcommit_ratio_denominator(self) -> Optional[_builtins.int]:
        """
        It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator")

    @_builtins.property
    @pulumi.getter(name="memoryOvercommitRatioDenominatorForUser")
    def memory_overcommit_ratio_denominator_for_user(self) -> Optional[_builtins.int]:
        """
        It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator_for_user")

    @_builtins.property
    @pulumi.getter(name="memoryProfilerSampleProbability")
    def memory_profiler_sample_probability(self) -> Optional[_builtins.float]:
        """
        Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        """
        return pulumi.get(self, "memory_profiler_sample_probability")

    @_builtins.property
    @pulumi.getter(name="memoryProfilerStep")
    def memory_profiler_step(self) -> Optional[_builtins.int]:
        """
        Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        """
        return pulumi.get(self, "memory_profiler_step")

    @_builtins.property
    @pulumi.getter(name="memoryUsageOvercommitMaxWaitMicroseconds")
    def memory_usage_overcommit_max_wait_microseconds(self) -> Optional[_builtins.int]:
        """
        Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        """
        return pulumi.get(self, "memory_usage_overcommit_max_wait_microseconds")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMaxBytesToUseCache")
    def merge_tree_max_bytes_to_use_cache(self) -> Optional[_builtins.int]:
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_bytes_to_use_cache")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMaxRowsToUseCache")
    def merge_tree_max_rows_to_use_cache(self) -> Optional[_builtins.int]:
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_rows_to_use_cache")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMinBytesForConcurrentRead")
    def merge_tree_min_bytes_for_concurrent_read(self) -> Optional[_builtins.int]:
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        return pulumi.get(self, "merge_tree_min_bytes_for_concurrent_read")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMinRowsForConcurrentRead")
    def merge_tree_min_rows_for_concurrent_read(self) -> Optional[_builtins.int]:
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        return pulumi.get(self, "merge_tree_min_rows_for_concurrent_read")

    @_builtins.property
    @pulumi.getter(name="minBytesToUseDirectIo")
    def min_bytes_to_use_direct_io(self) -> Optional[_builtins.int]:
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        return pulumi.get(self, "min_bytes_to_use_direct_io")

    @_builtins.property
    @pulumi.getter(name="minCountToCompile")
    def min_count_to_compile(self) -> Optional[_builtins.int]:
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        return pulumi.get(self, "min_count_to_compile")

    @_builtins.property
    @pulumi.getter(name="minCountToCompileExpression")
    def min_count_to_compile_expression(self) -> Optional[_builtins.int]:
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        return pulumi.get(self, "min_count_to_compile_expression")

    @_builtins.property
    @pulumi.getter(name="minExecutionSpeed")
    def min_execution_speed(self) -> Optional[_builtins.int]:
        """
        Minimal execution speed in rows per second.
        """
        return pulumi.get(self, "min_execution_speed")

    @_builtins.property
    @pulumi.getter(name="minExecutionSpeedBytes")
    def min_execution_speed_bytes(self) -> Optional[_builtins.int]:
        """
        Minimal execution speed in bytes per second.
        """
        return pulumi.get(self, "min_execution_speed_bytes")

    @_builtins.property
    @pulumi.getter(name="minInsertBlockSizeBytes")
    def min_insert_block_size_bytes(self) -> Optional[_builtins.int]:
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_bytes")

    @_builtins.property
    @pulumi.getter(name="minInsertBlockSizeRows")
    def min_insert_block_size_rows(self) -> Optional[_builtins.int]:
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_rows")

    @_builtins.property
    @pulumi.getter(name="outputFormatJsonQuote64bitIntegers")
    def output_format_json_quote64bit_integers(self) -> Optional[_builtins.bool]:
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        return pulumi.get(self, "output_format_json_quote64bit_integers")

    @_builtins.property
    @pulumi.getter(name="outputFormatJsonQuoteDenormals")
    def output_format_json_quote_denormals(self) -> Optional[_builtins.bool]:
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        return pulumi.get(self, "output_format_json_quote_denormals")

    @_builtins.property
    @pulumi.getter(name="preferLocalhostReplica")
    def prefer_localhost_replica(self) -> Optional[_builtins.bool]:
        """
        Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        """
        return pulumi.get(self, "prefer_localhost_replica")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Query priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="queryCacheMaxEntries")
    def query_cache_max_entries(self) -> Optional[_builtins.int]:
        """
        The maximum number of query results the current user may store in the query cache. 0 means unlimited.
        """
        return pulumi.get(self, "query_cache_max_entries")

    @_builtins.property
    @pulumi.getter(name="queryCacheMaxSizeInBytes")
    def query_cache_max_size_in_bytes(self) -> Optional[_builtins.int]:
        """
        The maximum amount of memory (in bytes) the current user may allocate in the query cache. 0 means unlimited.
        """
        return pulumi.get(self, "query_cache_max_size_in_bytes")

    @_builtins.property
    @pulumi.getter(name="queryCacheMinQueryDuration")
    def query_cache_min_query_duration(self) -> Optional[_builtins.int]:
        """
        Minimum duration in milliseconds a query needs to run for its result to be stored in the query cache.
        """
        return pulumi.get(self, "query_cache_min_query_duration")

    @_builtins.property
    @pulumi.getter(name="queryCacheMinQueryRuns")
    def query_cache_min_query_runs(self) -> Optional[_builtins.int]:
        """
        Minimum number of times a SELECT query must run before its result is stored in the query cache.
        """
        return pulumi.get(self, "query_cache_min_query_runs")

    @_builtins.property
    @pulumi.getter(name="queryCacheShareBetweenUsers")
    def query_cache_share_between_users(self) -> Optional[_builtins.bool]:
        """
        If turned on, the result of SELECT queries cached in the query cache can be read by other users. It is not recommended to enable this setting due to security reasons.
        """
        return pulumi.get(self, "query_cache_share_between_users")

    @_builtins.property
    @pulumi.getter(name="queryCacheTag")
    def query_cache_tag(self) -> Optional[_builtins.str]:
        """
        A string which acts as a label for query cache entries. The same queries with different tags are considered different by the query cache.
        """
        return pulumi.get(self, "query_cache_tag")

    @_builtins.property
    @pulumi.getter(name="queryCacheTtl")
    def query_cache_ttl(self) -> Optional[_builtins.int]:
        """
        After this time in seconds entries in the query cache become stale.
        """
        return pulumi.get(self, "query_cache_ttl")

    @_builtins.property
    @pulumi.getter(name="quotaMode")
    def quota_mode(self) -> Optional[_builtins.str]:
        """
        Quota accounting mode.
        """
        return pulumi.get(self, "quota_mode")

    @_builtins.property
    @pulumi.getter(name="readOverflowMode")
    def read_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow while read. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "read_overflow_mode")

    @_builtins.property
    @pulumi.getter
    def readonly(self) -> Optional[_builtins.int]:
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        return pulumi.get(self, "readonly")

    @_builtins.property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> Optional[_builtins.int]:
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "receive_timeout")

    @_builtins.property
    @pulumi.getter(name="remoteFilesystemReadMethod")
    def remote_filesystem_read_method(self) -> Optional[_builtins.str]:
        """
        Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        """
        return pulumi.get(self, "remote_filesystem_read_method")

    @_builtins.property
    @pulumi.getter(name="replicationAlterPartitionsSync")
    def replication_alter_partitions_sync(self) -> Optional[_builtins.int]:
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        return pulumi.get(self, "replication_alter_partitions_sync")

    @_builtins.property
    @pulumi.getter(name="resultOverflowMode")
    def result_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow in result. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "result_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="s3UseAdaptiveTimeouts")
    def s3_use_adaptive_timeouts(self) -> Optional[_builtins.bool]:
        """
        Enables or disables adaptive timeouts for S3 requests.
        """
        return pulumi.get(self, "s3_use_adaptive_timeouts")

    @_builtins.property
    @pulumi.getter(name="selectSequentialConsistency")
    def select_sequential_consistency(self) -> Optional[_builtins.bool]:
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        return pulumi.get(self, "select_sequential_consistency")

    @_builtins.property
    @pulumi.getter(name="sendProgressInHttpHeaders")
    def send_progress_in_http_headers(self) -> Optional[_builtins.bool]:
        """
        Enables or disables `X-ClickHouse-Progress` HTTP response headers in clickhouse-server responses.
        """
        return pulumi.get(self, "send_progress_in_http_headers")

    @_builtins.property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> Optional[_builtins.int]:
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "send_timeout")

    @_builtins.property
    @pulumi.getter(name="setOverflowMode")
    def set_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow in the set resulting. Possible values:
          * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "set_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="skipUnavailableShards")
    def skip_unavailable_shards(self) -> Optional[_builtins.bool]:
        """
        Enables or disables silently skipping of unavailable shards.
        """
        return pulumi.get(self, "skip_unavailable_shards")

    @_builtins.property
    @pulumi.getter(name="sortOverflowMode")
    def sort_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow while sort. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "sort_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="timeoutBeforeCheckingExecutionSpeed")
    def timeout_before_checking_execution_speed(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        """
        return pulumi.get(self, "timeout_before_checking_execution_speed")

    @_builtins.property
    @pulumi.getter(name="timeoutOverflowMode")
    def timeout_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "timeout_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="transferOverflowMode")
    def transfer_overflow_mode(self) -> Optional[_builtins.str]:
        """
        Sets behavior on overflow. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "transfer_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="transformNullIn")
    def transform_null_in(self) -> Optional[_builtins.bool]:
        """
        Enables equality of NULL values for IN operator.
        """
        return pulumi.get(self, "transform_null_in")

    @_builtins.property
    @pulumi.getter(name="useHedgedRequests")
    def use_hedged_requests(self) -> Optional[_builtins.bool]:
        """
        Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        """
        return pulumi.get(self, "use_hedged_requests")

    @_builtins.property
    @pulumi.getter(name="useQueryCache")
    def use_query_cache(self) -> Optional[_builtins.bool]:
        """
        If turned on, SELECT queries may utilize the query cache.
        """
        return pulumi.get(self, "use_query_cache")

    @_builtins.property
    @pulumi.getter(name="useUncompressedCache")
    def use_uncompressed_cache(self) -> Optional[_builtins.bool]:
        """
        Whether to use a cache of uncompressed blocks.
        """
        return pulumi.get(self, "use_uncompressed_cache")

    @_builtins.property
    @pulumi.getter(name="waitForAsyncInsert")
    def wait_for_async_insert(self) -> Optional[_builtins.bool]:
        """
        Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        """
        return pulumi.get(self, "wait_for_async_insert")

    @_builtins.property
    @pulumi.getter(name="waitForAsyncInsertTimeout")
    def wait_for_async_insert_timeout(self) -> Optional[_builtins.int]:
        """
        The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        return pulumi.get(self, "wait_for_async_insert_timeout")


@pulumi.output_type
class MdbClickhouseClusterZookeeper(dict):
    def __init__(__self__, *,
                 resources: Optional['outputs.MdbClickhouseClusterZookeeperResources'] = None):
        """
        :param 'MdbClickhouseClusterZookeeperResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbClickhouseClusterZookeeperResources']:
        """
        Resources allocated to hosts of the ZooKeeper subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbClickhouseClusterZookeeperResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbClickhouseClusterZookeeperResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbClickhouseClusterZookeeperResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbClickhouseClusterZookeeperResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbGreenplumClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "dataTransfer":
            suggest = "data_transfer"
        elif key == "webSql":
            suggest = "web_sql"
        elif key == "yandexQuery":
            suggest = "yandex_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None,
                 yandex_query: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer)
        :param _builtins.bool web_sql: Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        :param _builtins.bool yandex_query: Allow access for [Yandex Query](https://yandex.cloud/services/query)
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)
        if yandex_query is not None:
            pulumi.set(__self__, "yandex_query", yandex_query)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")

    @_builtins.property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> Optional[_builtins.bool]:
        """
        Allow access for [Yandex Query](https://yandex.cloud/services/query)
        """
        return pulumi.get(self, "yandex_query")


@pulumi.output_type
class MdbGreenplumClusterBackgroundActivity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "analyzeAndVacuums":
            suggest = "analyze_and_vacuums"
        elif key == "queryKillerIdleInTransactions":
            suggest = "query_killer_idle_in_transactions"
        elif key == "queryKillerIdles":
            suggest = "query_killer_idles"
        elif key == "queryKillerLongRunnings":
            suggest = "query_killer_long_runnings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterBackgroundActivity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterBackgroundActivity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterBackgroundActivity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyze_and_vacuums: Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum']] = None,
                 query_killer_idle_in_transactions: Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction']] = None,
                 query_killer_idles: Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityQueryKillerIdle']] = None,
                 query_killer_long_runnings: Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning']] = None):
        """
        :param Sequence['MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs'] analyze_and_vacuums: Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        :param Sequence['MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs'] query_killer_idle_in_transactions: Block to configure script that kills long running queries that are in `idle in transaction` state.
        :param Sequence['MdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs'] query_killer_idles: Block to configure script that kills long running queries that are in `idle` state.
        :param Sequence['MdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs'] query_killer_long_runnings: Block to configure script that kills long running queries (in any state).
        """
        if analyze_and_vacuums is not None:
            pulumi.set(__self__, "analyze_and_vacuums", analyze_and_vacuums)
        if query_killer_idle_in_transactions is not None:
            pulumi.set(__self__, "query_killer_idle_in_transactions", query_killer_idle_in_transactions)
        if query_killer_idles is not None:
            pulumi.set(__self__, "query_killer_idles", query_killer_idles)
        if query_killer_long_runnings is not None:
            pulumi.set(__self__, "query_killer_long_runnings", query_killer_long_runnings)

    @_builtins.property
    @pulumi.getter(name="analyzeAndVacuums")
    def analyze_and_vacuums(self) -> Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum']]:
        """
        Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        """
        return pulumi.get(self, "analyze_and_vacuums")

    @_builtins.property
    @pulumi.getter(name="queryKillerIdleInTransactions")
    def query_killer_idle_in_transactions(self) -> Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction']]:
        """
        Block to configure script that kills long running queries that are in `idle in transaction` state.
        """
        return pulumi.get(self, "query_killer_idle_in_transactions")

    @_builtins.property
    @pulumi.getter(name="queryKillerIdles")
    def query_killer_idles(self) -> Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityQueryKillerIdle']]:
        """
        Block to configure script that kills long running queries that are in `idle` state.
        """
        return pulumi.get(self, "query_killer_idles")

    @_builtins.property
    @pulumi.getter(name="queryKillerLongRunnings")
    def query_killer_long_runnings(self) -> Optional[Sequence['outputs.MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning']]:
        """
        Block to configure script that kills long running queries (in any state).
        """
        return pulumi.get(self, "query_killer_long_runnings")


@pulumi.output_type
class MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "analyzeTimeout":
            suggest = "analyze_timeout"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "vacuumTimeout":
            suggest = "vacuum_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterBackgroundActivityAnalyzeAndVacuum.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyze_timeout: Optional[_builtins.int] = None,
                 start_time: Optional[_builtins.str] = None,
                 vacuum_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int analyze_timeout: Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        :param _builtins.str start_time: Time of day in 'HH:MM' format when scripts should run.
        :param _builtins.int vacuum_timeout: Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        if analyze_timeout is not None:
            pulumi.set(__self__, "analyze_timeout", analyze_timeout)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if vacuum_timeout is not None:
            pulumi.set(__self__, "vacuum_timeout", vacuum_timeout)

    @_builtins.property
    @pulumi.getter(name="analyzeTimeout")
    def analyze_timeout(self) -> Optional[_builtins.int]:
        """
        Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        """
        return pulumi.get(self, "analyze_timeout")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Time of day in 'HH:MM' format when scripts should run.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="vacuumTimeout")
    def vacuum_timeout(self) -> Optional[_builtins.int]:
        """
        Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        return pulumi.get(self, "vacuum_timeout")


@pulumi.output_type
class MdbGreenplumClusterBackgroundActivityQueryKillerIdle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreUsers":
            suggest = "ignore_users"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterBackgroundActivityQueryKillerIdle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterBackgroundActivityQueryKillerIdle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterBackgroundActivityQueryKillerIdle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 ignore_users: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable: Flag that indicates whether script is enabled.
        :param Sequence[_builtins.str] ignore_users: List of users to ignore when considering queries to terminate.
        :param _builtins.int max_age: Maximum duration for this type of queries (in seconds).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if ignore_users is not None:
            pulumi.set(__self__, "ignore_users", ignore_users)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreUsers":
            suggest = "ignore_users"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransaction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 ignore_users: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable: Flag that indicates whether script is enabled.
        :param Sequence[_builtins.str] ignore_users: List of users to ignore when considering queries to terminate.
        :param _builtins.int max_age: Maximum duration for this type of queries (in seconds).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if ignore_users is not None:
            pulumi.set(__self__, "ignore_users", ignore_users)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreUsers":
            suggest = "ignore_users"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterBackgroundActivityQueryKillerLongRunning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 ignore_users: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable: Flag that indicates whether script is enabled.
        :param Sequence[_builtins.str] ignore_users: List of users to ignore when considering queries to terminate.
        :param _builtins.int max_age: Maximum duration for this type of queries (in seconds).
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if ignore_users is not None:
            pulumi.set(__self__, "ignore_users", ignore_users)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class MdbGreenplumClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started (UTC).
        :param _builtins.int minutes: The minute at which backup will be started (UTC).
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbGreenplumClusterCloudStorage(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable: Whether to use cloud storage or not.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Whether to use cloud storage or not.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class MdbGreenplumClusterLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandCenterEnabled":
            suggest = "command_center_enabled"
        elif key == "folderId":
            suggest = "folder_id"
        elif key == "greenplumEnabled":
            suggest = "greenplum_enabled"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "poolerEnabled":
            suggest = "pooler_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_center_enabled: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 greenplum_enabled: Optional[_builtins.bool] = None,
                 log_group_id: Optional[_builtins.str] = None,
                 pooler_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool command_center_enabled: Deliver Yandex Command Center's logs to Cloud Logging.
        :param _builtins.bool enabled: Flag that indicates whether log delivery to Cloud Logging is enabled.
        :param _builtins.str folder_id: ID of folder to which deliver logs.
        :param _builtins.bool greenplum_enabled: Deliver Greenplum's logs to Cloud Logging.
        :param _builtins.str log_group_id: Cloud Logging group ID to send logs to.
        :param _builtins.bool pooler_enabled: Deliver connection pooler's logs to Cloud Logging.
        """
        if command_center_enabled is not None:
            pulumi.set(__self__, "command_center_enabled", command_center_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if greenplum_enabled is not None:
            pulumi.set(__self__, "greenplum_enabled", greenplum_enabled)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if pooler_enabled is not None:
            pulumi.set(__self__, "pooler_enabled", pooler_enabled)

    @_builtins.property
    @pulumi.getter(name="commandCenterEnabled")
    def command_center_enabled(self) -> Optional[_builtins.bool]:
        """
        Deliver Yandex Command Center's logs to Cloud Logging.
        """
        return pulumi.get(self, "command_center_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether log delivery to Cloud Logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        ID of folder to which deliver logs.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="greenplumEnabled")
    def greenplum_enabled(self) -> Optional[_builtins.bool]:
        """
        Deliver Greenplum's logs to Cloud Logging.
        """
        return pulumi.get(self, "greenplum_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Cloud Logging group ID to send logs to.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="poolerEnabled")
    def pooler_enabled(self) -> Optional[_builtins.bool]:
        """
        Deliver connection pooler's logs to Cloud Logging.
        """
        return pulumi.get(self, "pooler_enabled")


@pulumi.output_type
class MdbGreenplumClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbGreenplumClusterMasterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterMasterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterMasterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterMasterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        """
        :param _builtins.bool assign_public_ip: Flag indicating that master hosts should be created with a public IP address.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Flag indicating that master hosts should be created with a public IP address.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class MdbGreenplumClusterMasterSubcluster(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbGreenplumClusterMasterSubclusterResources'):
        """
        :param 'MdbGreenplumClusterMasterSubclusterResourcesArgs' resources: Resources allocated to hosts for master subcluster of the Greenplum cluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbGreenplumClusterMasterSubclusterResources':
        """
        Resources allocated to hosts for master subcluster of the Greenplum cluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbGreenplumClusterMasterSubclusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterMasterSubclusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterMasterSubclusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterMasterSubclusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Greenplum hosts - environment default is used if missing.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Greenplum hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbGreenplumClusterPoolerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolClientIdleTimeout":
            suggest = "pool_client_idle_timeout"
        elif key == "poolSize":
            suggest = "pool_size"
        elif key == "poolingMode":
            suggest = "pooling_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterPoolerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterPoolerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterPoolerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_client_idle_timeout: Optional[_builtins.int] = None,
                 pool_size: Optional[_builtins.int] = None,
                 pooling_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.int pool_client_idle_timeout: Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        :param _builtins.int pool_size: Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        :param _builtins.str pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        if pool_client_idle_timeout is not None:
            pulumi.set(__self__, "pool_client_idle_timeout", pool_client_idle_timeout)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @_builtins.property
    @pulumi.getter(name="poolClientIdleTimeout")
    def pool_client_idle_timeout(self) -> Optional[_builtins.int]:
        """
        Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        """
        return pulumi.get(self, "pool_client_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[_builtins.int]:
        """
        Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        """
        return pulumi.get(self, "pool_size")

    @_builtins.property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[_builtins.str]:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class MdbGreenplumClusterPxfConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "maxThreads":
            suggest = "max_threads"
        elif key == "poolAllowCoreThreadTimeout":
            suggest = "pool_allow_core_thread_timeout"
        elif key == "poolCoreSize":
            suggest = "pool_core_size"
        elif key == "poolMaxSize":
            suggest = "pool_max_size"
        elif key == "poolQueueCapacity":
            suggest = "pool_queue_capacity"
        elif key == "uploadTimeout":
            suggest = "upload_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterPxfConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterPxfConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterPxfConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_timeout: Optional[_builtins.int] = None,
                 max_threads: Optional[_builtins.int] = None,
                 pool_allow_core_thread_timeout: Optional[_builtins.bool] = None,
                 pool_core_size: Optional[_builtins.int] = None,
                 pool_max_size: Optional[_builtins.int] = None,
                 pool_queue_capacity: Optional[_builtins.int] = None,
                 upload_timeout: Optional[_builtins.int] = None,
                 xms: Optional[_builtins.int] = None,
                 xmx: Optional[_builtins.int] = None):
        """
        :param _builtins.int connection_timeout: The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        :param _builtins.int max_threads: The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        :param _builtins.bool pool_allow_core_thread_timeout: Identifies whether or not core streaming threads are allowed to time out.
        :param _builtins.int pool_core_size: The number of core streaming threads. Value is between 1 and 1024.
        :param _builtins.int pool_max_size: The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        :param _builtins.int pool_queue_capacity: The capacity of the core streaming thread pool queue. Value is positive.
        :param _builtins.int upload_timeout: The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        :param _builtins.int xms: Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        :param _builtins.int xmx: Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if pool_allow_core_thread_timeout is not None:
            pulumi.set(__self__, "pool_allow_core_thread_timeout", pool_allow_core_thread_timeout)
        if pool_core_size is not None:
            pulumi.set(__self__, "pool_core_size", pool_core_size)
        if pool_max_size is not None:
            pulumi.set(__self__, "pool_max_size", pool_max_size)
        if pool_queue_capacity is not None:
            pulumi.set(__self__, "pool_queue_capacity", pool_queue_capacity)
        if upload_timeout is not None:
            pulumi.set(__self__, "upload_timeout", upload_timeout)
        if xms is not None:
            pulumi.set(__self__, "xms", xms)
        if xmx is not None:
            pulumi.set(__self__, "xmx", xmx)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[_builtins.int]:
        """
        The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "max_threads")

    @_builtins.property
    @pulumi.getter(name="poolAllowCoreThreadTimeout")
    def pool_allow_core_thread_timeout(self) -> Optional[_builtins.bool]:
        """
        Identifies whether or not core streaming threads are allowed to time out.
        """
        return pulumi.get(self, "pool_allow_core_thread_timeout")

    @_builtins.property
    @pulumi.getter(name="poolCoreSize")
    def pool_core_size(self) -> Optional[_builtins.int]:
        """
        The number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_core_size")

    @_builtins.property
    @pulumi.getter(name="poolMaxSize")
    def pool_max_size(self) -> Optional[_builtins.int]:
        """
        The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_max_size")

    @_builtins.property
    @pulumi.getter(name="poolQueueCapacity")
    def pool_queue_capacity(self) -> Optional[_builtins.int]:
        """
        The capacity of the core streaming thread pool queue. Value is positive.
        """
        return pulumi.get(self, "pool_queue_capacity")

    @_builtins.property
    @pulumi.getter(name="uploadTimeout")
    def upload_timeout(self) -> Optional[_builtins.int]:
        """
        The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "upload_timeout")

    @_builtins.property
    @pulumi.getter
    def xms(self) -> Optional[_builtins.int]:
        """
        Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xms")

    @_builtins.property
    @pulumi.getter
    def xmx(self) -> Optional[_builtins.int]:
        """
        Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xmx")


@pulumi.output_type
class MdbGreenplumClusterSegmentHost(dict):
    def __init__(__self__, *,
                 fqdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class MdbGreenplumClusterSegmentSubcluster(dict):
    def __init__(__self__, *,
                 resources: 'outputs.MdbGreenplumClusterSegmentSubclusterResources'):
        """
        :param 'MdbGreenplumClusterSegmentSubclusterResourcesArgs' resources: Resources allocated to hosts for segment subcluster of the Greenplum cluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbGreenplumClusterSegmentSubclusterResources':
        """
        Resources allocated to hosts for segment subcluster of the Greenplum cluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbGreenplumClusterSegmentSubclusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbGreenplumClusterSegmentSubclusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbGreenplumClusterSegmentSubclusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbGreenplumClusterSegmentSubclusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Greenplum hosts - environment default is used if missing.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Greenplum hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "brokersCount":
            suggest = "brokers_count"
        elif key == "diskSizeAutoscaling":
            suggest = "disk_size_autoscaling"
        elif key == "kafkaUi":
            suggest = "kafka_ui"
        elif key == "restApi":
            suggest = "rest_api"
        elif key == "schemaRegistry":
            suggest = "schema_registry"
        elif key == "unmanagedTopics":
            suggest = "unmanaged_topics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka: 'outputs.MdbKafkaClusterConfigKafka',
                 version: _builtins.str,
                 zones: Sequence[_builtins.str],
                 access: Optional['outputs.MdbKafkaClusterConfigAccess'] = None,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 brokers_count: Optional[_builtins.int] = None,
                 disk_size_autoscaling: Optional['outputs.MdbKafkaClusterConfigDiskSizeAutoscaling'] = None,
                 kafka_ui: Optional['outputs.MdbKafkaClusterConfigKafkaUi'] = None,
                 kraft: Optional['outputs.MdbKafkaClusterConfigKraft'] = None,
                 rest_api: Optional['outputs.MdbKafkaClusterConfigRestApi'] = None,
                 schema_registry: Optional[_builtins.bool] = None,
                 unmanaged_topics: Optional[_builtins.bool] = None,
                 zookeeper: Optional['outputs.MdbKafkaClusterConfigZookeeper'] = None):
        """
        :param 'MdbKafkaClusterConfigKafkaArgs' kafka: Configuration of the Kafka subcluster.
        :param _builtins.str version: Version of the Kafka server software.
        :param Sequence[_builtins.str] zones: List of availability zones.
        :param 'MdbKafkaClusterConfigAccessArgs' access: Access policy to the Kafka cluster.
        :param _builtins.bool assign_public_ip: Determines whether each broker will be assigned a public IP address. The default is `false`.
        :param _builtins.int brokers_count: Count of brokers per availability zone. The default is `1`.
        :param 'MdbKafkaClusterConfigDiskSizeAutoscalingArgs' disk_size_autoscaling: Disk autoscaling settings of the Kafka cluster.
        :param 'MdbKafkaClusterConfigKafkaUiArgs' kafka_ui: KAFKA UI settings of the Kafka cluster.
        :param 'MdbKafkaClusterConfigKraftArgs' kraft: Configuration of the KRaft-controller subcluster.
        :param 'MdbKafkaClusterConfigRestApiArgs' rest_api: REST API settings of the Kafka cluster.
        :param _builtins.bool schema_registry: Enables managed schema registry on cluster. The default is `false`.
        :param 'MdbKafkaClusterConfigZookeeperArgs' zookeeper: Configuration of the ZooKeeper subcluster.
        """
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zones", zones)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if brokers_count is not None:
            pulumi.set(__self__, "brokers_count", brokers_count)
        if disk_size_autoscaling is not None:
            pulumi.set(__self__, "disk_size_autoscaling", disk_size_autoscaling)
        if kafka_ui is not None:
            pulumi.set(__self__, "kafka_ui", kafka_ui)
        if kraft is not None:
            pulumi.set(__self__, "kraft", kraft)
        if rest_api is not None:
            pulumi.set(__self__, "rest_api", rest_api)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if unmanaged_topics is not None:
            pulumi.set(__self__, "unmanaged_topics", unmanaged_topics)
        if zookeeper is not None:
            pulumi.set(__self__, "zookeeper", zookeeper)

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> 'outputs.MdbKafkaClusterConfigKafka':
        """
        Configuration of the Kafka subcluster.
        """
        return pulumi.get(self, "kafka")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the Kafka server software.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        List of availability zones.
        """
        return pulumi.get(self, "zones")

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional['outputs.MdbKafkaClusterConfigAccess']:
        """
        Access policy to the Kafka cluster.
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Determines whether each broker will be assigned a public IP address. The default is `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="brokersCount")
    def brokers_count(self) -> Optional[_builtins.int]:
        """
        Count of brokers per availability zone. The default is `1`.
        """
        return pulumi.get(self, "brokers_count")

    @_builtins.property
    @pulumi.getter(name="diskSizeAutoscaling")
    def disk_size_autoscaling(self) -> Optional['outputs.MdbKafkaClusterConfigDiskSizeAutoscaling']:
        """
        Disk autoscaling settings of the Kafka cluster.
        """
        return pulumi.get(self, "disk_size_autoscaling")

    @_builtins.property
    @pulumi.getter(name="kafkaUi")
    def kafka_ui(self) -> Optional['outputs.MdbKafkaClusterConfigKafkaUi']:
        """
        KAFKA UI settings of the Kafka cluster.
        """
        return pulumi.get(self, "kafka_ui")

    @_builtins.property
    @pulumi.getter
    def kraft(self) -> Optional['outputs.MdbKafkaClusterConfigKraft']:
        """
        Configuration of the KRaft-controller subcluster.
        """
        return pulumi.get(self, "kraft")

    @_builtins.property
    @pulumi.getter(name="restApi")
    def rest_api(self) -> Optional['outputs.MdbKafkaClusterConfigRestApi']:
        """
        REST API settings of the Kafka cluster.
        """
        return pulumi.get(self, "rest_api")

    @_builtins.property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[_builtins.bool]:
        """
        Enables managed schema registry on cluster. The default is `false`.
        """
        return pulumi.get(self, "schema_registry")

    @_builtins.property
    @pulumi.getter(name="unmanagedTopics")
    @_utilities.deprecated("""The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""")
    def unmanaged_topics(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "unmanaged_topics")

    @_builtins.property
    @pulumi.getter
    def zookeeper(self) -> Optional['outputs.MdbKafkaClusterConfigZookeeper']:
        """
        Configuration of the ZooKeeper subcluster.
        """
        return pulumi.get(self, "zookeeper")


@pulumi.output_type
class MdbKafkaClusterConfigAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataTransfer":
            suggest = "data_transfer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_transfer: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")


@pulumi.output_type
class MdbKafkaClusterConfigDiskSizeAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigDiskSizeAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigDiskSizeAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigDiskSizeAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Maximum possible size of disk in bytes.
        :param _builtins.int emergency_usage_threshold: Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned*usage*threshold' value.
        :param _builtins.int planned_usage_threshold: Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Maximum possible size of disk in bytes.
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned*usage*threshold' value.
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbKafkaClusterConfigKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaConfig":
            suggest = "kafka_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resources: 'outputs.MdbKafkaClusterConfigKafkaResources',
                 kafka_config: Optional['outputs.MdbKafkaClusterConfigKafkaKafkaConfig'] = None):
        """
        :param 'MdbKafkaClusterConfigKafkaResourcesArgs' resources: Resources allocated to hosts of the Kafka subcluster.
        :param 'MdbKafkaClusterConfigKafkaKafkaConfigArgs' kafka_config: User-defined settings for the Kafka cluster. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        pulumi.set(__self__, "resources", resources)
        if kafka_config is not None:
            pulumi.set(__self__, "kafka_config", kafka_config)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbKafkaClusterConfigKafkaResources':
        """
        Resources allocated to hosts of the Kafka subcluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="kafkaConfig")
    def kafka_config(self) -> Optional['outputs.MdbKafkaClusterConfigKafkaKafkaConfig']:
        """
        User-defined settings for the Kafka cluster. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "kafka_config")


@pulumi.output_type
class MdbKafkaClusterConfigKafkaKafkaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCreateTopicsEnable":
            suggest = "auto_create_topics_enable"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "defaultReplicationFactor":
            suggest = "default_replication_factor"
        elif key == "logFlushIntervalMessages":
            suggest = "log_flush_interval_messages"
        elif key == "logFlushIntervalMs":
            suggest = "log_flush_interval_ms"
        elif key == "logFlushSchedulerIntervalMs":
            suggest = "log_flush_scheduler_interval_ms"
        elif key == "logPreallocate":
            suggest = "log_preallocate"
        elif key == "logRetentionBytes":
            suggest = "log_retention_bytes"
        elif key == "logRetentionHours":
            suggest = "log_retention_hours"
        elif key == "logRetentionMinutes":
            suggest = "log_retention_minutes"
        elif key == "logRetentionMs":
            suggest = "log_retention_ms"
        elif key == "logSegmentBytes":
            suggest = "log_segment_bytes"
        elif key == "messageMaxBytes":
            suggest = "message_max_bytes"
        elif key == "numPartitions":
            suggest = "num_partitions"
        elif key == "offsetsRetentionMinutes":
            suggest = "offsets_retention_minutes"
        elif key == "replicaFetchMaxBytes":
            suggest = "replica_fetch_max_bytes"
        elif key == "saslEnabledMechanisms":
            suggest = "sasl_enabled_mechanisms"
        elif key == "socketReceiveBufferBytes":
            suggest = "socket_receive_buffer_bytes"
        elif key == "socketSendBufferBytes":
            suggest = "socket_send_buffer_bytes"
        elif key == "sslCipherSuites":
            suggest = "ssl_cipher_suites"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKafkaKafkaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKafkaKafkaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKafkaKafkaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[_builtins.bool] = None,
                 compression_type: Optional[_builtins.str] = None,
                 default_replication_factor: Optional[_builtins.str] = None,
                 log_flush_interval_messages: Optional[_builtins.str] = None,
                 log_flush_interval_ms: Optional[_builtins.str] = None,
                 log_flush_scheduler_interval_ms: Optional[_builtins.str] = None,
                 log_preallocate: Optional[_builtins.bool] = None,
                 log_retention_bytes: Optional[_builtins.str] = None,
                 log_retention_hours: Optional[_builtins.str] = None,
                 log_retention_minutes: Optional[_builtins.str] = None,
                 log_retention_ms: Optional[_builtins.str] = None,
                 log_segment_bytes: Optional[_builtins.str] = None,
                 message_max_bytes: Optional[_builtins.str] = None,
                 num_partitions: Optional[_builtins.str] = None,
                 offsets_retention_minutes: Optional[_builtins.str] = None,
                 replica_fetch_max_bytes: Optional[_builtins.str] = None,
                 sasl_enabled_mechanisms: Optional[Sequence[_builtins.str]] = None,
                 socket_receive_buffer_bytes: Optional[_builtins.str] = None,
                 socket_send_buffer_bytes: Optional[_builtins.str] = None,
                 ssl_cipher_suites: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool auto_create_topics_enable: Enable auto creation of topic on the server.
        :param _builtins.str compression_type: Compression type of kafka topics.
        :param _builtins.str default_replication_factor: The replication factor for automatically created topics, and for topics created with -1 as the replication factor.
        :param _builtins.str log_flush_interval_messages: The number of messages accumulated on a log partition before messages are flushed to disk.
        :param _builtins.str log_flush_interval_ms: The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
        :param _builtins.str log_flush_scheduler_interval_ms: The frequency in ms that the log flusher checks whether any log needs to be flushed to disk.
        :param _builtins.bool log_preallocate: Should pre allocate file when create new segment?
        :param _builtins.str log_retention_bytes: The maximum size of the log before deleting it.
        :param _builtins.str log_retention_hours: The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property.
        :param _builtins.str log_retention_minutes: The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used.
        :param _builtins.str log_retention_ms: The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
        :param _builtins.str log_segment_bytes: The maximum size of a single log file.
        :param _builtins.str message_max_bytes: The largest record batch size allowed by Kafka (after compression if compression is enabled).
        :param _builtins.str num_partitions: The default number of log partitions per topic.
        :param _builtins.str offsets_retention_minutes: For subscribed consumers, committed offset of a specific partition will be expired and discarded after this period of time.
        :param _builtins.str replica_fetch_max_bytes: The number of bytes of messages to attempt to fetch for each partition.
        :param Sequence[_builtins.str] sasl_enabled_mechanisms: The list of SASL mechanisms enabled in the Kafka server.
        :param _builtins.str socket_receive_buffer_bytes: The SO_RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        :param _builtins.str socket_send_buffer_bytes: The SO_SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        :param Sequence[_builtins.str] ssl_cipher_suites: A list of cipher suites.
        """
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_flush_scheduler_interval_ms is not None:
            pulumi.set(__self__, "log_flush_scheduler_interval_ms", log_flush_scheduler_interval_ms)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_minutes is not None:
            pulumi.set(__self__, "log_retention_minutes", log_retention_minutes)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if sasl_enabled_mechanisms is not None:
            pulumi.set(__self__, "sasl_enabled_mechanisms", sasl_enabled_mechanisms)
        if socket_receive_buffer_bytes is not None:
            pulumi.set(__self__, "socket_receive_buffer_bytes", socket_receive_buffer_bytes)
        if socket_send_buffer_bytes is not None:
            pulumi.set(__self__, "socket_send_buffer_bytes", socket_send_buffer_bytes)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)

    @_builtins.property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[_builtins.bool]:
        """
        Enable auto creation of topic on the server.
        """
        return pulumi.get(self, "auto_create_topics_enable")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        Compression type of kafka topics.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[_builtins.str]:
        """
        The replication factor for automatically created topics, and for topics created with -1 as the replication factor.
        """
        return pulumi.get(self, "default_replication_factor")

    @_builtins.property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[_builtins.str]:
        """
        The number of messages accumulated on a log partition before messages are flushed to disk.
        """
        return pulumi.get(self, "log_flush_interval_messages")

    @_builtins.property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
        """
        return pulumi.get(self, "log_flush_interval_ms")

    @_builtins.property
    @pulumi.getter(name="logFlushSchedulerIntervalMs")
    def log_flush_scheduler_interval_ms(self) -> Optional[_builtins.str]:
        """
        The frequency in ms that the log flusher checks whether any log needs to be flushed to disk.
        """
        return pulumi.get(self, "log_flush_scheduler_interval_ms")

    @_builtins.property
    @pulumi.getter(name="logPreallocate")
    @_utilities.deprecated("""The 'log_preallocate' field has been deprecated, because feature not useful for Yandex Cloud.""")
    def log_preallocate(self) -> Optional[_builtins.bool]:
        """
        Should pre allocate file when create new segment?
        """
        return pulumi.get(self, "log_preallocate")

    @_builtins.property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size of the log before deleting it.
        """
        return pulumi.get(self, "log_retention_bytes")

    @_builtins.property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[_builtins.str]:
        """
        The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property.
        """
        return pulumi.get(self, "log_retention_hours")

    @_builtins.property
    @pulumi.getter(name="logRetentionMinutes")
    def log_retention_minutes(self) -> Optional[_builtins.str]:
        """
        The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used.
        """
        return pulumi.get(self, "log_retention_minutes")

    @_builtins.property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[_builtins.str]:
        """
        The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
        """
        return pulumi.get(self, "log_retention_ms")

    @_builtins.property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size of a single log file.
        """
        return pulumi.get(self, "log_segment_bytes")

    @_builtins.property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[_builtins.str]:
        """
        The largest record batch size allowed by Kafka (after compression if compression is enabled).
        """
        return pulumi.get(self, "message_max_bytes")

    @_builtins.property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[_builtins.str]:
        """
        The default number of log partitions per topic.
        """
        return pulumi.get(self, "num_partitions")

    @_builtins.property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[_builtins.str]:
        """
        For subscribed consumers, committed offset of a specific partition will be expired and discarded after this period of time.
        """
        return pulumi.get(self, "offsets_retention_minutes")

    @_builtins.property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[_builtins.str]:
        """
        The number of bytes of messages to attempt to fetch for each partition.
        """
        return pulumi.get(self, "replica_fetch_max_bytes")

    @_builtins.property
    @pulumi.getter(name="saslEnabledMechanisms")
    def sasl_enabled_mechanisms(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of SASL mechanisms enabled in the Kafka server.
        """
        return pulumi.get(self, "sasl_enabled_mechanisms")

    @_builtins.property
    @pulumi.getter(name="socketReceiveBufferBytes")
    def socket_receive_buffer_bytes(self) -> Optional[_builtins.str]:
        """
        The SO_RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        """
        return pulumi.get(self, "socket_receive_buffer_bytes")

    @_builtins.property
    @pulumi.getter(name="socketSendBufferBytes")
    def socket_send_buffer_bytes(self) -> Optional[_builtins.str]:
        """
        The SO_SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        """
        return pulumi.get(self, "socket_send_buffer_bytes")

    @_builtins.property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of cipher suites.
        """
        return pulumi.get(self, "ssl_cipher_suites")


@pulumi.output_type
class MdbKafkaClusterConfigKafkaResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKafkaResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKafkaResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKafkaResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a Kafka host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Kafka hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a Kafka host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a Kafka host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Kafka hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a Kafka host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterConfigKafkaUi(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables KAFKA UI on cluster. The default is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables KAFKA UI on cluster. The default is `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MdbKafkaClusterConfigKraft(dict):
    def __init__(__self__, *,
                 resources: Optional['outputs.MdbKafkaClusterConfigKraftResources'] = None):
        """
        :param 'MdbKafkaClusterConfigKraftResourcesArgs' resources: Resources allocated to hosts of the KRaft-controller subcluster.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbKafkaClusterConfigKraftResources']:
        """
        Resources allocated to hosts of the KRaft-controller subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbKafkaClusterConfigKraftResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigKraftResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigKraftResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigKraftResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a KRaft-controller host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a KRaft-controller host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterConfigRestApi(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables REST API on cluster. The default is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables REST API on cluster. The default is `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MdbKafkaClusterConfigZookeeper(dict):
    def __init__(__self__, *,
                 resources: Optional['outputs.MdbKafkaClusterConfigZookeeperResources'] = None):
        """
        :param 'MdbKafkaClusterConfigZookeeperResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MdbKafkaClusterConfigZookeeperResources']:
        """
        Resources allocated to hosts of the ZooKeeper subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MdbKafkaClusterConfigZookeeperResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterConfigZookeeperResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterConfigZookeeperResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterConfigZookeeperResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbKafkaClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 health: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool assign_public_ip: The flag that defines whether a public IP address is assigned to the node.
        :param _builtins.str health: Health of the host.
        :param _builtins.str name: The fully qualified domain name of the host.
        :param _builtins.str role: Role of the host in the cluster.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional[_builtins.str]:
        """
        Health of the host.
        """
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class MdbKafkaClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbKafkaClusterTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationFactor":
            suggest = "replication_factor"
        elif key == "topicConfig":
            suggest = "topic_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 partitions: _builtins.int,
                 replication_factor: _builtins.int,
                 topic_config: Optional['outputs.MdbKafkaClusterTopicTopicConfig'] = None):
        """
        :param _builtins.str name: The name of the topic.
        :param _builtins.int partitions: The number of the topic's partitions.
        :param _builtins.int replication_factor: Amount of data copies (replicas) for the topic in the cluster.
        :param 'MdbKafkaClusterTopicTopicConfigArgs' topic_config: User-defined settings for the topic. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replication_factor", replication_factor)
        if topic_config is not None:
            pulumi.set(__self__, "topic_config", topic_config)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> _builtins.int:
        """
        The number of the topic's partitions.
        """
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        """
        Amount of data copies (replicas) for the topic in the cluster.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="topicConfig")
    def topic_config(self) -> Optional['outputs.MdbKafkaClusterTopicTopicConfig']:
        """
        User-defined settings for the topic. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "topic_config")


@pulumi.output_type
class MdbKafkaClusterTopicTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterTopicTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterTopicTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterTopicTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 compression_type: Optional[_builtins.str] = None,
                 delete_retention_ms: Optional[_builtins.str] = None,
                 file_delete_delay_ms: Optional[_builtins.str] = None,
                 flush_messages: Optional[_builtins.str] = None,
                 flush_ms: Optional[_builtins.str] = None,
                 max_message_bytes: Optional[_builtins.str] = None,
                 min_compaction_lag_ms: Optional[_builtins.str] = None,
                 min_insync_replicas: Optional[_builtins.str] = None,
                 preallocate: Optional[_builtins.bool] = None,
                 retention_bytes: Optional[_builtins.str] = None,
                 retention_ms: Optional[_builtins.str] = None,
                 segment_bytes: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: Retention policy to use on log segments.
        :param _builtins.str compression_type: Compression type of kafka topic.
        :param _builtins.str delete_retention_ms: The amount of time to retain delete tombstone markers for log compacted topics.
        :param _builtins.str file_delete_delay_ms: The time to wait before deleting a file from the filesystem.
        :param _builtins.str flush_messages: This setting allows specifying an interval at which we will force an fsync of data written to the log.
        :param _builtins.str flush_ms: This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        :param _builtins.str max_message_bytes: The largest record batch size allowed by Kafka (after compression if compression is enabled).
        :param _builtins.str min_compaction_lag_ms: The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        :param _builtins.str min_insync_replicas: When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        :param _builtins.bool preallocate: True if we should preallocate the file on disk when creating a new log segment.
        :param _builtins.str retention_bytes: This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str retention_ms: This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str segment_bytes: This configuration controls the segment file size for the log.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        Retention policy to use on log segments.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        Compression type of kafka topic.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[_builtins.str]:
        """
        The amount of time to retain delete tombstone markers for log compacted topics.
        """
        return pulumi.get(self, "delete_retention_ms")

    @_builtins.property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[_builtins.str]:
        """
        The time to wait before deleting a file from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @_builtins.property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[_builtins.str]:
        """
        This setting allows specifying an interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_messages")

    @_builtins.property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[_builtins.str]:
        """
        This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_ms")

    @_builtins.property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[_builtins.str]:
        """
        The largest record batch size allowed by Kafka (after compression if compression is enabled).
        """
        return pulumi.get(self, "max_message_bytes")

    @_builtins.property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[_builtins.str]:
        """
        The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        """
        return pulumi.get(self, "min_compaction_lag_ms")

    @_builtins.property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[_builtins.str]:
        """
        When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'preallocate' field has been deprecated, because feature not useful for Yandex Cloud.""")
    def preallocate(self) -> Optional[_builtins.bool]:
        """
        True if we should preallocate the file on disk when creating a new log segment.
        """
        return pulumi.get(self, "preallocate")

    @_builtins.property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[_builtins.str]:
        """
        This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_bytes")

    @_builtins.property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[_builtins.str]:
        """
        This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_ms")

    @_builtins.property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[_builtins.str]:
        """
        This configuration controls the segment file size for the log.
        """
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class MdbKafkaClusterUser(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 permissions: Optional[Sequence['outputs.MdbKafkaClusterUserPermission']] = None):
        """
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param Sequence['MdbKafkaClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbKafkaClusterUserPermission']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbKafkaClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicName":
            suggest = "topic_name"
        elif key == "allowHosts":
            suggest = "allow_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: _builtins.str,
                 topic_name: _builtins.str,
                 allow_hosts: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str role: The role type to grant to the topic.
        :param _builtins.str topic_name: The name of the topic that the permission grants access to.
        :param Sequence[_builtins.str] allow_hosts: Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)
        if allow_hosts is not None:
            pulumi.set(__self__, "allow_hosts", allow_hosts)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        return pulumi.get(self, "allow_hosts")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormaker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationFactor":
            suggest = "replication_factor"
        elif key == "sourceCluster":
            suggest = "source_cluster"
        elif key == "targetCluster":
            suggest = "target_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigMirrormaker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormaker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormaker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replication_factor: _builtins.int,
                 source_cluster: 'outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster',
                 target_cluster: 'outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster',
                 topics: _builtins.str):
        """
        :param _builtins.int replication_factor: Replication factor for topics created in target cluster.
        :param 'MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs' source_cluster: Settings for source cluster.
        :param 'MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs' target_cluster: Settings for target cluster.
        :param _builtins.str topics: The pattern for topic names to be replicated.
        """
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "source_cluster", source_cluster)
        pulumi.set(__self__, "target_cluster", target_cluster)
        pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        """
        Replication factor for topics created in target cluster.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="sourceCluster")
    def source_cluster(self) -> 'outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster':
        """
        Settings for source cluster.
        """
        return pulumi.get(self, "source_cluster")

    @_builtins.property
    @pulumi.getter(name="targetCluster")
    def target_cluster(self) -> 'outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster':
        """
        Settings for target cluster.
        """
        return pulumi.get(self, "target_cluster")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> _builtins.str:
        """
        The pattern for topic names to be replicated.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalClusters":
            suggest = "external_clusters"
        elif key == "thisClusters":
            suggest = "this_clusters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 external_clusters: Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster']] = None,
                 this_clusters: Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster']] = None):
        """
        :param _builtins.str alias: Name of the cluster. Used also as a topic prefix.
        :param Sequence['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs'] external_clusters: Connection settings for external cluster.
        :param Sequence['MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs'] this_clusters: Using this section in the cluster definition (source or target) means it's this cluster.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if external_clusters is not None:
            pulumi.set(__self__, "external_clusters", external_clusters)
        if this_clusters is not None:
            pulumi.set(__self__, "this_clusters", this_clusters)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Name of the cluster. Used also as a topic prefix.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="externalClusters")
    def external_clusters(self) -> Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster']]:
        """
        Connection settings for external cluster.
        """
        return pulumi.get(self, "external_clusters")

    @_builtins.property
    @pulumi.getter(name="thisClusters")
    def this_clusters(self) -> Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster']]:
        """
        Using this section in the cluster definition (source or target) means it's this cluster.
        """
        return pulumi.get(self, "this_clusters")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapServers":
            suggest = "bootstrap_servers"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPassword":
            suggest = "sasl_password"
        elif key == "saslUsername":
            suggest = "sasl_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap_servers: _builtins.str,
                 sasl_mechanism: Optional[_builtins.str] = None,
                 sasl_password: Optional[_builtins.str] = None,
                 sasl_username: Optional[_builtins.str] = None,
                 security_protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str bootstrap_servers: List of bootstrap servers to connect to cluster.
        :param _builtins.str sasl_mechanism: Type of SASL authentification mechanism to use.
        :param _builtins.str sasl_password: Password to use in SASL authentification mechanism
        :param _builtins.str sasl_username: Username to use in SASL authentification mechanism.
        :param _builtins.str security_protocol: Security protocol to use.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> _builtins.str:
        """
        List of bootstrap servers to connect to cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[_builtins.str]:
        """
        Type of SASL authentification mechanism to use.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[_builtins.str]:
        """
        Password to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[_builtins.str]:
        """
        Username to use in SASL authentification mechanism.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[_builtins.str]:
        """
        Security protocol to use.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalClusters":
            suggest = "external_clusters"
        elif key == "thisClusters":
            suggest = "this_clusters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 external_clusters: Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster']] = None,
                 this_clusters: Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster']] = None):
        """
        :param _builtins.str alias: Name of the cluster. Used also as a topic prefix.
        :param Sequence['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs'] external_clusters: Connection settings for external cluster.
        :param Sequence['MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs'] this_clusters: Using this section in the cluster definition (source or target) means it's this cluster.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if external_clusters is not None:
            pulumi.set(__self__, "external_clusters", external_clusters)
        if this_clusters is not None:
            pulumi.set(__self__, "this_clusters", this_clusters)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Name of the cluster. Used also as a topic prefix.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="externalClusters")
    def external_clusters(self) -> Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster']]:
        """
        Connection settings for external cluster.
        """
        return pulumi.get(self, "external_clusters")

    @_builtins.property
    @pulumi.getter(name="thisClusters")
    def this_clusters(self) -> Optional[Sequence['outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster']]:
        """
        Using this section in the cluster definition (source or target) means it's this cluster.
        """
        return pulumi.get(self, "this_clusters")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapServers":
            suggest = "bootstrap_servers"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "saslPassword":
            suggest = "sasl_password"
        elif key == "saslUsername":
            suggest = "sasl_username"
        elif key == "securityProtocol":
            suggest = "security_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap_servers: _builtins.str,
                 sasl_mechanism: Optional[_builtins.str] = None,
                 sasl_password: Optional[_builtins.str] = None,
                 sasl_username: Optional[_builtins.str] = None,
                 security_protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str bootstrap_servers: List of bootstrap servers to connect to cluster.
        :param _builtins.str sasl_mechanism: Type of SASL authentification mechanism to use.
        :param _builtins.str sasl_password: Password to use in SASL authentification mechanism
        :param _builtins.str sasl_username: Username to use in SASL authentification mechanism.
        :param _builtins.str security_protocol: Security protocol to use.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> _builtins.str:
        """
        List of bootstrap servers to connect to cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[_builtins.str]:
        """
        Type of SASL authentification mechanism to use.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[_builtins.str]:
        """
        Password to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[_builtins.str]:
        """
        Username to use in SASL authentification mechanism.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[_builtins.str]:
        """
        Security protocol to use.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigS3Sink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileCompressionType":
            suggest = "file_compression_type"
        elif key == "s3Connection":
            suggest = "s3_connection"
        elif key == "fileMaxRecords":
            suggest = "file_max_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigS3Sink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigS3Sink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigS3Sink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_compression_type: _builtins.str,
                 s3_connection: 'outputs.MdbKafkaConnectorConnectorConfigS3SinkS3Connection',
                 topics: _builtins.str,
                 file_max_records: Optional[_builtins.int] = None):
        """
        :param _builtins.str file_compression_type: Compression type for messages. Cannot be changed.
        :param 'MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs' s3_connection: Settings for connection to s3-compatible storage.
        :param _builtins.str topics: The pattern for topic names to be copied to s3 bucket.
        :param _builtins.int file_max_records: Max records per file.
        """
        pulumi.set(__self__, "file_compression_type", file_compression_type)
        pulumi.set(__self__, "s3_connection", s3_connection)
        pulumi.set(__self__, "topics", topics)
        if file_max_records is not None:
            pulumi.set(__self__, "file_max_records", file_max_records)

    @_builtins.property
    @pulumi.getter(name="fileCompressionType")
    def file_compression_type(self) -> _builtins.str:
        """
        Compression type for messages. Cannot be changed.
        """
        return pulumi.get(self, "file_compression_type")

    @_builtins.property
    @pulumi.getter(name="s3Connection")
    def s3_connection(self) -> 'outputs.MdbKafkaConnectorConnectorConfigS3SinkS3Connection':
        """
        Settings for connection to s3-compatible storage.
        """
        return pulumi.get(self, "s3_connection")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> _builtins.str:
        """
        The pattern for topic names to be copied to s3 bucket.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="fileMaxRecords")
    def file_max_records(self) -> Optional[_builtins.int]:
        """
        Max records per file.
        """
        return pulumi.get(self, "file_max_records")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigS3SinkS3Connection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "externalS3s":
            suggest = "external_s3s"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigS3SinkS3Connection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigS3SinkS3Connection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigS3SinkS3Connection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 external_s3s: Sequence['outputs.MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3']):
        """
        :param _builtins.str bucket_name: Name of the bucket in s3-compatible storage.
        :param Sequence['MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args'] external_s3s: Connection params for external s3-compatible storage.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "external_s3s", external_s3s)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Name of the bucket in s3-compatible storage.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="externalS3s")
    def external_s3s(self) -> Sequence['outputs.MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3']:
        """
        Connection params for external s3-compatible storage.
        """
        return pulumi.get(self, "external_s3s")


@pulumi.output_type
class MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 access_key_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint: URL of s3-compatible storage.
        :param _builtins.str access_key_id: ID of aws-compatible static key.
        :param _builtins.str region: Region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        :param _builtins.str secret_access_key: Secret key of aws-compatible static key.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        URL of s3-compatible storage.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[_builtins.str]:
        """
        ID of aws-compatible static key.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        Secret key of aws-compatible static key.
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class MdbKafkaTopicTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaTopicTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaTopicTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaTopicTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 compression_type: Optional[_builtins.str] = None,
                 delete_retention_ms: Optional[_builtins.str] = None,
                 file_delete_delay_ms: Optional[_builtins.str] = None,
                 flush_messages: Optional[_builtins.str] = None,
                 flush_ms: Optional[_builtins.str] = None,
                 max_message_bytes: Optional[_builtins.str] = None,
                 min_compaction_lag_ms: Optional[_builtins.str] = None,
                 min_insync_replicas: Optional[_builtins.str] = None,
                 preallocate: Optional[_builtins.bool] = None,
                 retention_bytes: Optional[_builtins.str] = None,
                 retention_ms: Optional[_builtins.str] = None,
                 segment_bytes: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: Retention policy to use on log segments.
        :param _builtins.str compression_type: Compression type of kafka topic.
        :param _builtins.str delete_retention_ms: The amount of time to retain delete tombstone markers for log compacted topics.
        :param _builtins.str file_delete_delay_ms: The time to wait before deleting a file from the filesystem.
        :param _builtins.str flush_messages: This setting allows specifying an interval at which we will force an fsync of data written to the log.
        :param _builtins.str flush_ms: This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        :param _builtins.str max_message_bytes: The largest record batch size allowed by Kafka (after compression if compression is enabled).
        :param _builtins.str min_compaction_lag_ms: The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        :param _builtins.str min_insync_replicas: When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        :param _builtins.bool preallocate: True if we should preallocate the file on disk when creating a new log segment.
        :param _builtins.str retention_bytes: This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str retention_ms: This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str segment_bytes: This configuration controls the segment file size for the log.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        Retention policy to use on log segments.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        Compression type of kafka topic.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[_builtins.str]:
        """
        The amount of time to retain delete tombstone markers for log compacted topics.
        """
        return pulumi.get(self, "delete_retention_ms")

    @_builtins.property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[_builtins.str]:
        """
        The time to wait before deleting a file from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @_builtins.property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[_builtins.str]:
        """
        This setting allows specifying an interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_messages")

    @_builtins.property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[_builtins.str]:
        """
        This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_ms")

    @_builtins.property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[_builtins.str]:
        """
        The largest record batch size allowed by Kafka (after compression if compression is enabled).
        """
        return pulumi.get(self, "max_message_bytes")

    @_builtins.property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[_builtins.str]:
        """
        The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        """
        return pulumi.get(self, "min_compaction_lag_ms")

    @_builtins.property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[_builtins.str]:
        """
        When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'preallocate' field has been deprecated, because feature not useful for Yandex Cloud.""")
    def preallocate(self) -> Optional[_builtins.bool]:
        """
        True if we should preallocate the file on disk when creating a new log segment.
        """
        return pulumi.get(self, "preallocate")

    @_builtins.property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[_builtins.str]:
        """
        This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_bytes")

    @_builtins.property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[_builtins.str]:
        """
        This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_ms")

    @_builtins.property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[_builtins.str]:
        """
        This configuration controls the segment file size for the log.
        """
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class MdbKafkaUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicName":
            suggest = "topic_name"
        elif key == "allowHosts":
            suggest = "allow_hosts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbKafkaUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbKafkaUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbKafkaUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: _builtins.str,
                 topic_name: _builtins.str,
                 allow_hosts: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str role: The role type to grant to the topic.
        :param _builtins.str topic_name: The name of the topic that the permission grants access to.
        :param Sequence[_builtins.str] allow_hosts: Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)
        if allow_hosts is not None:
            pulumi.set(__self__, "allow_hosts", allow_hosts)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        return pulumi.get(self, "allow_hosts")


@pulumi.output_type
class MdbMongodbClusterClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupRetainPeriodDays":
            suggest = "backup_retain_period_days"
        elif key == "backupWindowStart":
            suggest = "backup_window_start"
        elif key == "featureCompatibilityVersion":
            suggest = "feature_compatibility_version"
        elif key == "performanceDiagnostics":
            suggest = "performance_diagnostics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: _builtins.str,
                 access: Optional['outputs.MdbMongodbClusterClusterConfigAccess'] = None,
                 backup_retain_period_days: Optional[_builtins.int] = None,
                 backup_window_start: Optional['outputs.MdbMongodbClusterClusterConfigBackupWindowStart'] = None,
                 feature_compatibility_version: Optional[_builtins.str] = None,
                 mongocfg: Optional['outputs.MdbMongodbClusterClusterConfigMongocfg'] = None,
                 mongod: Optional['outputs.MdbMongodbClusterClusterConfigMongod'] = None,
                 mongos: Optional['outputs.MdbMongodbClusterClusterConfigMongos'] = None,
                 performance_diagnostics: Optional['outputs.MdbMongodbClusterClusterConfigPerformanceDiagnostics'] = None):
        """
        :param _builtins.str version: Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        :param 'MdbMongodbClusterClusterConfigAccessArgs' access: Access policy to the MongoDB cluster.
        :param _builtins.int backup_retain_period_days: Retain period of automatically created backup in days.
        :param 'MdbMongodbClusterClusterConfigBackupWindowStartArgs' backup_window_start: Time to start the daily backup, in the UTC timezone.
        :param _builtins.str feature_compatibility_version: Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        :param 'MdbMongodbClusterClusterConfigMongocfgArgs' mongocfg: Configuration of the mongocfg service.
        :param 'MdbMongodbClusterClusterConfigMongodArgs' mongod: Configuration of the mongod service.
        :param 'MdbMongodbClusterClusterConfigMongosArgs' mongos: Configuration of the mongos service.
        :param 'MdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs' performance_diagnostics: Performance diagnostics to the MongoDB cluster.
        """
        pulumi.set(__self__, "version", version)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if backup_retain_period_days is not None:
            pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if feature_compatibility_version is not None:
            pulumi.set(__self__, "feature_compatibility_version", feature_compatibility_version)
        if mongocfg is not None:
            pulumi.set(__self__, "mongocfg", mongocfg)
        if mongod is not None:
            pulumi.set(__self__, "mongod", mongod)
        if mongos is not None:
            pulumi.set(__self__, "mongos", mongos)
        if performance_diagnostics is not None:
            pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional['outputs.MdbMongodbClusterClusterConfigAccess']:
        """
        Access policy to the MongoDB cluster.
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> Optional[_builtins.int]:
        """
        Retain period of automatically created backup in days.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @_builtins.property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional['outputs.MdbMongodbClusterClusterConfigBackupWindowStart']:
        """
        Time to start the daily backup, in the UTC timezone.
        """
        return pulumi.get(self, "backup_window_start")

    @_builtins.property
    @pulumi.getter(name="featureCompatibilityVersion")
    def feature_compatibility_version(self) -> Optional[_builtins.str]:
        """
        Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        """
        return pulumi.get(self, "feature_compatibility_version")

    @_builtins.property
    @pulumi.getter
    def mongocfg(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongocfg']:
        """
        Configuration of the mongocfg service.
        """
        return pulumi.get(self, "mongocfg")

    @_builtins.property
    @pulumi.getter
    def mongod(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongod']:
        """
        Configuration of the mongod service.
        """
        return pulumi.get(self, "mongod")

    @_builtins.property
    @pulumi.getter
    def mongos(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongos']:
        """
        Configuration of the mongos service.
        """
        return pulumi.get(self, "mongos")

    @_builtins.property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> Optional['outputs.MdbMongodbClusterClusterConfigPerformanceDiagnostics']:
        """
        Performance diagnostics to the MongoDB cluster.
        """
        return pulumi.get(self, "performance_diagnostics")


@pulumi.output_type
class MdbMongodbClusterClusterConfigAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "dataTransfer":
            suggest = "data_transfer"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        :param _builtins.bool web_sql: Allow access for [WebSQL](https://yandex.cloud/ru/docs/websql/).
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allow access for [WebSQL](https://yandex.cloud/ru/docs/websql/).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbMongodbClusterClusterConfigBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongocfg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationProfiling":
            suggest = "operation_profiling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongocfg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongocfg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongocfg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 net: Optional['outputs.MdbMongodbClusterClusterConfigMongocfgNet'] = None,
                 operation_profiling: Optional['outputs.MdbMongodbClusterClusterConfigMongocfgOperationProfiling'] = None,
                 storage: Optional['outputs.MdbMongodbClusterClusterConfigMongocfgStorage'] = None):
        """
        :param 'MdbMongodbClusterClusterConfigMongocfgNetArgs' net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        :param 'MdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs' operation_profiling: A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        :param 'MdbMongodbClusterClusterConfigMongocfgStorageArgs' storage: A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def net(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongocfgNet']:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        return pulumi.get(self, "net")

    @_builtins.property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongocfgOperationProfiling']:
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        """
        return pulumi.get(self, "operation_profiling")

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongocfgStorage']:
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongocfgNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIncomingConnections":
            suggest = "max_incoming_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongocfgNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongocfgNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongocfgNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_incoming_connections: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @_builtins.property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongocfgOperationProfiling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowOpThreshold":
            suggest = "slow_op_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongocfgOperationProfiling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongocfgOperationProfiling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongocfgOperationProfiling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 slow_op_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str mode: Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        :param _builtins.int slow_op_threshold: The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[_builtins.int]:
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_threshold")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongocfgStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wiredTiger":
            suggest = "wired_tiger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongocfgStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongocfgStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongocfgStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wired_tiger: Optional['outputs.MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger'] = None):
        """
        :param 'MdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs' wired_tiger: The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option).
        """
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @_builtins.property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger']:
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option).
        """
        return pulumi.get(self, "wired_tiger")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheSizeGb":
            suggest = "cache_size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_size_gb: Optional[_builtins.float] = None):
        """
        :param _builtins.float cache_size_gb: Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)

    @_builtins.property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[_builtins.float]:
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        return pulumi.get(self, "cache_size_gb")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLog":
            suggest = "audit_log"
        elif key == "operationProfiling":
            suggest = "operation_profiling"
        elif key == "setParameter":
            suggest = "set_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_log: Optional['outputs.MdbMongodbClusterClusterConfigMongodAuditLog'] = None,
                 net: Optional['outputs.MdbMongodbClusterClusterConfigMongodNet'] = None,
                 operation_profiling: Optional['outputs.MdbMongodbClusterClusterConfigMongodOperationProfiling'] = None,
                 security: Optional['outputs.MdbMongodbClusterClusterConfigMongodSecurity'] = None,
                 set_parameter: Optional['outputs.MdbMongodbClusterClusterConfigMongodSetParameter'] = None,
                 storage: Optional['outputs.MdbMongodbClusterClusterConfigMongodStorage'] = None):
        """
        :param 'MdbMongodbClusterClusterConfigMongodAuditLogArgs' audit_log: A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). Available only in enterprise edition.
        :param 'MdbMongodbClusterClusterConfigMongodNetArgs' net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        :param 'MdbMongodbClusterClusterConfigMongodOperationProfilingArgs' operation_profiling: A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        :param 'MdbMongodbClusterClusterConfigMongodSecurityArgs' security: A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). Available only in enterprise edition.
        :param 'MdbMongodbClusterClusterConfigMongodSetParameterArgs' set_parameter: A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option).
        :param 'MdbMongodbClusterClusterConfigMongodStorageArgs' storage: A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if security is not None:
            pulumi.set(__self__, "security", security)
        if set_parameter is not None:
            pulumi.set(__self__, "set_parameter", set_parameter)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodAuditLog']:
        """
        A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_log")

    @_builtins.property
    @pulumi.getter
    def net(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodNet']:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        return pulumi.get(self, "net")

    @_builtins.property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodOperationProfiling']:
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        """
        return pulumi.get(self, "operation_profiling")

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodSecurity']:
        """
        A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). Available only in enterprise edition.
        """
        return pulumi.get(self, "security")

    @_builtins.property
    @pulumi.getter(name="setParameter")
    def set_parameter(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodSetParameter']:
        """
        A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option).
        """
        return pulumi.get(self, "set_parameter")

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodStorage']:
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodAuditLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeConfiguration":
            suggest = "runtime_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodAuditLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodAuditLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodAuditLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter: Optional[_builtins.str] = None,
                 runtime_configuration: Optional[_builtins.bool] = None):
        """
        :param _builtins.str filter: Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        :param _builtins.bool runtime_configuration: Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if runtime_configuration is not None:
            pulumi.set(__self__, "runtime_configuration", runtime_configuration)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="runtimeConfiguration")
    def runtime_configuration(self) -> Optional[_builtins.bool]:
        """
        Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "runtime_configuration")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIncomingConnections":
            suggest = "max_incoming_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compressors: Optional[Sequence[_builtins.str]] = None,
                 max_incoming_connections: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] compressors: Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        :param _builtins.int max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @_builtins.property
    @pulumi.getter
    def compressors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        return pulumi.get(self, "compressors")

    @_builtins.property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodOperationProfiling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slowOpSampleRate":
            suggest = "slow_op_sample_rate"
        elif key == "slowOpThreshold":
            suggest = "slow_op_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodOperationProfiling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodOperationProfiling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodOperationProfiling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 slow_op_sample_rate: Optional[_builtins.float] = None,
                 slow_op_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str mode: Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        :param _builtins.float slow_op_sample_rate: The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        :param _builtins.int slow_op_threshold: The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_sample_rate is not None:
            pulumi.set(__self__, "slow_op_sample_rate", slow_op_sample_rate)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow_op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="slowOpSampleRate")
    def slow_op_sample_rate(self) -> Optional[_builtins.float]:
        """
        The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_sample_rate")

    @_builtins.property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[_builtins.int]:
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_threshold")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableEncryption":
            suggest = "enable_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_encryption: Optional[_builtins.bool] = None,
                 kmip: Optional['outputs.MdbMongodbClusterClusterConfigMongodSecurityKmip'] = None):
        """
        :param _builtins.bool enable_encryption: Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        :param 'MdbMongodbClusterClusterConfigMongodSecurityKmipArgs' kmip: Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if kmip is not None:
            pulumi.set(__self__, "kmip", kmip)

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        """
        Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter
    def kmip(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodSecurityKmip']:
        """
        Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "kmip")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodSecurityKmip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "serverCa":
            suggest = "server_ca"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodSecurityKmip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodSecurityKmip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodSecurityKmip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[_builtins.str] = None,
                 key_identifier: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 server_ca: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate: String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        :param _builtins.str key_identifier: Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        :param _builtins.int port: Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        :param _builtins.str server_ca: Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        :param _builtins.str server_name: Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_ca is not None:
            pulumi.set(__self__, "server_ca", server_ca)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[_builtins.str]:
        """
        Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        """
        return pulumi.get(self, "key_identifier")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="serverCa")
    def server_ca(self) -> Optional[_builtins.str]:
        """
        Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        """
        return pulumi.get(self, "server_ca")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodSetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditAuthorizationSuccess":
            suggest = "audit_authorization_success"
        elif key == "enableFlowControl":
            suggest = "enable_flow_control"
        elif key == "minSnapshotHistoryWindowInSeconds":
            suggest = "min_snapshot_history_window_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodSetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodSetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodSetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_authorization_success: Optional[_builtins.bool] = None,
                 enable_flow_control: Optional[_builtins.bool] = None,
                 min_snapshot_history_window_in_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.bool audit_authorization_success: Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        :param _builtins.bool enable_flow_control: Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        :param _builtins.int min_snapshot_history_window_in_seconds: The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
        if audit_authorization_success is not None:
            pulumi.set(__self__, "audit_authorization_success", audit_authorization_success)
        if enable_flow_control is not None:
            pulumi.set(__self__, "enable_flow_control", enable_flow_control)
        if min_snapshot_history_window_in_seconds is not None:
            pulumi.set(__self__, "min_snapshot_history_window_in_seconds", min_snapshot_history_window_in_seconds)

    @_builtins.property
    @pulumi.getter(name="auditAuthorizationSuccess")
    def audit_authorization_success(self) -> Optional[_builtins.bool]:
        """
        Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_authorization_success")

    @_builtins.property
    @pulumi.getter(name="enableFlowControl")
    def enable_flow_control(self) -> Optional[_builtins.bool]:
        """
        Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        """
        return pulumi.get(self, "enable_flow_control")

    @_builtins.property
    @pulumi.getter(name="minSnapshotHistoryWindowInSeconds")
    def min_snapshot_history_window_in_seconds(self) -> Optional[_builtins.int]:
        """
        The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
        return pulumi.get(self, "min_snapshot_history_window_in_seconds")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wiredTiger":
            suggest = "wired_tiger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 journal: Optional['outputs.MdbMongodbClusterClusterConfigMongodStorageJournal'] = None,
                 wired_tiger: Optional['outputs.MdbMongodbClusterClusterConfigMongodStorageWiredTiger'] = None):
        """
        :param 'MdbMongodbClusterClusterConfigMongodStorageJournalArgs' journal: The durability journal to ensure data files remain valid and recoverable.
        :param 'MdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs' wired_tiger: The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts.
        """
        if journal is not None:
            pulumi.set(__self__, "journal", journal)
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @_builtins.property
    @pulumi.getter
    def journal(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodStorageJournal']:
        """
        The durability journal to ensure data files remain valid and recoverable.
        """
        return pulumi.get(self, "journal")

    @_builtins.property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongodStorageWiredTiger']:
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts.
        """
        return pulumi.get(self, "wired_tiger")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodStorageJournal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commitInterval":
            suggest = "commit_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodStorageJournal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodStorageJournal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodStorageJournal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commit_interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int commit_interval: The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
        if commit_interval is not None:
            pulumi.set(__self__, "commit_interval", commit_interval)

    @_builtins.property
    @pulumi.getter(name="commitInterval")
    def commit_interval(self) -> Optional[_builtins.int]:
        """
        The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
        return pulumi.get(self, "commit_interval")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongodStorageWiredTiger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockCompressor":
            suggest = "block_compressor"
        elif key == "cacheSizeGb":
            suggest = "cache_size_gb"
        elif key == "prefixCompression":
            suggest = "prefix_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongodStorageWiredTiger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongodStorageWiredTiger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongodStorageWiredTiger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_compressor: Optional[_builtins.str] = None,
                 cache_size_gb: Optional[_builtins.float] = None,
                 prefix_compression: Optional[_builtins.bool] = None):
        """
        :param _builtins.str block_compressor: Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        :param _builtins.float cache_size_gb: Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        :param _builtins.bool prefix_compression: Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
        if block_compressor is not None:
            pulumi.set(__self__, "block_compressor", block_compressor)
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)
        if prefix_compression is not None:
            pulumi.set(__self__, "prefix_compression", prefix_compression)

    @_builtins.property
    @pulumi.getter(name="blockCompressor")
    def block_compressor(self) -> Optional[_builtins.str]:
        """
        Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        """
        return pulumi.get(self, "block_compressor")

    @_builtins.property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[_builtins.float]:
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        return pulumi.get(self, "cache_size_gb")

    @_builtins.property
    @pulumi.getter(name="prefixCompression")
    def prefix_compression(self) -> Optional[_builtins.bool]:
        """
        Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
        return pulumi.get(self, "prefix_compression")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongos(dict):
    def __init__(__self__, *,
                 net: Optional['outputs.MdbMongodbClusterClusterConfigMongosNet'] = None):
        """
        :param 'MdbMongodbClusterClusterConfigMongosNetArgs' net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        if net is not None:
            pulumi.set(__self__, "net", net)

    @_builtins.property
    @pulumi.getter
    def net(self) -> Optional['outputs.MdbMongodbClusterClusterConfigMongosNet']:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        return pulumi.get(self, "net")


@pulumi.output_type
class MdbMongodbClusterClusterConfigMongosNet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIncomingConnections":
            suggest = "max_incoming_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterClusterConfigMongosNet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterClusterConfigMongosNet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterClusterConfigMongosNet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compressors: Optional[Sequence[_builtins.str]] = None,
                 max_incoming_connections: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] compressors: Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        :param _builtins.int max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @_builtins.property
    @pulumi.getter
    def compressors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        return pulumi.get(self, "compressors")

    @_builtins.property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")


@pulumi.output_type
class MdbMongodbClusterClusterConfigPerformanceDiagnostics(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable or disable performance diagnostics.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable performance diagnostics.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MdbMongodbClusterDatabase(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbMongodbClusterDiskSizeAutoscalingMongocfg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterDiskSizeAutoscalingMongocfg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongocfg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongocfg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbMongodbClusterDiskSizeAutoscalingMongod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterDiskSizeAutoscalingMongod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbMongodbClusterDiskSizeAutoscalingMongoinfra(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterDiskSizeAutoscalingMongoinfra. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongoinfra.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongoinfra.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbMongodbClusterDiskSizeAutoscalingMongos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterDiskSizeAutoscalingMongos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterDiskSizeAutoscalingMongos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbMongodbClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "hostParameters":
            suggest = "host_parameters"
        elif key == "shardName":
            suggest = "shard_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 zone_id: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 health: Optional[_builtins.str] = None,
                 host_parameters: Optional['outputs.MdbMongodbClusterHostHostParameters'] = None,
                 name: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 shard_name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Should this host have assigned public IP assigned. Can be either `true` or `false`.
        :param _builtins.str health: The health of the host.
        :param 'MdbMongodbClusterHostHostParametersArgs' host_parameters: The parameters of mongod host in replicaset.
        :param _builtins.str name: The fully qualified domain name of the host. Computed on server side.
        :param _builtins.str role: The role of the cluster (either PRIMARY or SECONDARY).
        :param _builtins.str shard_name: The name of the shard to which the host belongs. Only for sharded cluster.
        :param _builtins.str type: Type of Mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to `mongod`.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if host_parameters is not None:
            pulumi.set(__self__, "host_parameters", host_parameters)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Should this host have assigned public IP assigned. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional[_builtins.str]:
        """
        The health of the host.
        """
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="hostParameters")
    def host_parameters(self) -> Optional['outputs.MdbMongodbClusterHostHostParameters']:
        """
        The parameters of mongod host in replicaset.
        """
        return pulumi.get(self, "host_parameters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host. Computed on server side.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The role of the cluster (either PRIMARY or SECONDARY).
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[_builtins.str]:
        """
        The name of the shard to which the host belongs. Only for sharded cluster.
        """
        return pulumi.get(self, "shard_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to `mongod`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MdbMongodbClusterHostHostParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secondaryDelaySecs":
            suggest = "secondary_delay_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterHostHostParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterHostHostParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterHostHostParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hidden: Optional[_builtins.bool] = None,
                 priority: Optional[_builtins.float] = None,
                 secondary_delay_secs: Optional[_builtins.int] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool hidden: Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden).
        :param _builtins.float priority: A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority).
        :param _builtins.int secondary_delay_secs: The number of seconds `behind` the primary that this replica set member should `lag`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs).
        :param Mapping[str, _builtins.str] tags: A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags).
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if secondary_delay_secs is not None:
            pulumi.set(__self__, "secondary_delay_secs", secondary_delay_secs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional[_builtins.bool]:
        """
        Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden).
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority).
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="secondaryDelaySecs")
    def secondary_delay_secs(self) -> Optional[_builtins.int]:
        """
        The number of seconds `behind` the primary that this replica set member should `lag`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs).
        """
        return pulumi.get(self, "secondary_delay_secs")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags).
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MdbMongodbClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbMongodbClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMongodbClusterResourcesMongocfg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterResourcesMongocfg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterResourcesMongocfg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterResourcesMongocfg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMongodbClusterResourcesMongod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterResourcesMongod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterResourcesMongod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterResourcesMongod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMongodbClusterResourcesMongoinfra(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterResourcesMongoinfra. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterResourcesMongoinfra.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterResourcesMongoinfra.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMongodbClusterResourcesMongos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterResourcesMongos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterResourcesMongos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterResourcesMongos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMongodbClusterRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupId":
            suggest = "backup_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_id: _builtins.str,
                 time: Optional[_builtins.str] = None):
        """
        :param _builtins.str backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups).
        :param _builtins.str time: Timestamp of the moment to which the MongoDB cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the moment to which the MongoDB cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class MdbMongodbClusterUser(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 permissions: Optional[Sequence['outputs.MdbMongodbClusterUserPermission']] = None):
        """
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param Sequence['MdbMongodbClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbMongodbClusterUserPermission']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbMongodbClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMongodbClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMongodbClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMongodbClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: The roles of the user in this database. For more information see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts/users-and-roles).
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        The roles of the user in this database. For more information see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts/users-and-roles).
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class MdbMysqlClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "dataTransfer":
            suggest = "data_transfer"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        :param _builtins.bool web_sql: Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbMysqlClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started (UTC).
        :param _builtins.int minutes: The minute at which backup will be started (UTC).
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbMysqlClusterDatabase(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbMysqlClusterDiskSizeAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterDiskSizeAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterDiskSizeAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterDiskSizeAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbMysqlClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "backupPriority":
            suggest = "backup_priority"
        elif key == "replicationSource":
            suggest = "replication_source"
        elif key == "replicationSourceName":
            suggest = "replication_source_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 backup_priority: Optional[_builtins.int] = None,
                 fqdn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 replication_source: Optional[_builtins.str] = None,
                 replication_source_name: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        :param _builtins.int backup_priority: Host backup priority. Value is between 0 and 100, default is 0.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        :param _builtins.int priority: Host master promotion priority. Value is between 0 and 100, default is 0.
        :param _builtins.str replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param _builtins.str replication_source_name: Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if backup_priority is not None:
            pulumi.set(__self__, "backup_priority", backup_priority)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if replication_source is not None:
            pulumi.set(__self__, "replication_source", replication_source)
        if replication_source_name is not None:
            pulumi.set(__self__, "replication_source_name", replication_source_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="backupPriority")
    def backup_priority(self) -> Optional[_builtins.int]:
        """
        Host backup priority. Value is between 0 and 100, default is 0.
        """
        return pulumi.get(self, "backup_priority")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please refer to `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Host master promotion priority. Value is between 0 and 100, default is 0.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> Optional[_builtins.str]:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @_builtins.property
    @pulumi.getter(name="replicationSourceName")
    def replication_source_name(self) -> Optional[_builtins.str]:
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "replication_source_name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbMysqlClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbMysqlClusterPerformanceDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionsSamplingInterval":
            suggest = "sessions_sampling_interval"
        elif key == "statementsSamplingInterval":
            suggest = "statements_sampling_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterPerformanceDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterPerformanceDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterPerformanceDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sessions_sampling_interval: _builtins.int,
                 statements_sampling_interval: _builtins.int,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int sessions_sampling_interval: Interval (in seconds) for my*stat*activity sampling Acceptable values are 1 to 86400, inclusive.
        :param _builtins.int statements_sampling_interval: Interval (in seconds) for my*stat*statements sampling Acceptable values are 1 to 86400, inclusive.
        :param _builtins.bool enabled: Enable performance diagnostics.
        """
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for my*stat*activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @_builtins.property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for my*stat*statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable performance diagnostics.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MdbMysqlClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MySQL host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MySQL hosts.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MySQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mysql/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MySQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MySQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MySQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mysql/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbMysqlClusterRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupId":
            suggest = "backup_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_id: _builtins.str,
                 time: Optional[_builtins.str] = None):
        """
        :param _builtins.str backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://yandex.cloud/docs/managed-mysql/operations/cluster-backups).
        :param _builtins.str time: Timestamp of the moment to which the MySQL cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of MySQL backups](https://yandex.cloud/docs/managed-mysql/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the moment to which the MySQL cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class MdbMysqlClusterUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationPlugin":
            suggest = "authentication_plugin"
        elif key == "connectionLimits":
            suggest = "connection_limits"
        elif key == "globalPermissions":
            suggest = "global_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 authentication_plugin: Optional[_builtins.str] = None,
                 connection_limits: Optional['outputs.MdbMysqlClusterUserConnectionLimits'] = None,
                 global_permissions: Optional[Sequence[_builtins.str]] = None,
                 permissions: Optional[Sequence['outputs.MdbMysqlClusterUserPermission']] = None):
        """
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param _builtins.str authentication_plugin: Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH`).
        :param 'MdbMysqlClusterUserConnectionLimitsArgs' connection_limits: User's connection limits. If not specified there will be no changes. Default value is -1. When these parameters are set to -1, backend default values will be actually used.
        :param Sequence[_builtins.str] global_permissions: List user's global permissions. Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS`, `FLUSH_OPTIMIZER_COSTS`, `SHOW_ROUTINE`, `MDB_ADMIN` for clear list use empty list. If the attribute is not specified there will be no changes.
        :param Sequence['MdbMysqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if authentication_plugin is not None:
            pulumi.set(__self__, "authentication_plugin", authentication_plugin)
        if connection_limits is not None:
            pulumi.set(__self__, "connection_limits", connection_limits)
        if global_permissions is not None:
            pulumi.set(__self__, "global_permissions", global_permissions)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="authenticationPlugin")
    def authentication_plugin(self) -> Optional[_builtins.str]:
        """
        Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH`).
        """
        return pulumi.get(self, "authentication_plugin")

    @_builtins.property
    @pulumi.getter(name="connectionLimits")
    def connection_limits(self) -> Optional['outputs.MdbMysqlClusterUserConnectionLimits']:
        """
        User's connection limits. If not specified there will be no changes. Default value is -1. When these parameters are set to -1, backend default values will be actually used.
        """
        return pulumi.get(self, "connection_limits")

    @_builtins.property
    @pulumi.getter(name="globalPermissions")
    def global_permissions(self) -> Optional[Sequence[_builtins.str]]:
        """
        List user's global permissions. Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS`, `FLUSH_OPTIMIZER_COSTS`, `SHOW_ROUTINE`, `MDB_ADMIN` for clear list use empty list. If the attribute is not specified there will be no changes.
        """
        return pulumi.get(self, "global_permissions")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbMysqlClusterUserPermission']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbMysqlClusterUserConnectionLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnectionsPerHour":
            suggest = "max_connections_per_hour"
        elif key == "maxQuestionsPerHour":
            suggest = "max_questions_per_hour"
        elif key == "maxUpdatesPerHour":
            suggest = "max_updates_per_hour"
        elif key == "maxUserConnections":
            suggest = "max_user_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterUserConnectionLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterUserConnectionLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterUserConnectionLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections_per_hour: Optional[_builtins.int] = None,
                 max_questions_per_hour: Optional[_builtins.int] = None,
                 max_updates_per_hour: Optional[_builtins.int] = None,
                 max_user_connections: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_connections_per_hour: Max connections per hour.
        :param _builtins.int max_questions_per_hour: Max questions per hour.
        :param _builtins.int max_updates_per_hour: Max updates per hour.
        :param _builtins.int max_user_connections: Max user connections.
        """
        if max_connections_per_hour is not None:
            pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        if max_questions_per_hour is not None:
            pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        if max_updates_per_hour is not None:
            pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        if max_user_connections is not None:
            pulumi.set(__self__, "max_user_connections", max_user_connections)

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> Optional[_builtins.int]:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> Optional[_builtins.int]:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> Optional[_builtins.int]:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> Optional[_builtins.int]:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")


@pulumi.output_type
class MdbMysqlClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class MdbMysqlUserConnectionLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnectionsPerHour":
            suggest = "max_connections_per_hour"
        elif key == "maxQuestionsPerHour":
            suggest = "max_questions_per_hour"
        elif key == "maxUpdatesPerHour":
            suggest = "max_updates_per_hour"
        elif key == "maxUserConnections":
            suggest = "max_user_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlUserConnectionLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlUserConnectionLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlUserConnectionLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections_per_hour: Optional[_builtins.int] = None,
                 max_questions_per_hour: Optional[_builtins.int] = None,
                 max_updates_per_hour: Optional[_builtins.int] = None,
                 max_user_connections: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_connections_per_hour: Max connections per hour.
        :param _builtins.int max_questions_per_hour: Max questions per hour.
        :param _builtins.int max_updates_per_hour: Max updates per hour.
        :param _builtins.int max_user_connections: Max user connections.
        """
        if max_connections_per_hour is not None:
            pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        if max_questions_per_hour is not None:
            pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        if max_updates_per_hour is not None:
            pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        if max_user_connections is not None:
            pulumi.set(__self__, "max_user_connections", max_user_connections)

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> Optional[_builtins.int]:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> Optional[_builtins.int]:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> Optional[_builtins.int]:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> Optional[_builtins.int]:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")


@pulumi.output_type
class MdbMysqlUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbMysqlUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbMysqlUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbMysqlUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class MdbPostgresqlClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupRetainPeriodDays":
            suggest = "backup_retain_period_days"
        elif key == "backupWindowStart":
            suggest = "backup_window_start"
        elif key == "diskSizeAutoscaling":
            suggest = "disk_size_autoscaling"
        elif key == "performanceDiagnostics":
            suggest = "performance_diagnostics"
        elif key == "poolerConfig":
            suggest = "pooler_config"
        elif key == "postgresqlConfig":
            suggest = "postgresql_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resources: 'outputs.MdbPostgresqlClusterConfigResources',
                 version: _builtins.str,
                 access: Optional['outputs.MdbPostgresqlClusterConfigAccess'] = None,
                 autofailover: Optional[_builtins.bool] = None,
                 backup_retain_period_days: Optional[_builtins.int] = None,
                 backup_window_start: Optional['outputs.MdbPostgresqlClusterConfigBackupWindowStart'] = None,
                 disk_size_autoscaling: Optional['outputs.MdbPostgresqlClusterConfigDiskSizeAutoscaling'] = None,
                 performance_diagnostics: Optional['outputs.MdbPostgresqlClusterConfigPerformanceDiagnostics'] = None,
                 pooler_config: Optional['outputs.MdbPostgresqlClusterConfigPoolerConfig'] = None,
                 postgresql_config: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param 'MdbPostgresqlClusterConfigResourcesArgs' resources: Resources allocated to hosts of the PostgreSQL cluster.
        :param _builtins.str version: Version of the PostgreSQL cluster. (allowed versions are: 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17).
        :param 'MdbPostgresqlClusterConfigAccessArgs' access: Access policy to the PostgreSQL cluster.
        :param _builtins.bool autofailover: Configuration setting which enables/disables autofailover in cluster.
        :param _builtins.int backup_retain_period_days: The period in days during which backups are stored.
        :param 'MdbPostgresqlClusterConfigBackupWindowStartArgs' backup_window_start: Time to start the daily backup, in the UTC timezone.
        :param 'MdbPostgresqlClusterConfigDiskSizeAutoscalingArgs' disk_size_autoscaling: Cluster disk size autoscaling settings.
        :param 'MdbPostgresqlClusterConfigPerformanceDiagnosticsArgs' performance_diagnostics: Cluster performance diagnostics settings. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics).
        :param 'MdbPostgresqlClusterConfigPoolerConfigArgs' pooler_config: Configuration of the connection pooler.
        :param Mapping[str, _builtins.str] postgresql_config: PostgreSQL cluster configuration. For detailed information specific to your PostgreSQL version, please refer to the [API proto specifications](https://github.com/yandex-cloud/cloudapi/tree/master/yandex/cloud/mdb/postgresql/v1/config).
        """
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "version", version)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if autofailover is not None:
            pulumi.set(__self__, "autofailover", autofailover)
        if backup_retain_period_days is not None:
            pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if disk_size_autoscaling is not None:
            pulumi.set(__self__, "disk_size_autoscaling", disk_size_autoscaling)
        if performance_diagnostics is not None:
            pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)
        if pooler_config is not None:
            pulumi.set(__self__, "pooler_config", pooler_config)
        if postgresql_config is not None:
            pulumi.set(__self__, "postgresql_config", postgresql_config)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.MdbPostgresqlClusterConfigResources':
        """
        Resources allocated to hosts of the PostgreSQL cluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the PostgreSQL cluster. (allowed versions are: 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17).
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional['outputs.MdbPostgresqlClusterConfigAccess']:
        """
        Access policy to the PostgreSQL cluster.
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter
    def autofailover(self) -> Optional[_builtins.bool]:
        """
        Configuration setting which enables/disables autofailover in cluster.
        """
        return pulumi.get(self, "autofailover")

    @_builtins.property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> Optional[_builtins.int]:
        """
        The period in days during which backups are stored.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @_builtins.property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional['outputs.MdbPostgresqlClusterConfigBackupWindowStart']:
        """
        Time to start the daily backup, in the UTC timezone.
        """
        return pulumi.get(self, "backup_window_start")

    @_builtins.property
    @pulumi.getter(name="diskSizeAutoscaling")
    def disk_size_autoscaling(self) -> Optional['outputs.MdbPostgresqlClusterConfigDiskSizeAutoscaling']:
        """
        Cluster disk size autoscaling settings.
        """
        return pulumi.get(self, "disk_size_autoscaling")

    @_builtins.property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> Optional['outputs.MdbPostgresqlClusterConfigPerformanceDiagnostics']:
        """
        Cluster performance diagnostics settings. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics).
        """
        return pulumi.get(self, "performance_diagnostics")

    @_builtins.property
    @pulumi.getter(name="poolerConfig")
    def pooler_config(self) -> Optional['outputs.MdbPostgresqlClusterConfigPoolerConfig']:
        """
        Configuration of the connection pooler.
        """
        return pulumi.get(self, "pooler_config")

    @_builtins.property
    @pulumi.getter(name="postgresqlConfig")
    def postgresql_config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        PostgreSQL cluster configuration. For detailed information specific to your PostgreSQL version, please refer to the [API proto specifications](https://github.com/yandex-cloud/cloudapi/tree/master/yandex/cloud/mdb/postgresql/v1/config).
        """
        return pulumi.get(self, "postgresql_config")


@pulumi.output_type
class MdbPostgresqlClusterConfigAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "dataTransfer":
            suggest = "data_transfer"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterConfigAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterConfigAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterConfigAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 serverless: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        :param _builtins.bool serverless: Allow access for [connection to managed databases from functions](https://yandex.cloud/docs/functions/operations/database-connection).
        :param _builtins.bool web_sql: Allow access for [SQL queries in the management console](https://yandex.cloud/docs/managed-postgresql/operations/web-sql-query).
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> Optional[_builtins.bool]:
        """
        Allow access for [connection to managed databases from functions](https://yandex.cloud/docs/functions/operations/database-connection).
        """
        return pulumi.get(self, "serverless")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allow access for [SQL queries in the management console](https://yandex.cloud/docs/managed-postgresql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbPostgresqlClusterConfigBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started (UTC).
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbPostgresqlClusterConfigDiskSizeAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterConfigDiskSizeAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterConfigDiskSizeAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterConfigDiskSizeAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: The overall maximum for disk size that limit all autoscaling iterations. See the [documentation](https://yandex.cloud/en/docs/managed-postgresql/concepts/storage#auto-rescale) for details.
        :param _builtins.int emergency_usage_threshold: Threshold of storage usage (in percent) that triggers immediate automatic scaling of the storage. Zero value means disabled threshold.
        :param _builtins.int planned_usage_threshold: Threshold of storage usage (in percent) that triggers automatic scaling of the storage during the maintenance window. Zero value means disabled threshold.
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        The overall maximum for disk size that limit all autoscaling iterations. See the [documentation](https://yandex.cloud/en/docs/managed-postgresql/concepts/storage#auto-rescale) for details.
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Threshold of storage usage (in percent) that triggers immediate automatic scaling of the storage. Zero value means disabled threshold.
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Threshold of storage usage (in percent) that triggers automatic scaling of the storage during the maintenance window. Zero value means disabled threshold.
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbPostgresqlClusterConfigPerformanceDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sessionsSamplingInterval":
            suggest = "sessions_sampling_interval"
        elif key == "statementsSamplingInterval":
            suggest = "statements_sampling_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterConfigPerformanceDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterConfigPerformanceDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterConfigPerformanceDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sessions_sampling_interval: _builtins.int,
                 statements_sampling_interval: _builtins.int,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int sessions_sampling_interval: Interval (in seconds) for pg_stat_activity sampling. Acceptable values are 1 to 86400, inclusive.
        :param _builtins.int statements_sampling_interval: Interval (in seconds) for pg_stat_statements sampling. Acceptable values are 1 to 86400, inclusive.
        :param _builtins.bool enabled: Enable performance diagnostics.
        """
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for pg_stat_activity sampling. Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @_builtins.property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for pg_stat_statements sampling. Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable performance diagnostics.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class MdbPostgresqlClusterConfigPoolerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolDiscard":
            suggest = "pool_discard"
        elif key == "poolingMode":
            suggest = "pooling_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterConfigPoolerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterConfigPoolerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterConfigPoolerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_discard: Optional[_builtins.bool] = None,
                 pooling_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.bool pool_discard: Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        :param _builtins.str pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        if pool_discard is not None:
            pulumi.set(__self__, "pool_discard", pool_discard)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @_builtins.property
    @pulumi.getter(name="poolDiscard")
    def pool_discard(self) -> Optional[_builtins.bool]:
        """
        Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        """
        return pulumi.get(self, "pool_discard")

    @_builtins.property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[_builtins.str]:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class MdbPostgresqlClusterConfigResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"
        elif key == "diskTypeId":
            suggest = "disk_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterConfigResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterConfigResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterConfigResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 resource_preset_id: _builtins.str,
                 disk_type_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a PostgreSQL host, in gigabytes.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a PostgreSQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-postgresql/concepts/instance-types).
        :param _builtins.str disk_type_id: Type of the storage of PostgreSQL hosts.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a PostgreSQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a PostgreSQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-postgresql/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of PostgreSQL hosts.
        """
        return pulumi.get(self, "disk_type_id")


@pulumi.output_type
class MdbPostgresqlClusterDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lcCollate":
            suggest = "lc_collate"
        elif key == "lcType":
            suggest = "lc_type"
        elif key == "templateDb":
            suggest = "template_db"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 owner: _builtins.str,
                 extensions: Optional[Sequence['outputs.MdbPostgresqlClusterDatabaseExtension']] = None,
                 lc_collate: Optional[_builtins.str] = None,
                 lc_type: Optional[_builtins.str] = None,
                 template_db: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The resource name.
        :param _builtins.str owner: Name of the user assigned as the owner of the database. Forbidden to change in an existing database.
        :param Sequence['MdbPostgresqlClusterDatabaseExtensionArgs'] extensions: Set of database extensions.
        :param _builtins.str lc_collate: POSIX locale for string sorting order. Forbidden to change in an existing database.
        :param _builtins.str lc_type: POSIX locale for character classification. Forbidden to change in an existing database.
        :param _builtins.str template_db: Name of the template database.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if lc_collate is not None:
            pulumi.set(__self__, "lc_collate", lc_collate)
        if lc_type is not None:
            pulumi.set(__self__, "lc_type", lc_type)
        if template_db is not None:
            pulumi.set(__self__, "template_db", template_db)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        Name of the user assigned as the owner of the database. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.MdbPostgresqlClusterDatabaseExtension']]:
        """
        Set of database extensions.
        """
        return pulumi.get(self, "extensions")

    @_builtins.property
    @pulumi.getter(name="lcCollate")
    def lc_collate(self) -> Optional[_builtins.str]:
        """
        POSIX locale for string sorting order. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "lc_collate")

    @_builtins.property
    @pulumi.getter(name="lcType")
    def lc_type(self) -> Optional[_builtins.str]:
        """
        POSIX locale for character classification. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "lc_type")

    @_builtins.property
    @pulumi.getter(name="templateDb")
    def template_db(self) -> Optional[_builtins.str]:
        """
        Name of the template database.
        """
        return pulumi.get(self, "template_db")


@pulumi.output_type
class MdbPostgresqlClusterDatabaseExtension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        :param _builtins.str version: Version of the extension.
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the extension.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MdbPostgresqlClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "replicationSource":
            suggest = "replication_source"
        elif key == "replicationSourceName":
            suggest = "replication_source_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 replication_source: Optional[_builtins.str] = None,
                 replication_source_name: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Whether the host should get a public IP address.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str name: Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please see `replication_source_name` parameter.
        :param _builtins.int priority: Host priority in HA group. It works only when `name` is set.
        :param _builtins.str replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param _builtins.str replication_source_name: Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        :param _builtins.str role: Host's role (replica|primary), computed by server.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if replication_source is not None:
            pulumi.set(__self__, "replication_source", replication_source)
        if replication_source_name is not None:
            pulumi.set(__self__, "replication_source_name", replication_source_name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Whether the host should get a public IP address.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Host state name. It should be set for all hosts or unset for all hosts. This field can be used by another host, to select which host will be its replication source. Please see `replication_source_name` parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The field has not affected anything. You can safely delete it.""")
    def priority(self) -> Optional[_builtins.int]:
        """
        Host priority in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> Optional[_builtins.str]:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @_builtins.property
    @pulumi.getter(name="replicationSourceName")
    def replication_source_name(self) -> Optional[_builtins.str]:
        """
        Host replication source name points to host's `name` from which this host should replicate. When not set then host in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "replication_source_name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Host's role (replica|primary), computed by server.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbPostgresqlClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbPostgresqlClusterRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupId":
            suggest = "backup_id"
        elif key == "timeInclusive":
            suggest = "time_inclusive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_id: _builtins.str,
                 time: Optional[_builtins.str] = None,
                 time_inclusive: Optional[_builtins.bool] = None):
        """
        :param _builtins.str backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-postgresql/operations/cluster-backups).
        :param _builtins.str time: Timestamp of the moment to which the PostgreSQL cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        :param _builtins.bool time_inclusive: Flag that indicates whether a database should be restored to the first backup point available just after the timestamp specified in the [time] field instead of just before. Possible values:
               * `false` (default)  the restore point refers to the first backup moment before [time].
               * `true`  the restore point refers to the first backup point after [time].
        """
        pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if time_inclusive is not None:
            pulumi.set(__self__, "time_inclusive", time_inclusive)

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> _builtins.str:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-postgresql/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the moment to which the PostgreSQL cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter(name="timeInclusive")
    def time_inclusive(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether a database should be restored to the first backup point available just after the timestamp specified in the [time] field instead of just before. Possible values:
        * `false` (default)  the restore point refers to the first backup moment before [time].
        * `true`  the restore point refers to the first backup point after [time].
        """
        return pulumi.get(self, "time_inclusive")


@pulumi.output_type
class MdbPostgresqlClusterUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connLimit":
            suggest = "conn_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 conn_limit: Optional[_builtins.int] = None,
                 grants: Optional[Sequence[_builtins.str]] = None,
                 login: Optional[_builtins.bool] = None,
                 permissions: Optional[Sequence['outputs.MdbPostgresqlClusterUserPermission']] = None,
                 settings: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param _builtins.int conn_limit: The maximum number of connections per user. (Default 50).
        :param Sequence[_builtins.str] grants: List of the user's grants.
        :param _builtins.bool login: User's ability to login.
        :param Sequence['MdbPostgresqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        :param Mapping[str, _builtins.str] settings: Map of user settings. [Full description](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/Cluster/create#yandex.cloud.mdb.postgresql.v1.UserSettings).
               
               * `default_transaction_isolation` - defines the default isolation level to be set for all new SQL transactions. One of:
                 - 1: `read uncommitted`
                 - 2: `read committed`
                 - 3: `repeatable read`
                 - 4: `serializable`
               
               * `lock_timeout` - The maximum time (in milliseconds) for any statement to wait for acquiring a lock on an table, index, row or other database object (default 0).
               
               * `log_min_duration_statement` - This setting controls logging of the duration of statements. Default -1 disables logging of the duration of statements.
               
               * `synchronous_commit` - This setting defines whether DBMS will commit transaction in a synchronous way. One of:
                 - 1: `on`
                 - 2: `off`
                 - 3: `local`
                 - 4: `remote write`
                 - 5: `remote apply`
               
               * `temp_file_limit` - The maximum storage space size (in kilobytes) that a single process can use to create temporary files.
               
               * `log_statement` - This setting specifies which SQL statements should be logged (on the user level). One of:
                 - 1: `none`
                 - 2: `ddl`
                 - 3: `mod`
                 - 4: `all`
               
               * `pool_mode` - Mode that the connection pooler is working in with specified user. One of:
                 - 1: `session`
                 - 2: `transaction`
                 - 3: `statement`
               
               * `prepared_statements_pooling` - This setting allows user to use prepared statements with transaction pooling. Boolean.
               
               * `catchup_timeout` - The connection pooler setting. It determines the maximum allowed replication lag (in seconds). Pooler will reject connections to the replica with a lag above this threshold. Default value is 0, which disables this feature. Integer.
               
               * `wal_sender_timeout` - The maximum time (in milliseconds) to wait for WAL replication. Terminate replication connections that are inactive for longer than this amount of time. Integer.
               
               * `idle_in_transaction_session_timeout` - Sets the maximum allowed idle time (in milliseconds) between queries, when in a transaction. Value of 0 (default) disables the timeout. Integer.
               
               * `statement_timeout` - The maximum time (in milliseconds) to wait for statement. Value of 0 (default) disables the timeout. Integer.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if conn_limit is not None:
            pulumi.set(__self__, "conn_limit", conn_limit)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="connLimit")
    def conn_limit(self) -> Optional[_builtins.int]:
        """
        The maximum number of connections per user. (Default 50).
        """
        return pulumi.get(self, "conn_limit")

    @_builtins.property
    @pulumi.getter
    def grants(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of the user's grants.
        """
        return pulumi.get(self, "grants")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional[_builtins.bool]:
        """
        User's ability to login.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbPostgresqlClusterUserPermission']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of user settings. [Full description](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/Cluster/create#yandex.cloud.mdb.postgresql.v1.UserSettings).

        * `default_transaction_isolation` - defines the default isolation level to be set for all new SQL transactions. One of:
          - 1: `read uncommitted`
          - 2: `read committed`
          - 3: `repeatable read`
          - 4: `serializable`

        * `lock_timeout` - The maximum time (in milliseconds) for any statement to wait for acquiring a lock on an table, index, row or other database object (default 0).

        * `log_min_duration_statement` - This setting controls logging of the duration of statements. Default -1 disables logging of the duration of statements.

        * `synchronous_commit` - This setting defines whether DBMS will commit transaction in a synchronous way. One of:
          - 1: `on`
          - 2: `off`
          - 3: `local`
          - 4: `remote write`
          - 5: `remote apply`

        * `temp_file_limit` - The maximum storage space size (in kilobytes) that a single process can use to create temporary files.

        * `log_statement` - This setting specifies which SQL statements should be logged (on the user level). One of:
          - 1: `none`
          - 2: `ddl`
          - 3: `mod`
          - 4: `all`

        * `pool_mode` - Mode that the connection pooler is working in with specified user. One of:
          - 1: `session`
          - 2: `transaction`
          - 3: `statement`

        * `prepared_statements_pooling` - This setting allows user to use prepared statements with transaction pooling. Boolean.

        * `catchup_timeout` - The connection pooler setting. It determines the maximum allowed replication lag (in seconds). Pooler will reject connections to the replica with a lag above this threshold. Default value is 0, which disables this feature. Integer.

        * `wal_sender_timeout` - The maximum time (in milliseconds) to wait for WAL replication. Terminate replication connections that are inactive for longer than this amount of time. Integer.

        * `idle_in_transaction_session_timeout` - Sets the maximum allowed idle time (in milliseconds) between queries, when in a transaction. Value of 0 (default) disables the timeout. Integer.

        * `statement_timeout` - The maximum time (in milliseconds) to wait for statement. Value of 0 (default) disables the timeout. Integer.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class MdbPostgresqlClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class MdbPostgresqlDatabaseExtension(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbPostgresqlUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbPostgresqlUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbPostgresqlUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbPostgresqlUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class MdbRedisClusterAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLens":
            suggest = "data_lens"
        elif key == "webSql":
            suggest = "web_sql"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for DataLens. Can be either `true` or `false`.
        :param _builtins.bool web_sql: Allow access for Web SQL. Can be either `true` or `false`.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for DataLens. Can be either `true` or `false`.
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allow access for Web SQL. Can be either `true` or `false`.
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class MdbRedisClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowDataLoss":
            suggest = "allow_data_loss"
        elif key == "backupWindowStart":
            suggest = "backup_window_start"
        elif key == "clientOutputBufferLimitNormal":
            suggest = "client_output_buffer_limit_normal"
        elif key == "clientOutputBufferLimitPubsub":
            suggest = "client_output_buffer_limit_pubsub"
        elif key == "clusterAllowPubsubshardWhenDown":
            suggest = "cluster_allow_pubsubshard_when_down"
        elif key == "clusterAllowReadsWhenDown":
            suggest = "cluster_allow_reads_when_down"
        elif key == "clusterRequireFullCoverage":
            suggest = "cluster_require_full_coverage"
        elif key == "ioThreadsAllowed":
            suggest = "io_threads_allowed"
        elif key == "lfuDecayTime":
            suggest = "lfu_decay_time"
        elif key == "lfuLogFactor":
            suggest = "lfu_log_factor"
        elif key == "luaTimeLimit":
            suggest = "lua_time_limit"
        elif key == "maxmemoryPercent":
            suggest = "maxmemory_percent"
        elif key == "maxmemoryPolicy":
            suggest = "maxmemory_policy"
        elif key == "notifyKeyspaceEvents":
            suggest = "notify_keyspace_events"
        elif key == "replBacklogSizePercent":
            suggest = "repl_backlog_size_percent"
        elif key == "slowlogLogSlowerThan":
            suggest = "slowlog_log_slower_than"
        elif key == "slowlogMaxLen":
            suggest = "slowlog_max_len"
        elif key == "turnBeforeSwitchover":
            suggest = "turn_before_switchover"
        elif key == "useLuajit":
            suggest = "use_luajit"
        elif key == "zsetMaxListpackEntries":
            suggest = "zset_max_listpack_entries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 version: _builtins.str,
                 allow_data_loss: Optional[_builtins.bool] = None,
                 backup_window_start: Optional['outputs.MdbRedisClusterConfigBackupWindowStart'] = None,
                 client_output_buffer_limit_normal: Optional[_builtins.str] = None,
                 client_output_buffer_limit_pubsub: Optional[_builtins.str] = None,
                 cluster_allow_pubsubshard_when_down: Optional[_builtins.bool] = None,
                 cluster_allow_reads_when_down: Optional[_builtins.bool] = None,
                 cluster_require_full_coverage: Optional[_builtins.bool] = None,
                 databases: Optional[_builtins.int] = None,
                 io_threads_allowed: Optional[_builtins.bool] = None,
                 lfu_decay_time: Optional[_builtins.int] = None,
                 lfu_log_factor: Optional[_builtins.int] = None,
                 lua_time_limit: Optional[_builtins.int] = None,
                 maxmemory_percent: Optional[_builtins.int] = None,
                 maxmemory_policy: Optional[_builtins.str] = None,
                 notify_keyspace_events: Optional[_builtins.str] = None,
                 repl_backlog_size_percent: Optional[_builtins.int] = None,
                 slowlog_log_slower_than: Optional[_builtins.int] = None,
                 slowlog_max_len: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None,
                 turn_before_switchover: Optional[_builtins.bool] = None,
                 use_luajit: Optional[_builtins.bool] = None,
                 zset_max_listpack_entries: Optional[_builtins.int] = None):
        """
        :param _builtins.str password: Password for the Redis cluster.
        :param _builtins.str version: Version of Redis.
        :param _builtins.bool allow_data_loss: Allows some data to be lost in favor of faster switchover/restart by RDSync.
        :param 'MdbRedisClusterConfigBackupWindowStartArgs' backup_window_start: Time to start the daily backup, in the UTC timezone.
        :param _builtins.str client_output_buffer_limit_normal: Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        :param _builtins.str client_output_buffer_limit_pubsub: Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        :param _builtins.bool cluster_allow_pubsubshard_when_down: Permits Pub/Sub shard operations when cluster is down.
        :param _builtins.bool cluster_allow_reads_when_down: Allows read operations when cluster is down.
        :param _builtins.bool cluster_require_full_coverage: Controls whether all hash slots must be covered by nodes.
        :param _builtins.int databases: Number of databases (changing requires redis-server restart).
        :param _builtins.bool io_threads_allowed: Allow Redis to use io-threads.
        :param _builtins.int lfu_decay_time: The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        :param _builtins.int lfu_log_factor: Determines how the frequency counter represents key hits.
        :param _builtins.int lua_time_limit: Maximum time in milliseconds for Lua scripts.
        :param _builtins.int maxmemory_percent: Redis maxmemory usage in percent
        :param _builtins.str maxmemory_policy: Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        :param _builtins.str notify_keyspace_events: Select the events that Redis will notify among a set of classes.
        :param _builtins.int repl_backlog_size_percent: Replication backlog size as a percentage of flavor maxmemory.
        :param _builtins.int slowlog_log_slower_than: Log slow queries below this number in microseconds.
        :param _builtins.int slowlog_max_len: Slow queries log length.
        :param _builtins.int timeout: Close the connection after a client is idle for N seconds.
        :param _builtins.bool turn_before_switchover: Allows to turn before switchover in RDSync.
        :param _builtins.bool use_luajit: Use JIT for lua scripts and functions.
        :param _builtins.int zset_max_listpack_entries: Controls max number of entries in zset before conversion from memory-efficient listpack to CPU-efficient hash table and skiplist
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "version", version)
        if allow_data_loss is not None:
            pulumi.set(__self__, "allow_data_loss", allow_data_loss)
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if client_output_buffer_limit_normal is not None:
            pulumi.set(__self__, "client_output_buffer_limit_normal", client_output_buffer_limit_normal)
        if client_output_buffer_limit_pubsub is not None:
            pulumi.set(__self__, "client_output_buffer_limit_pubsub", client_output_buffer_limit_pubsub)
        if cluster_allow_pubsubshard_when_down is not None:
            pulumi.set(__self__, "cluster_allow_pubsubshard_when_down", cluster_allow_pubsubshard_when_down)
        if cluster_allow_reads_when_down is not None:
            pulumi.set(__self__, "cluster_allow_reads_when_down", cluster_allow_reads_when_down)
        if cluster_require_full_coverage is not None:
            pulumi.set(__self__, "cluster_require_full_coverage", cluster_require_full_coverage)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if io_threads_allowed is not None:
            pulumi.set(__self__, "io_threads_allowed", io_threads_allowed)
        if lfu_decay_time is not None:
            pulumi.set(__self__, "lfu_decay_time", lfu_decay_time)
        if lfu_log_factor is not None:
            pulumi.set(__self__, "lfu_log_factor", lfu_log_factor)
        if lua_time_limit is not None:
            pulumi.set(__self__, "lua_time_limit", lua_time_limit)
        if maxmemory_percent is not None:
            pulumi.set(__self__, "maxmemory_percent", maxmemory_percent)
        if maxmemory_policy is not None:
            pulumi.set(__self__, "maxmemory_policy", maxmemory_policy)
        if notify_keyspace_events is not None:
            pulumi.set(__self__, "notify_keyspace_events", notify_keyspace_events)
        if repl_backlog_size_percent is not None:
            pulumi.set(__self__, "repl_backlog_size_percent", repl_backlog_size_percent)
        if slowlog_log_slower_than is not None:
            pulumi.set(__self__, "slowlog_log_slower_than", slowlog_log_slower_than)
        if slowlog_max_len is not None:
            pulumi.set(__self__, "slowlog_max_len", slowlog_max_len)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if turn_before_switchover is not None:
            pulumi.set(__self__, "turn_before_switchover", turn_before_switchover)
        if use_luajit is not None:
            pulumi.set(__self__, "use_luajit", use_luajit)
        if zset_max_listpack_entries is not None:
            pulumi.set(__self__, "zset_max_listpack_entries", zset_max_listpack_entries)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for the Redis cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of Redis.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="allowDataLoss")
    def allow_data_loss(self) -> Optional[_builtins.bool]:
        """
        Allows some data to be lost in favor of faster switchover/restart by RDSync.
        """
        return pulumi.get(self, "allow_data_loss")

    @_builtins.property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional['outputs.MdbRedisClusterConfigBackupWindowStart']:
        """
        Time to start the daily backup, in the UTC timezone.
        """
        return pulumi.get(self, "backup_window_start")

    @_builtins.property
    @pulumi.getter(name="clientOutputBufferLimitNormal")
    def client_output_buffer_limit_normal(self) -> Optional[_builtins.str]:
        """
        Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        """
        return pulumi.get(self, "client_output_buffer_limit_normal")

    @_builtins.property
    @pulumi.getter(name="clientOutputBufferLimitPubsub")
    def client_output_buffer_limit_pubsub(self) -> Optional[_builtins.str]:
        """
        Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        """
        return pulumi.get(self, "client_output_buffer_limit_pubsub")

    @_builtins.property
    @pulumi.getter(name="clusterAllowPubsubshardWhenDown")
    def cluster_allow_pubsubshard_when_down(self) -> Optional[_builtins.bool]:
        """
        Permits Pub/Sub shard operations when cluster is down.
        """
        return pulumi.get(self, "cluster_allow_pubsubshard_when_down")

    @_builtins.property
    @pulumi.getter(name="clusterAllowReadsWhenDown")
    def cluster_allow_reads_when_down(self) -> Optional[_builtins.bool]:
        """
        Allows read operations when cluster is down.
        """
        return pulumi.get(self, "cluster_allow_reads_when_down")

    @_builtins.property
    @pulumi.getter(name="clusterRequireFullCoverage")
    def cluster_require_full_coverage(self) -> Optional[_builtins.bool]:
        """
        Controls whether all hash slots must be covered by nodes.
        """
        return pulumi.get(self, "cluster_require_full_coverage")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[_builtins.int]:
        """
        Number of databases (changing requires redis-server restart).
        """
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="ioThreadsAllowed")
    def io_threads_allowed(self) -> Optional[_builtins.bool]:
        """
        Allow Redis to use io-threads.
        """
        return pulumi.get(self, "io_threads_allowed")

    @_builtins.property
    @pulumi.getter(name="lfuDecayTime")
    def lfu_decay_time(self) -> Optional[_builtins.int]:
        """
        The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        """
        return pulumi.get(self, "lfu_decay_time")

    @_builtins.property
    @pulumi.getter(name="lfuLogFactor")
    def lfu_log_factor(self) -> Optional[_builtins.int]:
        """
        Determines how the frequency counter represents key hits.
        """
        return pulumi.get(self, "lfu_log_factor")

    @_builtins.property
    @pulumi.getter(name="luaTimeLimit")
    def lua_time_limit(self) -> Optional[_builtins.int]:
        """
        Maximum time in milliseconds for Lua scripts.
        """
        return pulumi.get(self, "lua_time_limit")

    @_builtins.property
    @pulumi.getter(name="maxmemoryPercent")
    def maxmemory_percent(self) -> Optional[_builtins.int]:
        """
        Redis maxmemory usage in percent
        """
        return pulumi.get(self, "maxmemory_percent")

    @_builtins.property
    @pulumi.getter(name="maxmemoryPolicy")
    def maxmemory_policy(self) -> Optional[_builtins.str]:
        """
        Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        """
        return pulumi.get(self, "maxmemory_policy")

    @_builtins.property
    @pulumi.getter(name="notifyKeyspaceEvents")
    def notify_keyspace_events(self) -> Optional[_builtins.str]:
        """
        Select the events that Redis will notify among a set of classes.
        """
        return pulumi.get(self, "notify_keyspace_events")

    @_builtins.property
    @pulumi.getter(name="replBacklogSizePercent")
    def repl_backlog_size_percent(self) -> Optional[_builtins.int]:
        """
        Replication backlog size as a percentage of flavor maxmemory.
        """
        return pulumi.get(self, "repl_backlog_size_percent")

    @_builtins.property
    @pulumi.getter(name="slowlogLogSlowerThan")
    def slowlog_log_slower_than(self) -> Optional[_builtins.int]:
        """
        Log slow queries below this number in microseconds.
        """
        return pulumi.get(self, "slowlog_log_slower_than")

    @_builtins.property
    @pulumi.getter(name="slowlogMaxLen")
    def slowlog_max_len(self) -> Optional[_builtins.int]:
        """
        Slow queries log length.
        """
        return pulumi.get(self, "slowlog_max_len")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Close the connection after a client is idle for N seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="turnBeforeSwitchover")
    def turn_before_switchover(self) -> Optional[_builtins.bool]:
        """
        Allows to turn before switchover in RDSync.
        """
        return pulumi.get(self, "turn_before_switchover")

    @_builtins.property
    @pulumi.getter(name="useLuajit")
    def use_luajit(self) -> Optional[_builtins.bool]:
        """
        Use JIT for lua scripts and functions.
        """
        return pulumi.get(self, "use_luajit")

    @_builtins.property
    @pulumi.getter(name="zsetMaxListpackEntries")
    def zset_max_listpack_entries(self) -> Optional[_builtins.int]:
        """
        Controls max number of entries in zset before conversion from memory-efficient listpack to CPU-efficient hash table and skiplist
        """
        return pulumi.get(self, "zset_max_listpack_entries")


@pulumi.output_type
class MdbRedisClusterConfigBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbRedisClusterDiskSizeAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeLimit":
            suggest = "disk_size_limit"
        elif key == "emergencyUsageThreshold":
            suggest = "emergency_usage_threshold"
        elif key == "plannedUsageThreshold":
            suggest = "planned_usage_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterDiskSizeAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterDiskSizeAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterDiskSizeAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class MdbRedisClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "replicaPriority":
            suggest = "replica_priority"
        elif key == "shardName":
            suggest = "shard_name"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None,
                 replica_priority: Optional[_builtins.int] = None,
                 shard_name: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address or not.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.int replica_priority: Replica priority of a current replica (usable for non-sharded only).
        :param _builtins.str shard_name: The name of the shard to which the host belongs.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if replica_priority is not None:
            pulumi.set(__self__, "replica_priority", replica_priority)
        if shard_name is not None:
            pulumi.set(__self__, "shard_name", shard_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Sets whether the host should get a public IP address or not.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="replicaPriority")
    def replica_priority(self) -> Optional[_builtins.int]:
        """
        Replica priority of a current replica (usable for non-sharded only).
        """
        return pulumi.get(self, "replica_priority")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> Optional[_builtins.str]:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbRedisClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        :param _builtins.str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        pulumi.set(__self__, "type", type)
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MdbRedisClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"
        elif key == "diskTypeId":
            suggest = "disk_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbRedisClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbRedisClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbRedisClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 resource_preset_id: _builtins.str,
                 disk_type_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-redis/concepts).
        :param _builtins.str disk_type_id: Type of the storage of Redis hosts - environment default is used if missing.
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-redis/concepts).
        """
        return pulumi.get(self, "resource_preset_id")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of Redis hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")


@pulumi.output_type
class MdbSqlserverClusterBackupWindowStart(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class MdbSqlserverClusterDatabase(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MdbSqlserverClusterHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbSqlserverClusterHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbSqlserverClusterHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbSqlserverClusterHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 zone: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MdbSqlserverClusterResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskTypeId":
            suggest = "disk_type_id"
        elif key == "resourcePresetId":
            suggest = "resource_preset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbSqlserverClusterResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbSqlserverClusterResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbSqlserverClusterResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a SQLServer host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of SQLServer hosts.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a SQLServer host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-sqlserver/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a SQLServer host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of SQLServer hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a SQLServer host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-sqlserver/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class MdbSqlserverClusterUser(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 permissions: Optional[Sequence['outputs.MdbSqlserverClusterUserPermission']] = None):
        """
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param Sequence['MdbSqlserverClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.MdbSqlserverClusterUserPermission']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class MdbSqlserverClusterUserPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MdbSqlserverClusterUserPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MdbSqlserverClusterUserPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MdbSqlserverClusterUserPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class MonitoringDashboardParametrization(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence['outputs.MonitoringDashboardParametrizationParameter']] = None,
                 selectors: Optional[_builtins.str] = None):
        """
        :param Sequence['MonitoringDashboardParametrizationParameterArgs'] parameters: Dashboard parameters.
        :param _builtins.str selectors: Dashboard predefined parameters selector.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.MonitoringDashboardParametrizationParameter']]:
        """
        Dashboard parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Optional[_builtins.str]:
        """
        Dashboard predefined parameters selector.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class MonitoringDashboardParametrizationParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelValues":
            suggest = "label_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardParametrizationParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardParametrizationParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardParametrizationParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 customs: Optional[Sequence['outputs.MonitoringDashboardParametrizationParameterCustom']] = None,
                 description: Optional[_builtins.str] = None,
                 hidden: Optional[_builtins.bool] = None,
                 label_values: Optional[Sequence['outputs.MonitoringDashboardParametrizationParameterLabelValue']] = None,
                 texts: Optional[Sequence['outputs.MonitoringDashboardParametrizationParameterText']] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Parameter identifier.
        :param Sequence['MonitoringDashboardParametrizationParameterCustomArgs'] customs: Custom values parameter. Oneof: label_values, custom, text.
        :param _builtins.str description: Parameter description.
        :param _builtins.bool hidden: UI-visibility
        :param Sequence['MonitoringDashboardParametrizationParameterLabelValueArgs'] label_values: Label values parameter. Oneof: label_values, custom, text.
        :param Sequence['MonitoringDashboardParametrizationParameterTextArgs'] texts: Text parameter. Oneof: label_values, custom, text.
        :param _builtins.str title: UI-visible title of the parameter.
        """
        pulumi.set(__self__, "id", id)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if label_values is not None:
            pulumi.set(__self__, "label_values", label_values)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Parameter identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.MonitoringDashboardParametrizationParameterCustom']]:
        """
        Custom values parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional[_builtins.bool]:
        """
        UI-visibility
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter(name="labelValues")
    def label_values(self) -> Optional[Sequence['outputs.MonitoringDashboardParametrizationParameterLabelValue']]:
        """
        Label values parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "label_values")

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[Sequence['outputs.MonitoringDashboardParametrizationParameterText']]:
        """
        Text parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "texts")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        UI-visible title of the parameter.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class MonitoringDashboardParametrizationParameterCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValues":
            suggest = "default_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardParametrizationParameterCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardParametrizationParameterCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardParametrizationParameterCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_values: Optional[Sequence[_builtins.str]] = None,
                 multiselectable: Optional[_builtins.bool] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] default_values: Default value.
        :param _builtins.bool multiselectable: Specifies the multiselectable values of parameter.
        :param Sequence[_builtins.str] values: Parameter values.
        """
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if multiselectable is not None:
            pulumi.set(__self__, "multiselectable", multiselectable)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Default value.
        """
        return pulumi.get(self, "default_values")

    @_builtins.property
    @pulumi.getter
    def multiselectable(self) -> Optional[_builtins.bool]:
        """
        Specifies the multiselectable values of parameter.
        """
        return pulumi.get(self, "multiselectable")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MonitoringDashboardParametrizationParameterLabelValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelKey":
            suggest = "label_key"
        elif key == "defaultValues":
            suggest = "default_values"
        elif key == "folderId":
            suggest = "folder_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardParametrizationParameterLabelValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardParametrizationParameterLabelValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardParametrizationParameterLabelValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_key: _builtins.str,
                 default_values: Optional[Sequence[_builtins.str]] = None,
                 folder_id: Optional[_builtins.str] = None,
                 multiselectable: Optional[_builtins.bool] = None,
                 selectors: Optional[_builtins.str] = None):
        """
        :param _builtins.str label_key: Label key to list label values.
        :param Sequence[_builtins.str] default_values: Default value.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.bool multiselectable: Specifies the multiselectable values of parameter.
        :param _builtins.str selectors: Selectors to select metric label values.
        """
        pulumi.set(__self__, "label_key", label_key)
        if default_values is not None:
            pulumi.set(__self__, "default_values", default_values)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if multiselectable is not None:
            pulumi.set(__self__, "multiselectable", multiselectable)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter(name="labelKey")
    def label_key(self) -> _builtins.str:
        """
        Label key to list label values.
        """
        return pulumi.get(self, "label_key")

    @_builtins.property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Default value.
        """
        return pulumi.get(self, "default_values")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def multiselectable(self) -> Optional[_builtins.bool]:
        """
        Specifies the multiselectable values of parameter.
        """
        return pulumi.get(self, "multiselectable")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Optional[_builtins.str]:
        """
        Selectors to select metric label values.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class MonitoringDashboardParametrizationParameterText(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardParametrizationParameterText. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardParametrizationParameterText.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardParametrizationParameterText.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_value: Default value.
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        Default value.
        """
        return pulumi.get(self, "default_value")


@pulumi.output_type
class MonitoringDashboardWidget(dict):
    def __init__(__self__, *,
                 charts: Optional[Sequence['outputs.MonitoringDashboardWidgetChart']] = None,
                 positions: Optional[Sequence['outputs.MonitoringDashboardWidgetPosition']] = None,
                 texts: Optional[Sequence['outputs.MonitoringDashboardWidgetText']] = None,
                 titles: Optional[Sequence['outputs.MonitoringDashboardWidgetTitle']] = None):
        """
        :param Sequence['MonitoringDashboardWidgetChartArgs'] charts: Chart widget settings.
        :param Sequence['MonitoringDashboardWidgetPositionArgs'] positions: Widget layout position.
        :param Sequence['MonitoringDashboardWidgetTextArgs'] texts: Text widget settings.
        :param Sequence['MonitoringDashboardWidgetTitleArgs'] titles: Title widget settings.
        """
        if charts is not None:
            pulumi.set(__self__, "charts", charts)
        if positions is not None:
            pulumi.set(__self__, "positions", positions)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)
        if titles is not None:
            pulumi.set(__self__, "titles", titles)

    @_builtins.property
    @pulumi.getter
    def charts(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChart']]:
        """
        Chart widget settings.
        """
        return pulumi.get(self, "charts")

    @_builtins.property
    @pulumi.getter
    def positions(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetPosition']]:
        """
        Widget layout position.
        """
        return pulumi.get(self, "positions")

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetText']]:
        """
        Text widget settings.
        """
        return pulumi.get(self, "texts")

    @_builtins.property
    @pulumi.getter
    def titles(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetTitle']]:
        """
        Title widget settings.
        """
        return pulumi.get(self, "titles")


@pulumi.output_type
class MonitoringDashboardWidgetChart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartId":
            suggest = "chart_id"
        elif key == "displayLegend":
            suggest = "display_legend"
        elif key == "nameHidingSettings":
            suggest = "name_hiding_settings"
        elif key == "seriesOverrides":
            suggest = "series_overrides"
        elif key == "visualizationSettings":
            suggest = "visualization_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_id: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 display_legend: Optional[_builtins.bool] = None,
                 freeze: Optional[_builtins.str] = None,
                 name_hiding_settings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartNameHidingSetting']] = None,
                 queries: Optional[Sequence['outputs.MonitoringDashboardWidgetChartQuery']] = None,
                 series_overrides: Optional[Sequence['outputs.MonitoringDashboardWidgetChartSeriesOverride']] = None,
                 title: Optional[_builtins.str] = None,
                 visualization_settings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSetting']] = None):
        """
        :param _builtins.str chart_id: Chart ID.
        :param _builtins.str description: Chart description in dashboard (not enabled in UI).
        :param _builtins.bool display_legend: Enable legend under chart.
        :param _builtins.str freeze: Fixed time interval for chart. Values:
               - FREEZE_DURATION_HOUR: Last hour.
               - FREEZE_DURATION_DAY: Last day = last 24 hours.
               - FREEZE_DURATION_WEEK: Last 7 days.
               - FREEZE_DURATION_MONTH: Last 31 days.
        :param Sequence['MonitoringDashboardWidgetChartNameHidingSettingArgs'] name_hiding_settings: Name hiding settings
        :param Sequence['MonitoringDashboardWidgetChartQueryArgs'] queries: Queries settings.
        :param Sequence['MonitoringDashboardWidgetChartSeriesOverrideArgs'] series_overrides: Time series settings.
        :param _builtins.str title: Chart widget title.
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingArgs'] visualization_settings: Visualization settings.
        """
        if chart_id is not None:
            pulumi.set(__self__, "chart_id", chart_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_legend is not None:
            pulumi.set(__self__, "display_legend", display_legend)
        if freeze is not None:
            pulumi.set(__self__, "freeze", freeze)
        if name_hiding_settings is not None:
            pulumi.set(__self__, "name_hiding_settings", name_hiding_settings)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if series_overrides is not None:
            pulumi.set(__self__, "series_overrides", series_overrides)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visualization_settings is not None:
            pulumi.set(__self__, "visualization_settings", visualization_settings)

    @_builtins.property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> Optional[_builtins.str]:
        """
        Chart ID.
        """
        return pulumi.get(self, "chart_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Chart description in dashboard (not enabled in UI).
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayLegend")
    def display_legend(self) -> Optional[_builtins.bool]:
        """
        Enable legend under chart.
        """
        return pulumi.get(self, "display_legend")

    @_builtins.property
    @pulumi.getter
    def freeze(self) -> Optional[_builtins.str]:
        """
        Fixed time interval for chart. Values:
        - FREEZE_DURATION_HOUR: Last hour.
        - FREEZE_DURATION_DAY: Last day = last 24 hours.
        - FREEZE_DURATION_WEEK: Last 7 days.
        - FREEZE_DURATION_MONTH: Last 31 days.
        """
        return pulumi.get(self, "freeze")

    @_builtins.property
    @pulumi.getter(name="nameHidingSettings")
    def name_hiding_settings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartNameHidingSetting']]:
        """
        Name hiding settings
        """
        return pulumi.get(self, "name_hiding_settings")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartQuery']]:
        """
        Queries settings.
        """
        return pulumi.get(self, "queries")

    @_builtins.property
    @pulumi.getter(name="seriesOverrides")
    def series_overrides(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartSeriesOverride']]:
        """
        Time series settings.
        """
        return pulumi.get(self, "series_overrides")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Chart widget title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="visualizationSettings")
    def visualization_settings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSetting']]:
        """
        Visualization settings.
        """
        return pulumi.get(self, "visualization_settings")


@pulumi.output_type
class MonitoringDashboardWidgetChartNameHidingSetting(dict):
    def __init__(__self__, *,
                 names: Optional[Sequence[_builtins.str]] = None,
                 positive: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool positive: True if we want to show concrete series names only, false if we want to hide concrete series names
        """
        if names is not None:
            pulumi.set(__self__, "names", names)
        if positive is not None:
            pulumi.set(__self__, "positive", positive)

    @_builtins.property
    @pulumi.getter
    def names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "names")

    @_builtins.property
    @pulumi.getter
    def positive(self) -> Optional[_builtins.bool]:
        """
        True if we want to show concrete series names only, false if we want to hide concrete series names
        """
        return pulumi.get(self, "positive")


@pulumi.output_type
class MonitoringDashboardWidgetChartQuery(dict):
    def __init__(__self__, *,
                 downsamplings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartQueryDownsampling']] = None,
                 targets: Optional[Sequence['outputs.MonitoringDashboardWidgetChartQueryTarget']] = None):
        """
        :param Sequence['MonitoringDashboardWidgetChartQueryDownsamplingArgs'] downsamplings: Downsampling settings
        :param Sequence['MonitoringDashboardWidgetChartQueryTargetArgs'] targets: Downsampling settings
        """
        if downsamplings is not None:
            pulumi.set(__self__, "downsamplings", downsamplings)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def downsamplings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartQueryDownsampling']]:
        """
        Downsampling settings
        """
        return pulumi.get(self, "downsamplings")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartQueryTarget']]:
        """
        Downsampling settings
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class MonitoringDashboardWidgetChartQueryDownsampling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gapFilling":
            suggest = "gap_filling"
        elif key == "gridAggregation":
            suggest = "grid_aggregation"
        elif key == "gridInterval":
            suggest = "grid_interval"
        elif key == "maxPoints":
            suggest = "max_points"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartQueryDownsampling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartQueryDownsampling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartQueryDownsampling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 gap_filling: Optional[_builtins.str] = None,
                 grid_aggregation: Optional[_builtins.str] = None,
                 grid_interval: Optional[_builtins.int] = None,
                 max_points: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disabled: Disable downsampling
        :param _builtins.str gap_filling: Parameters for filling gaps in data
        :param _builtins.str grid_aggregation: Function that is used for downsampling
        :param _builtins.int grid_interval: Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        :param _builtins.int max_points: Maximum number of points to be returned
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if gap_filling is not None:
            pulumi.set(__self__, "gap_filling", gap_filling)
        if grid_aggregation is not None:
            pulumi.set(__self__, "grid_aggregation", grid_aggregation)
        if grid_interval is not None:
            pulumi.set(__self__, "grid_interval", grid_interval)
        if max_points is not None:
            pulumi.set(__self__, "max_points", max_points)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Disable downsampling
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="gapFilling")
    def gap_filling(self) -> Optional[_builtins.str]:
        """
        Parameters for filling gaps in data
        """
        return pulumi.get(self, "gap_filling")

    @_builtins.property
    @pulumi.getter(name="gridAggregation")
    def grid_aggregation(self) -> Optional[_builtins.str]:
        """
        Function that is used for downsampling
        """
        return pulumi.get(self, "grid_aggregation")

    @_builtins.property
    @pulumi.getter(name="gridInterval")
    def grid_interval(self) -> Optional[_builtins.int]:
        """
        Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        """
        return pulumi.get(self, "grid_interval")

    @_builtins.property
    @pulumi.getter(name="maxPoints")
    def max_points(self) -> Optional[_builtins.int]:
        """
        Maximum number of points to be returned
        """
        return pulumi.get(self, "max_points")


@pulumi.output_type
class MonitoringDashboardWidgetChartQueryTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textMode":
            suggest = "text_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartQueryTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartQueryTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartQueryTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hidden: Optional[_builtins.bool] = None,
                 query: Optional[_builtins.str] = None,
                 text_mode: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool hidden: Checks that target is visible or invisible
        :param _builtins.str query: Required. Query
        :param _builtins.bool text_mode: Text mode
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if text_mode is not None:
            pulumi.set(__self__, "text_mode", text_mode)

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional[_builtins.bool]:
        """
        Checks that target is visible or invisible
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Required. Query
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter(name="textMode")
    def text_mode(self) -> Optional[_builtins.bool]:
        """
        Text mode
        """
        return pulumi.get(self, "text_mode")


@pulumi.output_type
class MonitoringDashboardWidgetChartSeriesOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetIndex":
            suggest = "target_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartSeriesOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartSeriesOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartSeriesOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 settings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartSeriesOverrideSetting']] = None,
                 target_index: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Series name
        :param Sequence['MonitoringDashboardWidgetChartSeriesOverrideSettingArgs'] settings: Override settings
        :param _builtins.str target_index: Target index
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if target_index is not None:
            pulumi.set(__self__, "target_index", target_index)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Series name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartSeriesOverrideSetting']]:
        """
        Override settings
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="targetIndex")
    def target_index(self) -> Optional[_builtins.str]:
        """
        Target index
        """
        return pulumi.get(self, "target_index")


@pulumi.output_type
class MonitoringDashboardWidgetChartSeriesOverrideSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "growDown":
            suggest = "grow_down"
        elif key == "stackName":
            suggest = "stack_name"
        elif key == "yaxisPosition":
            suggest = "yaxis_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartSeriesOverrideSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartSeriesOverrideSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartSeriesOverrideSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color: Optional[_builtins.str] = None,
                 grow_down: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 stack_name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 yaxis_position: Optional[_builtins.str] = None):
        """
        :param _builtins.str color: Series color or empty
        :param _builtins.bool grow_down: Stack grow down
        :param _builtins.str name: Series name or empty
        :param _builtins.str stack_name: Stack name or empty
        :param _builtins.str type: Type
        :param _builtins.str yaxis_position: Yaxis position
        """
        if color is not None:
            pulumi.set(__self__, "color", color)
        if grow_down is not None:
            pulumi.set(__self__, "grow_down", grow_down)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if stack_name is not None:
            pulumi.set(__self__, "stack_name", stack_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if yaxis_position is not None:
            pulumi.set(__self__, "yaxis_position", yaxis_position)

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        Series color or empty
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="growDown")
    def grow_down(self) -> Optional[_builtins.bool]:
        """
        Stack grow down
        """
        return pulumi.get(self, "grow_down")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Series name or empty
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stackName")
    def stack_name(self) -> Optional[_builtins.str]:
        """
        Stack name or empty
        """
        return pulumi.get(self, "stack_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="yaxisPosition")
    def yaxis_position(self) -> Optional[_builtins.str]:
        """
        Yaxis position
        """
        return pulumi.get(self, "yaxis_position")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorSchemeSettings":
            suggest = "color_scheme_settings"
        elif key == "heatmapSettings":
            suggest = "heatmap_settings"
        elif key == "showLabels":
            suggest = "show_labels"
        elif key == "yaxisSettings":
            suggest = "yaxis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartVisualizationSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartVisualizationSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartVisualizationSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation: Optional[_builtins.str] = None,
                 color_scheme_settings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting']] = None,
                 heatmap_settings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting']] = None,
                 interpolate: Optional[_builtins.str] = None,
                 normalize: Optional[_builtins.bool] = None,
                 show_labels: Optional[_builtins.bool] = None,
                 title: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 yaxis_settings: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSetting']] = None):
        """
        :param _builtins.str aggregation: Aggregation
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs'] color_scheme_settings: Color scheme settings
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs'] heatmap_settings: Heatmap settings
        :param _builtins.str interpolate: Interpolate
        :param _builtins.bool normalize: Normalize
        :param _builtins.bool show_labels: Show chart labels
        :param _builtins.str title: Inside chart title
        :param _builtins.str type: Visualization type
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs'] yaxis_settings: Y axis settings
        """
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if color_scheme_settings is not None:
            pulumi.set(__self__, "color_scheme_settings", color_scheme_settings)
        if heatmap_settings is not None:
            pulumi.set(__self__, "heatmap_settings", heatmap_settings)
        if interpolate is not None:
            pulumi.set(__self__, "interpolate", interpolate)
        if normalize is not None:
            pulumi.set(__self__, "normalize", normalize)
        if show_labels is not None:
            pulumi.set(__self__, "show_labels", show_labels)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if yaxis_settings is not None:
            pulumi.set(__self__, "yaxis_settings", yaxis_settings)

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        Aggregation
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter(name="colorSchemeSettings")
    def color_scheme_settings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting']]:
        """
        Color scheme settings
        """
        return pulumi.get(self, "color_scheme_settings")

    @_builtins.property
    @pulumi.getter(name="heatmapSettings")
    def heatmap_settings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting']]:
        """
        Heatmap settings
        """
        return pulumi.get(self, "heatmap_settings")

    @_builtins.property
    @pulumi.getter
    def interpolate(self) -> Optional[_builtins.str]:
        """
        Interpolate
        """
        return pulumi.get(self, "interpolate")

    @_builtins.property
    @pulumi.getter
    def normalize(self) -> Optional[_builtins.bool]:
        """
        Normalize
        """
        return pulumi.get(self, "normalize")

    @_builtins.property
    @pulumi.getter(name="showLabels")
    def show_labels(self) -> Optional[_builtins.bool]:
        """
        Show chart labels
        """
        return pulumi.get(self, "show_labels")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Inside chart title
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Visualization type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="yaxisSettings")
    def yaxis_settings(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSetting']]:
        """
        Y axis settings
        """
        return pulumi.get(self, "yaxis_settings")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting(dict):
    def __init__(__self__, *,
                 automatics: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic']] = None,
                 gradients: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient']] = None,
                 standards: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard']] = None):
        """
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs'] automatics: Automatic color scheme
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs'] gradients: Gradient color scheme
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs'] standards: Standard color scheme
        """
        if automatics is not None:
            pulumi.set(__self__, "automatics", automatics)
        if gradients is not None:
            pulumi.set(__self__, "gradients", gradients)
        if standards is not None:
            pulumi.set(__self__, "standards", standards)

    @_builtins.property
    @pulumi.getter
    def automatics(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic']]:
        """
        Automatic color scheme
        """
        return pulumi.get(self, "automatics")

    @_builtins.property
    @pulumi.getter
    def gradients(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient']]:
        """
        Gradient color scheme
        """
        return pulumi.get(self, "gradients")

    @_builtins.property
    @pulumi.getter
    def standards(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard']]:
        """
        Standard color scheme
        """
        return pulumi.get(self, "standards")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "greenValue":
            suggest = "green_value"
        elif key == "redValue":
            suggest = "red_value"
        elif key == "violetValue":
            suggest = "violet_value"
        elif key == "yellowValue":
            suggest = "yellow_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 green_value: Optional[_builtins.str] = None,
                 red_value: Optional[_builtins.str] = None,
                 violet_value: Optional[_builtins.str] = None,
                 yellow_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str green_value: Gradient green value
        :param _builtins.str red_value: Gradient red value
        :param _builtins.str violet_value: Gradient violet_value
        :param _builtins.str yellow_value: Gradient yellow value
        """
        if green_value is not None:
            pulumi.set(__self__, "green_value", green_value)
        if red_value is not None:
            pulumi.set(__self__, "red_value", red_value)
        if violet_value is not None:
            pulumi.set(__self__, "violet_value", violet_value)
        if yellow_value is not None:
            pulumi.set(__self__, "yellow_value", yellow_value)

    @_builtins.property
    @pulumi.getter(name="greenValue")
    def green_value(self) -> Optional[_builtins.str]:
        """
        Gradient green value
        """
        return pulumi.get(self, "green_value")

    @_builtins.property
    @pulumi.getter(name="redValue")
    def red_value(self) -> Optional[_builtins.str]:
        """
        Gradient red value
        """
        return pulumi.get(self, "red_value")

    @_builtins.property
    @pulumi.getter(name="violetValue")
    def violet_value(self) -> Optional[_builtins.str]:
        """
        Gradient violet_value
        """
        return pulumi.get(self, "violet_value")

    @_builtins.property
    @pulumi.getter(name="yellowValue")
    def yellow_value(self) -> Optional[_builtins.str]:
        """
        Gradient yellow value
        """
        return pulumi.get(self, "yellow_value")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "greenValue":
            suggest = "green_value"
        elif key == "redValue":
            suggest = "red_value"
        elif key == "violetValue":
            suggest = "violet_value"
        elif key == "yellowValue":
            suggest = "yellow_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 green_value: Optional[_builtins.str] = None,
                 red_value: Optional[_builtins.str] = None,
                 violet_value: Optional[_builtins.str] = None,
                 yellow_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str green_value: Heatmap green value
        :param _builtins.str red_value: Heatmap red value
        :param _builtins.str violet_value: Heatmap violet_value
        :param _builtins.str yellow_value: Heatmap yellow value
        """
        if green_value is not None:
            pulumi.set(__self__, "green_value", green_value)
        if red_value is not None:
            pulumi.set(__self__, "red_value", red_value)
        if violet_value is not None:
            pulumi.set(__self__, "violet_value", violet_value)
        if yellow_value is not None:
            pulumi.set(__self__, "yellow_value", yellow_value)

    @_builtins.property
    @pulumi.getter(name="greenValue")
    def green_value(self) -> Optional[_builtins.str]:
        """
        Heatmap green value
        """
        return pulumi.get(self, "green_value")

    @_builtins.property
    @pulumi.getter(name="redValue")
    def red_value(self) -> Optional[_builtins.str]:
        """
        Heatmap red value
        """
        return pulumi.get(self, "red_value")

    @_builtins.property
    @pulumi.getter(name="violetValue")
    def violet_value(self) -> Optional[_builtins.str]:
        """
        Heatmap violet_value
        """
        return pulumi.get(self, "violet_value")

    @_builtins.property
    @pulumi.getter(name="yellowValue")
    def yellow_value(self) -> Optional[_builtins.str]:
        """
        Heatmap yellow value
        """
        return pulumi.get(self, "yellow_value")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingYaxisSetting(dict):
    def __init__(__self__, *,
                 lefts: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft']] = None,
                 rights: Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight']] = None):
        """
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs'] lefts: Left Y axis settings
        :param Sequence['MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs'] rights: Right Y axis settings
        """
        if lefts is not None:
            pulumi.set(__self__, "lefts", lefts)
        if rights is not None:
            pulumi.set(__self__, "rights", rights)

    @_builtins.property
    @pulumi.getter
    def lefts(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft']]:
        """
        Left Y axis settings
        """
        return pulumi.get(self, "lefts")

    @_builtins.property
    @pulumi.getter
    def rights(self) -> Optional[Sequence['outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight']]:
        """
        Right Y axis settings
        """
        return pulumi.get(self, "rights")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unitFormat":
            suggest = "unit_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max: Optional[_builtins.str] = None,
                 min: Optional[_builtins.str] = None,
                 precision: Optional[_builtins.int] = None,
                 title: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 unit_format: Optional[_builtins.str] = None):
        """
        :param _builtins.str max: Max value in extended number format or empty
        :param _builtins.str min: Min value in extended number format or empty
        :param _builtins.int precision: Tick value precision (null as default, 0-7 in other cases)
        :param _builtins.str title: Title or empty
        :param _builtins.str type: Type
        :param _builtins.str unit_format: Unit format
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit_format is not None:
            pulumi.set(__self__, "unit_format", unit_format)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.str]:
        """
        Max value in extended number format or empty
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.str]:
        """
        Min value in extended number format or empty
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        Tick value precision (null as default, 0-7 in other cases)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title or empty
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unitFormat")
    def unit_format(self) -> Optional[_builtins.str]:
        """
        Unit format
        """
        return pulumi.get(self, "unit_format")


@pulumi.output_type
class MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unitFormat":
            suggest = "unit_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max: Optional[_builtins.str] = None,
                 min: Optional[_builtins.str] = None,
                 precision: Optional[_builtins.int] = None,
                 title: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 unit_format: Optional[_builtins.str] = None):
        """
        :param _builtins.str max: Max value in extended number format or empty
        :param _builtins.str min: Min value in extended number format or empty
        :param _builtins.int precision: Tick value precision (null as default, 0-7 in other cases)
        :param _builtins.str title: Title or empty
        :param _builtins.str type: Type
        :param _builtins.str unit_format: Unit format
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit_format is not None:
            pulumi.set(__self__, "unit_format", unit_format)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.str]:
        """
        Max value in extended number format or empty
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.str]:
        """
        Min value in extended number format or empty
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        Tick value precision (null as default, 0-7 in other cases)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title or empty
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unitFormat")
    def unit_format(self) -> Optional[_builtins.str]:
        """
        Unit format
        """
        return pulumi.get(self, "unit_format")


@pulumi.output_type
class MonitoringDashboardWidgetPosition(dict):
    def __init__(__self__, *,
                 h: Optional[_builtins.int] = None,
                 w: Optional[_builtins.int] = None,
                 x: Optional[_builtins.int] = None,
                 y: Optional[_builtins.int] = None):
        """
        :param _builtins.int h: Height.
        :param _builtins.int w: Weight.
        :param _builtins.int x: X-axis top-left corner coordinate.
        :param _builtins.int y: Y-axis top-left corner coordinate.
        """
        if h is not None:
            pulumi.set(__self__, "h", h)
        if w is not None:
            pulumi.set(__self__, "w", w)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @_builtins.property
    @pulumi.getter
    def h(self) -> Optional[_builtins.int]:
        """
        Height.
        """
        return pulumi.get(self, "h")

    @_builtins.property
    @pulumi.getter
    def w(self) -> Optional[_builtins.int]:
        """
        Weight.
        """
        return pulumi.get(self, "w")

    @_builtins.property
    @pulumi.getter
    def x(self) -> Optional[_builtins.int]:
        """
        X-axis top-left corner coordinate.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter
    def y(self) -> Optional[_builtins.int]:
        """
        Y-axis top-left corner coordinate.
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class MonitoringDashboardWidgetText(dict):
    def __init__(__self__, *,
                 text: Optional[_builtins.str] = None):
        """
        :param _builtins.str text: Widget text.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        Widget text.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class MonitoringDashboardWidgetTitle(dict):
    def __init__(__self__, *,
                 text: _builtins.str,
                 size: Optional[_builtins.str] = None):
        """
        :param _builtins.str text: Title text.
        :param _builtins.str size: Title size.
               Title size. Values:
               - TITLE_SIZE_XS: Extra small size.
               - TITLE_SIZE_S: Small size.
               - TITLE_SIZE_M: Middle size.
               - TITLE_SIZE_L: Large size.
        """
        pulumi.set(__self__, "text", text)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Title text.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        Title size.
        Title size. Values:
        - TITLE_SIZE_XS: Extra small size.
        - TITLE_SIZE_S: Small size.
        - TITLE_SIZE_M: Middle size.
        - TITLE_SIZE_L: Large size.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class OrganizationmanagerOsLoginSettingsSshCertificateSettings(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables or disables usage of SSH certificates signed by trusted Certification Authority (CA).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables usage of SSH certificates signed by trusted Certification Authority (CA).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationmanagerOsLoginSettingsUserSshKeySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowManageOwnKeys":
            suggest = "allow_manage_own_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationmanagerOsLoginSettingsUserSshKeySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationmanagerOsLoginSettingsUserSshKeySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationmanagerOsLoginSettingsUserSshKeySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_manage_own_keys: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_manage_own_keys: If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        :param _builtins.bool enabled: Enables or disables usage of ssh keys assigned to a specific subject.
        """
        if allow_manage_own_keys is not None:
            pulumi.set(__self__, "allow_manage_own_keys", allow_manage_own_keys)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowManageOwnKeys")
    def allow_manage_own_keys(self) -> Optional[_builtins.bool]:
        """
        If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        """
        return pulumi.get(self, "allow_manage_own_keys")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables usage of ssh keys assigned to a specific subject.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationmanagerSamlFederationSecuritySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedAssertions":
            suggest = "encrypted_assertions"
        elif key == "forceAuthn":
            suggest = "force_authn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationmanagerSamlFederationSecuritySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationmanagerSamlFederationSecuritySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationmanagerSamlFederationSecuritySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_assertions: Optional[_builtins.bool] = None,
                 force_authn: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool encrypted_assertions: Enable encrypted assertions.
        :param _builtins.bool force_authn: Force authentication on session expiration
        """
        if encrypted_assertions is not None:
            pulumi.set(__self__, "encrypted_assertions", encrypted_assertions)
        if force_authn is not None:
            pulumi.set(__self__, "force_authn", force_authn)

    @_builtins.property
    @pulumi.getter(name="encryptedAssertions")
    def encrypted_assertions(self) -> Optional[_builtins.bool]:
        """
        Enable encrypted assertions.
        """
        return pulumi.get(self, "encrypted_assertions")

    @_builtins.property
    @pulumi.getter(name="forceAuthn")
    def force_authn(self) -> Optional[_builtins.bool]:
        """
        Force authentication on session expiration
        """
        return pulumi.get(self, "force_authn")


@pulumi.output_type
class ServerlessContainerAsyncInvocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerAsyncInvocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerAsyncInvocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerAsyncInvocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_id: Service account used for async invocation.
        """
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account used for async invocation.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class ServerlessContainerConnectivity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerConnectivity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerConnectivity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerConnectivity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: _builtins.str):
        """
        :param _builtins.str network_id: Network the revision will have access to.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network the revision will have access to.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class ServerlessContainerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workDir":
            suggest = "work_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 args: Optional[Sequence[_builtins.str]] = None,
                 commands: Optional[Sequence[_builtins.str]] = None,
                 digest: Optional[_builtins.str] = None,
                 environment: Optional[Mapping[str, _builtins.str]] = None,
                 work_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: URL of image that will be deployed as Yandex Cloud Serverless Container.
        :param Sequence[_builtins.str] args: List of arguments for Yandex Cloud Serverless Container.
        :param Sequence[_builtins.str] commands: List of commands for Yandex Cloud Serverless Container.
        :param _builtins.str digest: Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if `image.0.url` stays the same. If field not specified then its value will be computed.
        :param Mapping[str, _builtins.str] environment: A set of key/value environment variable pairs for Yandex Cloud Serverless Container. Each key must begin with a letter (A-Z, a-z).
        :param _builtins.str work_dir: Working directory for Yandex Cloud Serverless Container.
        """
        pulumi.set(__self__, "url", url)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if work_dir is not None:
            pulumi.set(__self__, "work_dir", work_dir)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of image that will be deployed as Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of arguments for Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of commands for Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if `image.0.url` stays the same. If field not specified then its value will be computed.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value environment variable pairs for Yandex Cloud Serverless Container. Each key must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="workDir")
    def work_dir(self) -> Optional[_builtins.str]:
        """
        Working directory for Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "work_dir")


@pulumi.output_type
class ServerlessContainerLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderId":
            suggest = "folder_id"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 folder_id: Optional[_builtins.str] = None,
                 log_group_id: Optional[_builtins.str] = None,
                 min_level: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Is logging from container disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Is logging from container disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[_builtins.str]:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class ServerlessContainerMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsV1HttpEndpoint":
            suggest = "aws_v1_http_endpoint"
        elif key == "gceHttpEndpoint":
            suggest = "gce_http_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_v1_http_endpoint: Optional[_builtins.int] = None,
                 gce_http_endpoint: Optional[_builtins.int] = None):
        """
        :param _builtins.int aws_v1_http_endpoint: Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        :param _builtins.int gce_http_endpoint: Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        if aws_v1_http_endpoint is not None:
            pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        if gce_http_endpoint is not None:
            pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> Optional[_builtins.int]:
        """
        Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> Optional[_builtins.int]:
        """
        Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "gce_http_endpoint")


@pulumi.output_type
class ServerlessContainerMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPointPath":
            suggest = "mount_point_path"
        elif key == "ephemeralDisk":
            suggest = "ephemeral_disk"
        elif key == "objectStorage":
            suggest = "object_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_point_path: _builtins.str,
                 ephemeral_disk: Optional['outputs.ServerlessContainerMountEphemeralDisk'] = None,
                 mode: Optional[_builtins.str] = None,
                 object_storage: Optional['outputs.ServerlessContainerMountObjectStorage'] = None):
        """
        :param _builtins.str mount_point_path: Path inside the container to access the directory in which the target is mounted.
        :param 'ServerlessContainerMountEphemeralDiskArgs' ephemeral_disk: One of the available mount types. Disk available during the function execution time.
        :param _builtins.str mode: Mounts accessibility mode. Valid values are `ro` and `rw`.
        :param 'ServerlessContainerMountObjectStorageArgs' object_storage: Available mount types. Object storage as a mount.
        """
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @_builtins.property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> _builtins.str:
        """
        Path inside the container to access the directory in which the target is mounted.
        """
        return pulumi.get(self, "mount_point_path")

    @_builtins.property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional['outputs.ServerlessContainerMountEphemeralDisk']:
        """
        One of the available mount types. Disk available during the function execution time.
        """
        return pulumi.get(self, "ephemeral_disk")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional['outputs.ServerlessContainerMountObjectStorage']:
        """
        Available mount types. Object storage as a mount.
        """
        return pulumi.get(self, "object_storage")


@pulumi.output_type
class ServerlessContainerMountEphemeralDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"
        elif key == "blockSizeKb":
            suggest = "block_size_kb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerMountEphemeralDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerMountEphemeralDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerMountEphemeralDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: _builtins.int,
                 block_size_kb: Optional[_builtins.int] = None):
        """
        :param _builtins.int size_gb: Size of the ephemeral disk in GB.
        :param _builtins.int block_size_kb: Block size of the ephemeral disk in KB.
        """
        pulumi.set(__self__, "size_gb", size_gb)
        if block_size_kb is not None:
            pulumi.set(__self__, "block_size_kb", block_size_kb)

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        """
        Size of the ephemeral disk in GB.
        """
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> Optional[_builtins.int]:
        """
        Block size of the ephemeral disk in KB.
        """
        return pulumi.get(self, "block_size_kb")


@pulumi.output_type
class ServerlessContainerMountObjectStorage(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ServerlessContainerProvisionPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minInstances":
            suggest = "min_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerProvisionPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerProvisionPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerProvisionPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_instances: _builtins.int):
        """
        :param _builtins.int min_instances: Minimum number of prepared instances that are always ready to serve requests.
        """
        pulumi.set(__self__, "min_instances", min_instances)

    @_builtins.property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> _builtins.int:
        """
        Minimum number of prepared instances that are always ready to serve requests.
        """
        return pulumi.get(self, "min_instances")


@pulumi.output_type
class ServerlessContainerRuntime(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerlessContainerSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariable":
            suggest = "environment_variable"
        elif key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_variable: _builtins.str,
                 id: _builtins.str,
                 key: _builtins.str,
                 version_id: _builtins.str):
        """
        :param _builtins.str environment_variable: Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        :param _builtins.str id: Secret's ID.
        :param _builtins.str key: Secret's entries key which value will be stored in environment variable.
        :param _builtins.str version_id: Secret's version ID.
        """
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> _builtins.str:
        """
        Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment_variable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Secret's ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Secret's entries key which value will be stored in environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Secret's version ID.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class ServerlessContainerStorageMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPointPath":
            suggest = "mount_point_path"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessContainerStorageMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessContainerStorageMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessContainerStorageMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 mount_point_path: _builtins.str,
                 prefix: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str mount_point_path: Path inside the container to access the directory in which the bucket is mounted.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        :param _builtins.bool read_only: Mount the bucket in read-only mode.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> _builtins.str:
        """
        Path inside the container to access the directory in which the bucket is mounted.
        """
        return pulumi.get(self, "mount_point_path")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Mount the bucket in read-only mode.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class ServerlessEventrouterConnectorTimer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterConnectorTimer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterConnectorTimer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterConnectorTimer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 payload: Optional[_builtins.str] = None,
                 timezone: Optional[_builtins.str] = None):
        """
        :param _builtins.str cron_expression: Cron expression. Cron expression with seconds. Example: 0 45 16 ? * *
        :param _builtins.str payload: Payload to be passed to bus
        :param _builtins.str timezone: Timezone in tz database format. Example: Europe/Moscow
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        Cron expression. Cron expression with seconds. Example: 0 45 16 ? * *
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        Payload to be passed to bus
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Timezone in tz database format. Example: Europe/Moscow
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class ServerlessEventrouterConnectorYd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterConnectorYd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterConnectorYd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterConnectorYd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer: _builtins.str,
                 database: _builtins.str,
                 service_account_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str consumer: Consumer name
        :param _builtins.str database: Stream database
        :param _builtins.str service_account_id: Service account which has read permission on the stream
        :param _builtins.str stream_name: Stream name, absolute or relative
        """
        pulumi.set(__self__, "consumer", consumer)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def consumer(self) -> _builtins.str:
        """
        Consumer name
        """
        return pulumi.get(self, "consumer")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Stream database
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has read permission on the stream
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Stream name, absolute or relative
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ServerlessEventrouterConnectorYmq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueArn":
            suggest = "queue_arn"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "pollingTimeout":
            suggest = "polling_timeout"
        elif key == "visibilityTimeout":
            suggest = "visibility_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterConnectorYmq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterConnectorYmq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterConnectorYmq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_arn: _builtins.str,
                 service_account_id: _builtins.str,
                 batch_size: Optional[_builtins.int] = None,
                 polling_timeout: Optional[_builtins.str] = None,
                 visibility_timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.str queue_arn: Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        :param _builtins.str service_account_id: Service account which has read access to the queue
        :param _builtins.int batch_size: Batch size for polling
        :param _builtins.str polling_timeout: Queue polling timeout
        :param _builtins.str visibility_timeout: Queue visibility timeout override
        """
        pulumi.set(__self__, "queue_arn", queue_arn)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if polling_timeout is not None:
            pulumi.set(__self__, "polling_timeout", polling_timeout)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> _builtins.str:
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        return pulumi.get(self, "queue_arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has read access to the queue
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.int]:
        """
        Batch size for polling
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="pollingTimeout")
    def polling_timeout(self) -> Optional[_builtins.str]:
        """
        Queue polling timeout
        """
        return pulumi.get(self, "polling_timeout")

    @_builtins.property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[_builtins.str]:
        """
        Queue visibility timeout override
        """
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class ServerlessEventrouterRuleContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerId":
            suggest = "container_id"
        elif key == "batchSettings":
            suggest = "batch_settings"
        elif key == "containerRevisionId":
            suggest = "container_revision_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_id: _builtins.str,
                 batch_settings: Optional['outputs.ServerlessEventrouterRuleContainerBatchSettings'] = None,
                 container_revision_id: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str container_id: Container ID
        :param 'ServerlessEventrouterRuleContainerBatchSettingsArgs' batch_settings: Batch settings
        :param _builtins.str container_revision_id: Container revision ID
        :param _builtins.str path: Endpoint HTTP path to invoke
        :param _builtins.str service_account_id: Service account which should be used to call a container
        """
        pulumi.set(__self__, "container_id", container_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)
        if container_revision_id is not None:
            pulumi.set(__self__, "container_revision_id", container_revision_id)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> _builtins.str:
        """
        Container ID
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional['outputs.ServerlessEventrouterRuleContainerBatchSettings']:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @_builtins.property
    @pulumi.getter(name="containerRevisionId")
    def container_revision_id(self) -> Optional[_builtins.str]:
        """
        Container revision ID
        """
        return pulumi.get(self, "container_revision_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Endpoint HTTP path to invoke
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account which should be used to call a container
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class ServerlessEventrouterRuleContainerBatchSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxCount":
            suggest = "max_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleContainerBatchSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleContainerBatchSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleContainerBatchSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cutoff: _builtins.str,
                 max_bytes: Optional[_builtins.int] = None,
                 max_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param _builtins.int max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param _builtins.int max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @_builtins.property
    @pulumi.getter
    def cutoff(self) -> _builtins.str:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")


@pulumi.output_type
class ServerlessEventrouterRuleFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionId":
            suggest = "function_id"
        elif key == "batchSettings":
            suggest = "batch_settings"
        elif key == "functionTag":
            suggest = "function_tag"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_id: _builtins.str,
                 batch_settings: Optional['outputs.ServerlessEventrouterRuleFunctionBatchSettings'] = None,
                 function_tag: Optional[_builtins.str] = None,
                 service_account_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str function_id: Function ID
        :param 'ServerlessEventrouterRuleFunctionBatchSettingsArgs' batch_settings: Batch settings
        :param _builtins.str function_tag: Function tag
        :param _builtins.str service_account_id: Service account which has call permission on the function
        """
        pulumi.set(__self__, "function_id", function_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)
        if function_tag is not None:
            pulumi.set(__self__, "function_tag", function_tag)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> _builtins.str:
        """
        Function ID
        """
        return pulumi.get(self, "function_id")

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional['outputs.ServerlessEventrouterRuleFunctionBatchSettings']:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @_builtins.property
    @pulumi.getter(name="functionTag")
    def function_tag(self) -> Optional[_builtins.str]:
        """
        Function tag
        """
        return pulumi.get(self, "function_tag")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[_builtins.str]:
        """
        Service account which has call permission on the function
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class ServerlessEventrouterRuleFunctionBatchSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxCount":
            suggest = "max_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleFunctionBatchSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleFunctionBatchSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleFunctionBatchSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cutoff: _builtins.str,
                 max_bytes: Optional[_builtins.int] = None,
                 max_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param _builtins.int max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param _builtins.int max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @_builtins.property
    @pulumi.getter
    def cutoff(self) -> _builtins.str:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")


@pulumi.output_type
class ServerlessEventrouterRuleGatewayWebsocketBroadcast(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayId":
            suggest = "gateway_id"
        elif key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "batchSettings":
            suggest = "batch_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleGatewayWebsocketBroadcast. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleGatewayWebsocketBroadcast.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleGatewayWebsocketBroadcast.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_id: _builtins.str,
                 path: _builtins.str,
                 service_account_id: _builtins.str,
                 batch_settings: Optional['outputs.ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings'] = None):
        """
        :param _builtins.str gateway_id: Gateway ID
        :param _builtins.str path: Path
        :param _builtins.str service_account_id: Service account which has permission for writing to websockets
        :param 'ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettingsArgs' batch_settings: Batch settings
        """
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        Gateway ID
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has permission for writing to websockets
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional['outputs.ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings']:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")


@pulumi.output_type
class ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxCount":
            suggest = "max_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleGatewayWebsocketBroadcastBatchSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cutoff: _builtins.str,
                 max_bytes: Optional[_builtins.int] = None,
                 max_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param _builtins.int max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param _builtins.int max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @_builtins.property
    @pulumi.getter
    def cutoff(self) -> _builtins.str:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")


@pulumi.output_type
class ServerlessEventrouterRuleLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "folderId":
            suggest = "folder_id"
        elif key == "logGroupId":
            suggest = "log_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_id: _builtins.str,
                 folder_id: Optional[_builtins.str] = None,
                 log_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_id: Service account which has permission for writing logs
        :param _builtins.str folder_id: Folder ID
        :param _builtins.str log_group_id: Log group ID
        """
        pulumi.set(__self__, "service_account_id", service_account_id)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has permission for writing logs
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[_builtins.str]:
        """
        Folder ID
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Log group ID
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class ServerlessEventrouterRuleWorkflow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "workflowId":
            suggest = "workflow_id"
        elif key == "batchSettings":
            suggest = "batch_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleWorkflow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleWorkflow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleWorkflow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_id: _builtins.str,
                 workflow_id: _builtins.str,
                 batch_settings: Optional['outputs.ServerlessEventrouterRuleWorkflowBatchSettings'] = None):
        """
        :param _builtins.str service_account_id: Service account which should be used to start workflow
        :param _builtins.str workflow_id: Workflow ID
        :param 'ServerlessEventrouterRuleWorkflowBatchSettingsArgs' batch_settings: Batch settings
        """
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "workflow_id", workflow_id)
        if batch_settings is not None:
            pulumi.set(__self__, "batch_settings", batch_settings)

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which should be used to start workflow
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Optional['outputs.ServerlessEventrouterRuleWorkflowBatchSettings']:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")


@pulumi.output_type
class ServerlessEventrouterRuleWorkflowBatchSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxCount":
            suggest = "max_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleWorkflowBatchSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleWorkflowBatchSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleWorkflowBatchSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cutoff: _builtins.str,
                 max_bytes: Optional[_builtins.int] = None,
                 max_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param _builtins.int max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param _builtins.int max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @_builtins.property
    @pulumi.getter
    def cutoff(self) -> _builtins.str:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")


@pulumi.output_type
class ServerlessEventrouterRuleYd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountId":
            suggest = "service_account_id"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleYd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleYd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleYd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 service_account_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str database: Stream database
        :param _builtins.str service_account_id: Service account, which has write permission on the stream
        :param _builtins.str stream_name: Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Stream database
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account, which has write permission on the stream
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ServerlessEventrouterRuleYmq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueArn":
            suggest = "queue_arn"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessEventrouterRuleYmq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessEventrouterRuleYmq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessEventrouterRuleYmq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_arn: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str queue_arn: Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        :param _builtins.str service_account_id: Service account which has write access to the queue
        """
        pulumi.set(__self__, "queue_arn", queue_arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> _builtins.str:
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        return pulumi.get(self, "queue_arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has write access to the queue
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class SmartcaptchaCaptchaOverrideVariant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "challengeType":
            suggest = "challenge_type"
        elif key == "preCheckType":
            suggest = "pre_check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaOverrideVariant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaOverrideVariant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaOverrideVariant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 challenge_type: Optional[_builtins.str] = None,
                 complexity: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 pre_check_type: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str challenge_type: Additional task type of the captcha.
        :param _builtins.str complexity: Complexity of the captcha.
        :param _builtins.str description: Optional description of the rule. 0-512 characters long.
        :param _builtins.str pre_check_type: Basic check type of the captcha.
        :param _builtins.str uuid: Unique identifier of the variant.
        """
        if challenge_type is not None:
            pulumi.set(__self__, "challenge_type", challenge_type)
        if complexity is not None:
            pulumi.set(__self__, "complexity", complexity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if pre_check_type is not None:
            pulumi.set(__self__, "pre_check_type", pre_check_type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="challengeType")
    def challenge_type(self) -> Optional[_builtins.str]:
        """
        Additional task type of the captcha.
        """
        return pulumi.get(self, "challenge_type")

    @_builtins.property
    @pulumi.getter
    def complexity(self) -> Optional[_builtins.str]:
        """
        Complexity of the captcha.
        """
        return pulumi.get(self, "complexity")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="preCheckType")
    def pre_check_type(self) -> Optional[_builtins.str]:
        """
        Basic check type of the captcha.
        """
        return pulumi.get(self, "pre_check_type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the variant.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideVariantUuid":
            suggest = "override_variant_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional['outputs.SmartcaptchaCaptchaSecurityRuleCondition'] = None,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 override_variant_uuid: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None):
        """
        :param 'SmartcaptchaCaptchaSecurityRuleConditionArgs' condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        :param _builtins.str description: Description of the rule. 0-512 characters long.
        :param _builtins.str name: Name of the rule. The name is unique within the captcha. 1-50 characters long.
        :param _builtins.str override_variant_uuid: Variant UUID to show in case of match the rule. Keep empty to use defaults.
        :param _builtins.int priority: Priority of the rule. Lower value means higher priority.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_variant_uuid is not None:
            pulumi.set(__self__, "override_variant_uuid", override_variant_uuid)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleCondition']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule. The name is unique within the captcha. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideVariantUuid")
    def override_variant_uuid(self) -> Optional[_builtins.str]:
        """
        Variant UUID to show in case of match the rule. Keep empty to use defaults.
        """
        return pulumi.get(self, "override_variant_uuid")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the rule. Lower value means higher priority.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.SmartcaptchaCaptchaSecurityRuleConditionHeader']] = None,
                 host: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionHost'] = None,
                 source_ip: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIp'] = None,
                 uri: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionUri'] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SmartcaptchaCaptchaSecurityRuleConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionHost']:
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIp']:
        return pulumi.get(self, "source_ip")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionUri']:
        return pulumi.get(self, "uri")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SmartcaptchaCaptchaSecurityRuleConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SmartcaptchaCaptchaSecurityRuleConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionHost(dict):
    def __init__(__self__, *,
                 hosts: Optional[Sequence['outputs.SmartcaptchaCaptchaSecurityRuleConditionHostHost']] = None):
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.SmartcaptchaCaptchaSecurityRuleConditionHostHost']]:
        return pulumi.get(self, "hosts")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionHostHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionHostHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionHostHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionHostHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch'] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch']:
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch']:
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch']:
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch']:
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionUriPath'] = None,
                 queries: Optional[Sequence['outputs.SmartcaptchaCaptchaSecurityRuleConditionUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SmartcaptchaCaptchaSecurityRuleConditionUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SmartcaptchaCaptchaSecurityRuleConditionUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class StorageBucketAnonymousAccessFlags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configRead":
            suggest = "config_read"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketAnonymousAccessFlags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketAnonymousAccessFlags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketAnonymousAccessFlags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_read: Optional[_builtins.bool] = None,
                 list: Optional[_builtins.bool] = None,
                 read: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool config_read: Allows to read bucket configuration anonymously.
        :param _builtins.bool list: Allows to list object in bucket anonymously.
        :param _builtins.bool read: Allows to read objects in bucket anonymously.
        """
        if config_read is not None:
            pulumi.set(__self__, "config_read", config_read)
        if list is not None:
            pulumi.set(__self__, "list", list)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @_builtins.property
    @pulumi.getter(name="configRead")
    def config_read(self) -> Optional[_builtins.bool]:
        """
        Allows to read bucket configuration anonymously.
        """
        return pulumi.get(self, "config_read")

    @_builtins.property
    @pulumi.getter
    def list(self) -> Optional[_builtins.bool]:
        """
        Allows to list object in bucket anonymously.
        """
        return pulumi.get(self, "list")

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.bool]:
        """
        Allows to read objects in bucket anonymously.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class StorageBucketCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[_builtins.str],
                 allowed_origins: Sequence[_builtins.str],
                 allowed_headers: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] allowed_methods: Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param Sequence[_builtins.str] allowed_origins: Specifies which origins are allowed.
        :param Sequence[_builtins.str] allowed_headers: Specifies which headers are allowed.
        :param Sequence[_builtins.str] expose_headers: Specifies expose header in the response.
        :param _builtins.int max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[_builtins.str]:
        """
        Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[_builtins.str]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies expose header in the response.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class StorageBucketGrant(dict):
    def __init__(__self__, *,
                 permissions: Sequence[_builtins.str],
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] permissions: List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `FULL_CONTROL`.
        :param _builtins.str type: Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`.
        :param _builtins.str id: Canonical user id to grant for. Used only when type is `CanonicalUser`.
        :param _builtins.str uri: URI address to grant for. Used only when type is Group.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        """
        List of permissions to apply for grantee. Valid values are `READ`, `WRITE`, `FULL_CONTROL`.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of grantee to apply for. Valid values are `CanonicalUser` and `Group`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Canonical user id to grant for. Used only when type is `CanonicalUser`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        URI address to grant for. Used only when type is Group.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class StorageBucketHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_id: _builtins.str):
        """
        :param _builtins.str certificate_id: Id of the certificate in Certificate Manager, that will be used for bucket.
        """
        pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        Id of the certificate in Certificate Manager, that will be used for bucket.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class StorageBucketLifecycleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUploadDays":
            suggest = "abort_incomplete_multipart_upload_days"
        elif key == "noncurrentVersionExpiration":
            suggest = "noncurrent_version_expiration"
        elif key == "noncurrentVersionTransitions":
            suggest = "noncurrent_version_transitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 abort_incomplete_multipart_upload_days: Optional[_builtins.int] = None,
                 expiration: Optional['outputs.StorageBucketLifecycleRuleExpiration'] = None,
                 filter: Optional['outputs.StorageBucketLifecycleRuleFilter'] = None,
                 id: Optional[_builtins.str] = None,
                 noncurrent_version_expiration: Optional['outputs.StorageBucketLifecycleRuleNoncurrentVersionExpiration'] = None,
                 noncurrent_version_transitions: Optional[Sequence['outputs.StorageBucketLifecycleRuleNoncurrentVersionTransition']] = None,
                 prefix: Optional[_builtins.str] = None,
                 transitions: Optional[Sequence['outputs.StorageBucketLifecycleRuleTransition']] = None):
        """
        :param _builtins.bool enabled: Specifies lifecycle rule status.
        :param _builtins.int abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        :param 'StorageBucketLifecycleRuleExpirationArgs' expiration: Specifies a period in the object's expire.
        :param 'StorageBucketLifecycleRuleFilterArgs' filter: Filter block identifies one or more objects to which the rule applies. A Filter must have exactly one of Prefix, Tag, or And specified. The filter supports options listed below.
        :param _builtins.str id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param 'StorageBucketLifecycleRuleNoncurrentVersionExpirationArgs' noncurrent_version_expiration: Specifies when noncurrent object versions expire.
        :param Sequence['StorageBucketLifecycleRuleNoncurrentVersionTransitionArgs'] noncurrent_version_transitions: Specifies when noncurrent object versions transitions.
        :param _builtins.str prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param Sequence['StorageBucketLifecycleRuleTransitionArgs'] transitions: Specifies a period in the object's transitions.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.StorageBucketLifecycleRuleExpiration']:
        """
        Specifies a period in the object's expire.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional['outputs.StorageBucketLifecycleRuleFilter']:
        """
        Filter block identifies one or more objects to which the rule applies. A Filter must have exactly one of Prefix, Tag, or And specified. The filter supports options listed below.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional['outputs.StorageBucketLifecycleRuleNoncurrentVersionExpiration']:
        """
        Specifies when noncurrent object versions expire.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[Sequence['outputs.StorageBucketLifecycleRuleNoncurrentVersionTransition']]:
        """
        Specifies when noncurrent object versions transitions.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Use filter instead""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def transitions(self) -> Optional[Sequence['outputs.StorageBucketLifecycleRuleTransition']]:
        """
        Specifies a period in the object's transitions.
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class StorageBucketLifecycleRuleExpiration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiredObjectDeleteMarker":
            suggest = "expired_object_delete_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleExpiration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleExpiration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleExpiration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date: Optional[_builtins.str] = None,
                 days: Optional[_builtins.int] = None,
                 expired_object_delete_marker: Optional[_builtins.bool] = None):
        """
        :param _builtins.str date: Specifies the date after which you want the corresponding action to take effect.
        :param _builtins.int days: Specifies the number of days after object creation when the specific rule action takes effect.
        :param _builtins.bool expired_object_delete_marker: n a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[_builtins.str]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[_builtins.bool]:
        """
        n a versioned bucket (versioning-enabled or versioning-suspended bucket), you can add this element in the lifecycle configuration to direct Object Storage to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")


@pulumi.output_type
class StorageBucketLifecycleRuleFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "and":
            suggest = "and_"
        elif key == "objectSizeGreaterThan":
            suggest = "object_size_greater_than"
        elif key == "objectSizeLessThan":
            suggest = "object_size_less_than"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_: Optional['outputs.StorageBucketLifecycleRuleFilterAnd'] = None,
                 object_size_greater_than: Optional[_builtins.int] = None,
                 object_size_less_than: Optional[_builtins.int] = None,
                 prefix: Optional[_builtins.str] = None,
                 tag: Optional['outputs.StorageBucketLifecycleRuleFilterTag'] = None):
        """
        :param 'StorageBucketLifecycleRuleFilterAndArgs' and_: A logical `and` operator applied to one or more filter parameters. It should be used when two or more of the above parameters are used.
        :param _builtins.int object_size_greater_than: Minimum object size to which the rule applies.
        :param _builtins.int object_size_less_than: Maximum object size to which the rule applies.
        :param _builtins.str prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param 'StorageBucketLifecycleRuleFilterTagArgs' tag: A key and value pair for filtering objects. E.g.: `key=key1, value=value1`.
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="and")
    def and_(self) -> Optional['outputs.StorageBucketLifecycleRuleFilterAnd']:
        """
        A logical `and` operator applied to one or more filter parameters. It should be used when two or more of the above parameters are used.
        """
        return pulumi.get(self, "and_")

    @_builtins.property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[_builtins.int]:
        """
        Minimum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than")

    @_builtins.property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[_builtins.int]:
        """
        Maximum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional['outputs.StorageBucketLifecycleRuleFilterTag']:
        """
        A key and value pair for filtering objects. E.g.: `key=key1, value=value1`.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class StorageBucketLifecycleRuleFilterAnd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectSizeGreaterThan":
            suggest = "object_size_greater_than"
        elif key == "objectSizeLessThan":
            suggest = "object_size_less_than"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleFilterAnd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleFilterAnd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleFilterAnd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_size_greater_than: Optional[_builtins.int] = None,
                 object_size_less_than: Optional[_builtins.int] = None,
                 prefix: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int object_size_greater_than: Minimum object size to which the rule applies.
        :param _builtins.int object_size_less_than: Maximum object size to which the rule applies.
        :param _builtins.str prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param Mapping[str, _builtins.str] tags: The `tags` object for setting tags (or labels) for bucket. See [Tags](https://yandex.cloud/docs/storage/concepts/tags) for more information.
        """
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[_builtins.int]:
        """
        Minimum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than")

    @_builtins.property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[_builtins.int]:
        """
        Maximum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The `tags` object for setting tags (or labels) for bucket. See [Tags](https://yandex.cloud/docs/storage/concepts/tags) for more information.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class StorageBucketLifecycleRuleFilterTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: A key.
        :param _builtins.str value: A value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StorageBucketLifecycleRuleNoncurrentVersionExpiration(dict):
    def __init__(__self__, *,
                 days: Optional[_builtins.int] = None):
        """
        :param _builtins.int days: Specifies the number of days noncurrent object versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days noncurrent object versions expire.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class StorageBucketLifecycleRuleNoncurrentVersionTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleNoncurrentVersionTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleNoncurrentVersionTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleNoncurrentVersionTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: _builtins.str,
                 days: Optional[_builtins.int] = None):
        """
        :param _builtins.str storage_class: Specifies the storage class to which you want the noncurrent object versions to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        :param _builtins.int days: Specifies the number of days noncurrent object versions transition.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> _builtins.str:
        """
        Specifies the storage class to which you want the noncurrent object versions to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        """
        return pulumi.get(self, "storage_class")

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days noncurrent object versions transition.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class StorageBucketLifecycleRuleTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLifecycleRuleTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLifecycleRuleTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLifecycleRuleTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: _builtins.str,
                 date: Optional[_builtins.str] = None,
                 days: Optional[_builtins.int] = None):
        """
        :param _builtins.str storage_class: Specifies the storage class to which you want the object to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        :param _builtins.str date: Specifies the date after which you want the corresponding action to take effect.
        :param _builtins.int days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> _builtins.str:
        """
        Specifies the storage class to which you want the object to transition. Supported values: [`STANDARD_IA`, `COLD`, `ICE`].
        """
        return pulumi.get(self, "storage_class")

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[_builtins.str]:
        """
        Specifies the date after which you want the corresponding action to take effect.
        """
        return pulumi.get(self, "date")

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class StorageBucketLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetBucket":
            suggest = "target_bucket"
        elif key == "targetPrefix":
            suggest = "target_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_bucket: _builtins.str,
                 target_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str target_bucket: The name of the bucket that will receive the log objects.
        :param _builtins.str target_prefix: To specify a key prefix for log objects.
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @_builtins.property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> _builtins.str:
        """
        The name of the bucket that will receive the log objects.
        """
        return pulumi.get(self, "target_bucket")

    @_builtins.property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[_builtins.str]:
        """
        To specify a key prefix for log objects.
        """
        return pulumi.get(self, "target_prefix")


@pulumi.output_type
class StorageBucketObjectLockConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectLockEnabled":
            suggest = "object_lock_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketObjectLockConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketObjectLockConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketObjectLockConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_lock_enabled: Optional[_builtins.str] = None,
                 rule: Optional['outputs.StorageBucketObjectLockConfigurationRule'] = None):
        """
        :param _builtins.str object_lock_enabled: Enable object locking in a bucket. Require versioning to be enabled.
        :param 'StorageBucketObjectLockConfigurationRuleArgs' rule: Specifies a default locking configuration for added objects. Require object*lock*enabled to be enabled.
        """
        if object_lock_enabled is not None:
            pulumi.set(__self__, "object_lock_enabled", object_lock_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @_builtins.property
    @pulumi.getter(name="objectLockEnabled")
    def object_lock_enabled(self) -> Optional[_builtins.str]:
        """
        Enable object locking in a bucket. Require versioning to be enabled.
        """
        return pulumi.get(self, "object_lock_enabled")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional['outputs.StorageBucketObjectLockConfigurationRule']:
        """
        Specifies a default locking configuration for added objects. Require object*lock*enabled to be enabled.
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class StorageBucketObjectLockConfigurationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRetention":
            suggest = "default_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketObjectLockConfigurationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketObjectLockConfigurationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketObjectLockConfigurationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_retention: 'outputs.StorageBucketObjectLockConfigurationRuleDefaultRetention'):
        """
        :param 'StorageBucketObjectLockConfigurationRuleDefaultRetentionArgs' default_retention: Default retention object.
        """
        pulumi.set(__self__, "default_retention", default_retention)

    @_builtins.property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> 'outputs.StorageBucketObjectLockConfigurationRuleDefaultRetention':
        """
        Default retention object.
        """
        return pulumi.get(self, "default_retention")


@pulumi.output_type
class StorageBucketObjectLockConfigurationRuleDefaultRetention(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 days: Optional[_builtins.int] = None,
                 years: Optional[_builtins.int] = None):
        """
        :param _builtins.str mode: Specifies a type of object lock. One of `["GOVERNANCE", "COMPLIANCE"]`.
        :param _builtins.int days: Specifies a retention period in days after uploading an object version. It must be a positive integer. You can't set it simultaneously with `years`.
        :param _builtins.int years: Specifies a retention period in years after uploading an object version. It must be a positive integer. You can't set it simultaneously with `days`.
        """
        pulumi.set(__self__, "mode", mode)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Specifies a type of object lock. One of `["GOVERNANCE", "COMPLIANCE"]`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies a retention period in days after uploading an object version. It must be a positive integer. You can't set it simultaneously with `years`.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter
    def years(self) -> Optional[_builtins.int]:
        """
        Specifies a retention period in years after uploading an object version. It must be a positive integer. You can't set it simultaneously with `days`.
        """
        return pulumi.get(self, "years")


@pulumi.output_type
class StorageBucketServerSideEncryptionConfiguration(dict):
    def __init__(__self__, *,
                 rule: 'outputs.StorageBucketServerSideEncryptionConfigurationRule'):
        """
        :param 'StorageBucketServerSideEncryptionConfigurationRuleArgs' rule: A single object for server-side encryption by default configuration.
        """
        pulumi.set(__self__, "rule", rule)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> 'outputs.StorageBucketServerSideEncryptionConfigurationRule':
        """
        A single object for server-side encryption by default configuration.
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class StorageBucketServerSideEncryptionConfigurationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyServerSideEncryptionByDefault":
            suggest = "apply_server_side_encryption_by_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketServerSideEncryptionConfigurationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketServerSideEncryptionConfigurationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketServerSideEncryptionConfigurationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_server_side_encryption_by_default: 'outputs.StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault'):
        """
        :param 'StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultArgs' apply_server_side_encryption_by_default: A single object for setting server-side encryption by default.
        """
        pulumi.set(__self__, "apply_server_side_encryption_by_default", apply_server_side_encryption_by_default)

    @_builtins.property
    @pulumi.getter(name="applyServerSideEncryptionByDefault")
    def apply_server_side_encryption_by_default(self) -> 'outputs.StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault':
        """
        A single object for setting server-side encryption by default.
        """
        return pulumi.get(self, "apply_server_side_encryption_by_default")


@pulumi.output_type
class StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsMasterKeyId":
            suggest = "kms_master_key_id"
        elif key == "sseAlgorithm":
            suggest = "sse_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_master_key_id: _builtins.str,
                 sse_algorithm: _builtins.str):
        """
        :param _builtins.str kms_master_key_id: The KMS master key ID used for the SSE-KMS encryption.
        :param _builtins.str sse_algorithm: The server-side encryption algorithm to use. Single valid value is `aws:kms`.
        """
        pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)

    @_builtins.property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> _builtins.str:
        """
        The KMS master key ID used for the SSE-KMS encryption.
        """
        return pulumi.get(self, "kms_master_key_id")

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> _builtins.str:
        """
        The server-side encryption algorithm to use. Single valid value is `aws:kms`.
        """
        return pulumi.get(self, "sse_algorithm")


@pulumi.output_type
class StorageBucketVersioning(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class StorageBucketWebsite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDocument":
            suggest = "error_document"
        elif key == "indexDocument":
            suggest = "index_document"
        elif key == "redirectAllRequestsTo":
            suggest = "redirect_all_requests_to"
        elif key == "routingRules":
            suggest = "routing_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBucketWebsite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBucketWebsite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBucketWebsite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_document: Optional[_builtins.str] = None,
                 index_document: Optional[_builtins.str] = None,
                 redirect_all_requests_to: Optional[_builtins.str] = None,
                 routing_rules: Optional[_builtins.str] = None):
        """
        :param _builtins.str error_document: An absolute path to the document to return in case of a 4XX error.
        :param _builtins.str index_document: Storage returns this index document when requests are made to the root domain or any of the subfolders (unless using `redirect_all_requests_to`).
        :param _builtins.str redirect_all_requests_to: A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        :param _builtins.str routing_rules: A JSON array containing [routing rules](https://yandex.cloud/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.
        """
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[_builtins.str]:
        """
        An absolute path to the document to return in case of a 4XX error.
        """
        return pulumi.get(self, "error_document")

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[_builtins.str]:
        """
        Storage returns this index document when requests are made to the root domain or any of the subfolders (unless using `redirect_all_requests_to`).
        """
        return pulumi.get(self, "index_document")

    @_builtins.property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[_builtins.str]:
        """
        A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "redirect_all_requests_to")

    @_builtins.property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[_builtins.str]:
        """
        A JSON array containing [routing rules](https://yandex.cloud/docs/storage/s3/api-ref/hosting/upload#request-scheme) describing redirect behavior and when redirects are applied.
        """
        return pulumi.get(self, "routing_rules")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"
        elif key == "dynamicQuota":
            suggest = "dynamic_quota"
        elif key == "staticQuota":
            suggest = "static_quota"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 dry_run: Optional[_builtins.bool] = None,
                 dynamic_quota: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuota'] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 static_quota: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuota'] = None):
        """
        :param _builtins.str description: Description of the rule. 0-512 characters long.
        :param _builtins.bool dry_run: This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        :param 'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs' dynamic_quota: Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
        :param _builtins.str name: Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        :param _builtins.int priority: Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        :param 'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs' static_quota: Static quota. Counting each request individually.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if dynamic_quota is not None:
            pulumi.set(__self__, "dynamic_quota", dynamic_quota)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if static_quota is not None:
            pulumi.set(__self__, "static_quota", static_quota)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[_builtins.bool]:
        """
        This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter(name="dynamicQuota")
    def dynamic_quota(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuota']:
        """
        Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
        """
        return pulumi.get(self, "dynamic_quota")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="staticQuota")
    def static_quota(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuota']:
        """
        Static quota. Counting each request individually.
        """
        return pulumi.get(self, "static_quota")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuota(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 characteristics: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic']] = None,
                 condition: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition'] = None,
                 limit: Optional[_builtins.int] = None,
                 period: Optional[_builtins.int] = None):
        """
        :param _builtins.str action: Action in case of exceeding this quota. Possible values: `DENY`.
        :param Sequence['SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs'] characteristics: List of characteristics.
        :param 'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs' condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.int limit: Desired maximum number of requests per period.
        :param _builtins.int period: Period of time in seconds.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if characteristics is not None:
            pulumi.set(__self__, "characteristics", characteristics)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def characteristics(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic']]:
        """
        List of characteristics.
        """
        return pulumi.get(self, "characteristics")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Desired maximum number of requests per period.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        """
        Period of time in seconds.
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseInsensitive":
            suggest = "case_insensitive"
        elif key == "keyCharacteristic":
            suggest = "key_characteristic"
        elif key == "simpleCharacteristic":
            suggest = "simple_characteristic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_insensitive: Optional[_builtins.bool] = None,
                 key_characteristic: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristic'] = None,
                 simple_characteristic: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristic'] = None):
        """
        :param _builtins.bool case_insensitive: Determines case-sensitive or case-insensitive keys matching.
        :param 'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs' key_characteristic: Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        :param 'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs' simple_characteristic: Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        """
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if key_characteristic is not None:
            pulumi.set(__self__, "key_characteristic", key_characteristic)
        if simple_characteristic is not None:
            pulumi.set(__self__, "simple_characteristic", simple_characteristic)

    @_builtins.property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[_builtins.bool]:
        """
        Determines case-sensitive or case-insensitive keys matching.
        """
        return pulumi.get(self, "case_insensitive")

    @_builtins.property
    @pulumi.getter(name="keyCharacteristic")
    def key_characteristic(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristic']:
        """
        Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        """
        return pulumi.get(self, "key_characteristic")

    @_builtins.property
    @pulumi.getter(name="simpleCharacteristic")
    def simple_characteristic(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristic']:
        """
        Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        """
        return pulumi.get(self, "simple_characteristic")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristic(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        :param _builtins.str value: String value of the key.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristic(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"
        elif key == "requestUri":
            suggest = "request_uri"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthority'] = None,
                 headers: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeader']] = None,
                 http_method: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod'] = None,
                 request_uri: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUri'] = None,
                 source_ip: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp'] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthority']:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUri']:
        return pulumi.get(self, "request_uri")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp']:
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthority(dict):
    def __init__(__self__, *,
                 authorities: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority']] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority']]:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod']] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod']]:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath'] = None,
                 queries: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch'] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatch']:
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatch']:
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch']:
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch']:
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuota(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 condition: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition'] = None,
                 limit: Optional[_builtins.int] = None,
                 period: Optional[_builtins.int] = None):
        """
        :param _builtins.str action: Action in case of exceeding this quota. Possible values: `DENY`.
        :param 'SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs' condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.int limit: Desired maximum number of requests per period.
        :param _builtins.int period: Period of time in seconds.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Desired maximum number of requests per period.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        """
        Period of time in seconds.
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"
        elif key == "requestUri":
            suggest = "request_uri"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthority'] = None,
                 headers: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeader']] = None,
                 http_method: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod'] = None,
                 request_uri: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUri'] = None,
                 source_ip: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp'] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthority']:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUri']:
        return pulumi.get(self, "request_uri")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp']:
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthority(dict):
    def __init__(__self__, *,
                 authorities: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority']] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority']]:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod']] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod']]:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath'] = None,
                 queries: Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch'] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatch']:
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatch']:
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch']:
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch']:
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsSecurityProfileAnalyzeRequestBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeLimit":
            suggest = "size_limit"
        elif key == "sizeLimitAction":
            suggest = "size_limit_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileAnalyzeRequestBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileAnalyzeRequestBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileAnalyzeRequestBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_limit: Optional[_builtins.int] = None,
                 size_limit_action: Optional[_builtins.str] = None):
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)
        if size_limit_action is not None:
            pulumi.set(__self__, "size_limit_action", size_limit_action)

    @_builtins.property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size_limit")

    @_builtins.property
    @pulumi.getter(name="sizeLimitAction")
    def size_limit_action(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "size_limit_action")


@pulumi.output_type
class SwsSecurityProfileSecurityRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRun":
            suggest = "dry_run"
        elif key == "ruleCondition":
            suggest = "rule_condition"
        elif key == "smartProtection":
            suggest = "smart_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 dry_run: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 rule_condition: Optional['outputs.SwsSecurityProfileSecurityRuleRuleCondition'] = None,
                 smart_protection: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtection'] = None,
                 waf: Optional['outputs.SwsSecurityProfileSecurityRuleWaf'] = None):
        """
        :param _builtins.str description: Optional description of the rule. 0-512 characters long.
        :param _builtins.bool dry_run: This mode allows you to test your security profile or a single rule.
        :param _builtins.str name: Name of the rule. The name is unique within the security profile. 1-50 characters long.
        :param _builtins.int priority: Determines the priority for checking the incoming traffic.
        :param 'SwsSecurityProfileSecurityRuleRuleConditionArgs' rule_condition: Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action).
        :param 'SwsSecurityProfileSecurityRuleSmartProtectionArgs' smart_protection: Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules).
        :param 'SwsSecurityProfileSecurityRuleWafArgs' waf: Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules).
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dry_run is not None:
            pulumi.set(__self__, "dry_run", dry_run)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_condition is not None:
            pulumi.set(__self__, "rule_condition", rule_condition)
        if smart_protection is not None:
            pulumi.set(__self__, "smart_protection", smart_protection)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> Optional[_builtins.bool]:
        """
        This mode allows you to test your security profile or a single rule.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule. The name is unique within the security profile. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Determines the priority for checking the incoming traffic.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="ruleCondition")
    def rule_condition(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleCondition']:
        """
        Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action).
        """
        return pulumi.get(self, "rule_condition")

    @_builtins.property
    @pulumi.getter(name="smartProtection")
    def smart_protection(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtection']:
        """
        Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules).
        """
        return pulumi.get(self, "smart_protection")

    @_builtins.property
    @pulumi.getter
    def waf(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWaf']:
        """
        Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules).
        """
        return pulumi.get(self, "waf")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleCondition(dict):
    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 condition: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionCondition'] = None):
        """
        :param _builtins.str action: Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        :param 'SwsSecurityProfileSecurityRuleRuleConditionConditionArgs' condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionCondition']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"
        elif key == "requestUri":
            suggest = "request_uri"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionAuthority'] = None,
                 headers: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHeader']] = None,
                 http_method: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod'] = None,
                 request_uri: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri'] = None,
                 source_ip: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp'] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionAuthority']:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri']:
        return pulumi.get(self, "request_uri")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp']:
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionAuthority(dict):
    def __init__(__self__, *,
                 authorities: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority']] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority']]:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod']] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod']]:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath'] = None,
                 queries: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch'] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch']:
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch']:
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch']:
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch']:
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtection(dict):
    def __init__(__self__, *,
                 condition: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionCondition'] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param 'SwsSecurityProfileSecurityRuleSmartProtectionConditionArgs' condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.str mode: Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionCondition']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"
        elif key == "requestUri":
            suggest = "request_uri"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority'] = None,
                 headers: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHeader']] = None,
                 http_method: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod'] = None,
                 request_uri: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri'] = None,
                 source_ip: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp'] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority']:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri']:
        return pulumi.get(self, "request_uri")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp']:
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority(dict):
    def __init__(__self__, *,
                 authorities: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority']] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority']]:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod']] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod']]:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath'] = None,
                 queries: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch'] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch']:
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch']:
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch']:
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch']:
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWaf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wafProfileId":
            suggest = "waf_profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWaf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWaf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWaf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 waf_profile_id: _builtins.str,
                 condition: Optional['outputs.SwsSecurityProfileSecurityRuleWafCondition'] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str waf_profile_id: ID of WAF profile to use in this rule.
        :param 'SwsSecurityProfileSecurityRuleWafConditionArgs' condition: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.str mode: Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        pulumi.set(__self__, "waf_profile_id", waf_profile_id)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="wafProfileId")
    def waf_profile_id(self) -> _builtins.str:
        """
        ID of WAF profile to use in this rule.
        """
        return pulumi.get(self, "waf_profile_id")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafCondition']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"
        elif key == "requestUri":
            suggest = "request_uri"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionAuthority'] = None,
                 headers: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionHeader']] = None,
                 http_method: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionHttpMethod'] = None,
                 request_uri: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUri'] = None,
                 source_ip: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIp'] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionAuthority']:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUri']:
        return pulumi.get(self, "request_uri")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIp']:
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionAuthority(dict):
    def __init__(__self__, *,
                 authorities: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority']] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority']]:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionAuthorityAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SwsSecurityProfileSecurityRuleWafConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsSecurityProfileSecurityRuleWafConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod']] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod']]:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUriPath'] = None,
                 queries: Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionRequestUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionRequestUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionRequestUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch'] = None):
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatch']:
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatch']:
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch']:
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch']:
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsWafProfileAnalyzeRequestBody(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "sizeLimit":
            suggest = "size_limit"
        elif key == "sizeLimitAction":
            suggest = "size_limit_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileAnalyzeRequestBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileAnalyzeRequestBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileAnalyzeRequestBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[_builtins.bool] = None,
                 size_limit: Optional[_builtins.int] = None,
                 size_limit_action: Optional[_builtins.str] = None):
        """
        :param _builtins.bool is_enabled: Possible to turn analyzer on and turn if off.
        :param _builtins.int size_limit: Maximum size of body to pass to analyzer. In kilobytes.
        :param _builtins.str size_limit_action: Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)
        if size_limit_action is not None:
            pulumi.set(__self__, "size_limit_action", size_limit_action)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Possible to turn analyzer on and turn if off.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[_builtins.int]:
        """
        Maximum size of body to pass to analyzer. In kilobytes.
        """
        return pulumi.get(self, "size_limit")

    @_builtins.property
    @pulumi.getter(name="sizeLimitAction")
    def size_limit_action(self) -> Optional[_builtins.str]:
        """
        Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
        return pulumi.get(self, "size_limit_action")


@pulumi.output_type
class SwsWafProfileCoreRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSet":
            suggest = "rule_set"
        elif key == "inboundAnomalyScore":
            suggest = "inbound_anomaly_score"
        elif key == "paranoiaLevel":
            suggest = "paranoia_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileCoreRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileCoreRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileCoreRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_set: 'outputs.SwsWafProfileCoreRuleSetRuleSet',
                 inbound_anomaly_score: Optional[_builtins.int] = None,
                 paranoia_level: Optional[_builtins.int] = None):
        """
        :param 'SwsWafProfileCoreRuleSetRuleSetArgs' rule_set: Rule set settings. See [Basic rule set](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#rules-set) for details.
        :param _builtins.int inbound_anomaly_score: Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        :param _builtins.int paranoia_level: Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        """
        pulumi.set(__self__, "rule_set", rule_set)
        if inbound_anomaly_score is not None:
            pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        if paranoia_level is not None:
            pulumi.set(__self__, "paranoia_level", paranoia_level)

    @_builtins.property
    @pulumi.getter(name="ruleSet")
    def rule_set(self) -> 'outputs.SwsWafProfileCoreRuleSetRuleSet':
        """
        Rule set settings. See [Basic rule set](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#rules-set) for details.
        """
        return pulumi.get(self, "rule_set")

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> Optional[_builtins.int]:
        """
        Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="paranoiaLevel")
    def paranoia_level(self) -> Optional[_builtins.int]:
        """
        Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        """
        return pulumi.get(self, "paranoia_level")


@pulumi.output_type
class SwsWafProfileCoreRuleSetRuleSet(dict):
    def __init__(__self__, *,
                 version: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: Version of the rule set.
        :param _builtins.str id: The ID of this resource.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        """
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwsWafProfileExclusionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeRules":
            suggest = "exclude_rules"
        elif key == "logExcluded":
            suggest = "log_excluded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_rules: 'outputs.SwsWafProfileExclusionRuleExcludeRules',
                 condition: Optional['outputs.SwsWafProfileExclusionRuleCondition'] = None,
                 description: Optional[_builtins.str] = None,
                 log_excluded: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param 'SwsWafProfileExclusionRuleExcludeRulesArgs' exclude_rules: Exclude rules.
        :param _builtins.str description: Description of the rule. 0-512 characters long.
        :param _builtins.bool log_excluded: Records the fact that an exception rule is triggered.
        :param _builtins.str name: Name of exclusion rule.
        """
        pulumi.set(__self__, "exclude_rules", exclude_rules)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if log_excluded is not None:
            pulumi.set(__self__, "log_excluded", log_excluded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="excludeRules")
    def exclude_rules(self) -> 'outputs.SwsWafProfileExclusionRuleExcludeRules':
        """
        Exclude rules.
        """
        return pulumi.get(self, "exclude_rules")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional['outputs.SwsWafProfileExclusionRuleCondition']:
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="logExcluded")
    def log_excluded(self) -> Optional[_builtins.bool]:
        """
        Records the fact that an exception rule is triggered.
        """
        return pulumi.get(self, "log_excluded")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of exclusion rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsWafProfileExclusionRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethod":
            suggest = "http_method"
        elif key == "requestUri":
            suggest = "request_uri"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional['outputs.SwsWafProfileExclusionRuleConditionAuthority'] = None,
                 headers: Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionHeader']] = None,
                 http_method: Optional['outputs.SwsWafProfileExclusionRuleConditionHttpMethod'] = None,
                 request_uri: Optional['outputs.SwsWafProfileExclusionRuleConditionRequestUri'] = None,
                 source_ip: Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIp'] = None):
        """
        :param 'SwsWafProfileExclusionRuleConditionSourceIpArgs' source_ip: Source IP.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionAuthority']:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionHeader']]:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionHttpMethod']:
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionRequestUri']:
        return pulumi.get(self, "request_uri")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIp']:
        """
        Source IP.
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionAuthority(dict):
    def __init__(__self__, *,
                 authorities: Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionAuthorityAuthority']] = None):
        if authorities is not None:
            pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionAuthorityAuthority']]:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionAuthorityAuthority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionAuthorityAuthority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionAuthorityAuthority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionAuthorityAuthority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionHeader(dict):
    def __init__(__self__, *,
                 value: 'outputs.SwsWafProfileExclusionRuleConditionHeaderValue',
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsWafProfileExclusionRuleConditionHeaderValue':
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionHeaderValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionHeaderValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionHeaderValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionHeaderValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpMethods":
            suggest = "http_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_methods: Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod']] = None):
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod']]:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionHttpMethodHttpMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionRequestUri(dict):
    def __init__(__self__, *,
                 path: Optional['outputs.SwsWafProfileExclusionRuleConditionRequestUriPath'] = None,
                 queries: Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionRequestUriQuery']] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionRequestUriPath']:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.SwsWafProfileExclusionRuleConditionRequestUriQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionRequestUriPath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionRequestUriPath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionRequestUriPath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionRequestUriPath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionRequestUriQuery(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.SwsWafProfileExclusionRuleConditionRequestUriQueryValue'):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.SwsWafProfileExclusionRuleConditionRequestUriQueryValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionRequestUriQueryValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "exactNotMatch":
            suggest = "exact_not_match"
        elif key == "pireRegexMatch":
            suggest = "pire_regex_match"
        elif key == "pireRegexNotMatch":
            suggest = "pire_regex_not_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "prefixNotMatch":
            suggest = "prefix_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionRequestUriQueryValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionRequestUriQueryValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionRequestUriQueryValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 exact_not_match: Optional[_builtins.str] = None,
                 pire_regex_match: Optional[_builtins.str] = None,
                 pire_regex_not_match: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 prefix_not_match: Optional[_builtins.str] = None):
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if exact_not_match is not None:
            pulumi.set(__self__, "exact_not_match", exact_not_match)
        if pire_regex_match is not None:
            pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        if pire_regex_not_match is not None:
            pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if prefix_not_match is not None:
            pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionSourceIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoIpMatch":
            suggest = "geo_ip_match"
        elif key == "geoIpNotMatch":
            suggest = "geo_ip_not_match"
        elif key == "ipRangesMatch":
            suggest = "ip_ranges_match"
        elif key == "ipRangesNotMatch":
            suggest = "ip_ranges_not_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionSourceIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionSourceIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionSourceIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_ip_match: Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatch'] = None,
                 geo_ip_not_match: Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatch'] = None,
                 ip_ranges_match: Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch'] = None,
                 ip_ranges_not_match: Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch'] = None):
        """
        :param 'SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs' geo_ip_match: Locations to include.
        :param 'SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs' geo_ip_not_match: Locations to exclude.
        :param 'SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs' ip_ranges_match: IP ranges to include.
        :param 'SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs' ip_ranges_not_match: IP ranges to exclude.
        """
        if geo_ip_match is not None:
            pulumi.set(__self__, "geo_ip_match", geo_ip_match)
        if geo_ip_not_match is not None:
            pulumi.set(__self__, "geo_ip_not_match", geo_ip_not_match)
        if ip_ranges_match is not None:
            pulumi.set(__self__, "ip_ranges_match", ip_ranges_match)
        if ip_ranges_not_match is not None:
            pulumi.set(__self__, "ip_ranges_not_match", ip_ranges_not_match)

    @_builtins.property
    @pulumi.getter(name="geoIpMatch")
    def geo_ip_match(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatch']:
        """
        Locations to include.
        """
        return pulumi.get(self, "geo_ip_match")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatch")
    def geo_ip_not_match(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatch']:
        """
        Locations to exclude.
        """
        return pulumi.get(self, "geo_ip_not_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatch")
    def ip_ranges_match(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch']:
        """
        IP ranges to include.
        """
        return pulumi.get(self, "ip_ranges_match")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatch")
    def ip_ranges_not_match(self) -> Optional['outputs.SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch']:
        """
        IP ranges to exclude.
        """
        return pulumi.get(self, "ip_ranges_not_match")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionSourceIpGeoIpMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] locations: Locations to include.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Locations to include.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatch(dict):
    def __init__(__self__, *,
                 locations: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] locations: Locations to exclude.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Locations to exclude.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionSourceIpIpRangesMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ip_ranges: IP ranges to include.
        """
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        IP ranges to include.
        """
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRanges":
            suggest = "ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_ranges: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] ip_ranges: IP ranges to exclude.
        """
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        IP ranges to exclude.
        """
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class SwsWafProfileExclusionRuleExcludeRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeAll":
            suggest = "exclude_all"
        elif key == "ruleIds":
            suggest = "rule_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileExclusionRuleExcludeRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileExclusionRuleExcludeRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileExclusionRuleExcludeRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_all: Optional[_builtins.bool] = None,
                 rule_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool exclude_all: Set this option true to exclude all rules.
        :param Sequence[_builtins.str] rule_ids: List of rules to exclude.
        """
        if exclude_all is not None:
            pulumi.set(__self__, "exclude_all", exclude_all)
        if rule_ids is not None:
            pulumi.set(__self__, "rule_ids", rule_ids)

    @_builtins.property
    @pulumi.getter(name="excludeAll")
    def exclude_all(self) -> Optional[_builtins.bool]:
        """
        Set this option true to exclude all rules.
        """
        return pulumi.get(self, "exclude_all")

    @_builtins.property
    @pulumi.getter(name="ruleIds")
    def rule_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of rules to exclude.
        """
        return pulumi.get(self, "rule_ids")


@pulumi.output_type
class SwsWafProfileRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"
        elif key == "isBlocking":
            suggest = "is_blocking"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_id: _builtins.str,
                 is_blocking: Optional[_builtins.bool] = None,
                 is_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str rule_id: Rule ID.
        :param _builtins.bool is_blocking: Determines is it rule blocking or not.
        :param _builtins.bool is_enabled: Determines is it rule enabled or not.
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if is_blocking is not None:
            pulumi.set(__self__, "is_blocking", is_blocking)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.str:
        """
        Rule ID.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="isBlocking")
    def is_blocking(self) -> Optional[_builtins.bool]:
        """
        Determines is it rule blocking or not.
        """
        return pulumi.get(self, "is_blocking")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Determines is it rule enabled or not.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class SwsWafProfileRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreRuleSet":
            suggest = "core_rule_set"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "mlRuleSet":
            suggest = "ml_rule_set"
        elif key == "yaRuleSet":
            suggest = "ya_rule_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 core_rule_set: Optional['outputs.SwsWafProfileRuleSetCoreRuleSet'] = None,
                 is_enabled: Optional[_builtins.bool] = None,
                 ml_rule_set: Optional['outputs.SwsWafProfileRuleSetMlRuleSet'] = None,
                 priority: Optional[_builtins.int] = None,
                 ya_rule_set: Optional['outputs.SwsWafProfileRuleSetYaRuleSet'] = None):
        """
        :param _builtins.str action: Action of the rule set.
        :param 'SwsWafProfileRuleSetCoreRuleSetArgs' core_rule_set: Core rule set.
        :param _builtins.bool is_enabled: Determines is it rule set enabled or not.
        :param 'SwsWafProfileRuleSetMlRuleSetArgs' ml_rule_set: List of ML rule sets.
        :param _builtins.int priority: Priority of the rule set.
        :param 'SwsWafProfileRuleSetYaRuleSetArgs' ya_rule_set: Yandex rule set.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if core_rule_set is not None:
            pulumi.set(__self__, "core_rule_set", core_rule_set)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if ml_rule_set is not None:
            pulumi.set(__self__, "ml_rule_set", ml_rule_set)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ya_rule_set is not None:
            pulumi.set(__self__, "ya_rule_set", ya_rule_set)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action of the rule set.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="coreRuleSet")
    def core_rule_set(self) -> Optional['outputs.SwsWafProfileRuleSetCoreRuleSet']:
        """
        Core rule set.
        """
        return pulumi.get(self, "core_rule_set")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Determines is it rule set enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="mlRuleSet")
    def ml_rule_set(self) -> Optional['outputs.SwsWafProfileRuleSetMlRuleSet']:
        """
        List of ML rule sets.
        """
        return pulumi.get(self, "ml_rule_set")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the rule set.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="yaRuleSet")
    def ya_rule_set(self) -> Optional['outputs.SwsWafProfileRuleSetYaRuleSet']:
        """
        Yandex rule set.
        """
        return pulumi.get(self, "ya_rule_set")


@pulumi.output_type
class SwsWafProfileRuleSetCoreRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSet":
            suggest = "rule_set"
        elif key == "inboundAnomalyScore":
            suggest = "inbound_anomaly_score"
        elif key == "paranoiaLevel":
            suggest = "paranoia_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRuleSetCoreRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRuleSetCoreRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRuleSetCoreRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_set: 'outputs.SwsWafProfileRuleSetCoreRuleSetRuleSet',
                 inbound_anomaly_score: Optional[_builtins.int] = None,
                 paranoia_level: Optional[_builtins.int] = None):
        """
        :param 'SwsWafProfileRuleSetCoreRuleSetRuleSetArgs' rule_set: Rule set.
        :param _builtins.int inbound_anomaly_score: Inbound anomaly score of the rule set.
        :param _builtins.int paranoia_level: Paranoia level of the rule set.
        """
        pulumi.set(__self__, "rule_set", rule_set)
        if inbound_anomaly_score is not None:
            pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        if paranoia_level is not None:
            pulumi.set(__self__, "paranoia_level", paranoia_level)

    @_builtins.property
    @pulumi.getter(name="ruleSet")
    def rule_set(self) -> 'outputs.SwsWafProfileRuleSetCoreRuleSetRuleSet':
        """
        Rule set.
        """
        return pulumi.get(self, "rule_set")

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> Optional[_builtins.int]:
        """
        Inbound anomaly score of the rule set.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="paranoiaLevel")
    def paranoia_level(self) -> Optional[_builtins.int]:
        """
        Paranoia level of the rule set.
        """
        return pulumi.get(self, "paranoia_level")


@pulumi.output_type
class SwsWafProfileRuleSetCoreRuleSetRuleSet(dict):
    def __init__(__self__, *,
                 version: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: Version of the rule set.
        :param _builtins.str id: The ID of this resource.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        """
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwsWafProfileRuleSetMlRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSet":
            suggest = "rule_set"
        elif key == "ruleGroups":
            suggest = "rule_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRuleSetMlRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRuleSetMlRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRuleSetMlRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_set: 'outputs.SwsWafProfileRuleSetMlRuleSetRuleSet',
                 rule_groups: Optional[Sequence['outputs.SwsWafProfileRuleSetMlRuleSetRuleGroup']] = None):
        """
        :param 'SwsWafProfileRuleSetMlRuleSetRuleSetArgs' rule_set: Rule set of the ML rule set.
        :param Sequence['SwsWafProfileRuleSetMlRuleSetRuleGroupArgs'] rule_groups: List of rule groups.
        """
        pulumi.set(__self__, "rule_set", rule_set)
        if rule_groups is not None:
            pulumi.set(__self__, "rule_groups", rule_groups)

    @_builtins.property
    @pulumi.getter(name="ruleSet")
    def rule_set(self) -> 'outputs.SwsWafProfileRuleSetMlRuleSetRuleSet':
        """
        Rule set of the ML rule set.
        """
        return pulumi.get(self, "rule_set")

    @_builtins.property
    @pulumi.getter(name="ruleGroups")
    def rule_groups(self) -> Optional[Sequence['outputs.SwsWafProfileRuleSetMlRuleSetRuleGroup']]:
        """
        List of rule groups.
        """
        return pulumi.get(self, "rule_groups")


@pulumi.output_type
class SwsWafProfileRuleSetMlRuleSetRuleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAnomalyScore":
            suggest = "inbound_anomaly_score"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRuleSetMlRuleSetRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRuleSetMlRuleSetRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRuleSetMlRuleSetRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 inbound_anomaly_score: Optional[_builtins.int] = None,
                 is_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: Action of the rule group.
        :param _builtins.str id: ID of the rule group.
        :param _builtins.int inbound_anomaly_score: Inbound anomaly score.
        :param _builtins.bool is_enabled: Is the rule group enabled.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inbound_anomaly_score is not None:
            pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action of the rule group.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the rule group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> Optional[_builtins.int]:
        """
        Inbound anomaly score.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Is the rule group enabled.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class SwsWafProfileRuleSetMlRuleSetRuleSet(dict):
    def __init__(__self__, *,
                 version: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: Version of the rule set.
        :param _builtins.str id: The ID of this resource.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        """
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SwsWafProfileRuleSetYaRuleSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSet":
            suggest = "rule_set"
        elif key == "ruleGroups":
            suggest = "rule_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRuleSetYaRuleSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRuleSetYaRuleSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRuleSetYaRuleSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_set: 'outputs.SwsWafProfileRuleSetYaRuleSetRuleSet',
                 rule_groups: Optional[Sequence['outputs.SwsWafProfileRuleSetYaRuleSetRuleGroup']] = None):
        """
        :param 'SwsWafProfileRuleSetYaRuleSetRuleSetArgs' rule_set: Rule set of the Yandex rule set.
        :param Sequence['SwsWafProfileRuleSetYaRuleSetRuleGroupArgs'] rule_groups: List of rule groups.
        """
        pulumi.set(__self__, "rule_set", rule_set)
        if rule_groups is not None:
            pulumi.set(__self__, "rule_groups", rule_groups)

    @_builtins.property
    @pulumi.getter(name="ruleSet")
    def rule_set(self) -> 'outputs.SwsWafProfileRuleSetYaRuleSetRuleSet':
        """
        Rule set of the Yandex rule set.
        """
        return pulumi.get(self, "rule_set")

    @_builtins.property
    @pulumi.getter(name="ruleGroups")
    def rule_groups(self) -> Optional[Sequence['outputs.SwsWafProfileRuleSetYaRuleSetRuleGroup']]:
        """
        List of rule groups.
        """
        return pulumi.get(self, "rule_groups")


@pulumi.output_type
class SwsWafProfileRuleSetYaRuleSetRuleGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAnomalyScore":
            suggest = "inbound_anomaly_score"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwsWafProfileRuleSetYaRuleSetRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwsWafProfileRuleSetYaRuleSetRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwsWafProfileRuleSetYaRuleSetRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 inbound_anomaly_score: Optional[_builtins.int] = None,
                 is_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str action: Action of the rule group.
        :param _builtins.str id: ID of the rule group.
        :param _builtins.int inbound_anomaly_score: Inbound anomaly score.
        :param _builtins.bool is_enabled: Is the rule group enabled.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inbound_anomaly_score is not None:
            pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Action of the rule group.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the rule group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> Optional[_builtins.int]:
        """
        Inbound anomaly score.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Is the rule group enabled.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class SwsWafProfileRuleSetYaRuleSetRuleSet(dict):
    def __init__(__self__, *,
                 version: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: Version of the rule set.
        :param _builtins.str id: The ID of this resource.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        """
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VpcAddressDnsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneId":
            suggest = "dns_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcAddressDnsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcAddressDnsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcAddressDnsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        :param _builtins.str dns_zone_id: DNS zone id to create record at.
        :param _builtins.str fqdn: FQDN for record to address.
        :param _builtins.bool ptr: If PTR record is needed.
        :param _builtins.int ttl: TTL of DNS record.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        if ptr is not None:
            pulumi.set(__self__, "ptr", ptr)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone id to create record at.
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        FQDN for record to address.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> Optional[_builtins.bool]:
        """
        If PTR record is needed.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        TTL of DNS record.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class VpcAddressExternalIpv4Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ddosProtectionProvider":
            suggest = "ddos_protection_provider"
        elif key == "outgoingSmtpCapability":
            suggest = "outgoing_smtp_capability"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcAddressExternalIpv4Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcAddressExternalIpv4Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcAddressExternalIpv4Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 ddos_protection_provider: Optional[_builtins.str] = None,
                 outgoing_smtp_capability: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Allocated IP address.
        :param _builtins.str ddos_protection_provider: Enable DDOS protection. Possible values are: `qrator`
        :param _builtins.str outgoing_smtp_capability: Wanted outgoing smtp capability.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ddos_protection_provider is not None:
            pulumi.set(__self__, "ddos_protection_provider", ddos_protection_provider)
        if outgoing_smtp_capability is not None:
            pulumi.set(__self__, "outgoing_smtp_capability", outgoing_smtp_capability)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Allocated IP address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="ddosProtectionProvider")
    def ddos_protection_provider(self) -> Optional[_builtins.str]:
        """
        Enable DDOS protection. Possible values are: `qrator`
        """
        return pulumi.get(self, "ddos_protection_provider")

    @_builtins.property
    @pulumi.getter(name="outgoingSmtpCapability")
    def outgoing_smtp_capability(self) -> Optional[_builtins.str]:
        """
        Wanted outgoing smtp capability.
        """
        return pulumi.get(self, "outgoing_smtp_capability")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class VpcDefaultSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcDefaultSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcDefaultSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcDefaultSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 from_port: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 predefined_target: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None,
                 to_port: Optional[_builtins.int] = None,
                 v4_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 v6_cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param _builtins.str description: Description of the rule.
        :param _builtins.int from_port: Minimum port number.
        :param _builtins.str id: The resource identifier.
        :param Mapping[str, _builtins.str] labels: Labels to assign to this rule.
        :param _builtins.int port: Port number (if applied to a single port).
        :param _builtins.str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        :param _builtins.str security_group_id: Target security group ID for this rule.
        :param _builtins.int to_port: Maximum port number.
        :param Sequence[_builtins.str] v4_cidr_blocks: The blocks of IPv4 addresses for this rule.
        :param Sequence[_builtins.str] v6_cidr_blocks: The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[_builtins.str]:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        """
        Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcDefaultSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcDefaultSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcDefaultSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcDefaultSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 from_port: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 predefined_target: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None,
                 to_port: Optional[_builtins.int] = None,
                 v4_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 v6_cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param _builtins.str description: Description of the rule.
        :param _builtins.int from_port: Minimum port number.
        :param _builtins.str id: The resource identifier.
        :param Mapping[str, _builtins.str] labels: Labels to assign to this rule.
        :param _builtins.int port: Port number (if applied to a single port).
        :param _builtins.str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        :param _builtins.str security_group_id: Target security group ID for this rule.
        :param _builtins.int to_port: Maximum port number.
        :param Sequence[_builtins.str] v4_cidr_blocks: The blocks of IPv4 addresses for this rule.
        :param Sequence[_builtins.str] v6_cidr_blocks: The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[_builtins.str]:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        """
        Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcGatewaySharedEgressGateway(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcPrivateEndpointDnsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateDnsRecordsEnabled":
            suggest = "private_dns_records_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPrivateEndpointDnsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPrivateEndpointDnsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPrivateEndpointDnsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_dns_records_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool private_dns_records_enabled: If enabled - additional service DNS will be created.
        """
        if private_dns_records_enabled is not None:
            pulumi.set(__self__, "private_dns_records_enabled", private_dns_records_enabled)

    @_builtins.property
    @pulumi.getter(name="privateDnsRecordsEnabled")
    def private_dns_records_enabled(self) -> Optional[_builtins.bool]:
        """
        If enabled - additional service DNS will be created.
        """
        return pulumi.get(self, "private_dns_records_enabled")


@pulumi.output_type
class VpcPrivateEndpointEndpointAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressId":
            suggest = "address_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPrivateEndpointEndpointAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPrivateEndpointEndpointAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPrivateEndpointEndpointAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 address_id: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Specifies IP address within `subnet_id`.
        :param _builtins.str address_id: ID of the address.
        :param _builtins.str subnet_id: Subnet of the IP address.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address_id is not None:
            pulumi.set(__self__, "address_id", address_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Specifies IP address within `subnet_id`.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressId")
    def address_id(self) -> Optional[_builtins.str]:
        """
        ID of the address.
        """
        return pulumi.get(self, "address_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Subnet of the IP address.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcPrivateEndpointObjectStorage(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcRouteTableStaticRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPrefix":
            suggest = "destination_prefix"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "nextHopAddress":
            suggest = "next_hop_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcRouteTableStaticRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcRouteTableStaticRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcRouteTableStaticRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_prefix: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 next_hop_address: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_prefix: Route prefix in CIDR notation.
        :param _builtins.str gateway_id: ID of the gateway used ad next hop.
        :param _builtins.str next_hop_address: Address of the next hop.
        """
        if destination_prefix is not None:
            pulumi.set(__self__, "destination_prefix", destination_prefix)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if next_hop_address is not None:
            pulumi.set(__self__, "next_hop_address", next_hop_address)

    @_builtins.property
    @pulumi.getter(name="destinationPrefix")
    def destination_prefix(self) -> Optional[_builtins.str]:
        """
        Route prefix in CIDR notation.
        """
        return pulumi.get(self, "destination_prefix")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        """
        ID of the gateway used ad next hop.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="nextHopAddress")
    def next_hop_address(self) -> Optional[_builtins.str]:
        """
        Address of the next hop.
        """
        return pulumi.get(self, "next_hop_address")


@pulumi.output_type
class VpcSecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 from_port: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 predefined_target: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None,
                 to_port: Optional[_builtins.int] = None,
                 v4_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 v6_cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param _builtins.str description: Description of the rule.
        :param _builtins.int from_port: Minimum port number.
        :param _builtins.str id: The resource identifier.
        :param Mapping[str, _builtins.str] labels: Labels to assign to this rule.
        :param _builtins.int port: Port number (if applied to a single port).
        :param _builtins.str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        :param _builtins.str security_group_id: Target security group ID for this rule.
        :param _builtins.int to_port: Maximum port number.
        :param Sequence[_builtins.str] v4_cidr_blocks: The blocks of IPv4 addresses for this rule.
        :param Sequence[_builtins.str] v6_cidr_blocks: The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[_builtins.str]:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        """
        Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcSecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "predefinedTarget":
            suggest = "predefined_target"
        elif key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "v4CidrBlocks":
            suggest = "v4_cidr_blocks"
        elif key == "v6CidrBlocks":
            suggest = "v6_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 from_port: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 port: Optional[_builtins.int] = None,
                 predefined_target: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None,
                 to_port: Optional[_builtins.int] = None,
                 v4_cidr_blocks: Optional[Sequence[_builtins.str]] = None,
                 v6_cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param _builtins.str description: Description of the rule.
        :param _builtins.int from_port: Minimum port number.
        :param _builtins.str id: The resource identifier.
        :param Mapping[str, _builtins.str] labels: Labels to assign to this rule.
        :param _builtins.int port: Port number (if applied to a single port).
        :param _builtins.str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        :param _builtins.str security_group_id: Target security group ID for this rule.
        :param _builtins.int to_port: Maximum port number.
        :param Sequence[_builtins.str] v4_cidr_blocks: The blocks of IPv4 addresses for this rule.
        :param Sequence[_builtins.str] v6_cidr_blocks: The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if predefined_target is not None:
            pulumi.set(__self__, "predefined_target", predefined_target)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if v4_cidr_blocks is not None:
            pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        if v6_cidr_blocks is not None:
            pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> Optional[_builtins.str]:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        """
        Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class VpcSubnetDhcpOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "domainNameServers":
            suggest = "domain_name_servers"
        elif key == "ntpServers":
            suggest = "ntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSubnetDhcpOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSubnetDhcpOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSubnetDhcpOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: Optional[_builtins.str] = None,
                 domain_name_servers: Optional[Sequence[_builtins.str]] = None,
                 ntp_servers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str domain_name: Domain name.
        :param Sequence[_builtins.str] domain_name_servers: Domain name server IP addresses.
        :param Sequence[_builtins.str] ntp_servers: NTP server IP addresses.
        """
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        Domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Domain name server IP addresses.
        """
        return pulumi.get(self, "domain_name_servers")

    @_builtins.property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        NTP server IP addresses.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class YdbDatabaseDedicatedLocation(dict):
    def __init__(__self__, *,
                 region: Optional['outputs.YdbDatabaseDedicatedLocationRegion'] = None):
        """
        :param 'YdbDatabaseDedicatedLocationRegionArgs' region: Region for the Yandex Database cluster.
        """
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional['outputs.YdbDatabaseDedicatedLocationRegion']:
        """
        Region for the Yandex Database cluster.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class YdbDatabaseDedicatedLocationRegion(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: Region ID for the Yandex Database cluster.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Region ID for the Yandex Database cluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class YdbDatabaseDedicatedScalePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScale":
            suggest = "auto_scale"
        elif key == "fixedScale":
            suggest = "fixed_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseDedicatedScalePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseDedicatedScalePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseDedicatedScalePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scale: Optional['outputs.YdbDatabaseDedicatedScalePolicyAutoScale'] = None,
                 fixed_scale: Optional['outputs.YdbDatabaseDedicatedScalePolicyFixedScale'] = None):
        """
        :param 'YdbDatabaseDedicatedScalePolicyAutoScaleArgs' auto_scale: Auto scaling policy for the Yandex Database cluster. This is a preview feature, and you need to enable it using the label `enable_autoscaling=1`.
        :param 'YdbDatabaseDedicatedScalePolicyFixedScaleArgs' fixed_scale: Fixed scaling policy for the Yandex Database cluster.
        """
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if fixed_scale is not None:
            pulumi.set(__self__, "fixed_scale", fixed_scale)

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional['outputs.YdbDatabaseDedicatedScalePolicyAutoScale']:
        """
        Auto scaling policy for the Yandex Database cluster. This is a preview feature, and you need to enable it using the label `enable_autoscaling=1`.
        """
        return pulumi.get(self, "auto_scale")

    @_builtins.property
    @pulumi.getter(name="fixedScale")
    def fixed_scale(self) -> Optional['outputs.YdbDatabaseDedicatedScalePolicyFixedScale']:
        """
        Fixed scaling policy for the Yandex Database cluster.
        """
        return pulumi.get(self, "fixed_scale")


@pulumi.output_type
class YdbDatabaseDedicatedScalePolicyAutoScale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "targetTracking":
            suggest = "target_tracking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseDedicatedScalePolicyAutoScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseDedicatedScalePolicyAutoScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseDedicatedScalePolicyAutoScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: _builtins.int,
                 min_size: _builtins.int,
                 target_tracking: 'outputs.YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking'):
        """
        :param _builtins.int max_size: Maximum number of nodes to which autoscaling can scale the database.
        :param _builtins.int min_size: Minimum number of nodes to which autoscaling can scale the database.
        :param 'YdbDatabaseDedicatedScalePolicyAutoScaleTargetTrackingArgs' target_tracking: A target tracking scaling policy automatically scales the capacity of your Yandex Database cluster based on a target metric value.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "target_tracking", target_tracking)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        Maximum number of nodes to which autoscaling can scale the database.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> _builtins.int:
        """
        Minimum number of nodes to which autoscaling can scale the database.
        """
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter(name="targetTracking")
    def target_tracking(self) -> 'outputs.YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking':
        """
        A target tracking scaling policy automatically scales the capacity of your Yandex Database cluster based on a target metric value.
        """
        return pulumi.get(self, "target_tracking")


@pulumi.output_type
class YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuUtilizationPercent":
            suggest = "cpu_utilization_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseDedicatedScalePolicyAutoScaleTargetTracking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_utilization_percent: _builtins.int):
        """
        :param _builtins.int cpu_utilization_percent: A percentage of database nodes average CPU utilization.
        """
        pulumi.set(__self__, "cpu_utilization_percent", cpu_utilization_percent)

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationPercent")
    def cpu_utilization_percent(self) -> _builtins.int:
        """
        A percentage of database nodes average CPU utilization.
        """
        return pulumi.get(self, "cpu_utilization_percent")


@pulumi.output_type
class YdbDatabaseDedicatedScalePolicyFixedScale(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        """
        :param _builtins.int size: Number of instances for the Yandex Database cluster.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Number of instances for the Yandex Database cluster.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class YdbDatabaseDedicatedStorageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupCount":
            suggest = "group_count"
        elif key == "storageTypeId":
            suggest = "storage_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseDedicatedStorageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseDedicatedStorageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseDedicatedStorageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_count: _builtins.int,
                 storage_type_id: _builtins.str):
        """
        :param _builtins.int group_count: Amount of storage groups of selected type for the Yandex Database cluster.
        :param _builtins.str storage_type_id: Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
        pulumi.set(__self__, "group_count", group_count)
        pulumi.set(__self__, "storage_type_id", storage_type_id)

    @_builtins.property
    @pulumi.getter(name="groupCount")
    def group_count(self) -> _builtins.int:
        """
        Amount of storage groups of selected type for the Yandex Database cluster.
        """
        return pulumi.get(self, "group_count")

    @_builtins.property
    @pulumi.getter(name="storageTypeId")
    def storage_type_id(self) -> _builtins.str:
        """
        Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
        return pulumi.get(self, "storage_type_id")


@pulumi.output_type
class YdbDatabaseServerlessServerlessDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableThrottlingRcuLimit":
            suggest = "enable_throttling_rcu_limit"
        elif key == "provisionedRcuLimit":
            suggest = "provisioned_rcu_limit"
        elif key == "storageSizeLimit":
            suggest = "storage_size_limit"
        elif key == "throttlingRcuLimit":
            suggest = "throttling_rcu_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbDatabaseServerlessServerlessDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbDatabaseServerlessServerlessDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbDatabaseServerlessServerlessDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_throttling_rcu_limit: Optional[_builtins.bool] = None,
                 provisioned_rcu_limit: Optional[_builtins.int] = None,
                 storage_size_limit: Optional[_builtins.int] = None,
                 throttling_rcu_limit: Optional[_builtins.int] = None):
        if enable_throttling_rcu_limit is not None:
            pulumi.set(__self__, "enable_throttling_rcu_limit", enable_throttling_rcu_limit)
        if provisioned_rcu_limit is not None:
            pulumi.set(__self__, "provisioned_rcu_limit", provisioned_rcu_limit)
        if storage_size_limit is not None:
            pulumi.set(__self__, "storage_size_limit", storage_size_limit)
        if throttling_rcu_limit is not None:
            pulumi.set(__self__, "throttling_rcu_limit", throttling_rcu_limit)

    @_builtins.property
    @pulumi.getter(name="enableThrottlingRcuLimit")
    def enable_throttling_rcu_limit(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_throttling_rcu_limit")

    @_builtins.property
    @pulumi.getter(name="provisionedRcuLimit")
    def provisioned_rcu_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "provisioned_rcu_limit")

    @_builtins.property
    @pulumi.getter(name="storageSizeLimit")
    def storage_size_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "storage_size_limit")

    @_builtins.property
    @pulumi.getter(name="throttlingRcuLimit")
    def throttling_rcu_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throttling_rcu_limit")


@pulumi.output_type
class YdbTableChangefeedConsumer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startingMessageTimestampMs":
            suggest = "starting_message_timestamp_ms"
        elif key == "supportedCodecs":
            suggest = "supported_codecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTableChangefeedConsumer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTableChangefeedConsumer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTableChangefeedConsumer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 important: Optional[_builtins.bool] = None,
                 starting_message_timestamp_ms: Optional[_builtins.int] = None,
                 supported_codecs: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Consumer name. It is used in the SDK or CLI to [read data](https://ydb.tech/en/docs/best_practices/cdc#read) from the topic.
        :param _builtins.int starting_message_timestamp_ms: Timestamp in the UNIX timestamp format, from which the consumer will start reading data.
        :param Sequence[_builtins.str] supported_codecs: Supported data encodings.
        """
        pulumi.set(__self__, "name", name)
        if important is not None:
            pulumi.set(__self__, "important", important)
        if starting_message_timestamp_ms is not None:
            pulumi.set(__self__, "starting_message_timestamp_ms", starting_message_timestamp_ms)
        if supported_codecs is not None:
            pulumi.set(__self__, "supported_codecs", supported_codecs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Consumer name. It is used in the SDK or CLI to [read data](https://ydb.tech/en/docs/best_practices/cdc#read) from the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def important(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "important")

    @_builtins.property
    @pulumi.getter(name="startingMessageTimestampMs")
    def starting_message_timestamp_ms(self) -> Optional[_builtins.int]:
        """
        Timestamp in the UNIX timestamp format, from which the consumer will start reading data.
        """
        return pulumi.get(self, "starting_message_timestamp_ms")

    @_builtins.property
    @pulumi.getter(name="supportedCodecs")
    def supported_codecs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Supported data encodings.
        """
        return pulumi.get(self, "supported_codecs")


@pulumi.output_type
class YdbTableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notNull":
            suggest = "not_null"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 family: Optional[_builtins.str] = None,
                 not_null: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Column name.
        :param _builtins.str type: Column data type. YQL data types are used.
        :param _builtins.str family: Column group.
        :param _builtins.bool not_null: A column cannot have the NULL data type. Default: `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if not_null is not None:
            pulumi.set(__self__, "not_null", not_null)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Column name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Column data type. YQL data types are used.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        Column group.
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter(name="notNull")
    def not_null(self) -> Optional[_builtins.bool]:
        """
        A column cannot have the NULL data type. Default: `false`.
        """
        return pulumi.get(self, "not_null")


@pulumi.output_type
class YdbTableFamily(dict):
    def __init__(__self__, *,
                 compression: _builtins.str,
                 data: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str compression: Data codec (acceptable values: off, lz4).
        :param _builtins.str data: Type of storage device for column data in this group (acceptable values: ssd, rot (from HDD spindle rotation)).
        :param _builtins.str name: Column family name.
        """
        pulumi.set(__self__, "compression", compression)
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> _builtins.str:
        """
        Data codec (acceptable values: off, lz4).
        """
        return pulumi.get(self, "compression")

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        Type of storage device for column data in this group (acceptable values: ssd, rot (from HDD spindle rotation)).
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Column family name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class YdbTablePartitioningSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPartitioningByLoad":
            suggest = "auto_partitioning_by_load"
        elif key == "autoPartitioningBySizeEnabled":
            suggest = "auto_partitioning_by_size_enabled"
        elif key == "autoPartitioningMaxPartitionsCount":
            suggest = "auto_partitioning_max_partitions_count"
        elif key == "autoPartitioningMinPartitionsCount":
            suggest = "auto_partitioning_min_partitions_count"
        elif key == "autoPartitioningPartitionSizeMb":
            suggest = "auto_partitioning_partition_size_mb"
        elif key == "partitionAtKeys":
            suggest = "partition_at_keys"
        elif key == "partitionBies":
            suggest = "partition_bies"
        elif key == "uniformPartitions":
            suggest = "uniform_partitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTablePartitioningSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTablePartitioningSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTablePartitioningSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_partitioning_by_load: Optional[_builtins.bool] = None,
                 auto_partitioning_by_size_enabled: Optional[_builtins.bool] = None,
                 auto_partitioning_max_partitions_count: Optional[_builtins.int] = None,
                 auto_partitioning_min_partitions_count: Optional[_builtins.int] = None,
                 auto_partitioning_partition_size_mb: Optional[_builtins.int] = None,
                 partition_at_keys: Optional[Sequence['outputs.YdbTablePartitioningSettingsPartitionAtKey']] = None,
                 partition_bies: Optional[Sequence[_builtins.str]] = None,
                 uniform_partitions: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] partition_bies: Partitioning keys constitute a subset of the table's primary keys. If not set, primary keys will be used.
        """
        if auto_partitioning_by_load is not None:
            pulumi.set(__self__, "auto_partitioning_by_load", auto_partitioning_by_load)
        if auto_partitioning_by_size_enabled is not None:
            pulumi.set(__self__, "auto_partitioning_by_size_enabled", auto_partitioning_by_size_enabled)
        if auto_partitioning_max_partitions_count is not None:
            pulumi.set(__self__, "auto_partitioning_max_partitions_count", auto_partitioning_max_partitions_count)
        if auto_partitioning_min_partitions_count is not None:
            pulumi.set(__self__, "auto_partitioning_min_partitions_count", auto_partitioning_min_partitions_count)
        if auto_partitioning_partition_size_mb is not None:
            pulumi.set(__self__, "auto_partitioning_partition_size_mb", auto_partitioning_partition_size_mb)
        if partition_at_keys is not None:
            pulumi.set(__self__, "partition_at_keys", partition_at_keys)
        if partition_bies is not None:
            pulumi.set(__self__, "partition_bies", partition_bies)
        if uniform_partitions is not None:
            pulumi.set(__self__, "uniform_partitions", uniform_partitions)

    @_builtins.property
    @pulumi.getter(name="autoPartitioningByLoad")
    def auto_partitioning_by_load(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_partitioning_by_load")

    @_builtins.property
    @pulumi.getter(name="autoPartitioningBySizeEnabled")
    def auto_partitioning_by_size_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_partitioning_by_size_enabled")

    @_builtins.property
    @pulumi.getter(name="autoPartitioningMaxPartitionsCount")
    def auto_partitioning_max_partitions_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "auto_partitioning_max_partitions_count")

    @_builtins.property
    @pulumi.getter(name="autoPartitioningMinPartitionsCount")
    def auto_partitioning_min_partitions_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "auto_partitioning_min_partitions_count")

    @_builtins.property
    @pulumi.getter(name="autoPartitioningPartitionSizeMb")
    def auto_partitioning_partition_size_mb(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "auto_partitioning_partition_size_mb")

    @_builtins.property
    @pulumi.getter(name="partitionAtKeys")
    def partition_at_keys(self) -> Optional[Sequence['outputs.YdbTablePartitioningSettingsPartitionAtKey']]:
        return pulumi.get(self, "partition_at_keys")

    @_builtins.property
    @pulumi.getter(name="partitionBies")
    def partition_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Partitioning keys constitute a subset of the table's primary keys. If not set, primary keys will be used.
        """
        return pulumi.get(self, "partition_bies")

    @_builtins.property
    @pulumi.getter(name="uniformPartitions")
    def uniform_partitions(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "uniform_partitions")


@pulumi.output_type
class YdbTablePartitioningSettingsPartitionAtKey(dict):
    def __init__(__self__, *,
                 keys: Sequence[_builtins.str]):
        pulumi.set(__self__, "keys", keys)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "keys")


@pulumi.output_type
class YdbTableTtl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"
        elif key == "expireInterval":
            suggest = "expire_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTableTtl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTableTtl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTableTtl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: _builtins.str,
                 expire_interval: _builtins.str,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str column_name: Column name for TTL.
        :param _builtins.str expire_interval: Interval in the ISO 8601 format.
        """
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "expire_interval", expire_interval)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> _builtins.str:
        """
        Column name for TTL.
        """
        return pulumi.get(self, "column_name")

    @_builtins.property
    @pulumi.getter(name="expireInterval")
    def expire_interval(self) -> _builtins.str:
        """
        Interval in the ISO 8601 format.
        """
        return pulumi.get(self, "expire_interval")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class YdbTopicAutoPartitioningSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPartitioningStrategy":
            suggest = "auto_partitioning_strategy"
        elif key == "autoPartitioningWriteSpeedStrategy":
            suggest = "auto_partitioning_write_speed_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTopicAutoPartitioningSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTopicAutoPartitioningSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTopicAutoPartitioningSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_partitioning_strategy: Optional[_builtins.str] = None,
                 auto_partitioning_write_speed_strategy: Optional['outputs.YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy'] = None):
        """
        :param _builtins.str auto_partitioning_strategy: The auto partitioning strategy to use
        """
        if auto_partitioning_strategy is not None:
            pulumi.set(__self__, "auto_partitioning_strategy", auto_partitioning_strategy)
        if auto_partitioning_write_speed_strategy is not None:
            pulumi.set(__self__, "auto_partitioning_write_speed_strategy", auto_partitioning_write_speed_strategy)

    @_builtins.property
    @pulumi.getter(name="autoPartitioningStrategy")
    def auto_partitioning_strategy(self) -> Optional[_builtins.str]:
        """
        The auto partitioning strategy to use
        """
        return pulumi.get(self, "auto_partitioning_strategy")

    @_builtins.property
    @pulumi.getter(name="autoPartitioningWriteSpeedStrategy")
    def auto_partitioning_write_speed_strategy(self) -> Optional['outputs.YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy']:
        return pulumi.get(self, "auto_partitioning_write_speed_strategy")


@pulumi.output_type
class YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "downUtilizationPercent":
            suggest = "down_utilization_percent"
        elif key == "stabilizationWindow":
            suggest = "stabilization_window"
        elif key == "upUtilizationPercent":
            suggest = "up_utilization_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTopicAutoPartitioningSettingsAutoPartitioningWriteSpeedStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 down_utilization_percent: Optional[_builtins.int] = None,
                 stabilization_window: Optional[_builtins.int] = None,
                 up_utilization_percent: Optional[_builtins.int] = None):
        """
        :param _builtins.int down_utilization_percent: The down utilization percentage threshold
        :param _builtins.int stabilization_window: The stabilization window in seconds
        :param _builtins.int up_utilization_percent: The up utilization percentage threshold
        """
        if down_utilization_percent is not None:
            pulumi.set(__self__, "down_utilization_percent", down_utilization_percent)
        if stabilization_window is not None:
            pulumi.set(__self__, "stabilization_window", stabilization_window)
        if up_utilization_percent is not None:
            pulumi.set(__self__, "up_utilization_percent", up_utilization_percent)

    @_builtins.property
    @pulumi.getter(name="downUtilizationPercent")
    def down_utilization_percent(self) -> Optional[_builtins.int]:
        """
        The down utilization percentage threshold
        """
        return pulumi.get(self, "down_utilization_percent")

    @_builtins.property
    @pulumi.getter(name="stabilizationWindow")
    def stabilization_window(self) -> Optional[_builtins.int]:
        """
        The stabilization window in seconds
        """
        return pulumi.get(self, "stabilization_window")

    @_builtins.property
    @pulumi.getter(name="upUtilizationPercent")
    def up_utilization_percent(self) -> Optional[_builtins.int]:
        """
        The up utilization percentage threshold
        """
        return pulumi.get(self, "up_utilization_percent")


@pulumi.output_type
class YdbTopicConsumer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startingMessageTimestampMs":
            suggest = "starting_message_timestamp_ms"
        elif key == "supportedCodecs":
            suggest = "supported_codecs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in YdbTopicConsumer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        YdbTopicConsumer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        YdbTopicConsumer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 important: Optional[_builtins.bool] = None,
                 starting_message_timestamp_ms: Optional[_builtins.int] = None,
                 supported_codecs: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Reader's name.
        :param _builtins.bool important: Defines an important consumer. No data will be deleted from the topic until all the important consumers read them. Default value `false`.
        :param _builtins.int starting_message_timestamp_ms: Timestamp in UNIX timestamp format from which the reader will start reading data. Default value `0`.
        :param Sequence[_builtins.str] supported_codecs: Supported data encodings. Can be one of `gzip`, `raw` or `zstd`.
        """
        pulumi.set(__self__, "name", name)
        if important is not None:
            pulumi.set(__self__, "important", important)
        if starting_message_timestamp_ms is not None:
            pulumi.set(__self__, "starting_message_timestamp_ms", starting_message_timestamp_ms)
        if supported_codecs is not None:
            pulumi.set(__self__, "supported_codecs", supported_codecs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Reader's name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def important(self) -> Optional[_builtins.bool]:
        """
        Defines an important consumer. No data will be deleted from the topic until all the important consumers read them. Default value `false`.
        """
        return pulumi.get(self, "important")

    @_builtins.property
    @pulumi.getter(name="startingMessageTimestampMs")
    def starting_message_timestamp_ms(self) -> Optional[_builtins.int]:
        """
        Timestamp in UNIX timestamp format from which the reader will start reading data. Default value `0`.
        """
        return pulumi.get(self, "starting_message_timestamp_ms")

    @_builtins.property
    @pulumi.getter(name="supportedCodecs")
    def supported_codecs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Supported data encodings. Can be one of `gzip`, `raw` or `zstd`.
        """
        return pulumi.get(self, "supported_codecs")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendResult(dict):
    def __init__(__self__, *,
                 healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckResult',
                 load_balancing_config: 'outputs.GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult',
                 name: _builtins.str,
                 port: _builtins.int,
                 target_group_ids: Sequence[_builtins.str],
                 tls: 'outputs.GetAlbBackendGroupGrpcBackendTlsResult',
                 weight: _builtins.int):
        """
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend.
        :param 'GetAlbBackendGroupGrpcBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend.
        :param _builtins.str name: Name of the backend.
        :param _builtins.int port: Port for incoming traffic.
        :param Sequence[_builtins.str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupGrpcBackendTlsArgs' tls: TLS specification that will be used by this backend.
        :param _builtins.int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckResult':
        """
        Healthcheck specification that will be used by this backend.
        """
        return pulumi.get(self, "healthcheck")

    @_builtins.property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'outputs.GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult':
        """
        Load Balancing Config specification that will be used by this backend.
        """
        return pulumi.get(self, "load_balancing_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[_builtins.str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> 'outputs.GetAlbBackendGroupGrpcBackendTlsResult':
        """
        TLS specification that will be used by this backend.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckResult(dict):
    def __init__(__self__, *,
                 grpc_healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult',
                 healthcheck_port: _builtins.int,
                 healthy_threshold: _builtins.int,
                 http_healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult',
                 interval: _builtins.str,
                 interval_jitter_percent: _builtins.float,
                 stream_healthcheck: 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult',
                 timeout: _builtins.str,
                 unhealthy_threshold: _builtins.int):
        """
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: gRPC Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int healthcheck_port: Optional alternative port for health checking.
        :param _builtins.int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: HTTP Healthcheck specification that will be used by this healthcheck.
        :param _builtins.str interval: Interval between health checks.
        :param _builtins.float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck.
        :param _builtins.str timeout: Time to wait for a health check response.
        :param _builtins.int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult':
        """
        gRPC Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @_builtins.property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> _builtins.int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult':
        """
        HTTP Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "http_healthcheck")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> _builtins.float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @_builtins.property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'outputs.GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult':
        """
        Stream Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "stream_healthcheck")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheckResult(dict):
    def __init__(__self__, *,
                 service_name: _builtins.str):
        """
        :param _builtins.str service_name: Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheckResult(dict):
    def __init__(__self__, *,
                 expected_statuses: Sequence[_builtins.int],
                 host: _builtins.str,
                 http2: _builtins.bool,
                 path: _builtins.str):
        """
        :param Sequence[_builtins.int] expected_statuses: A list of HTTP response statuses considered healthy.
        :param _builtins.str host: `Host` HTTP header value.
        :param _builtins.bool http2: If set, health checks will use HTTP2.
        :param _builtins.str path: HTTP path.
        """
        pulumi.set(__self__, "expected_statuses", expected_statuses)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Sequence[_builtins.int]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        `Host` HTTP header value.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> _builtins.bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheckResult(dict):
    def __init__(__self__, *,
                 receive: _builtins.str,
                 send: _builtins.str):
        """
        :param _builtins.str receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param _builtins.str send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> _builtins.str:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @_builtins.property
    @pulumi.getter
    def send(self) -> _builtins.str:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendLoadBalancingConfigResult(dict):
    def __init__(__self__, *,
                 locality_aware_routing_percent: _builtins.int,
                 mode: _builtins.str,
                 panic_threshold: _builtins.int,
                 strict_locality: _builtins.bool):
        """
        :param _builtins.int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param _builtins.str mode: Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        :param _builtins.int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param _builtins.bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @_builtins.property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> _builtins.int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> _builtins.int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @_builtins.property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> _builtins.bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendTlsResult(dict):
    def __init__(__self__, *,
                 sni: _builtins.str,
                 validation_context: 'outputs.GetAlbBackendGroupGrpcBackendTlsValidationContextResult'):
        """
        :param _builtins.str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> _builtins.str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'outputs.GetAlbBackendGroupGrpcBackendTlsValidationContextResult':
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class GetAlbBackendGroupGrpcBackendTlsValidationContextResult(dict):
    def __init__(__self__, *,
                 trusted_ca_bytes: _builtins.str,
                 trusted_ca_id: _builtins.str):
        """
        :param _builtins.str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param _builtins.str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @_builtins.property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> _builtins.str:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @_builtins.property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> _builtins.str:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendResult(dict):
    def __init__(__self__, *,
                 healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckResult',
                 http2: _builtins.bool,
                 load_balancing_config: 'outputs.GetAlbBackendGroupHttpBackendLoadBalancingConfigResult',
                 name: _builtins.str,
                 port: _builtins.int,
                 storage_bucket: _builtins.str,
                 target_group_ids: Sequence[_builtins.str],
                 tls: 'outputs.GetAlbBackendGroupHttpBackendTlsResult',
                 weight: _builtins.int):
        """
        :param 'GetAlbBackendGroupHttpBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend.
        :param _builtins.bool http2: Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        :param 'GetAlbBackendGroupHttpBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend.
        :param _builtins.str name: Name of the backend.
        :param _builtins.int port: Port for incoming traffic.
        :param _builtins.str storage_bucket: Name of bucket which should be used as a backend.
        :param Sequence[_builtins.str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupHttpBackendTlsArgs' tls: TLS specification that will be used by this backend.
        :param _builtins.int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "storage_bucket", storage_bucket)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckResult':
        """
        Healthcheck specification that will be used by this backend.
        """
        return pulumi.get(self, "healthcheck")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> _builtins.bool:
        """
        Enables HTTP2 for upstream requests. If not set, HTTP 1.1 will be used by default.
        """
        return pulumi.get(self, "http2")

    @_builtins.property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'outputs.GetAlbBackendGroupHttpBackendLoadBalancingConfigResult':
        """
        Load Balancing Config specification that will be used by this backend.
        """
        return pulumi.get(self, "load_balancing_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="storageBucket")
    def storage_bucket(self) -> _builtins.str:
        """
        Name of bucket which should be used as a backend.
        """
        return pulumi.get(self, "storage_bucket")

    @_builtins.property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[_builtins.str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> 'outputs.GetAlbBackendGroupHttpBackendTlsResult':
        """
        TLS specification that will be used by this backend.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckResult(dict):
    def __init__(__self__, *,
                 grpc_healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult',
                 healthcheck_port: _builtins.int,
                 healthy_threshold: _builtins.int,
                 http_healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult',
                 interval: _builtins.str,
                 interval_jitter_percent: _builtins.float,
                 stream_healthcheck: 'outputs.GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult',
                 timeout: _builtins.str,
                 unhealthy_threshold: _builtins.int):
        """
        :param 'GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: gRPC Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int healthcheck_port: Optional alternative port for health checking.
        :param _builtins.int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: HTTP Healthcheck specification that will be used by this healthcheck.
        :param _builtins.str interval: Interval between health checks.
        :param _builtins.float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck.
        :param _builtins.str timeout: Time to wait for a health check response.
        :param _builtins.int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult':
        """
        gRPC Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @_builtins.property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> _builtins.int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult':
        """
        HTTP Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "http_healthcheck")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> _builtins.float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @_builtins.property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'outputs.GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult':
        """
        Stream Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "stream_healthcheck")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheckResult(dict):
    def __init__(__self__, *,
                 service_name: _builtins.str):
        """
        :param _builtins.str service_name: Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheckResult(dict):
    def __init__(__self__, *,
                 expected_statuses: Sequence[_builtins.int],
                 host: _builtins.str,
                 http2: _builtins.bool,
                 path: _builtins.str):
        """
        :param Sequence[_builtins.int] expected_statuses: A list of HTTP response statuses considered healthy.
        :param _builtins.str host: `Host` HTTP header value.
        :param _builtins.bool http2: If set, health checks will use HTTP2.
        :param _builtins.str path: HTTP path.
        """
        pulumi.set(__self__, "expected_statuses", expected_statuses)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Sequence[_builtins.int]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        `Host` HTTP header value.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> _builtins.bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheckResult(dict):
    def __init__(__self__, *,
                 receive: _builtins.str,
                 send: _builtins.str):
        """
        :param _builtins.str receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param _builtins.str send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> _builtins.str:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @_builtins.property
    @pulumi.getter
    def send(self) -> _builtins.str:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendLoadBalancingConfigResult(dict):
    def __init__(__self__, *,
                 locality_aware_routing_percent: _builtins.int,
                 mode: _builtins.str,
                 panic_threshold: _builtins.int,
                 strict_locality: _builtins.bool):
        """
        :param _builtins.int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param _builtins.str mode: Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        :param _builtins.int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param _builtins.bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @_builtins.property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> _builtins.int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> _builtins.int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @_builtins.property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> _builtins.bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendTlsResult(dict):
    def __init__(__self__, *,
                 sni: _builtins.str,
                 validation_context: 'outputs.GetAlbBackendGroupHttpBackendTlsValidationContextResult'):
        """
        :param _builtins.str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> _builtins.str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'outputs.GetAlbBackendGroupHttpBackendTlsValidationContextResult':
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class GetAlbBackendGroupHttpBackendTlsValidationContextResult(dict):
    def __init__(__self__, *,
                 trusted_ca_bytes: _builtins.str,
                 trusted_ca_id: _builtins.str):
        """
        :param _builtins.str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param _builtins.str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @_builtins.property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> _builtins.str:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @_builtins.property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> _builtins.str:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class GetAlbBackendGroupSessionAffinityResult(dict):
    def __init__(__self__, *,
                 connection: 'outputs.GetAlbBackendGroupSessionAffinityConnectionResult',
                 cookie: 'outputs.GetAlbBackendGroupSessionAffinityCookieResult',
                 header: 'outputs.GetAlbBackendGroupSessionAffinityHeaderResult'):
        """
        :param 'GetAlbBackendGroupSessionAffinityConnectionArgs' connection: Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address.
        :param 'GetAlbBackendGroupSessionAffinityCookieArgs' cookie: Requests with the same cookie value and the specified file name are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        :param 'GetAlbBackendGroupSessionAffinityHeaderArgs' header: Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "cookie", cookie)
        pulumi.set(__self__, "header", header)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> 'outputs.GetAlbBackendGroupSessionAffinityConnectionResult':
        """
        Requests received from the same IP are combined into a session. Stream backend groups only support session affinity by client IP address.
        """
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> 'outputs.GetAlbBackendGroupSessionAffinityCookieResult':
        """
        Requests with the same cookie value and the specified file name are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        """
        return pulumi.get(self, "cookie")

    @_builtins.property
    @pulumi.getter
    def header(self) -> 'outputs.GetAlbBackendGroupSessionAffinityHeaderResult':
        """
        Requests with the same value of the specified HTTP header, such as with user authentication data, are combined into a session. Allowed only for `HTTP` and `gRPC` backend groups.
        """
        return pulumi.get(self, "header")


@pulumi.output_type
class GetAlbBackendGroupSessionAffinityConnectionResult(dict):
    def __init__(__self__, *,
                 source_ip: _builtins.bool):
        """
        :param _builtins.bool source_ip: Use source IP address Source IP address to use with affinity.
        """
        pulumi.set(__self__, "source_ip", source_ip)

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> _builtins.bool:
        """
        Use source IP address Source IP address to use with affinity.
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class GetAlbBackendGroupSessionAffinityCookieResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 ttl: _builtins.str):
        """
        :param _builtins.str name: Name of the HTTP cookie Name of the HTTP cookie to use with affinity.
        :param _builtins.str ttl: TTL for the cookie (if not set, session cookie will be used) TTL for the cookie (if not set, session cookie will be used).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the HTTP cookie Name of the HTTP cookie to use with affinity.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.str:
        """
        TTL for the cookie (if not set, session cookie will be used) TTL for the cookie (if not set, session cookie will be used).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetAlbBackendGroupSessionAffinityHeaderResult(dict):
    def __init__(__self__, *,
                 header_name: _builtins.str):
        """
        :param _builtins.str header_name: The name of the request header that will be used The name of the request header that will be used with affinity.
        """
        pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> _builtins.str:
        """
        The name of the request header that will be used The name of the request header that will be used with affinity.
        """
        return pulumi.get(self, "header_name")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendResult(dict):
    def __init__(__self__, *,
                 enable_proxy_protocol: _builtins.bool,
                 healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckResult',
                 load_balancing_config: 'outputs.GetAlbBackendGroupStreamBackendLoadBalancingConfigResult',
                 name: _builtins.str,
                 port: _builtins.int,
                 target_group_ids: Sequence[_builtins.str],
                 tls: 'outputs.GetAlbBackendGroupStreamBackendTlsResult',
                 weight: _builtins.int,
                 keep_connections_on_host_health_failure: Optional[_builtins.bool] = None):
        """
        :param 'GetAlbBackendGroupStreamBackendHealthcheckArgs' healthcheck: Healthcheck specification that will be used by this backend.
        :param 'GetAlbBackendGroupStreamBackendLoadBalancingConfigArgs' load_balancing_config: Load Balancing Config specification that will be used by this backend.
        :param _builtins.str name: Name of the backend.
        :param _builtins.int port: Port for incoming traffic.
        :param Sequence[_builtins.str] target_group_ids: References target groups for the backend.
        :param 'GetAlbBackendGroupStreamBackendTlsArgs' tls: TLS specification that will be used by this backend.
        :param _builtins.int weight: Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        :param _builtins.bool keep_connections_on_host_health_failure: If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        pulumi.set(__self__, "enable_proxy_protocol", enable_proxy_protocol)
        pulumi.set(__self__, "healthcheck", healthcheck)
        pulumi.set(__self__, "load_balancing_config", load_balancing_config)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "target_group_ids", target_group_ids)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "weight", weight)
        if keep_connections_on_host_health_failure is not None:
            pulumi.set(__self__, "keep_connections_on_host_health_failure", keep_connections_on_host_health_failure)

    @_builtins.property
    @pulumi.getter(name="enableProxyProtocol")
    def enable_proxy_protocol(self) -> _builtins.bool:
        return pulumi.get(self, "enable_proxy_protocol")

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckResult':
        """
        Healthcheck specification that will be used by this backend.
        """
        return pulumi.get(self, "healthcheck")

    @_builtins.property
    @pulumi.getter(name="loadBalancingConfig")
    def load_balancing_config(self) -> 'outputs.GetAlbBackendGroupStreamBackendLoadBalancingConfigResult':
        """
        Load Balancing Config specification that will be used by this backend.
        """
        return pulumi.get(self, "load_balancing_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the backend.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="targetGroupIds")
    def target_group_ids(self) -> Sequence[_builtins.str]:
        """
        References target groups for the backend.
        """
        return pulumi.get(self, "target_group_ids")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> 'outputs.GetAlbBackendGroupStreamBackendTlsResult':
        """
        TLS specification that will be used by this backend.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Weight of the backend. Traffic will be split between backends of the same BackendGroup according to their weights.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="keepConnectionsOnHostHealthFailure")
    def keep_connections_on_host_health_failure(self) -> Optional[_builtins.bool]:
        """
        If set, when a backend host becomes unhealthy (as determined by the configured health checks), keep connections to the failed host.
        """
        return pulumi.get(self, "keep_connections_on_host_health_failure")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckResult(dict):
    def __init__(__self__, *,
                 grpc_healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult',
                 healthcheck_port: _builtins.int,
                 healthy_threshold: _builtins.int,
                 http_healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult',
                 interval: _builtins.str,
                 interval_jitter_percent: _builtins.float,
                 stream_healthcheck: 'outputs.GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult',
                 timeout: _builtins.str,
                 unhealthy_threshold: _builtins.int):
        """
        :param 'GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckArgs' grpc_healthcheck: gRPC Healthcheck specification that will be used by this healthcheck.
        :param _builtins.int healthcheck_port: Optional alternative port for health checking.
        :param _builtins.int healthy_threshold: Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        :param 'GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckArgs' http_healthcheck: HTTP Healthcheck specification that will be used by this healthcheck.
        :param _builtins.str interval: Interval between health checks.
        :param _builtins.float interval_jitter_percent: An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        :param 'GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckArgs' stream_healthcheck: Stream Healthcheck specification that will be used by this healthcheck.
        :param _builtins.str timeout: Time to wait for a health check response.
        :param _builtins.int unhealthy_threshold: Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        pulumi.set(__self__, "grpc_healthcheck", grpc_healthcheck)
        pulumi.set(__self__, "healthcheck_port", healthcheck_port)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_healthcheck", http_healthcheck)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "interval_jitter_percent", interval_jitter_percent)
        pulumi.set(__self__, "stream_healthcheck", stream_healthcheck)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="grpcHealthcheck")
    def grpc_healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult':
        """
        gRPC Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "grpc_healthcheck")

    @_builtins.property
    @pulumi.getter(name="healthcheckPort")
    def healthcheck_port(self) -> _builtins.int:
        """
        Optional alternative port for health checking.
        """
        return pulumi.get(self, "healthcheck_port")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        Number of consecutive successful health checks required to promote endpoint into the healthy state. 0 means 1. Note that during startup, only a single successful health check is required to mark a host healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpHealthcheck")
    def http_healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult':
        """
        HTTP Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "http_healthcheck")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Interval between health checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="intervalJitterPercent")
    def interval_jitter_percent(self) -> _builtins.float:
        """
        An optional jitter amount as a percentage of interval. If specified, during every interval value of (interval*ms * interval*jitter_percent / 100) will be added to the wait time.
        """
        return pulumi.get(self, "interval_jitter_percent")

    @_builtins.property
    @pulumi.getter(name="streamHealthcheck")
    def stream_healthcheck(self) -> 'outputs.GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult':
        """
        Stream Healthcheck specification that will be used by this healthcheck.
        """
        return pulumi.get(self, "stream_healthcheck")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Time to wait for a health check response.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        Number of consecutive failed health checks required to demote endpoint into the unhealthy state. 0 means 1. Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheckResult(dict):
    def __init__(__self__, *,
                 service_name: _builtins.str):
        """
        :param _builtins.str service_name: Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        Service name for `grpc.health.v1.HealthCheckRequest` message.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheckResult(dict):
    def __init__(__self__, *,
                 expected_statuses: Sequence[_builtins.int],
                 host: _builtins.str,
                 http2: _builtins.bool,
                 path: _builtins.str):
        """
        :param Sequence[_builtins.int] expected_statuses: A list of HTTP response statuses considered healthy.
        :param _builtins.str host: `Host` HTTP header value.
        :param _builtins.bool http2: If set, health checks will use HTTP2.
        :param _builtins.str path: HTTP path.
        """
        pulumi.set(__self__, "expected_statuses", expected_statuses)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http2", http2)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="expectedStatuses")
    def expected_statuses(self) -> Sequence[_builtins.int]:
        """
        A list of HTTP response statuses considered healthy.
        """
        return pulumi.get(self, "expected_statuses")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        `Host` HTTP header value.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def http2(self) -> _builtins.bool:
        """
        If set, health checks will use HTTP2.
        """
        return pulumi.get(self, "http2")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        HTTP path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheckResult(dict):
    def __init__(__self__, *,
                 receive: _builtins.str,
                 send: _builtins.str):
        """
        :param _builtins.str receive: Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        :param _builtins.str send: Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        pulumi.set(__self__, "receive", receive)
        pulumi.set(__self__, "send", send)

    @_builtins.property
    @pulumi.getter
    def receive(self) -> _builtins.str:
        """
        Data that must be contained in the messages received from targets for a successful health check. If not specified, no messages are expected from targets, and those that are received are not checked.
        """
        return pulumi.get(self, "receive")

    @_builtins.property
    @pulumi.getter
    def send(self) -> _builtins.str:
        """
        Message sent to targets during TCP data transfer. If not specified, no data is sent to the target.
        """
        return pulumi.get(self, "send")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendLoadBalancingConfigResult(dict):
    def __init__(__self__, *,
                 locality_aware_routing_percent: _builtins.int,
                 mode: _builtins.str,
                 panic_threshold: _builtins.int,
                 strict_locality: _builtins.bool):
        """
        :param _builtins.int locality_aware_routing_percent: Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        :param _builtins.str mode: Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        :param _builtins.int panic_threshold: If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        :param _builtins.bool strict_locality: If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        pulumi.set(__self__, "locality_aware_routing_percent", locality_aware_routing_percent)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "panic_threshold", panic_threshold)
        pulumi.set(__self__, "strict_locality", strict_locality)

    @_builtins.property
    @pulumi.getter(name="localityAwareRoutingPercent")
    def locality_aware_routing_percent(self) -> _builtins.int:
        """
        Percent of traffic to be sent to the same availability zone. The rest will be equally divided between other zones.
        """
        return pulumi.get(self, "locality_aware_routing_percent")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Load balancing mode for the backend. Possible values: `ROUND_ROBIN`, `RANDOM`, `LEAST_REQUEST`, `MAGLEV_HASH`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="panicThreshold")
    def panic_threshold(self) -> _builtins.int:
        """
        If percentage of healthy hosts in the backend is lower than panic_threshold, traffic will be routed to all backends no matter what the health status is. This helps to avoid healthy backends overloading when everything is bad. Zero means no panic threshold.
        """
        return pulumi.get(self, "panic_threshold")

    @_builtins.property
    @pulumi.getter(name="strictLocality")
    def strict_locality(self) -> _builtins.bool:
        """
        If set, will route requests only to the same availability zone. Balancer won't know about endpoints in other zones.
        """
        return pulumi.get(self, "strict_locality")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendTlsResult(dict):
    def __init__(__self__, *,
                 sni: _builtins.str,
                 validation_context: 'outputs.GetAlbBackendGroupStreamBackendTlsValidationContextResult'):
        """
        :param _builtins.str sni: [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        pulumi.set(__self__, "sni", sni)
        pulumi.set(__self__, "validation_context", validation_context)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> _builtins.str:
        """
        [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) string for TLS connections.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="validationContext")
    def validation_context(self) -> 'outputs.GetAlbBackendGroupStreamBackendTlsValidationContextResult':
        return pulumi.get(self, "validation_context")


@pulumi.output_type
class GetAlbBackendGroupStreamBackendTlsValidationContextResult(dict):
    def __init__(__self__, *,
                 trusted_ca_bytes: _builtins.str,
                 trusted_ca_id: _builtins.str):
        """
        :param _builtins.str trusted_ca_bytes: PEM-encoded trusted CA certificate chain.
        :param _builtins.str trusted_ca_id: Trusted CA certificate ID in the Certificate Manager.
        """
        pulumi.set(__self__, "trusted_ca_bytes", trusted_ca_bytes)
        pulumi.set(__self__, "trusted_ca_id", trusted_ca_id)

    @_builtins.property
    @pulumi.getter(name="trustedCaBytes")
    def trusted_ca_bytes(self) -> _builtins.str:
        """
        PEM-encoded trusted CA certificate chain.
        """
        return pulumi.get(self, "trusted_ca_bytes")

    @_builtins.property
    @pulumi.getter(name="trustedCaId")
    def trusted_ca_id(self) -> _builtins.str:
        """
        Trusted CA certificate ID in the Certificate Manager.
        """
        return pulumi.get(self, "trusted_ca_id")


@pulumi.output_type
class GetAlbHttpRouterRouteOptionResult(dict):
    def __init__(__self__, *,
                 rbacs: Sequence['outputs.GetAlbHttpRouterRouteOptionRbacResult'],
                 security_profile_id: Optional[_builtins.str] = None):
        """
        :param Sequence['GetAlbHttpRouterRouteOptionRbacArgs'] rbacs: RBAC configuration.
        :param _builtins.str security_profile_id: SWS profile ID.
        """
        pulumi.set(__self__, "rbacs", rbacs)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @_builtins.property
    @pulumi.getter
    def rbacs(self) -> Sequence['outputs.GetAlbHttpRouterRouteOptionRbacResult']:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbacs")

    @_builtins.property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[_builtins.str]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")


@pulumi.output_type
class GetAlbHttpRouterRouteOptionRbacResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 principals: Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalResult']):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalResult']:
        return pulumi.get(self, "principals")


@pulumi.output_type
class GetAlbHttpRouterRouteOptionRbacPrincipalResult(dict):
    def __init__(__self__, *,
                 and_principals: Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalResult']):
        pulumi.set(__self__, "and_principals", and_principals)

    @_builtins.property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalResult']:
        return pulumi.get(self, "and_principals")


@pulumi.output_type
class GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalResult(dict):
    def __init__(__self__, *,
                 any: _builtins.bool,
                 headers: Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderResult'],
                 remote_ip: _builtins.str):
        pulumi.set(__self__, "any", any)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter
    def any(self) -> _builtins.bool:
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> _builtins.str:
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValueResult']):
        """
        :param Sequence['GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValueArgs'] values: The `path` and `fqmn` blocks.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValueResult']:
        """
        The `path` and `fqmn` blocks.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact: _builtins.str,
                 prefix: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> _builtins.str:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAlbLoadBalancerAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 locations: Sequence['outputs.GetAlbLoadBalancerAllocationPolicyLocationResult']):
        """
        :param Sequence['GetAlbLoadBalancerAllocationPolicyLocationArgs'] locations: Unique set of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetAlbLoadBalancerAllocationPolicyLocationResult']:
        """
        Unique set of locations.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetAlbLoadBalancerAllocationPolicyLocationResult(dict):
    def __init__(__self__, *,
                 disable_traffic: _builtins.bool,
                 subnet_id: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.bool disable_traffic: If set, will disable all L7 instances in the zone for request handling.
        :param _builtins.str subnet_id: ID of the subnet that location is located at.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "disable_traffic", disable_traffic)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="disableTraffic")
    def disable_traffic(self) -> _builtins.bool:
        """
        If set, will disable all L7 instances in the zone for request handling.
        """
        return pulumi.get(self, "disable_traffic")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet that location is located at.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetAlbLoadBalancerAutoScalePolicyResult(dict):
    def __init__(__self__, *,
                 max_size: _builtins.int,
                 min_zone_size: _builtins.int):
        """
        :param _builtins.int max_size: Upper limit for total instance count (across all zones)
        :param _builtins.int min_zone_size: Lower limit for instance count in each zone.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_zone_size", min_zone_size)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        Upper limit for total instance count (across all zones)
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> _builtins.int:
        """
        Lower limit for instance count in each zone.
        """
        return pulumi.get(self, "min_zone_size")


@pulumi.output_type
class GetAlbLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 endpoints: Sequence['outputs.GetAlbLoadBalancerListenerEndpointResult'],
                 name: _builtins.str,
                 https: Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpResult']] = None,
                 stream: Optional['outputs.GetAlbLoadBalancerListenerStreamResult'] = None,
                 tls: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlResult']] = None):
        """
        :param Sequence['GetAlbLoadBalancerListenerEndpointArgs'] endpoints: Network endpoint (addresses and ports) of the listener.
        :param _builtins.str name: Name of the listener.
        :param Sequence['GetAlbLoadBalancerListenerHttpArgs'] https: HTTP handler that sets plain text HTTP router.
        :param 'GetAlbLoadBalancerListenerStreamArgs' stream: Stream configuration
        :param Sequence['GetAlbLoadBalancerListenerTlArgs'] tls: TLS configuration
        """
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "name", name)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if stream is not None:
            pulumi.set(__self__, "stream", stream)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointResult']:
        """
        Network endpoint (addresses and ports) of the listener.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the listener.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def https(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpResult']]:
        """
        HTTP handler that sets plain text HTTP router.
        """
        return pulumi.get(self, "https")

    @_builtins.property
    @pulumi.getter
    def stream(self) -> Optional['outputs.GetAlbLoadBalancerListenerStreamResult']:
        """
        Stream configuration
        """
        return pulumi.get(self, "stream")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlResult']]:
        """
        TLS configuration
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointResult(dict):
    def __init__(__self__, *,
                 addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressResult'],
                 ports: Sequence[_builtins.int]):
        """
        :param Sequence['GetAlbLoadBalancerListenerEndpointAddressArgs'] addresses: One or more addresses to listen on.
        :param Sequence[_builtins.int] ports: One or more ports to listen on.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressResult']:
        """
        One or more addresses to listen on.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.int]:
        """
        One or more ports to listen on.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressResult(dict):
    def __init__(__self__, *,
                 external_ipv4_addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult'],
                 external_ipv6_addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult'],
                 internal_ipv4_addresses: Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult']):
        """
        :param Sequence['GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressArgs'] external_ipv4_addresses: External IPv4 address.
        :param Sequence['GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressArgs'] external_ipv6_addresses: External IPv6 address.
        :param Sequence['GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressArgs'] internal_ipv4_addresses: Internal IPv4 address.
        """
        pulumi.set(__self__, "external_ipv4_addresses", external_ipv4_addresses)
        pulumi.set(__self__, "external_ipv6_addresses", external_ipv6_addresses)
        pulumi.set(__self__, "internal_ipv4_addresses", internal_ipv4_addresses)

    @_builtins.property
    @pulumi.getter(name="externalIpv4Addresses")
    def external_ipv4_addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult']:
        """
        External IPv4 address.
        """
        return pulumi.get(self, "external_ipv4_addresses")

    @_builtins.property
    @pulumi.getter(name="externalIpv6Addresses")
    def external_ipv6_addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult']:
        """
        External IPv6 address.
        """
        return pulumi.get(self, "external_ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="internalIpv4Addresses")
    def internal_ipv4_addresses(self) -> Sequence['outputs.GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult']:
        """
        Internal IPv4 address.
        """
        return pulumi.get(self, "internal_ipv4_addresses")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressExternalIpv4AddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: Provided by the client or computed automatically.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressExternalIpv6AddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str):
        """
        :param _builtins.str address: Provided by the client or computed automatically.
        """
        pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class GetAlbLoadBalancerListenerEndpointAddressInternalIpv4AddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str address: Provided by the client or computed automatically.
        :param _builtins.str subnet_id: ID of the subnet that the address belongs to.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Provided by the client or computed automatically.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet that the address belongs to.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpResult(dict):
    def __init__(__self__, *,
                 handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerResult']] = None,
                 redirects: Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpRedirectResult']] = None):
        """
        :param Sequence['GetAlbLoadBalancerListenerHttpHandlerArgs'] handlers: HTTP handler.
        :param Sequence['GetAlbLoadBalancerListenerHttpRedirectArgs'] redirects: Shortcut for adding http > https redirects.
        """
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)

    @_builtins.property
    @pulumi.getter
    def handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerResult']]:
        """
        HTTP handler.
        """
        return pulumi.get(self, "handlers")

    @_builtins.property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerHttpRedirectResult']]:
        """
        Shortcut for adding http > https redirects.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpHandlerResult(dict):
    def __init__(__self__, *,
                 http2_options: Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult'],
                 http_router_id: _builtins.str,
                 rewrite_request_id: _builtins.bool,
                 allow_http10: Optional[_builtins.bool] = None):
        """
        :param Sequence['GetAlbLoadBalancerListenerHttpHandlerHttp2OptionArgs'] http2_options: If set, will enable HTTP2 protocol for the handler.
        :param _builtins.str http_router_id: HTTP router id.
        :param _builtins.bool rewrite_request_id: When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        :param _builtins.bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        pulumi.set(__self__, "http2_options", http2_options)
        pulumi.set(__self__, "http_router_id", http_router_id)
        pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)

    @_builtins.property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Sequence['outputs.GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult']:
        """
        If set, will enable HTTP2 protocol for the handler.
        """
        return pulumi.get(self, "http2_options")

    @_builtins.property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> _builtins.str:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @_builtins.property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> _builtins.bool:
        """
        When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")

    @_builtins.property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[_builtins.bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpHandlerHttp2OptionResult(dict):
    def __init__(__self__, *,
                 max_concurrent_streams: _builtins.int):
        """
        :param _builtins.int max_concurrent_streams: Maximum number of concurrent streams.
        """
        pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> _builtins.int:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class GetAlbLoadBalancerListenerHttpRedirectResult(dict):
    def __init__(__self__, *,
                 http_to_https: _builtins.bool):
        """
        :param _builtins.bool http_to_https: If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
        pulumi.set(__self__, "http_to_https", http_to_https)

    @_builtins.property
    @pulumi.getter(name="httpToHttps")
    def http_to_https(self) -> _builtins.bool:
        """
        If set redirects all unencrypted HTTP requests to the same URI with scheme changed to `https`.
        """
        return pulumi.get(self, "http_to_https")


@pulumi.output_type
class GetAlbLoadBalancerListenerStreamResult(dict):
    def __init__(__self__, *,
                 handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerStreamHandlerResult']] = None):
        """
        :param Sequence['GetAlbLoadBalancerListenerStreamHandlerArgs'] handlers: Stream handler resource.
        """
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)

    @_builtins.property
    @pulumi.getter
    def handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerStreamHandlerResult']]:
        """
        Stream handler resource.
        """
        return pulumi.get(self, "handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerStreamHandlerResult(dict):
    def __init__(__self__, *,
                 backend_group_id: _builtins.str,
                 idle_timeout: _builtins.str):
        """
        :param _builtins.str backend_group_id: Backend Group ID.
        :param _builtins.str idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend Group ID.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.str:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlResult(dict):
    def __init__(__self__, *,
                 default_handlers: Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerResult'],
                 sni_handlers: Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerResult']):
        """
        :param Sequence['GetAlbLoadBalancerListenerTlDefaultHandlerArgs'] default_handlers: TLS handler resource.
        :param Sequence['GetAlbLoadBalancerListenerTlSniHandlerArgs'] sni_handlers: Settings for handling requests with Server Name Indication (SNI)
        """
        pulumi.set(__self__, "default_handlers", default_handlers)
        pulumi.set(__self__, "sni_handlers", sni_handlers)

    @_builtins.property
    @pulumi.getter(name="defaultHandlers")
    def default_handlers(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerResult']:
        """
        TLS handler resource.
        """
        return pulumi.get(self, "default_handlers")

    @_builtins.property
    @pulumi.getter(name="sniHandlers")
    def sni_handlers(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerResult']:
        """
        Settings for handling requests with Server Name Indication (SNI)
        """
        return pulumi.get(self, "sni_handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerResult(dict):
    def __init__(__self__, *,
                 certificate_ids: Sequence[_builtins.str],
                 http_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult']] = None,
                 stream_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult']] = None):
        """
        :param Sequence[_builtins.str] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        :param Sequence['GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerArgs'] http_handlers: HTTP handler.
        :param Sequence['GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerArgs'] stream_handlers: Stream handler resource.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handlers is not None:
            pulumi.set(__self__, "http_handlers", http_handlers)
        if stream_handlers is not None:
            pulumi.set(__self__, "stream_handlers", stream_handlers)

    @_builtins.property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[_builtins.str]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        """
        return pulumi.get(self, "certificate_ids")

    @_builtins.property
    @pulumi.getter(name="httpHandlers")
    def http_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult']]:
        """
        HTTP handler.
        """
        return pulumi.get(self, "http_handlers")

    @_builtins.property
    @pulumi.getter(name="streamHandlers")
    def stream_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult']]:
        """
        Stream handler resource.
        """
        return pulumi.get(self, "stream_handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerResult(dict):
    def __init__(__self__, *,
                 http2_options: Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult'],
                 http_router_id: _builtins.str,
                 rewrite_request_id: _builtins.bool,
                 allow_http10: Optional[_builtins.bool] = None):
        """
        :param Sequence['GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionArgs'] http2_options: If set, will enable HTTP2 protocol for the handler.
        :param _builtins.str http_router_id: HTTP router id.
        :param _builtins.bool rewrite_request_id: When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        :param _builtins.bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        pulumi.set(__self__, "http2_options", http2_options)
        pulumi.set(__self__, "http_router_id", http_router_id)
        pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)

    @_builtins.property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult']:
        """
        If set, will enable HTTP2 protocol for the handler.
        """
        return pulumi.get(self, "http2_options")

    @_builtins.property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> _builtins.str:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @_builtins.property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> _builtins.bool:
        """
        When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")

    @_builtins.property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[_builtins.bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2OptionResult(dict):
    def __init__(__self__, *,
                 max_concurrent_streams: _builtins.int):
        """
        :param _builtins.int max_concurrent_streams: Maximum number of concurrent streams.
        """
        pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> _builtins.int:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandlerResult(dict):
    def __init__(__self__, *,
                 backend_group_id: _builtins.str,
                 idle_timeout: _builtins.str):
        """
        :param _builtins.str backend_group_id: Backend Group ID.
        :param _builtins.str idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend Group ID.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.str:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerResult(dict):
    def __init__(__self__, *,
                 handlers: Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerResult'],
                 name: _builtins.str,
                 server_names: Sequence[_builtins.str]):
        """
        :param Sequence['GetAlbLoadBalancerListenerTlSniHandlerHandlerArgs'] handlers: TLS handler resource.
        :param _builtins.str name: Name of the SNI handler
        :param Sequence[_builtins.str] server_names: Server names that are matched by the SNI handler
        """
        pulumi.set(__self__, "handlers", handlers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_names", server_names)

    @_builtins.property
    @pulumi.getter
    def handlers(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerResult']:
        """
        TLS handler resource.
        """
        return pulumi.get(self, "handlers")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the SNI handler
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serverNames")
    def server_names(self) -> Sequence[_builtins.str]:
        """
        Server names that are matched by the SNI handler
        """
        return pulumi.get(self, "server_names")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerResult(dict):
    def __init__(__self__, *,
                 certificate_ids: Sequence[_builtins.str],
                 http_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult']] = None,
                 stream_handlers: Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult']] = None):
        """
        :param Sequence[_builtins.str] certificate_ids: Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        :param Sequence['GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerArgs'] http_handlers: HTTP handler.
        :param Sequence['GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerArgs'] stream_handlers: Stream handler resource.
        """
        pulumi.set(__self__, "certificate_ids", certificate_ids)
        if http_handlers is not None:
            pulumi.set(__self__, "http_handlers", http_handlers)
        if stream_handlers is not None:
            pulumi.set(__self__, "stream_handlers", stream_handlers)

    @_builtins.property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[_builtins.str]:
        """
        Certificate IDs in the Certificate Manager. Multiple TLS certificates can be associated with the same context to allow both RSA and ECDSA certificates. Only the first certificate of each type will be used.
        """
        return pulumi.get(self, "certificate_ids")

    @_builtins.property
    @pulumi.getter(name="httpHandlers")
    def http_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult']]:
        """
        HTTP handler.
        """
        return pulumi.get(self, "http_handlers")

    @_builtins.property
    @pulumi.getter(name="streamHandlers")
    def stream_handlers(self) -> Optional[Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult']]:
        """
        Stream handler resource.
        """
        return pulumi.get(self, "stream_handlers")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerResult(dict):
    def __init__(__self__, *,
                 http2_options: Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult'],
                 http_router_id: _builtins.str,
                 rewrite_request_id: _builtins.bool,
                 allow_http10: Optional[_builtins.bool] = None):
        """
        :param Sequence['GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionArgs'] http2_options: If set, will enable HTTP2 protocol for the handler.
        :param _builtins.str http_router_id: HTTP router id.
        :param _builtins.bool rewrite_request_id: When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        :param _builtins.bool allow_http10: If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        pulumi.set(__self__, "http2_options", http2_options)
        pulumi.set(__self__, "http_router_id", http_router_id)
        pulumi.set(__self__, "rewrite_request_id", rewrite_request_id)
        if allow_http10 is not None:
            pulumi.set(__self__, "allow_http10", allow_http10)

    @_builtins.property
    @pulumi.getter(name="http2Options")
    def http2_options(self) -> Sequence['outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult']:
        """
        If set, will enable HTTP2 protocol for the handler.
        """
        return pulumi.get(self, "http2_options")

    @_builtins.property
    @pulumi.getter(name="httpRouterId")
    def http_router_id(self) -> _builtins.str:
        """
        HTTP router id.
        """
        return pulumi.get(self, "http_router_id")

    @_builtins.property
    @pulumi.getter(name="rewriteRequestId")
    def rewrite_request_id(self) -> _builtins.bool:
        """
        When unset, will preserve the incoming `x-request-id` header, otherwise would rewrite it with a new value.
        """
        return pulumi.get(self, "rewrite_request_id")

    @_builtins.property
    @pulumi.getter(name="allowHttp10")
    def allow_http10(self) -> Optional[_builtins.bool]:
        """
        If set, will enable only HTTP1 protocol with HTTP1.0 support.
        """
        return pulumi.get(self, "allow_http10")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2OptionResult(dict):
    def __init__(__self__, *,
                 max_concurrent_streams: _builtins.int):
        """
        :param _builtins.int max_concurrent_streams: Maximum number of concurrent streams.
        """
        pulumi.set(__self__, "max_concurrent_streams", max_concurrent_streams)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentStreams")
    def max_concurrent_streams(self) -> _builtins.int:
        """
        Maximum number of concurrent streams.
        """
        return pulumi.get(self, "max_concurrent_streams")


@pulumi.output_type
class GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandlerResult(dict):
    def __init__(__self__, *,
                 backend_group_id: _builtins.str,
                 idle_timeout: _builtins.str):
        """
        :param _builtins.str backend_group_id: Backend Group ID.
        :param _builtins.str idle_timeout: The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "idle_timeout", idle_timeout)

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend Group ID.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.str:
        """
        The idle timeout is the interval after which the connection will be forcibly closed if no data has been transmitted or received on either the upstream or downstream connection. If not configured, the default idle timeout is 1 hour. Setting it to 0 disables the timeout.
        """
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class GetAlbLoadBalancerLogOptionResult(dict):
    def __init__(__self__, *,
                 disable: _builtins.bool,
                 discard_rules: Sequence['outputs.GetAlbLoadBalancerLogOptionDiscardRuleResult'],
                 log_group_id: _builtins.str):
        """
        :param _builtins.bool disable: Set to `true` to disable Cloud Logging for the balancer.
        :param Sequence['GetAlbLoadBalancerLogOptionDiscardRuleArgs'] discard_rules: List of rules to discard a fraction of logs.
        :param _builtins.str log_group_id: Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
        pulumi.set(__self__, "disable", disable)
        pulumi.set(__self__, "discard_rules", discard_rules)
        pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> _builtins.bool:
        """
        Set to `true` to disable Cloud Logging for the balancer.
        """
        return pulumi.get(self, "disable")

    @_builtins.property
    @pulumi.getter(name="discardRules")
    def discard_rules(self) -> Sequence['outputs.GetAlbLoadBalancerLogOptionDiscardRuleResult']:
        """
        List of rules to discard a fraction of logs.
        """
        return pulumi.get(self, "discard_rules")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Cloud Logging group ID to send logs to. Leave empty to use the balancer folder default log group.
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class GetAlbLoadBalancerLogOptionDiscardRuleResult(dict):
    def __init__(__self__, *,
                 discard_percent: _builtins.int,
                 grpc_codes: Sequence[_builtins.str],
                 http_code_intervals: Sequence[_builtins.str],
                 http_codes: Sequence[_builtins.int]):
        """
        :param _builtins.int discard_percent: The percent of logs which will be discarded.
        :param Sequence[_builtins.str] grpc_codes: list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
        :param Sequence[_builtins.str] http_code_intervals: List of http code intervals *1XX*-*5XX* or *ALL*
        :param Sequence[_builtins.int] http_codes: List of http codes *100*-*599*.
        """
        pulumi.set(__self__, "discard_percent", discard_percent)
        pulumi.set(__self__, "grpc_codes", grpc_codes)
        pulumi.set(__self__, "http_code_intervals", http_code_intervals)
        pulumi.set(__self__, "http_codes", http_codes)

    @_builtins.property
    @pulumi.getter(name="discardPercent")
    def discard_percent(self) -> _builtins.int:
        """
        The percent of logs which will be discarded.
        """
        return pulumi.get(self, "discard_percent")

    @_builtins.property
    @pulumi.getter(name="grpcCodes")
    def grpc_codes(self) -> Sequence[_builtins.str]:
        """
        list of grpc codes by name, e.g, [**NOT_FOUND**, **RESOURCE_EXHAUSTED**].
        """
        return pulumi.get(self, "grpc_codes")

    @_builtins.property
    @pulumi.getter(name="httpCodeIntervals")
    def http_code_intervals(self) -> Sequence[_builtins.str]:
        """
        List of http code intervals *1XX*-*5XX* or *ALL*
        """
        return pulumi.get(self, "http_code_intervals")

    @_builtins.property
    @pulumi.getter(name="httpCodes")
    def http_codes(self) -> Sequence[_builtins.int]:
        """
        List of http codes *100*-*599*.
        """
        return pulumi.get(self, "http_codes")


@pulumi.output_type
class GetAlbTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 private_ipv4_address: Optional[_builtins.bool] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_address: IP address of the target.
        :param _builtins.str subnet_id: ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if private_ipv4_address is not None:
            pulumi.set(__self__, "private_ipv4_address", private_ipv4_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address of the target.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="privateIpv4Address")
    def private_ipv4_address(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "private_ipv4_address")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetAlbVirtualHostModifyRequestHeaderResult(dict):
    def __init__(__self__, *,
                 append: _builtins.str,
                 name: _builtins.str,
                 remove: _builtins.bool,
                 replace: _builtins.str):
        """
        :param _builtins.str append: Append string to the header value.
        :param _builtins.str name: Name of the header to modify.
        :param _builtins.bool remove: If set, remove the header.
        :param _builtins.str replace: New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter
    def append(self) -> _builtins.str:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the header to modify.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def remove(self) -> _builtins.bool:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.str:
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetAlbVirtualHostModifyResponseHeaderResult(dict):
    def __init__(__self__, *,
                 append: _builtins.str,
                 name: _builtins.str,
                 remove: _builtins.bool,
                 replace: _builtins.str):
        """
        :param _builtins.str append: Append string to the header value.
        :param _builtins.str name: Name of the header to modify.
        :param _builtins.bool remove: If set, remove the header.
        :param _builtins.str replace: New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        pulumi.set(__self__, "append", append)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remove", remove)
        pulumi.set(__self__, "replace", replace)

    @_builtins.property
    @pulumi.getter
    def append(self) -> _builtins.str:
        """
        Append string to the header value.
        """
        return pulumi.get(self, "append")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the header to modify.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def remove(self) -> _builtins.bool:
        """
        If set, remove the header.
        """
        return pulumi.get(self, "remove")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.str:
        """
        New value for a header. Header values support the following [formatters](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#custom-request-response-headers).
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class GetAlbVirtualHostRateLimitResult(dict):
    def __init__(__self__, *,
                 all_requests: Sequence['outputs.GetAlbVirtualHostRateLimitAllRequestResult'],
                 requests_per_ips: Sequence['outputs.GetAlbVirtualHostRateLimitRequestsPerIpResult']):
        """
        :param Sequence['GetAlbVirtualHostRateLimitAllRequestArgs'] all_requests: Rate limit configuration applied to all incoming requests
        :param Sequence['GetAlbVirtualHostRateLimitRequestsPerIpArgs'] requests_per_ips: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        pulumi.set(__self__, "all_requests", all_requests)
        pulumi.set(__self__, "requests_per_ips", requests_per_ips)

    @_builtins.property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Sequence['outputs.GetAlbVirtualHostRateLimitAllRequestResult']:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @_builtins.property
    @pulumi.getter(name="requestsPerIps")
    def requests_per_ips(self) -> Sequence['outputs.GetAlbVirtualHostRateLimitRequestsPerIpResult']:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ips")


@pulumi.output_type
class GetAlbVirtualHostRateLimitAllRequestResult(dict):
    def __init__(__self__, *,
                 per_minute: _builtins.int,
                 per_second: _builtins.int):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        pulumi.set(__self__, "per_minute", per_minute)
        pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> _builtins.int:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> _builtins.int:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class GetAlbVirtualHostRateLimitRequestsPerIpResult(dict):
    def __init__(__self__, *,
                 per_minute: _builtins.int,
                 per_second: _builtins.int):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        pulumi.set(__self__, "per_minute", per_minute)
        pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> _builtins.int:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> _builtins.int:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class GetAlbVirtualHostRouteResult(dict):
    def __init__(__self__, *,
                 disable_security_profile: _builtins.bool,
                 grpc_routes: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteResult'],
                 http_routes: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteResult'],
                 name: _builtins.str,
                 route_options: Sequence['outputs.GetAlbVirtualHostRouteRouteOptionResult']):
        """
        :param _builtins.bool disable_security_profile: Disables security profile for the route
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteArgs'] grpc_routes: gRPC route resource.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteArgs'] http_routes: HTTP route resource.
        :param _builtins.str name: Name of the route.
        :param Sequence['GetAlbVirtualHostRouteRouteOptionArgs'] route_options: Route options for the virtual host.
        """
        pulumi.set(__self__, "disable_security_profile", disable_security_profile)
        pulumi.set(__self__, "grpc_routes", grpc_routes)
        pulumi.set(__self__, "http_routes", http_routes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "route_options", route_options)

    @_builtins.property
    @pulumi.getter(name="disableSecurityProfile")
    def disable_security_profile(self) -> _builtins.bool:
        """
        Disables security profile for the route
        """
        return pulumi.get(self, "disable_security_profile")

    @_builtins.property
    @pulumi.getter(name="grpcRoutes")
    def grpc_routes(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteResult']:
        """
        gRPC route resource.
        """
        return pulumi.get(self, "grpc_routes")

    @_builtins.property
    @pulumi.getter(name="httpRoutes")
    def http_routes(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteResult']:
        """
        HTTP route resource.
        """
        return pulumi.get(self, "http_routes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="routeOptions")
    def route_options(self) -> Sequence['outputs.GetAlbVirtualHostRouteRouteOptionResult']:
        """
        Route options for the virtual host.
        """
        return pulumi.get(self, "route_options")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteResult(dict):
    def __init__(__self__, *,
                 grpc_matches: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult'],
                 grpc_route_actions: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult'],
                 grpc_status_response_actions: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcMatchArgs'] grpc_matches: Checks `/` prefix by default.
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionArgs'] grpc_route_actions: gRPC route action resource.
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionArgs'] grpc_status_response_actions: gRPC status response action resource.
        """
        pulumi.set(__self__, "grpc_matches", grpc_matches)
        pulumi.set(__self__, "grpc_route_actions", grpc_route_actions)
        pulumi.set(__self__, "grpc_status_response_actions", grpc_status_response_actions)

    @_builtins.property
    @pulumi.getter(name="grpcMatches")
    def grpc_matches(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult']:
        """
        Checks `/` prefix by default.
        """
        return pulumi.get(self, "grpc_matches")

    @_builtins.property
    @pulumi.getter(name="grpcRouteActions")
    def grpc_route_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult']:
        """
        gRPC route action resource.
        """
        return pulumi.get(self, "grpc_route_actions")

    @_builtins.property
    @pulumi.getter(name="grpcStatusResponseActions")
    def grpc_status_response_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult']:
        """
        gRPC status response action resource.
        """
        return pulumi.get(self, "grpc_status_response_actions")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcMatchResult(dict):
    def __init__(__self__, *,
                 fqmns: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnArgs'] fqmns: The `path` and `fqmn` blocks.
        """
        pulumi.set(__self__, "fqmns", fqmns)

    @_builtins.property
    @pulumi.getter
    def fqmns(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "fqmns")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmnResult(dict):
    def __init__(__self__, *,
                 exact: _builtins.str,
                 prefix: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> _builtins.str:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionResult(dict):
    def __init__(__self__, *,
                 auto_host_rewrite: _builtins.bool,
                 backend_group_id: _builtins.str,
                 host_rewrite: _builtins.str,
                 idle_timeout: _builtins.str,
                 max_timeout: _builtins.str,
                 rate_limits: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitResult']):
        """
        :param _builtins.bool auto_host_rewrite: If set, will automatically rewrite host.
        :param _builtins.str backend_group_id: Backend group to route requests.
        :param _builtins.str host_rewrite: Host rewrite specifier.
        :param _builtins.str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle*timeout to something meaningful and max*timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param _builtins.str max_timeout: Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitArgs'] rate_limits: Rate limit configuration applied for a whole virtual host
        """
        pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "host_rewrite", host_rewrite)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "max_timeout", max_timeout)
        pulumi.set(__self__, "rate_limits", rate_limits)

    @_builtins.property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> _builtins.bool:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> _builtins.str:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.str:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios - one should set idle*timeout to something meaningful and max*timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="maxTimeout")
    def max_timeout(self) -> _builtins.str:
        """
        Lower timeout may be specified by the client (using grpc-timeout header). If not set, default is 60 seconds.
        """
        return pulumi.get(self, "max_timeout")

    @_builtins.property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitResult']:
        """
        Rate limit configuration applied for a whole virtual host
        """
        return pulumi.get(self, "rate_limits")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitResult(dict):
    def __init__(__self__, *,
                 all_requests: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestResult'],
                 requests_per_ips: Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestArgs'] all_requests: Rate limit configuration applied to all incoming requests
        :param Sequence['GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpArgs'] requests_per_ips: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        pulumi.set(__self__, "all_requests", all_requests)
        pulumi.set(__self__, "requests_per_ips", requests_per_ips)

    @_builtins.property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestResult']:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @_builtins.property
    @pulumi.getter(name="requestsPerIps")
    def requests_per_ips(self) -> Sequence['outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpResult']:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ips")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitAllRequestResult(dict):
    def __init__(__self__, *,
                 per_minute: _builtins.int,
                 per_second: _builtins.int):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        pulumi.set(__self__, "per_minute", per_minute)
        pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> _builtins.int:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> _builtins.int:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcRouteActionRateLimitRequestsPerIpResult(dict):
    def __init__(__self__, *,
                 per_minute: _builtins.int,
                 per_second: _builtins.int):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        pulumi.set(__self__, "per_minute", per_minute)
        pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> _builtins.int:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> _builtins.int:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseActionResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: The status of the response. Supported values are: ok, invalid*argumet, not*found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the response. Supported values are: ok, invalid*argumet, not*found, permission_denied, unauthenticated, unimplemented, internal, unavailable.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteResult(dict):
    def __init__(__self__, *,
                 direct_response_actions: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult'],
                 http_matches: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchResult'],
                 http_route_actions: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult'],
                 redirect_actions: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteRedirectActionResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteHttpRouteDirectResponseActionArgs'] direct_response_actions: Direct response action resource.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpMatchArgs'] http_matches: Checks `/` prefix by default.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpRouteActionArgs'] http_route_actions: HTTP route action resource.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteRedirectActionArgs'] redirect_actions: Redirect action resource.
        """
        pulumi.set(__self__, "direct_response_actions", direct_response_actions)
        pulumi.set(__self__, "http_matches", http_matches)
        pulumi.set(__self__, "http_route_actions", http_route_actions)
        pulumi.set(__self__, "redirect_actions", redirect_actions)

    @_builtins.property
    @pulumi.getter(name="directResponseActions")
    def direct_response_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult']:
        """
        Direct response action resource.
        """
        return pulumi.get(self, "direct_response_actions")

    @_builtins.property
    @pulumi.getter(name="httpMatches")
    def http_matches(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchResult']:
        """
        Checks `/` prefix by default.
        """
        return pulumi.get(self, "http_matches")

    @_builtins.property
    @pulumi.getter(name="httpRouteActions")
    def http_route_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult']:
        """
        HTTP route action resource.
        """
        return pulumi.get(self, "http_route_actions")

    @_builtins.property
    @pulumi.getter(name="redirectActions")
    def redirect_actions(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteRedirectActionResult']:
        """
        Redirect action resource.
        """
        return pulumi.get(self, "redirect_actions")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteDirectResponseActionResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 status: _builtins.int):
        """
        :param _builtins.str body: Response body text.
        :param _builtins.int status: HTTP response status. Should be between `100` and `599`.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        Response body text.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        HTTP response status. Should be between `100` and `599`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpMatchResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence[_builtins.str],
                 paths: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult']):
        """
        :param Sequence[_builtins.str] http_methods: List of methods (strings).
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpMatchPathArgs'] paths: The `path` and `fqmn` blocks.
        """
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence[_builtins.str]:
        """
        List of methods (strings).
        """
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult']:
        """
        The `path` and `fqmn` blocks.
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpMatchPathResult(dict):
    def __init__(__self__, *,
                 exact: _builtins.str,
                 prefix: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> _builtins.str:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpRouteActionResult(dict):
    def __init__(__self__, *,
                 auto_host_rewrite: _builtins.bool,
                 backend_group_id: _builtins.str,
                 host_rewrite: _builtins.str,
                 idle_timeout: _builtins.str,
                 prefix_rewrite: _builtins.str,
                 rate_limits: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitResult'],
                 regex_rewrites: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewriteResult'],
                 timeout: _builtins.str,
                 upgrade_types: Sequence[_builtins.str]):
        """
        :param _builtins.bool auto_host_rewrite: If set, will automatically rewrite host.
        :param _builtins.str backend_group_id: Backend group to route requests.
        :param _builtins.str host_rewrite: Host rewrite specifier.
        :param _builtins.str idle_timeout: Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        :param _builtins.str prefix_rewrite: If not empty, matched path prefix will be replaced by this value.
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitArgs'] rate_limits: Rate limit configuration applied for a whole virtual host
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewriteArgs'] regex_rewrites: Replacement for path substrings that match the pattern
        :param _builtins.str timeout: Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        :param Sequence[_builtins.str] upgrade_types: List of upgrade types. Only specified upgrade types will be allowed. For example, `websocket`.
        """
        pulumi.set(__self__, "auto_host_rewrite", auto_host_rewrite)
        pulumi.set(__self__, "backend_group_id", backend_group_id)
        pulumi.set(__self__, "host_rewrite", host_rewrite)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)
        pulumi.set(__self__, "rate_limits", rate_limits)
        pulumi.set(__self__, "regex_rewrites", regex_rewrites)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "upgrade_types", upgrade_types)

    @_builtins.property
    @pulumi.getter(name="autoHostRewrite")
    def auto_host_rewrite(self) -> _builtins.bool:
        """
        If set, will automatically rewrite host.
        """
        return pulumi.get(self, "auto_host_rewrite")

    @_builtins.property
    @pulumi.getter(name="backendGroupId")
    def backend_group_id(self) -> _builtins.str:
        """
        Backend group to route requests.
        """
        return pulumi.get(self, "backend_group_id")

    @_builtins.property
    @pulumi.getter(name="hostRewrite")
    def host_rewrite(self) -> _builtins.str:
        """
        Host rewrite specifier.
        """
        return pulumi.get(self, "host_rewrite")

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> _builtins.str:
        """
        Specifies the idle timeout (time without any data transfer for the active request) for the route. It is useful for streaming scenarios (i.e. long-polling, server-sent events) - one should set idle_timeout to something meaningful and timeout to the maximum time the stream is allowed to be alive. If not specified, there is no per-route idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> _builtins.str:
        """
        If not empty, matched path prefix will be replaced by this value.
        """
        return pulumi.get(self, "prefix_rewrite")

    @_builtins.property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitResult']:
        """
        Rate limit configuration applied for a whole virtual host
        """
        return pulumi.get(self, "rate_limits")

    @_builtins.property
    @pulumi.getter(name="regexRewrites")
    def regex_rewrites(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewriteResult']:
        """
        Replacement for path substrings that match the pattern
        """
        return pulumi.get(self, "regex_rewrites")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Specifies the request timeout (overall time request processing is allowed to take) for the route. If not set, default is 60 seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="upgradeTypes")
    def upgrade_types(self) -> Sequence[_builtins.str]:
        """
        List of upgrade types. Only specified upgrade types will be allowed. For example, `websocket`.
        """
        return pulumi.get(self, "upgrade_types")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitResult(dict):
    def __init__(__self__, *,
                 all_requests: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestResult'],
                 requests_per_ips: Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestArgs'] all_requests: Rate limit configuration applied to all incoming requests
        :param Sequence['GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpArgs'] requests_per_ips: Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        pulumi.set(__self__, "all_requests", all_requests)
        pulumi.set(__self__, "requests_per_ips", requests_per_ips)

    @_builtins.property
    @pulumi.getter(name="allRequests")
    def all_requests(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestResult']:
        """
        Rate limit configuration applied to all incoming requests
        """
        return pulumi.get(self, "all_requests")

    @_builtins.property
    @pulumi.getter(name="requestsPerIps")
    def requests_per_ips(self) -> Sequence['outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpResult']:
        """
        Rate limit configuration applied separately for each set of requests grouped by client IP address
        """
        return pulumi.get(self, "requests_per_ips")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitAllRequestResult(dict):
    def __init__(__self__, *,
                 per_minute: _builtins.int,
                 per_second: _builtins.int):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        pulumi.set(__self__, "per_minute", per_minute)
        pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> _builtins.int:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> _builtins.int:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpRouteActionRateLimitRequestsPerIpResult(dict):
    def __init__(__self__, *,
                 per_minute: _builtins.int,
                 per_second: _builtins.int):
        """
        :param _builtins.int per_minute: Limit value specified with per minute time unit
        :param _builtins.int per_second: Limit value specified with per second time unit
        """
        pulumi.set(__self__, "per_minute", per_minute)
        pulumi.set(__self__, "per_second", per_second)

    @_builtins.property
    @pulumi.getter(name="perMinute")
    def per_minute(self) -> _builtins.int:
        """
        Limit value specified with per minute time unit
        """
        return pulumi.get(self, "per_minute")

    @_builtins.property
    @pulumi.getter(name="perSecond")
    def per_second(self) -> _builtins.int:
        """
        Limit value specified with per second time unit
        """
        return pulumi.get(self, "per_second")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteHttpRouteActionRegexRewriteResult(dict):
    def __init__(__self__, *,
                 regex: _builtins.str,
                 substitute: _builtins.str):
        """
        :param _builtins.str regex: RE2 regular expression
        :param _builtins.str substitute: The string which should be used to substitute matched substrings
        """
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "substitute", substitute)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        RE2 regular expression
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def substitute(self) -> _builtins.str:
        """
        The string which should be used to substitute matched substrings
        """
        return pulumi.get(self, "substitute")


@pulumi.output_type
class GetAlbVirtualHostRouteHttpRouteRedirectActionResult(dict):
    def __init__(__self__, *,
                 remove_query: _builtins.bool,
                 replace_host: _builtins.str,
                 replace_path: _builtins.str,
                 replace_port: _builtins.int,
                 replace_prefix: _builtins.str,
                 replace_scheme: _builtins.str,
                 response_code: _builtins.str):
        """
        :param _builtins.bool remove_query: If set, remove query part.
        :param _builtins.str replace_host: Replaces hostname.
        :param _builtins.str replace_path: Replace path.
        :param _builtins.int replace_port: Replaces port.
        :param _builtins.str replace_prefix: Replace only matched prefix. Example:\\n\\n match:{ prefix*match: `/some` } \\n\\n redirect: { replace*prefix: `/other` } \\n\\n will redirect `/something` to `/otherthing`.
        :param _builtins.str replace_scheme: Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        :param _builtins.str response_code: The HTTP status code to use in the redirect response. Supported values are: `moved_permanently`, `found`, `see_other`, `temporary_redirect`, `permanent_redirect`.
        """
        pulumi.set(__self__, "remove_query", remove_query)
        pulumi.set(__self__, "replace_host", replace_host)
        pulumi.set(__self__, "replace_path", replace_path)
        pulumi.set(__self__, "replace_port", replace_port)
        pulumi.set(__self__, "replace_prefix", replace_prefix)
        pulumi.set(__self__, "replace_scheme", replace_scheme)
        pulumi.set(__self__, "response_code", response_code)

    @_builtins.property
    @pulumi.getter(name="removeQuery")
    def remove_query(self) -> _builtins.bool:
        """
        If set, remove query part.
        """
        return pulumi.get(self, "remove_query")

    @_builtins.property
    @pulumi.getter(name="replaceHost")
    def replace_host(self) -> _builtins.str:
        """
        Replaces hostname.
        """
        return pulumi.get(self, "replace_host")

    @_builtins.property
    @pulumi.getter(name="replacePath")
    def replace_path(self) -> _builtins.str:
        """
        Replace path.
        """
        return pulumi.get(self, "replace_path")

    @_builtins.property
    @pulumi.getter(name="replacePort")
    def replace_port(self) -> _builtins.int:
        """
        Replaces port.
        """
        return pulumi.get(self, "replace_port")

    @_builtins.property
    @pulumi.getter(name="replacePrefix")
    def replace_prefix(self) -> _builtins.str:
        """
        Replace only matched prefix. Example:\\n\\n match:{ prefix*match: `/some` } \\n\\n redirect: { replace*prefix: `/other` } \\n\\n will redirect `/something` to `/otherthing`.
        """
        return pulumi.get(self, "replace_prefix")

    @_builtins.property
    @pulumi.getter(name="replaceScheme")
    def replace_scheme(self) -> _builtins.str:
        """
        Replaces scheme. If the original scheme is `http` or `https`, will also remove the 80 or 443 port, if present.
        """
        return pulumi.get(self, "replace_scheme")

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> _builtins.str:
        """
        The HTTP status code to use in the redirect response. Supported values are: `moved_permanently`, `found`, `see_other`, `temporary_redirect`, `permanent_redirect`.
        """
        return pulumi.get(self, "response_code")


@pulumi.output_type
class GetAlbVirtualHostRouteOptionResult(dict):
    def __init__(__self__, *,
                 rbacs: Sequence['outputs.GetAlbVirtualHostRouteOptionRbacResult'],
                 security_profile_id: Optional[_builtins.str] = None):
        """
        :param Sequence['GetAlbVirtualHostRouteOptionRbacArgs'] rbacs: RBAC configuration.
        :param _builtins.str security_profile_id: SWS profile ID.
        """
        pulumi.set(__self__, "rbacs", rbacs)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @_builtins.property
    @pulumi.getter
    def rbacs(self) -> Sequence['outputs.GetAlbVirtualHostRouteOptionRbacResult']:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbacs")

    @_builtins.property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[_builtins.str]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")


@pulumi.output_type
class GetAlbVirtualHostRouteOptionRbacResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 principals: Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalResult']):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalResult']:
        return pulumi.get(self, "principals")


@pulumi.output_type
class GetAlbVirtualHostRouteOptionRbacPrincipalResult(dict):
    def __init__(__self__, *,
                 and_principals: Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalResult']):
        pulumi.set(__self__, "and_principals", and_principals)

    @_builtins.property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalResult']:
        return pulumi.get(self, "and_principals")


@pulumi.output_type
class GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalResult(dict):
    def __init__(__self__, *,
                 any: _builtins.bool,
                 headers: Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderResult'],
                 remote_ip: _builtins.str):
        pulumi.set(__self__, "any", any)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter
    def any(self) -> _builtins.bool:
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> _builtins.str:
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValueResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValueArgs'] values: The `path` and `fqmn` blocks.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValueResult']:
        """
        The `path` and `fqmn` blocks.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact: _builtins.str,
                 prefix: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> _builtins.str:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAlbVirtualHostRouteRouteOptionResult(dict):
    def __init__(__self__, *,
                 rbacs: Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacResult'],
                 security_profile_id: Optional[_builtins.str] = None):
        """
        :param Sequence['GetAlbVirtualHostRouteRouteOptionRbacArgs'] rbacs: RBAC configuration.
        :param _builtins.str security_profile_id: SWS profile ID.
        """
        pulumi.set(__self__, "rbacs", rbacs)
        if security_profile_id is not None:
            pulumi.set(__self__, "security_profile_id", security_profile_id)

    @_builtins.property
    @pulumi.getter
    def rbacs(self) -> Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacResult']:
        """
        RBAC configuration.
        """
        return pulumi.get(self, "rbacs")

    @_builtins.property
    @pulumi.getter(name="securityProfileId")
    def security_profile_id(self) -> Optional[_builtins.str]:
        """
        SWS profile ID.
        """
        return pulumi.get(self, "security_profile_id")


@pulumi.output_type
class GetAlbVirtualHostRouteRouteOptionRbacResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 principals: Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalResult']):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalResult']:
        return pulumi.get(self, "principals")


@pulumi.output_type
class GetAlbVirtualHostRouteRouteOptionRbacPrincipalResult(dict):
    def __init__(__self__, *,
                 and_principals: Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalResult']):
        pulumi.set(__self__, "and_principals", and_principals)

    @_builtins.property
    @pulumi.getter(name="andPrincipals")
    def and_principals(self) -> Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalResult']:
        return pulumi.get(self, "and_principals")


@pulumi.output_type
class GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalResult(dict):
    def __init__(__self__, *,
                 any: _builtins.bool,
                 headers: Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderResult'],
                 remote_ip: _builtins.str):
        pulumi.set(__self__, "any", any)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "remote_ip", remote_ip)

    @_builtins.property
    @pulumi.getter
    def any(self) -> _builtins.bool:
        return pulumi.get(self, "any")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="remoteIp")
    def remote_ip(self) -> _builtins.str:
        return pulumi.get(self, "remote_ip")


@pulumi.output_type
class GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValueResult']):
        """
        :param Sequence['GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValueArgs'] values: The `path` and `fqmn` blocks.
               
               > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValueResult']:
        """
        The `path` and `fqmn` blocks.

        > Exactly one type of string matches `exact`, `prefix` or `regex` should be specified.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact: _builtins.str,
                 prefix: _builtins.str,
                 regex: _builtins.str):
        """
        :param _builtins.str exact: Match exactly.
        :param _builtins.str prefix: Match prefix.
        :param _builtins.str regex: Match regex.
        """
        pulumi.set(__self__, "exact", exact)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> _builtins.str:
        """
        Match exactly.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Match prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        Match regex.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetApiGatewayCanaryResult(dict):
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, _builtins.str]] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param Mapping[str, _builtins.str] variables: A list of values for variables in gateway specification of canary release.
        :param _builtins.int weight: Percentage of requests, which will be processed by canary release.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of values for variables in gateway specification of canary release.
        """
        return pulumi.get(self, "variables")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Percentage of requests, which will be processed by canary release.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetApiGatewayConnectivityResult(dict):
    def __init__(__self__, *,
                 network_id: _builtins.str):
        """
        :param _builtins.str network_id: Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network the gateway will have access to. It's essential to specify network with subnets in all availability zones.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class GetApiGatewayCustomDomainResult(dict):
    def __init__(__self__, *,
                 certificate_id: _builtins.str,
                 domain_id: _builtins.str,
                 fqdn: _builtins.str):
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetApiGatewayLogOptionResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 folder_id: _builtins.str,
                 log_group_id: _builtins.str,
                 min_level: _builtins.str):
        """
        :param _builtins.bool disabled: Is logging from Yandex Cloud API Gateway disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Is logging from Yandex Cloud API Gateway disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> _builtins.str:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class GetAuditTrailsTrailDataStreamDestinationResult(dict):
    def __init__(__self__, *,
                 database_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str database_id: ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        :param _builtins.str stream_name: Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        ID of the [YDB](https://yandex.cloud/docs/ydb/concepts/resources) hosting the destination data stream.
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Name of the [YDS stream](https://yandex.cloud/docs/data-streams/concepts/glossary#stream-concepts) belonging to the specified YDB.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetAuditTrailsTrailFilterResult(dict):
    def __init__(__self__, *,
                 event_filters: Sequence['outputs.GetAuditTrailsTrailFilterEventFilterResult'],
                 path_filters: Sequence['outputs.GetAuditTrailsTrailFilterPathFilterResult']):
        """
        :param Sequence['GetAuditTrailsTrailFilterEventFilterArgs'] event_filters: Deprecated.
        :param Sequence['GetAuditTrailsTrailFilterPathFilterArgs'] path_filters: Deprecated.
        """
        pulumi.set(__self__, "event_filters", event_filters)
        pulumi.set(__self__, "path_filters", path_filters)

    @_builtins.property
    @pulumi.getter(name="eventFilters")
    def event_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterEventFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "event_filters")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterPathFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "path_filters")


@pulumi.output_type
class GetAuditTrailsTrailFilterEventFilterResult(dict):
    def __init__(__self__, *,
                 categories: Sequence['outputs.GetAuditTrailsTrailFilterEventFilterCategoryResult'],
                 path_filters: Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterResult'],
                 service: _builtins.str):
        """
        :param Sequence['GetAuditTrailsTrailFilterEventFilterCategoryArgs'] categories: Deprecated.
        :param Sequence['GetAuditTrailsTrailFilterEventFilterPathFilterArgs'] path_filters: Deprecated.
        :param _builtins.str service: Deprecated.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "path_filters", path_filters)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.GetAuditTrailsTrailFilterEventFilterCategoryResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter(name="pathFilters")
    def path_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "path_filters")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetAuditTrailsTrailFilterEventFilterCategoryResult(dict):
    def __init__(__self__, *,
                 plane: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str plane: Deprecated.
        :param _builtins.str type: Deprecated.
        """
        pulumi.set(__self__, "plane", plane)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def plane(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "plane")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAuditTrailsTrailFilterEventFilterPathFilterResult(dict):
    def __init__(__self__, *,
                 any_filters: Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilterResult'],
                 some_filters: Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterResult']):
        """
        :param Sequence['GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilterArgs'] any_filters: Deprecated.
        :param Sequence['GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterArgs'] some_filters: Deprecated.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "some_filters", some_filters)

    @_builtins.property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filters")

    @_builtins.property
    @pulumi.getter(name="someFilters")
    def some_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "some_filters")


@pulumi.output_type
class GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilterResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterResult(dict):
    def __init__(__self__, *,
                 any_filters: Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterResult'],
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param Sequence['GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterArgs'] any_filters: Deprecated.
        :param _builtins.str resource_id: Deprecated.
        :param _builtins.str resource_type: Deprecated.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filters")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilterResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilterPathFilterResult(dict):
    def __init__(__self__, *,
                 any_filters: Sequence['outputs.GetAuditTrailsTrailFilterPathFilterAnyFilterResult'],
                 some_filters: Sequence['outputs.GetAuditTrailsTrailFilterPathFilterSomeFilterResult']):
        """
        :param Sequence['GetAuditTrailsTrailFilterPathFilterAnyFilterArgs'] any_filters: Deprecated.
        :param Sequence['GetAuditTrailsTrailFilterPathFilterSomeFilterArgs'] some_filters: Deprecated.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "some_filters", some_filters)

    @_builtins.property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterPathFilterAnyFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filters")

    @_builtins.property
    @pulumi.getter(name="someFilters")
    def some_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterPathFilterSomeFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "some_filters")


@pulumi.output_type
class GetAuditTrailsTrailFilterPathFilterAnyFilterResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilterPathFilterSomeFilterResult(dict):
    def __init__(__self__, *,
                 any_filters: Sequence['outputs.GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilterResult'],
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param Sequence['GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilterArgs'] any_filters: Deprecated.
        :param _builtins.str resource_id: Deprecated.
        :param _builtins.str resource_type: Deprecated.
        """
        pulumi.set(__self__, "any_filters", any_filters)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="anyFilters")
    def any_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilterResult']:
        """
        Deprecated.
        """
        return pulumi.get(self, "any_filters")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Deprecated.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilterResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilteringPolicyResult(dict):
    def __init__(__self__, *,
                 data_events_filters: Sequence['outputs.GetAuditTrailsTrailFilteringPolicyDataEventsFilterResult'],
                 management_events_filters: Sequence['outputs.GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResult']):
        """
        :param Sequence['GetAuditTrailsTrailFilteringPolicyDataEventsFilterArgs'] data_events_filters: Structure describing filtering process for the service-specific data events.
        :param Sequence['GetAuditTrailsTrailFilteringPolicyManagementEventsFilterArgs'] management_events_filters: Structure describing filtering process for management events.
        """
        pulumi.set(__self__, "data_events_filters", data_events_filters)
        pulumi.set(__self__, "management_events_filters", management_events_filters)

    @_builtins.property
    @pulumi.getter(name="dataEventsFilters")
    def data_events_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilteringPolicyDataEventsFilterResult']:
        """
        Structure describing filtering process for the service-specific data events.
        """
        return pulumi.get(self, "data_events_filters")

    @_builtins.property
    @pulumi.getter(name="managementEventsFilters")
    def management_events_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResult']:
        """
        Structure describing filtering process for management events.
        """
        return pulumi.get(self, "management_events_filters")


@pulumi.output_type
class GetAuditTrailsTrailFilteringPolicyDataEventsFilterResult(dict):
    def __init__(__self__, *,
                 dns_filters: Sequence['outputs.GetAuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilterResult'],
                 excluded_events: Sequence[_builtins.str],
                 included_events: Sequence[_builtins.str],
                 resource_scopes: Sequence['outputs.GetAuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeResult'],
                 service: _builtins.str):
        """
        :param Sequence['GetAuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilterArgs'] dns_filters: Specific filter for DNS service.
        :param Sequence[_builtins.str] excluded_events: A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        :param Sequence[_builtins.str] included_events: A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        :param Sequence['GetAuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeArgs'] resource_scopes: Structure describing that events will be gathered from the specified resource.
        :param _builtins.str service: ID of the service which events will be gathered.
        """
        pulumi.set(__self__, "dns_filters", dns_filters)
        pulumi.set(__self__, "excluded_events", excluded_events)
        pulumi.set(__self__, "included_events", included_events)
        pulumi.set(__self__, "resource_scopes", resource_scopes)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter(name="dnsFilters")
    def dns_filters(self) -> Sequence['outputs.GetAuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilterResult']:
        """
        Specific filter for DNS service.
        """
        return pulumi.get(self, "dns_filters")

    @_builtins.property
    @pulumi.getter(name="excludedEvents")
    def excluded_events(self) -> Sequence[_builtins.str]:
        """
        A list of events that won't be gathered by the trail from this service. New events will be automatically gathered when this option is specified. Mutually exclusive with `included_events`.
        """
        return pulumi.get(self, "excluded_events")

    @_builtins.property
    @pulumi.getter(name="includedEvents")
    def included_events(self) -> Sequence[_builtins.str]:
        """
        A list of events that will be gathered by the trail from this service. New events won't be gathered by default when this option is specified. Mutually exclusive with `excluded_events`.
        """
        return pulumi.get(self, "included_events")

    @_builtins.property
    @pulumi.getter(name="resourceScopes")
    def resource_scopes(self) -> Sequence['outputs.GetAuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeResult']:
        """
        Structure describing that events will be gathered from the specified resource.
        """
        return pulumi.get(self, "resource_scopes")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        ID of the service which events will be gathered.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetAuditTrailsTrailFilteringPolicyDataEventsFilterDnsFilterResult(dict):
    def __init__(__self__, *,
                 include_nonrecursive_queries: _builtins.bool):
        """
        :param _builtins.bool include_nonrecursive_queries: All types of queries will be delivered.
        """
        pulumi.set(__self__, "include_nonrecursive_queries", include_nonrecursive_queries)

    @_builtins.property
    @pulumi.getter(name="includeNonrecursiveQueries")
    def include_nonrecursive_queries(self) -> _builtins.bool:
        """
        All types of queries will be delivered.
        """
        return pulumi.get(self, "include_nonrecursive_queries")


@pulumi.output_type
class GetAuditTrailsTrailFilteringPolicyDataEventsFilterResourceScopeResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResult(dict):
    def __init__(__self__, *,
                 resource_scopes: Sequence['outputs.GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeResult']):
        """
        :param Sequence['GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeArgs'] resource_scopes: Structure describing that events will be gathered from the specified resource.
        """
        pulumi.set(__self__, "resource_scopes", resource_scopes)

    @_builtins.property
    @pulumi.getter(name="resourceScopes")
    def resource_scopes(self) -> Sequence['outputs.GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeResult']:
        """
        Structure describing that events will be gathered from the specified resource.
        """
        return pulumi.get(self, "resource_scopes")


@pulumi.output_type
class GetAuditTrailsTrailFilteringPolicyManagementEventsFilterResourceScopeResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str resource_id: Resource ID.
        :param _builtins.str resource_type: Resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAuditTrailsTrailLoggingDestinationResult(dict):
    def __init__(__self__, *,
                 log_group_id: _builtins.str):
        """
        :param _builtins.str log_group_id: ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        ID of the destination [Cloud Logging Group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class GetAuditTrailsTrailStorageDestinationResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 object_prefix: _builtins.str):
        """
        :param _builtins.str bucket_name: Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        :param _builtins.str object_prefix: Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "object_prefix", object_prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Name of the [destination bucket](https://yandex.cloud/docs/storage/concepts/bucket).
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> _builtins.str:
        """
        Additional prefix of the uploaded objects. If not specified, objects will be uploaded with prefix equal to `trail_id`.
        """
        return pulumi.get(self, "object_prefix")


@pulumi.output_type
class GetBackupPolicyFileFilterResult(dict):
    def __init__(__self__, *,
                 exclusion_masks: Sequence[_builtins.str],
                 inclusion_masks: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] exclusion_masks: Do not backup files that match the following criteria.
        :param Sequence[_builtins.str] inclusion_masks: Backup only files that match the following criteria.
        """
        pulumi.set(__self__, "exclusion_masks", exclusion_masks)
        pulumi.set(__self__, "inclusion_masks", inclusion_masks)

    @_builtins.property
    @pulumi.getter(name="exclusionMasks")
    def exclusion_masks(self) -> Sequence[_builtins.str]:
        """
        Do not backup files that match the following criteria.
        """
        return pulumi.get(self, "exclusion_masks")

    @_builtins.property
    @pulumi.getter(name="inclusionMasks")
    def inclusion_masks(self) -> Sequence[_builtins.str]:
        """
        Backup only files that match the following criteria.
        """
        return pulumi.get(self, "inclusion_masks")


@pulumi.output_type
class GetBackupPolicyReattemptResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 interval: _builtins.str,
                 max_attempts: _builtins.int):
        """
        :param _builtins.bool enabled: Enable flag. Default `true`.
        :param _builtins.str interval: Retry interval. See `interval_type` for available values. Default: `5m`.
        :param _builtins.int max_attempts: Maximum number of attempts before throwing an error. Default `5`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "max_attempts", max_attempts)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable flag. Default `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Retry interval. See `interval_type` for available values. Default: `5m`.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> _builtins.int:
        """
        Maximum number of attempts before throwing an error. Default `5`.
        """
        return pulumi.get(self, "max_attempts")


@pulumi.output_type
class GetBackupPolicyRetentionResult(dict):
    def __init__(__self__, *,
                 after_backup: _builtins.bool,
                 rules: Sequence['outputs.GetBackupPolicyRetentionRuleResult']):
        """
        :param _builtins.bool after_backup: Defines whether retention rule applies after creating backup or before.
        :param Sequence['GetBackupPolicyRetentionRuleArgs'] rules: A list of retention rules.
        """
        pulumi.set(__self__, "after_backup", after_backup)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="afterBackup")
    def after_backup(self) -> _builtins.bool:
        """
        Defines whether retention rule applies after creating backup or before.
        """
        return pulumi.get(self, "after_backup")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetBackupPolicyRetentionRuleResult']:
        """
        A list of retention rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetBackupPolicyRetentionRuleResult(dict):
    def __init__(__self__, *,
                 max_age: Optional[_builtins.str] = None,
                 max_count: Optional[_builtins.int] = None,
                 repeat_periods: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str max_age: Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        :param _builtins.int max_count: Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        :param Sequence[_builtins.str] repeat_periods: Possible types: `REPEATE_PERIOD_UNSPECIFIED`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`. Specifies repeat period of the backupset.
        """
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if repeat_periods is not None:
            pulumi.set(__self__, "repeat_periods", repeat_periods)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        Deletes backups that older than `max_age`. Exactly one of `max_count` or `max_age` should be set.
        """
        return pulumi.get(self, "max_age")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Deletes backups if it's count exceeds `max_count`. Exactly one of `max_count` or `max_age` should be set.
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="repeatPeriods")
    def repeat_periods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Possible types: `REPEATE_PERIOD_UNSPECIFIED`, `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`. Specifies repeat period of the backupset.
        """
        return pulumi.get(self, "repeat_periods")


@pulumi.output_type
class GetBackupPolicySchedulingResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 max_parallel_backups: _builtins.int,
                 random_max_delay: _builtins.str,
                 scheme: _builtins.str,
                 weekly_backup_day: _builtins.str,
                 backup_sets: Optional[Sequence['outputs.GetBackupPolicySchedulingBackupSetResult']] = None):
        """
        :param _builtins.bool enabled: Enables or disables scheduling. Default `true`.
        :param _builtins.int max_parallel_backups: Maximum number of backup processes allowed to run in parallel. 0 for unlimited. Default `0`.
        :param _builtins.str random_max_delay: Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values. Default `30m`.
        :param _builtins.str scheme: Scheme of the backups. Available values are: `ALWAYS_INCREMENTAL`, `ALWAYS_FULL`, `WEEKLY_FULL_DAILY_INCREMENTAL`, `WEEKLY_INCREMENTAL`. Default `ALWAYS_INCREMENTAL`.
        :param _builtins.str weekly_backup_day: A day of week to start weekly backups. See `day_type` for available values. Default `MONDAY`.
        :param Sequence['GetBackupPolicySchedulingBackupSetArgs'] backup_sets: A list of schedules with backup sets that compose the whole scheme.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "max_parallel_backups", max_parallel_backups)
        pulumi.set(__self__, "random_max_delay", random_max_delay)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "weekly_backup_day", weekly_backup_day)
        if backup_sets is not None:
            pulumi.set(__self__, "backup_sets", backup_sets)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enables or disables scheduling. Default `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxParallelBackups")
    def max_parallel_backups(self) -> _builtins.int:
        """
        Maximum number of backup processes allowed to run in parallel. 0 for unlimited. Default `0`.
        """
        return pulumi.get(self, "max_parallel_backups")

    @_builtins.property
    @pulumi.getter(name="randomMaxDelay")
    def random_max_delay(self) -> _builtins.str:
        """
        Configuration of the random delay between the execution of parallel tasks. See `interval_type` for available values. Default `30m`.
        """
        return pulumi.get(self, "random_max_delay")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> _builtins.str:
        """
        Scheme of the backups. Available values are: `ALWAYS_INCREMENTAL`, `ALWAYS_FULL`, `WEEKLY_FULL_DAILY_INCREMENTAL`, `WEEKLY_INCREMENTAL`. Default `ALWAYS_INCREMENTAL`.
        """
        return pulumi.get(self, "scheme")

    @_builtins.property
    @pulumi.getter(name="weeklyBackupDay")
    def weekly_backup_day(self) -> _builtins.str:
        """
        A day of week to start weekly backups. See `day_type` for available values. Default `MONDAY`.
        """
        return pulumi.get(self, "weekly_backup_day")

    @_builtins.property
    @pulumi.getter(name="backupSets")
    def backup_sets(self) -> Optional[Sequence['outputs.GetBackupPolicySchedulingBackupSetResult']]:
        """
        A list of schedules with backup sets that compose the whole scheme.
        """
        return pulumi.get(self, "backup_sets")


@pulumi.output_type
class GetBackupPolicySchedulingBackupSetResult(dict):
    def __init__(__self__, *,
                 execute_by_interval: _builtins.int,
                 execute_by_times: Sequence['outputs.GetBackupPolicySchedulingBackupSetExecuteByTimeResult'],
                 type: _builtins.str):
        """
        :param _builtins.int execute_by_interval: Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param Sequence['GetBackupPolicySchedulingBackupSetExecuteByTimeArgs'] execute_by_times: Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        :param _builtins.str type: BackupSet type. See `backup_set_type` for available values. Default `TYPE_AUTO`.
        """
        pulumi.set(__self__, "execute_by_interval", execute_by_interval)
        pulumi.set(__self__, "execute_by_times", execute_by_times)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="executeByInterval")
    def execute_by_interval(self) -> _builtins.int:
        """
        Perform backup by interval, since last backup of the host. Maximum value is: 9999 days. See `interval_type` for available values. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_interval")

    @_builtins.property
    @pulumi.getter(name="executeByTimes")
    def execute_by_times(self) -> Sequence['outputs.GetBackupPolicySchedulingBackupSetExecuteByTimeResult']:
        """
        Perform backup periodically at specific time. Exactly on of options should be set: `execute_by_interval` or `execute_by_time`.
        """
        return pulumi.get(self, "execute_by_times")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        BackupSet type. See `backup_set_type` for available values. Default `TYPE_AUTO`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBackupPolicySchedulingBackupSetExecuteByTimeResult(dict):
    def __init__(__self__, *,
                 include_last_day_of_month: _builtins.bool,
                 monthdays: Sequence[_builtins.int],
                 months: Sequence[_builtins.int],
                 repeat_ats: Sequence[_builtins.str],
                 repeat_every: _builtins.str,
                 run_later: _builtins.bool,
                 type: _builtins.str,
                 weekdays: Sequence[_builtins.str]):
        """
        :param _builtins.bool include_last_day_of_month: If true, schedule will be applied on the last day of month. See `day_type` for available values. Default `false`.
        :param Sequence[_builtins.int] monthdays: List of days when schedule applies. Used in `MONTHLY` type.
        :param Sequence[_builtins.int] months: Set of values. Allowed values form 1 to 12.
        :param Sequence[_builtins.str] repeat_ats: List of time in format `HH:MM` (24-hours format), when the schedule applies.
        :param _builtins.str repeat_every: Frequency of backup repetition. See `interval_type` for available values.
        :param _builtins.bool run_later: If true and if the machine is off, launch missed tasks on boot up. Default `false`.
        :param _builtins.str type: Type of the scheduling. Available values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        :param Sequence[_builtins.str] weekdays: List of weekdays when the backup will be applied. Used in `WEEKLY` type.
        """
        pulumi.set(__self__, "include_last_day_of_month", include_last_day_of_month)
        pulumi.set(__self__, "monthdays", monthdays)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "repeat_ats", repeat_ats)
        pulumi.set(__self__, "repeat_every", repeat_every)
        pulumi.set(__self__, "run_later", run_later)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter(name="includeLastDayOfMonth")
    def include_last_day_of_month(self) -> _builtins.bool:
        """
        If true, schedule will be applied on the last day of month. See `day_type` for available values. Default `false`.
        """
        return pulumi.get(self, "include_last_day_of_month")

    @_builtins.property
    @pulumi.getter
    def monthdays(self) -> Sequence[_builtins.int]:
        """
        List of days when schedule applies. Used in `MONTHLY` type.
        """
        return pulumi.get(self, "monthdays")

    @_builtins.property
    @pulumi.getter
    def months(self) -> Sequence[_builtins.int]:
        """
        Set of values. Allowed values form 1 to 12.
        """
        return pulumi.get(self, "months")

    @_builtins.property
    @pulumi.getter(name="repeatAts")
    def repeat_ats(self) -> Sequence[_builtins.str]:
        """
        List of time in format `HH:MM` (24-hours format), when the schedule applies.
        """
        return pulumi.get(self, "repeat_ats")

    @_builtins.property
    @pulumi.getter(name="repeatEvery")
    def repeat_every(self) -> _builtins.str:
        """
        Frequency of backup repetition. See `interval_type` for available values.
        """
        return pulumi.get(self, "repeat_every")

    @_builtins.property
    @pulumi.getter(name="runLater")
    def run_later(self) -> _builtins.bool:
        """
        If true and if the machine is off, launch missed tasks on boot up. Default `false`.
        """
        return pulumi.get(self, "run_later")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the scheduling. Available values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Sequence[_builtins.str]:
        """
        List of weekdays when the backup will be applied. Used in `WEEKLY` type.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class GetBackupPolicyVmSnapshotReattemptResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 interval: _builtins.str,
                 max_attempts: _builtins.int):
        """
        :param _builtins.bool enabled: Enable flag. Default `true`.
        :param _builtins.str interval: Retry interval. See `interval_type` for available values. Default: `5m`.
        :param _builtins.int max_attempts: Maximum number of attempts before throwing an error. Default `5`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "max_attempts", max_attempts)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable flag. Default `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        Retry interval. See `interval_type` for available values. Default: `5m`.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxAttempts")
    def max_attempts(self) -> _builtins.int:
        """
        Maximum number of attempts before throwing an error. Default `5`.
        """
        return pulumi.get(self, "max_attempts")


@pulumi.output_type
class GetCdnOriginGroupOriginResult(dict):
    def __init__(__self__, *,
                 origin_group_id: _builtins.int,
                 source: _builtins.str,
                 backup: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str source: IP address or Domain name of your origin and the port.
        :param _builtins.bool backup: Specifies whether the origin is used in its origin group as backup. A backup origin is used when one of active origins becomes unavailable.
        :param _builtins.bool enabled: The origin is enabled and used as a source for the CDN. Default `enabled`.
        """
        pulumi.set(__self__, "origin_group_id", origin_group_id)
        pulumi.set(__self__, "source", source)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="originGroupId")
    def origin_group_id(self) -> _builtins.int:
        return pulumi.get(self, "origin_group_id")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        IP address or Domain name of your origin and the port.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def backup(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the origin is used in its origin group as backup. A backup origin is used when one of active origins becomes unavailable.
        """
        return pulumi.get(self, "backup")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        The origin is enabled and used as a source for the CDN. Default `enabled`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetCdnResourceOptionsResult(dict):
    def __init__(__self__, *,
                 allowed_http_methods: Sequence[_builtins.str],
                 browser_cache_settings: _builtins.int,
                 cache_http_headers: Sequence[_builtins.str],
                 cors: Sequence[_builtins.str],
                 custom_host_header: _builtins.str,
                 custom_server_name: _builtins.str,
                 disable_cache: _builtins.bool,
                 disable_proxy_force_ranges: _builtins.bool,
                 edge_cache_settings: _builtins.int,
                 enable_ip_url_signing: _builtins.bool,
                 fetched_compressed: _builtins.bool,
                 forward_host_header: _builtins.bool,
                 gzip_on: _builtins.bool,
                 ignore_cookie: _builtins.bool,
                 ignore_query_params: _builtins.bool,
                 ip_address_acl: 'outputs.GetCdnResourceOptionsIpAddressAclResult',
                 proxy_cache_methods_set: _builtins.bool,
                 query_params_blacklists: Sequence[_builtins.str],
                 query_params_whitelists: Sequence[_builtins.str],
                 redirect_http_to_https: _builtins.bool,
                 redirect_https_to_http: _builtins.bool,
                 secure_key: _builtins.str,
                 slice: _builtins.bool,
                 static_request_headers: Mapping[str, _builtins.str],
                 static_response_headers: Mapping[str, _builtins.str]):
        """
        :param Sequence[_builtins.str] allowed_http_methods: HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response. HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        :param _builtins.int browser_cache_settings: Set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days. Set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        :param Sequence[_builtins.str] cache_http_headers: List HTTP headers that must be included in responses to clients. List HTTP headers that must be included in responses to clients.
        :param Sequence[_builtins.str] cors: Parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received. Parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        :param _builtins.str custom_host_header: Custom value for the Host header. Your server must be able to process requests with the chosen header. Custom value for the Host header. Your server must be able to process requests with the chosen header.
        :param _builtins.str custom_server_name: Wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS.
        :param _builtins.bool disable_cache: Setup a cache status. Setup a cache status.
        :param _builtins.bool disable_proxy_force_ranges: Disabling proxy force ranges. Disabling proxy force ranges.
        :param _builtins.int edge_cache_settings: Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached. Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        :param _builtins.bool enable_ip_url_signing: Enable access limiting by IP addresses, option available only with setting secure*key. Enable access limiting by IP addresses, option available only with setting secure*key.
        :param _builtins.bool fetched_compressed: Option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN. Option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        :param _builtins.bool forward_host_header: Choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server. Choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        :param _builtins.bool gzip_on: GZip compression at CDN servers reduces file size by 70% and can be as high as 90%. GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        :param _builtins.bool ignore_cookie: Set for ignoring cookie. Set for ignoring cookie.
        :param _builtins.bool ignore_query_params: Files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default. Files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        :param 'GetCdnResourceOptionsIpAddressAclArgs' ip_address_acl: IP address access control list. The list of specified IP addresses to be allowed or denied depending on acl policy type.
        :param _builtins.bool proxy_cache_methods_set: Allows caching for GET, HEAD and POST requests. Allows caching for GET, HEAD and POST requests.
        :param Sequence[_builtins.str] query_params_blacklists: Files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys. Files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        :param Sequence[_builtins.str] query_params_whitelists: Files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key. Files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        :param _builtins.bool redirect_http_to_https: Set up a redirect from HTTP to HTTPS. Set up a redirect from HTTP to HTTPS.
        :param _builtins.bool redirect_https_to_http: Set up a redirect from HTTPS to HTTP. Set up a redirect from HTTPS to HTTP.
        :param _builtins.str secure_key: Set secure key for url encoding to protect contect and limit access by IP addresses and time limits. Set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        :param _builtins.bool slice: Files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests. Files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        :param Mapping[str, _builtins.str] static_request_headers: Set up custom headers that CDN servers will send in requests to origins. Set up custom headers that CDN servers will send in requests to origins.
        :param Mapping[str, _builtins.str] static_response_headers: Set up a static response header. The header name must be lowercase. Set up a static response header. The header name must be lowercase.
        """
        pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        pulumi.set(__self__, "browser_cache_settings", browser_cache_settings)
        pulumi.set(__self__, "cache_http_headers", cache_http_headers)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "custom_host_header", custom_host_header)
        pulumi.set(__self__, "custom_server_name", custom_server_name)
        pulumi.set(__self__, "disable_cache", disable_cache)
        pulumi.set(__self__, "disable_proxy_force_ranges", disable_proxy_force_ranges)
        pulumi.set(__self__, "edge_cache_settings", edge_cache_settings)
        pulumi.set(__self__, "enable_ip_url_signing", enable_ip_url_signing)
        pulumi.set(__self__, "fetched_compressed", fetched_compressed)
        pulumi.set(__self__, "forward_host_header", forward_host_header)
        pulumi.set(__self__, "gzip_on", gzip_on)
        pulumi.set(__self__, "ignore_cookie", ignore_cookie)
        pulumi.set(__self__, "ignore_query_params", ignore_query_params)
        pulumi.set(__self__, "ip_address_acl", ip_address_acl)
        pulumi.set(__self__, "proxy_cache_methods_set", proxy_cache_methods_set)
        pulumi.set(__self__, "query_params_blacklists", query_params_blacklists)
        pulumi.set(__self__, "query_params_whitelists", query_params_whitelists)
        pulumi.set(__self__, "redirect_http_to_https", redirect_http_to_https)
        pulumi.set(__self__, "redirect_https_to_http", redirect_https_to_http)
        pulumi.set(__self__, "secure_key", secure_key)
        pulumi.set(__self__, "slice", slice)
        pulumi.set(__self__, "static_request_headers", static_request_headers)
        pulumi.set(__self__, "static_response_headers", static_response_headers)

    @_builtins.property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Sequence[_builtins.str]:
        """
        HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response. HTTP methods for your CDN content. By default the following methods are allowed: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS. In case some methods are not allowed to the user, they will get the 405 (Method Not Allowed) response. If the method is not supported, the user gets the 501 (Not Implemented) response.
        """
        return pulumi.get(self, "allowed_http_methods")

    @_builtins.property
    @pulumi.getter(name="browserCacheSettings")
    def browser_cache_settings(self) -> _builtins.int:
        """
        Set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days. Set up a cache period for the end-users browser. Content will be cached due to origin settings. If there are no cache settings on your origin, the content will not be cached. The list of HTTP response codes that can be cached in browsers: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Other response codes will not be cached. The default value is 4 days.
        """
        return pulumi.get(self, "browser_cache_settings")

    @_builtins.property
    @pulumi.getter(name="cacheHttpHeaders")
    def cache_http_headers(self) -> Sequence[_builtins.str]:
        """
        List HTTP headers that must be included in responses to clients. List HTTP headers that must be included in responses to clients.
        """
        return pulumi.get(self, "cache_http_headers")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Sequence[_builtins.str]:
        """
        Parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received. Parameter that lets browsers get access to selected resources from a domain different to a domain from which the request is received.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="customHostHeader")
    def custom_host_header(self) -> _builtins.str:
        """
        Custom value for the Host header. Your server must be able to process requests with the chosen header. Custom value for the Host header. Your server must be able to process requests with the chosen header.
        """
        return pulumi.get(self, "custom_host_header")

    @_builtins.property
    @pulumi.getter(name="customServerName")
    def custom_server_name(self) -> _builtins.str:
        """
        Wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS. Wildcard additional CNAME. If a resource has a wildcard additional CNAME, you can use your own certificate for content delivery via HTTPS.
        """
        return pulumi.get(self, "custom_server_name")

    @_builtins.property
    @pulumi.getter(name="disableCache")
    def disable_cache(self) -> _builtins.bool:
        """
        Setup a cache status. Setup a cache status.
        """
        return pulumi.get(self, "disable_cache")

    @_builtins.property
    @pulumi.getter(name="disableProxyForceRanges")
    def disable_proxy_force_ranges(self) -> _builtins.bool:
        """
        Disabling proxy force ranges. Disabling proxy force ranges.
        """
        return pulumi.get(self, "disable_proxy_force_ranges")

    @_builtins.property
    @pulumi.getter(name="edgeCacheSettings")
    def edge_cache_settings(self) -> _builtins.int:
        """
        Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached. Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308 if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
        """
        return pulumi.get(self, "edge_cache_settings")

    @_builtins.property
    @pulumi.getter(name="enableIpUrlSigning")
    def enable_ip_url_signing(self) -> _builtins.bool:
        """
        Enable access limiting by IP addresses, option available only with setting secure*key. Enable access limiting by IP addresses, option available only with setting secure*key.
        """
        return pulumi.get(self, "enable_ip_url_signing")

    @_builtins.property
    @pulumi.getter(name="fetchedCompressed")
    def fetched_compressed(self) -> _builtins.bool:
        """
        Option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN. Option helps you to reduce the bandwidth between origin and CDN servers. Also, content delivery speed becomes higher because of reducing the time for compressing files in a CDN.
        """
        return pulumi.get(self, "fetched_compressed")

    @_builtins.property
    @pulumi.getter(name="forwardHostHeader")
    def forward_host_header(self) -> _builtins.bool:
        """
        Choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server. Choose the Forward Host header option if is important to send in the request to the Origin the same Host header as was sent in the request to CDN server.
        """
        return pulumi.get(self, "forward_host_header")

    @_builtins.property
    @pulumi.getter(name="gzipOn")
    def gzip_on(self) -> _builtins.bool:
        """
        GZip compression at CDN servers reduces file size by 70% and can be as high as 90%. GZip compression at CDN servers reduces file size by 70% and can be as high as 90%.
        """
        return pulumi.get(self, "gzip_on")

    @_builtins.property
    @pulumi.getter(name="ignoreCookie")
    def ignore_cookie(self) -> _builtins.bool:
        """
        Set for ignoring cookie. Set for ignoring cookie.
        """
        return pulumi.get(self, "ignore_cookie")

    @_builtins.property
    @pulumi.getter(name="ignoreQueryParams")
    def ignore_query_params(self) -> _builtins.bool:
        """
        Files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default. Files with different query parameters are cached as objects with the same key regardless of the parameter value. selected by default.
        """
        return pulumi.get(self, "ignore_query_params")

    @_builtins.property
    @pulumi.getter(name="ipAddressAcl")
    def ip_address_acl(self) -> 'outputs.GetCdnResourceOptionsIpAddressAclResult':
        """
        IP address access control list. The list of specified IP addresses to be allowed or denied depending on acl policy type.
        """
        return pulumi.get(self, "ip_address_acl")

    @_builtins.property
    @pulumi.getter(name="proxyCacheMethodsSet")
    def proxy_cache_methods_set(self) -> _builtins.bool:
        """
        Allows caching for GET, HEAD and POST requests. Allows caching for GET, HEAD and POST requests.
        """
        return pulumi.get(self, "proxy_cache_methods_set")

    @_builtins.property
    @pulumi.getter(name="queryParamsBlacklists")
    def query_params_blacklists(self) -> Sequence[_builtins.str]:
        """
        Files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys. Files with the specified query parameters are cached as objects with the same key, files with other parameters are cached as objects with different keys.
        """
        return pulumi.get(self, "query_params_blacklists")

    @_builtins.property
    @pulumi.getter(name="queryParamsWhitelists")
    def query_params_whitelists(self) -> Sequence[_builtins.str]:
        """
        Files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key. Files with the specified query parameters are cached as objects with different keys, files with other parameters are cached as objects with the same key.
        """
        return pulumi.get(self, "query_params_whitelists")

    @_builtins.property
    @pulumi.getter(name="redirectHttpToHttps")
    def redirect_http_to_https(self) -> _builtins.bool:
        """
        Set up a redirect from HTTP to HTTPS. Set up a redirect from HTTP to HTTPS.
        """
        return pulumi.get(self, "redirect_http_to_https")

    @_builtins.property
    @pulumi.getter(name="redirectHttpsToHttp")
    def redirect_https_to_http(self) -> _builtins.bool:
        """
        Set up a redirect from HTTPS to HTTP. Set up a redirect from HTTPS to HTTP.
        """
        return pulumi.get(self, "redirect_https_to_http")

    @_builtins.property
    @pulumi.getter(name="secureKey")
    def secure_key(self) -> _builtins.str:
        """
        Set secure key for url encoding to protect contect and limit access by IP addresses and time limits. Set secure key for url encoding to protect contect and limit access by IP addresses and time limits.
        """
        return pulumi.get(self, "secure_key")

    @_builtins.property
    @pulumi.getter
    def slice(self) -> _builtins.bool:
        """
        Files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests. Files larger than 10 MB will be requested and cached in parts (no larger than 10 MB each part). It reduces time to first byte. The origin must support HTTP Range requests.
        """
        return pulumi.get(self, "slice")

    @_builtins.property
    @pulumi.getter(name="staticRequestHeaders")
    def static_request_headers(self) -> Mapping[str, _builtins.str]:
        """
        Set up custom headers that CDN servers will send in requests to origins. Set up custom headers that CDN servers will send in requests to origins.
        """
        return pulumi.get(self, "static_request_headers")

    @_builtins.property
    @pulumi.getter(name="staticResponseHeaders")
    def static_response_headers(self) -> Mapping[str, _builtins.str]:
        """
        Set up a static response header. The header name must be lowercase. Set up a static response header. The header name must be lowercase.
        """
        return pulumi.get(self, "static_response_headers")


@pulumi.output_type
class GetCdnResourceOptionsIpAddressAclResult(dict):
    def __init__(__self__, *,
                 excepted_values: Sequence[_builtins.str],
                 policy_type: _builtins.str):
        """
        :param Sequence[_builtins.str] excepted_values: The list of specified IP addresses to be allowed or denied depending on acl policy type. The list of specified IP addresses to be allowed or denied depending on acl policy type.
        :param _builtins.str policy_type: The policy type for ACL. One of `allow` or `deny` values. The policy type for ACL. One of `allow` or `deny` values.
        """
        pulumi.set(__self__, "excepted_values", excepted_values)
        pulumi.set(__self__, "policy_type", policy_type)

    @_builtins.property
    @pulumi.getter(name="exceptedValues")
    def excepted_values(self) -> Sequence[_builtins.str]:
        """
        The list of specified IP addresses to be allowed or denied depending on acl policy type. The list of specified IP addresses to be allowed or denied depending on acl policy type.
        """
        return pulumi.get(self, "excepted_values")

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        """
        The policy type for ACL. One of `allow` or `deny` values. The policy type for ACL. One of `allow` or `deny` values.
        """
        return pulumi.get(self, "policy_type")


@pulumi.output_type
class GetCdnResourceSslCertificateResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str,
                 type: _builtins.str,
                 certificate_manager_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str status: SSL certificate status. SSL certificate status.
        :param _builtins.str type: SSL certificate type. SSL certificate type.
        :param _builtins.str certificate_manager_id: Certificate Manager ID. Certificate Manager ID.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if certificate_manager_id is not None:
            pulumi.set(__self__, "certificate_manager_id", certificate_manager_id)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        SSL certificate status. SSL certificate status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        SSL certificate type. SSL certificate type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="certificateManagerId")
    def certificate_manager_id(self) -> Optional[_builtins.str]:
        """
        Certificate Manager ID. Certificate Manager ID.
        """
        return pulumi.get(self, "certificate_manager_id")


@pulumi.output_type
class GetCmCertificateChallengeResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 dns_name: _builtins.str,
                 dns_type: _builtins.str,
                 dns_value: _builtins.str,
                 domain: _builtins.str,
                 http_content: _builtins.str,
                 http_url: _builtins.str,
                 message: _builtins.str,
                 type: _builtins.str,
                 updated_at: _builtins.str):
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "dns_type", dns_type)
        pulumi.set(__self__, "dns_value", dns_value)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "http_content", http_content)
        pulumi.set(__self__, "http_url", http_url)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="dnsType")
    def dns_type(self) -> _builtins.str:
        return pulumi.get(self, "dns_type")

    @_builtins.property
    @pulumi.getter(name="dnsValue")
    def dns_value(self) -> _builtins.str:
        return pulumi.get(self, "dns_value")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="httpContent")
    def http_content(self) -> _builtins.str:
        return pulumi.get(self, "http_content")

    @_builtins.property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> _builtins.str:
        return pulumi.get(self, "http_url")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetComputeDiskDiskPlacementPolicyResult(dict):
    def __init__(__self__, *,
                 disk_placement_group_id: _builtins.str):
        """
        :param _builtins.str disk_placement_group_id: Specifies Disk Placement Group id.
        """
        pulumi.set(__self__, "disk_placement_group_id", disk_placement_group_id)

    @_builtins.property
    @pulumi.getter(name="diskPlacementGroupId")
    def disk_placement_group_id(self) -> _builtins.str:
        """
        Specifies Disk Placement Group id.
        """
        return pulumi.get(self, "disk_placement_group_id")


@pulumi.output_type
class GetComputeDiskHardwareGenerationResult(dict):
    def __init__(__self__, *,
                 generation2_features: Sequence['outputs.GetComputeDiskHardwareGenerationGeneration2FeatureResult'],
                 legacy_features: Sequence['outputs.GetComputeDiskHardwareGenerationLegacyFeatureResult']):
        """
        :param Sequence['GetComputeDiskHardwareGenerationGeneration2FeatureArgs'] generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param Sequence['GetComputeDiskHardwareGenerationLegacyFeatureArgs'] legacy_features: Defines the first known hardware generation and its features.
        """
        pulumi.set(__self__, "generation2_features", generation2_features)
        pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Sequence['outputs.GetComputeDiskHardwareGenerationGeneration2FeatureResult']:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Sequence['outputs.GetComputeDiskHardwareGenerationLegacyFeatureResult']:
        """
        Defines the first known hardware generation and its features.
        """
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class GetComputeDiskHardwareGenerationGeneration2FeatureResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeDiskHardwareGenerationLegacyFeatureResult(dict):
    def __init__(__self__, *,
                 pci_topology: _builtins.str):
        """
        :param _builtins.str pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> _builtins.str:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class GetComputeImageHardwareGenerationResult(dict):
    def __init__(__self__, *,
                 generation2_features: Sequence['outputs.GetComputeImageHardwareGenerationGeneration2FeatureResult'],
                 legacy_features: Sequence['outputs.GetComputeImageHardwareGenerationLegacyFeatureResult']):
        """
        :param Sequence['GetComputeImageHardwareGenerationGeneration2FeatureArgs'] generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param Sequence['GetComputeImageHardwareGenerationLegacyFeatureArgs'] legacy_features: Defines the first known hardware generation and its features.
        """
        pulumi.set(__self__, "generation2_features", generation2_features)
        pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Sequence['outputs.GetComputeImageHardwareGenerationGeneration2FeatureResult']:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Sequence['outputs.GetComputeImageHardwareGenerationLegacyFeatureResult']:
        """
        Defines the first known hardware generation and its features.
        """
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class GetComputeImageHardwareGenerationGeneration2FeatureResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeImageHardwareGenerationLegacyFeatureResult(dict):
    def __init__(__self__, *,
                 pci_topology: _builtins.str):
        """
        :param _builtins.str pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> _builtins.str:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class GetComputeInstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: _builtins.bool,
                 device_name: _builtins.str,
                 disk_id: _builtins.str,
                 initialize_params: Sequence['outputs.GetComputeInstanceBootDiskInitializeParamResult'],
                 mode: _builtins.str):
        """
        :param _builtins.bool auto_delete: Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        :param _builtins.str device_name: Name that can be used to access an attached disk.
        :param _builtins.str disk_id: The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        :param Sequence['GetComputeInstanceBootDiskInitializeParamArgs'] initialize_params: Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. Either `image_id` or `snapshot_id` must be specified.
        :param _builtins.str mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Defines whether the disk will be auto-deleted when the instance is deleted. The default value is `True`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name that can be used to access an attached disk.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> _builtins.str:
        """
        The ID of the existing disk (such as those managed by `ComputeDisk`) to attach as a boot disk.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetComputeInstanceBootDiskInitializeParamResult']:
        """
        Parameters for a new disk that will be created alongside the new instance. Either `initialize_params` or `disk_id` must be set. Either `image_id` or `snapshot_id` must be specified.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeInstanceBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 block_size: _builtins.int,
                 description: _builtins.str,
                 image_id: _builtins.str,
                 kms_key_id: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.int,
                 snapshot_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int block_size: Block size of the disk, specified in bytes.
        :param _builtins.str description: Description of the boot disk.
        :param _builtins.str image_id: A disk image to initialize this disk from.
        :param _builtins.str kms_key_id: ID of KMS symmetric key used to encrypt disk.
        :param _builtins.str name: Name of the boot disk.
        :param _builtins.int size: Size of the disk in GB.
        :param _builtins.str snapshot_id: A snapshot to initialize this disk from.
        :param _builtins.str type: Disk type.
        """
        pulumi.set(__self__, "block_size", block_size)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> _builtins.int:
        """
        Block size of the disk, specified in bytes.
        """
        return pulumi.get(self, "block_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        A disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        ID of KMS symmetric key used to encrypt disk.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the boot disk.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        A snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceFilesystemResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 filesystem_id: _builtins.str,
                 mode: _builtins.str):
        """
        :param _builtins.str device_name: Name of the device representing the filesystem on the instance.
        :param _builtins.str filesystem_id: ID of the filesystem that should be attached.
        :param _builtins.str mode: Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the device representing the filesystem on the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> _builtins.str:
        """
        ID of the filesystem that should be attached.
        """
        return pulumi.get(self, "filesystem_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeInstanceGroupAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 instance_tags_pools: Sequence['outputs.GetComputeInstanceGroupAllocationPolicyInstanceTagsPoolResult'],
                 zones: Sequence[_builtins.str]):
        """
        :param Sequence['GetComputeInstanceGroupAllocationPolicyInstanceTagsPoolArgs'] instance_tags_pools: Array of availability zone IDs with list of instance tags.
        :param Sequence[_builtins.str] zones: A list of [availability zones](https://yandex.cloud/docs/overview/concepts/geo-scope).
        """
        pulumi.set(__self__, "instance_tags_pools", instance_tags_pools)
        pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="instanceTagsPools")
    def instance_tags_pools(self) -> Sequence['outputs.GetComputeInstanceGroupAllocationPolicyInstanceTagsPoolResult']:
        """
        Array of availability zone IDs with list of instance tags.
        """
        return pulumi.get(self, "instance_tags_pools")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        A list of [availability zones](https://yandex.cloud/docs/overview/concepts/geo-scope).
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class GetComputeInstanceGroupAllocationPolicyInstanceTagsPoolResult(dict):
    def __init__(__self__, *,
                 tags: Sequence[_builtins.str],
                 zone: _builtins.str):
        """
        :param Sequence[_builtins.str] tags: List of tags for instances in zone.
        :param _builtins.str zone: Availability zone.
        """
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        List of tags for instances in zone.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        Availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetComputeInstanceGroupApplicationBalancerStateResult(dict):
    def __init__(__self__, *,
                 status_message: _builtins.str,
                 target_group_id: _builtins.str):
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> _builtins.str:
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class GetComputeInstanceGroupApplicationLoadBalancerResult(dict):
    def __init__(__self__, *,
                 ignore_health_checks: _builtins.bool,
                 max_opening_traffic_duration: _builtins.int,
                 status_message: _builtins.str,
                 target_group_description: _builtins.str,
                 target_group_id: _builtins.str,
                 target_group_labels: Mapping[str, _builtins.str],
                 target_group_name: _builtins.str):
        """
        :param _builtins.bool ignore_health_checks: Do not wait load balancer health checks.
        :param _builtins.int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param _builtins.str status_message: The status message of the instance.
        :param _builtins.str target_group_description: A description of the target group.
        :param _builtins.str target_group_id: The ID of the target group.
        :param Mapping[str, _builtins.str] target_group_labels: A set of key/value label pairs.
        :param _builtins.str target_group_name: The name of the target group.
        """
        pulumi.set(__self__, "ignore_health_checks", ignore_health_checks)
        pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_description", target_group_description)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "target_group_labels", target_group_labels)
        pulumi.set(__self__, "target_group_name", target_group_name)

    @_builtins.property
    @pulumi.getter(name="ignoreHealthChecks")
    def ignore_health_checks(self) -> _builtins.bool:
        """
        Do not wait load balancer health checks.
        """
        return pulumi.get(self, "ignore_health_checks")

    @_builtins.property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> _builtins.int:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        """
        The status message of the instance.
        """
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> _builtins.str:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> _builtins.str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @_builtins.property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @_builtins.property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> _builtins.str:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class GetComputeInstanceGroupDeployPolicyResult(dict):
    def __init__(__self__, *,
                 max_creating: _builtins.int,
                 max_deleting: _builtins.int,
                 max_expansion: _builtins.int,
                 max_unavailable: _builtins.int,
                 startup_duration: _builtins.int,
                 strategy: _builtins.str):
        """
        :param _builtins.int max_creating: The maximum number of instances that can be created at the same time.
        :param _builtins.int max_deleting: The maximum number of instances that can be deleted at the same time.
        :param _builtins.int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        :param _builtins.int max_unavailable: The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        :param _builtins.int startup_duration: The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        :param _builtins.str strategy: Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
        pulumi.set(__self__, "max_creating", max_creating)
        pulumi.set(__self__, "max_deleting", max_deleting)
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        pulumi.set(__self__, "startup_duration", startup_duration)
        pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="maxCreating")
    def max_creating(self) -> _builtins.int:
        """
        The maximum number of instances that can be created at the same time.
        """
        return pulumi.get(self, "max_creating")

    @_builtins.property
    @pulumi.getter(name="maxDeleting")
    def max_deleting(self) -> _builtins.int:
        """
        The maximum number of instances that can be deleted at the same time.
        """
        return pulumi.get(self, "max_deleting")

    @_builtins.property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> _builtins.int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update process.
        """
        return pulumi.get(self, "max_expansion")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> _builtins.int:
        """
        The maximum number of running instances that can be taken offline (stopped or deleted) at the same time during the update process.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="startupDuration")
    def startup_duration(self) -> _builtins.int:
        """
        The amount of time in seconds to allow for an instance to start. Instance will be considered up and running (and start receiving traffic) only after the startup_duration has elapsed and all health checks are passed.
        """
        return pulumi.get(self, "startup_duration")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> _builtins.str:
        """
        Affects the lifecycle of the instance during deployment. If set to `proactive` (default), Instance Groups can forcefully stop a running instance. If `opportunistic`, Instance Groups does not stop a running instance. Instead, it will wait until the instance stops itself or becomes unhealthy.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetComputeInstanceGroupHealthCheckResult(dict):
    def __init__(__self__, *,
                 healthy_threshold: _builtins.int,
                 http_options: Sequence['outputs.GetComputeInstanceGroupHealthCheckHttpOptionResult'],
                 interval: _builtins.int,
                 tcp_options: Sequence['outputs.GetComputeInstanceGroupHealthCheckTcpOptionResult'],
                 timeout: _builtins.int,
                 unhealthy_threshold: _builtins.int):
        """
        :param _builtins.int healthy_threshold: The number of successful health checks before the managed instance is declared healthy.
        :param Sequence['GetComputeInstanceGroupHealthCheckHttpOptionArgs'] http_options: HTTP check options.
        :param _builtins.int interval: The interval to wait between health checks in seconds.
        :param Sequence['GetComputeInstanceGroupHealthCheckTcpOptionArgs'] tcp_options: TCP check options.
        :param _builtins.int timeout: The length of time to wait for a response before the health check times out in seconds.
        :param _builtins.int unhealthy_threshold: The number of failed health checks before the managed instance is declared unhealthy.
        """
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_options", http_options)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "tcp_options", tcp_options)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        The number of successful health checks before the managed instance is declared healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Sequence['outputs.GetComputeInstanceGroupHealthCheckHttpOptionResult']:
        """
        HTTP check options.
        """
        return pulumi.get(self, "http_options")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        The interval to wait between health checks in seconds.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Sequence['outputs.GetComputeInstanceGroupHealthCheckTcpOptionResult']:
        """
        TCP check options.
        """
        return pulumi.get(self, "tcp_options")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        The length of time to wait for a response before the health check times out in seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        The number of failed health checks before the managed instance is declared unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetComputeInstanceGroupHealthCheckHttpOptionResult(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str path: The URL path used for health check requests.
        :param _builtins.int port: The port used for HTTP health checks.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The URL path used for health check requests.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used for HTTP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetComputeInstanceGroupHealthCheckTcpOptionResult(dict):
    def __init__(__self__, *,
                 port: _builtins.int):
        """
        :param _builtins.int port: The port used for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetComputeInstanceGroupInstanceResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 instance_id: _builtins.str,
                 instance_tag: _builtins.str,
                 name: _builtins.str,
                 network_interfaces: Sequence['outputs.GetComputeInstanceGroupInstanceNetworkInterfaceResult'],
                 status: _builtins.str,
                 status_changed_at: _builtins.str,
                 status_message: _builtins.str,
                 zone_id: _builtins.str):
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_tag", instance_tag)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_changed_at", status_changed_at)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceTag")
    def instance_tag(self) -> _builtins.str:
        return pulumi.get(self, "instance_tag")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceNetworkInterfaceResult']:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusChangedAt")
    def status_changed_at(self) -> _builtins.str:
        return pulumi.get(self, "status_changed_at")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetComputeInstanceGroupInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 index: _builtins.int,
                 ip_address: _builtins.str,
                 ipv4: _builtins.bool,
                 ipv6: _builtins.bool,
                 ipv6_address: _builtins.str,
                 mac_address: _builtins.str,
                 nat: _builtins.bool,
                 nat_ip_address: _builtins.str,
                 nat_ip_version: _builtins.str,
                 subnet_id: _builtins.str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> _builtins.bool:
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> _builtins.str:
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> _builtins.bool:
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> _builtins.str:
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> _builtins.str:
        return pulumi.get(self, "nat_ip_version")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateResult(dict):
    def __init__(__self__, *,
                 boot_disks: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskResult'],
                 description: _builtins.str,
                 hostname: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 metadata: Mapping[str, _builtins.str],
                 metadata_options: 'outputs.GetComputeInstanceGroupInstanceTemplateMetadataOptionsResult',
                 name: _builtins.str,
                 network_interfaces: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult'],
                 network_settings: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkSettingResult'],
                 platform_id: _builtins.str,
                 resources: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateResourceResult'],
                 scheduling_policies: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult'],
                 secondary_disks: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult'],
                 service_account_id: _builtins.str,
                 filesystems: Optional[Sequence['outputs.GetComputeInstanceGroupInstanceTemplateFilesystemResult']] = None,
                 placement_policy: Optional['outputs.GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult'] = None):
        """
        :param Sequence['GetComputeInstanceGroupInstanceTemplateBootDiskArgs'] boot_disks: Boot disk specifications for the instance.
        :param _builtins.str description: A description of the instance.
        :param _builtins.str hostname: Hostname template for the instance. This field is used to generate the FQDN value of instance. The `hostname` must be unique within the network and region. If not specified, the hostname will be equal to `id` of the instance and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs to assign to the instance.
        :param Mapping[str, _builtins.str] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param 'GetComputeInstanceGroupInstanceTemplateMetadataOptionsArgs' metadata_options: Options allow user to configure access to managed instances metadata
        :param _builtins.str name: Name template of the instance.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkSettingArgs'] network_settings: Network acceleration type for instance.
        :param _builtins.str platform_id: The ID of the hardware platform configuration for the instance.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateResourceArgs'] resources: Compute resource specifications for the instance.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateSchedulingPolicyArgs'] scheduling_policies: The scheduling policy configuration.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateSecondaryDiskArgs'] secondary_disks: A list of disks to attach to the instance.
        :param _builtins.str service_account_id: The ID of the service account authorized for this instance.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateFilesystemArgs'] filesystems: List of filesystems to attach to the instance.
        :param 'GetComputeInstanceGroupInstanceTemplatePlacementPolicyArgs' placement_policy: The placement policy configuration.
        """
        pulumi.set(__self__, "boot_disks", boot_disks)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "metadata_options", metadata_options)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "network_settings", network_settings)
        pulumi.set(__self__, "platform_id", platform_id)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "scheduling_policies", scheduling_policies)
        pulumi.set(__self__, "secondary_disks", secondary_disks)
        pulumi.set(__self__, "service_account_id", service_account_id)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if placement_policy is not None:
            pulumi.set(__self__, "placement_policy", placement_policy)

    @_builtins.property
    @pulumi.getter(name="bootDisks")
    def boot_disks(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskResult']:
        """
        Boot disk specifications for the instance.
        """
        return pulumi.get(self, "boot_disks")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description of the instance.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname template for the instance. This field is used to generate the FQDN value of instance. The `hostname` must be unique within the network and region. If not specified, the hostname will be equal to `id` of the instance and FQDN will be `<id>.auto.internal`. Otherwise FQDN will be `<hostname>.<region_id>.internal`.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> 'outputs.GetComputeInstanceGroupInstanceTemplateMetadataOptionsResult':
        """
        Options allow user to configure access to managed instances metadata
        """
        return pulumi.get(self, "metadata_options")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name template of the instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult']:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="networkSettings")
    def network_settings(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkSettingResult']:
        """
        Network acceleration type for instance.
        """
        return pulumi.get(self, "network_settings")

    @_builtins.property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> _builtins.str:
        """
        The ID of the hardware platform configuration for the instance.
        """
        return pulumi.get(self, "platform_id")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateResourceResult']:
        """
        Compute resource specifications for the instance.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicies")
    def scheduling_policies(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult']:
        """
        The scheduling policy configuration.
        """
        return pulumi.get(self, "scheduling_policies")

    @_builtins.property
    @pulumi.getter(name="secondaryDisks")
    def secondary_disks(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult']:
        """
        A list of disks to attach to the instance.
        """
        return pulumi.get(self, "secondary_disks")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        The ID of the service account authorized for this instance.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter
    def filesystems(self) -> Optional[Sequence['outputs.GetComputeInstanceGroupInstanceTemplateFilesystemResult']]:
        """
        List of filesystems to attach to the instance.
        """
        return pulumi.get(self, "filesystems")

    @_builtins.property
    @pulumi.getter(name="placementPolicy")
    def placement_policy(self) -> Optional['outputs.GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult']:
        """
        The placement policy configuration.
        """
        return pulumi.get(self, "placement_policy")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateBootDiskResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 disk_id: _builtins.str,
                 initialize_params: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult'],
                 mode: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: The ID of the existing disk (such as those managed by yandex*compute*disk) to attach as a boot disk.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamArgs'] initialize_params: Parameters for creating a disk alongside the instance.
        :param _builtins.str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        :param _builtins.str name: When set can be later used to change DiskSpec of actual disk.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> _builtins.str:
        """
        The ID of the existing disk (such as those managed by yandex*compute*disk) to attach as a boot disk.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult']:
        """
        Parameters for creating a disk alongside the instance.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        When set can be later used to change DiskSpec of actual disk.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 image_id: _builtins.str,
                 size: _builtins.int,
                 snapshot_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: A description of the boot disk.
        :param _builtins.str image_id: The disk image to initialize this disk from.
        :param _builtins.int size: The size of the disk in GB.
        :param _builtins.str snapshot_id: The snapshot to initialize this disk from.
        :param _builtins.str type: The disk type.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateFilesystemResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 filesystem_id: _builtins.str,
                 mode: _builtins.str):
        """
        :param _builtins.str device_name: Name of the device representing the filesystem on the instance.
        :param _builtins.str filesystem_id: ID of the filesystem that should be attached.
        :param _builtins.str mode: Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "filesystem_id", filesystem_id)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name of the device representing the filesystem on the instance.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> _builtins.str:
        """
        ID of the filesystem that should be attached.
        """
        return pulumi.get(self, "filesystem_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of access to the filesystem that should be attached. By default, filesystem is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateMetadataOptionsResult(dict):
    def __init__(__self__, *,
                 aws_v1_http_endpoint: _builtins.int,
                 aws_v1_http_token: _builtins.int,
                 gce_http_endpoint: _builtins.int,
                 gce_http_token: _builtins.int):
        """
        :param _builtins.int aws_v1_http_endpoint: Enables access to AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        :param _builtins.int aws_v1_http_token: Enables access to IAM credentials with AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        :param _builtins.int gce_http_endpoint: Enables access to GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        :param _builtins.int gce_http_token: Enables access to IAM credentials with GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        pulumi.set(__self__, "gce_http_token", gce_http_token)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> _builtins.int:
        """
        Enables access to AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> _builtins.int:
        """
        Enables access to IAM credentials with AWS flavored metadata (IMDSv1). Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "aws_v1_http_token")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> _builtins.int:
        """
        Enables access to GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "gce_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> _builtins.int:
        """
        Enables access to IAM credentials with GCE flavored metadata. Possible values: `0`, `1` for `enabled` and `2` for `disabled`.
        """
        return pulumi.get(self, "gce_http_token")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 dns_records: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult'],
                 ip_address: _builtins.str,
                 ipv4: _builtins.bool,
                 ipv6: _builtins.bool,
                 ipv6_address: _builtins.str,
                 ipv6_dns_records: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult'],
                 nat: _builtins.bool,
                 nat_dns_records: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult'],
                 nat_ip_address: _builtins.str,
                 network_id: _builtins.str,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str]):
        """
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordArgs'] dns_records: List of DNS records.
        :param _builtins.str ip_address: Manual set static IP address.
        :param _builtins.bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param _builtins.bool ipv6: If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param _builtins.str ipv6_address: Manual set static IPv6 address.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of IPv6 DNS records.
        :param _builtins.bool nat: Flag for using NAT.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of NAT DNS records.
        :param _builtins.str nat_ip_address: A public address that can be used to access the internet over NAT. Use `variables` to set.
        :param _builtins.str network_id: The ID of the network.
        :param Sequence[_builtins.str] security_group_ids: Security group (SG) `IDs` for network interface.
        :param Sequence[_builtins.str] subnet_ids: The ID of the subnets to attach this interface to.
        """
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult']:
        """
        List of DNS records.
        """
        return pulumi.get(self, "dns_records")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> _builtins.bool:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult']:
        """
        List of IPv6 DNS records.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> _builtins.bool:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult']:
        """
        List of NAT DNS records.
        """
        return pulumi.get(self, "nat_dns_records")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> _builtins.str:
        """
        A public address that can be used to access the internet over NAT. Use `variables` to set.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The ID of the network.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Security group (SG) `IDs` for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        The ID of the subnets to attach this interface to.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone id (if not set, private zone used).
        :param _builtins.str fqdn: DNS record FQDN (must have dot at the end).
        :param _builtins.bool ptr: When set to `true`, also create PTR DNS record.
        :param _builtins.int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone id (if not set, private zone used).
        :param _builtins.str fqdn: DNS record FQDN (must have dot at the end).
        :param _builtins.bool ptr: When set to `true`, also create PTR DNS record.
        :param _builtins.int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone id (if not set, private zone used).
        :param _builtins.str fqdn: DNS record FQDN (must have dot at the end).
        :param _builtins.bool ptr: When set to `true`, also create PTR DNS record.
        :param _builtins.int ttl: DNS record TTL.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone id (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateNetworkSettingResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Network acceleration type. By default a network is in `STANDARD` mode.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Network acceleration type. By default a network is in `STANDARD` mode.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplatePlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: _builtins.str):
        """
        :param _builtins.str placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> _builtins.str:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: _builtins.int,
                 cores: _builtins.int,
                 gpus: _builtins.int,
                 memory: _builtins.float):
        """
        :param _builtins.int core_fraction: If provided, specifies baseline core performance as a percent.
        :param _builtins.int cores: The number of CPU cores for the instance.
        :param _builtins.int gpus: If provided, specifies the number of GPU devices for the instance.
        :param _builtins.float memory: The memory size in GB.
        """
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> _builtins.int:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> _builtins.int:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> _builtins.int:
        """
        If provided, specifies the number of GPU devices for the instance.
        """
        return pulumi.get(self, "gpus")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        The memory size in GB.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 preemptible: _builtins.bool):
        """
        :param _builtins.bool preemptible: Specifies if the instance is preemptible. Defaults to `false`.
        """
        pulumi.set(__self__, "preemptible", preemptible)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> _builtins.bool:
        """
        Specifies if the instance is preemptible. Defaults to `false`.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateSecondaryDiskResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 disk_id: _builtins.str,
                 initialize_params: Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult'],
                 mode: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: ID of the existing disk. To set use variables.
        :param Sequence['GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamArgs'] initialize_params: Parameters used for creating a disk alongside the instance.
        :param _builtins.str mode: The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        :param _builtins.str name: When set can be later used to change DiskSpec of actual disk.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> _builtins.str:
        """
        ID of the existing disk. To set use variables.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult']:
        """
        Parameters used for creating a disk alongside the instance.
        """
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The access mode to the disk resource. By default a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        When set can be later used to change DiskSpec of actual disk.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 image_id: _builtins.str,
                 size: _builtins.int,
                 snapshot_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: A description of the boot disk.
        :param _builtins.str image_id: The disk image to initialize this disk from.
        :param _builtins.int size: The size of the disk in GB.
        :param _builtins.str snapshot_id: The snapshot to initialize this disk from.
        :param _builtins.str type: The disk type.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The disk image to initialize this disk from.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the disk in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        The snapshot to initialize this disk from.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetComputeInstanceGroupLoadBalancerResult(dict):
    def __init__(__self__, *,
                 ignore_health_checks: _builtins.bool,
                 max_opening_traffic_duration: _builtins.int,
                 status_message: _builtins.str,
                 target_group_description: _builtins.str,
                 target_group_id: _builtins.str,
                 target_group_labels: Mapping[str, _builtins.str],
                 target_group_name: _builtins.str):
        """
        :param _builtins.bool ignore_health_checks: Do not wait load balancer health checks.
        :param _builtins.int max_opening_traffic_duration: Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        :param _builtins.str status_message: The status message of the target group.
        :param _builtins.str target_group_description: A description of the target group.
        :param _builtins.str target_group_id: The ID of the target group.
        :param Mapping[str, _builtins.str] target_group_labels: A set of key/value label pairs.
        :param _builtins.str target_group_name: The name of the target group.
        """
        pulumi.set(__self__, "ignore_health_checks", ignore_health_checks)
        pulumi.set(__self__, "max_opening_traffic_duration", max_opening_traffic_duration)
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_description", target_group_description)
        pulumi.set(__self__, "target_group_id", target_group_id)
        pulumi.set(__self__, "target_group_labels", target_group_labels)
        pulumi.set(__self__, "target_group_name", target_group_name)

    @_builtins.property
    @pulumi.getter(name="ignoreHealthChecks")
    def ignore_health_checks(self) -> _builtins.bool:
        """
        Do not wait load balancer health checks.
        """
        return pulumi.get(self, "ignore_health_checks")

    @_builtins.property
    @pulumi.getter(name="maxOpeningTrafficDuration")
    def max_opening_traffic_duration(self) -> _builtins.int:
        """
        Timeout for waiting for the VM to be checked by the load balancer. If the timeout is exceeded, the VM will be turned off based on the deployment policy. Specified in seconds.
        """
        return pulumi.get(self, "max_opening_traffic_duration")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        """
        The status message of the target group.
        """
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="targetGroupDescription")
    def target_group_description(self) -> _builtins.str:
        """
        A description of the target group.
        """
        return pulumi.get(self, "target_group_description")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> _builtins.str:
        """
        The ID of the target group.
        """
        return pulumi.get(self, "target_group_id")

    @_builtins.property
    @pulumi.getter(name="targetGroupLabels")
    def target_group_labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value label pairs.
        """
        return pulumi.get(self, "target_group_labels")

    @_builtins.property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> _builtins.str:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")


@pulumi.output_type
class GetComputeInstanceGroupLoadBalancerStateResult(dict):
    def __init__(__self__, *,
                 status_message: _builtins.str,
                 target_group_id: _builtins.str):
        pulumi.set(__self__, "status_message", status_message)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> _builtins.str:
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> _builtins.str:
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyResult(dict):
    def __init__(__self__, *,
                 auto_scales: Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleResult'],
                 fixed_scales: Sequence['outputs.GetComputeInstanceGroupScalePolicyFixedScaleResult'],
                 test_auto_scales: Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleResult']):
        """
        :param Sequence['GetComputeInstanceGroupScalePolicyAutoScaleArgs'] auto_scales: The auto scaling policy of the instance group.
        :param Sequence['GetComputeInstanceGroupScalePolicyFixedScaleArgs'] fixed_scales: The fixed scaling policy of the instance group.
        :param Sequence['GetComputeInstanceGroupScalePolicyTestAutoScaleArgs'] test_auto_scales: The test auto scaling policy of the instance group. Use it to test how the auto scale works.
        """
        pulumi.set(__self__, "auto_scales", auto_scales)
        pulumi.set(__self__, "fixed_scales", fixed_scales)
        pulumi.set(__self__, "test_auto_scales", test_auto_scales)

    @_builtins.property
    @pulumi.getter(name="autoScales")
    def auto_scales(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleResult']:
        """
        The auto scaling policy of the instance group.
        """
        return pulumi.get(self, "auto_scales")

    @_builtins.property
    @pulumi.getter(name="fixedScales")
    def fixed_scales(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyFixedScaleResult']:
        """
        The fixed scaling policy of the instance group.
        """
        return pulumi.get(self, "fixed_scales")

    @_builtins.property
    @pulumi.getter(name="testAutoScales")
    def test_auto_scales(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleResult']:
        """
        The test auto scaling policy of the instance group. Use it to test how the auto scale works.
        """
        return pulumi.get(self, "test_auto_scales")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyAutoScaleResult(dict):
    def __init__(__self__, *,
                 auto_scale_type: _builtins.str,
                 cpu_utilization_target: _builtins.float,
                 custom_rules: Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult'],
                 initial_size: _builtins.int,
                 max_size: _builtins.int,
                 measurement_duration: _builtins.int,
                 min_zone_size: _builtins.int,
                 stabilization_duration: _builtins.int,
                 warmup_duration: _builtins.int):
        """
        :param _builtins.str auto_scale_type: Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        :param _builtins.float cpu_utilization_target: Target CPU load level.
        :param Sequence['GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules.
        :param _builtins.int initial_size: The initial number of instances in the instance group.
        :param _builtins.int max_size: The maximum number of virtual machines in the group.
        :param _builtins.int measurement_duration: The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        :param _builtins.int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param _builtins.int stabilization_duration: The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param _builtins.int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "auto_scale_type", auto_scale_type)
        pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        pulumi.set(__self__, "custom_rules", custom_rules)
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        pulumi.set(__self__, "min_zone_size", min_zone_size)
        pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        pulumi.set(__self__, "warmup_duration", warmup_duration)

    @_builtins.property
    @pulumi.getter(name="autoScaleType")
    def auto_scale_type(self) -> _builtins.str:
        """
        Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        return pulumi.get(self, "auto_scale_type")

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> _builtins.float:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult']:
        """
        A list of custom rules.
        """
        return pulumi.get(self, "custom_rules")

    @_builtins.property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> _builtins.int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> _builtins.int:
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @_builtins.property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> _builtins.int:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @_builtins.property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> _builtins.int:
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @_builtins.property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> _builtins.int:
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyAutoScaleCustomRuleResult(dict):
    def __init__(__self__, *,
                 folder_id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 metric_name: _builtins.str,
                 metric_type: _builtins.str,
                 rule_type: _builtins.str,
                 service: _builtins.str,
                 target: _builtins.float):
        """
        :param _builtins.str folder_id: If specified, sets the folder id to fetch metrics from. By default, it is the ID of the folder the group belongs to.
        :param Mapping[str, _builtins.str] labels: Metrics [labels](https://yandex.cloud/en/docs/monitoring/concepts/data-model#label) from Monitoring.
        :param _builtins.str metric_name: Name of the metric in Monitoring.
        :param _builtins.str metric_type: Type of metric, can be `GAUGE` or `COUNTER`. `GAUGE` metric reflects the value at particular time point. `COUNTER` metric exhibits a monotonous growth over time.
        :param _builtins.str rule_type: The metric rule type (UTILIZATION, WORKLOAD). UTILIZATION for metrics describing resource utilization per VM instance. WORKLOAD for metrics describing total workload on all VM instances.
        :param _builtins.str service: If specified, sets the service name to fetch metrics. The default value is `custom`. You can use a label to specify service metrics, e.g., `service` with the `compute` value for Compute Cloud.
        :param _builtins.float target: Target metric value by which Instance Groups calculates the number of required VM instances.
        """
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        If specified, sets the folder id to fetch metrics from. By default, it is the ID of the folder the group belongs to.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Metrics [labels](https://yandex.cloud/en/docs/monitoring/concepts/data-model#label) from Monitoring.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Name of the metric in Monitoring.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Type of metric, can be `GAUGE` or `COUNTER`. `GAUGE` metric reflects the value at particular time point. `COUNTER` metric exhibits a monotonous growth over time.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        The metric rule type (UTILIZATION, WORKLOAD). UTILIZATION for metrics describing resource utilization per VM instance. WORKLOAD for metrics describing total workload on all VM instances.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        If specified, sets the service name to fetch metrics. The default value is `custom`. You can use a label to specify service metrics, e.g., `service` with the `compute` value for Compute Cloud.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Target metric value by which Instance Groups calculates the number of required VM instances.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyFixedScaleResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        """
        :param _builtins.int size: The number of instances in the instance group.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The number of instances in the instance group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyTestAutoScaleResult(dict):
    def __init__(__self__, *,
                 auto_scale_type: _builtins.str,
                 cpu_utilization_target: _builtins.float,
                 custom_rules: Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult'],
                 initial_size: _builtins.int,
                 max_size: _builtins.int,
                 measurement_duration: _builtins.int,
                 min_zone_size: _builtins.int,
                 stabilization_duration: _builtins.int,
                 warmup_duration: _builtins.int):
        """
        :param _builtins.str auto_scale_type: Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        :param _builtins.float cpu_utilization_target: Target CPU load level.
        :param Sequence['GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleArgs'] custom_rules: A list of custom rules.
        :param _builtins.int initial_size: The initial number of instances in the instance group.
        :param _builtins.int max_size: The maximum number of virtual machines in the group.
        :param _builtins.int measurement_duration: The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        :param _builtins.int min_zone_size: The minimum number of virtual machines in a single availability zone.
        :param _builtins.int stabilization_duration: The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        :param _builtins.int warmup_duration: The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        pulumi.set(__self__, "auto_scale_type", auto_scale_type)
        pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        pulumi.set(__self__, "custom_rules", custom_rules)
        pulumi.set(__self__, "initial_size", initial_size)
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        pulumi.set(__self__, "min_zone_size", min_zone_size)
        pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        pulumi.set(__self__, "warmup_duration", warmup_duration)

    @_builtins.property
    @pulumi.getter(name="autoScaleType")
    def auto_scale_type(self) -> _builtins.str:
        """
        Autoscale type, can be `ZONAL` or `REGIONAL`. By default `ZONAL` type is used.
        """
        return pulumi.get(self, "auto_scale_type")

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> _builtins.float:
        """
        Target CPU load level.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @_builtins.property
    @pulumi.getter(name="customRules")
    def custom_rules(self) -> Sequence['outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult']:
        """
        A list of custom rules.
        """
        return pulumi.get(self, "custom_rules")

    @_builtins.property
    @pulumi.getter(name="initialSize")
    def initial_size(self) -> _builtins.int:
        """
        The initial number of instances in the instance group.
        """
        return pulumi.get(self, "initial_size")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        The maximum number of virtual machines in the group.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> _builtins.int:
        """
        The amount of time, in seconds, that metrics are averaged for. If the average value at the end of the interval is higher than the `cpu_utilization_target`, the instance group will increase the number of virtual machines in the group.
        """
        return pulumi.get(self, "measurement_duration")

    @_builtins.property
    @pulumi.getter(name="minZoneSize")
    def min_zone_size(self) -> _builtins.int:
        """
        The minimum number of virtual machines in a single availability zone.
        """
        return pulumi.get(self, "min_zone_size")

    @_builtins.property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> _builtins.int:
        """
        The minimum time interval, in seconds, to monitor the load before an instance group can reduce the number of virtual machines in the group. During this time, the group will not decrease even if the average load falls below the value of `cpu_utilization_target`.
        """
        return pulumi.get(self, "stabilization_duration")

    @_builtins.property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> _builtins.int:
        """
        The warm-up time of the virtual machine, in seconds. During this time, traffic is fed to the virtual machine, but load metrics are not taken into account.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRuleResult(dict):
    def __init__(__self__, *,
                 folder_id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 metric_name: _builtins.str,
                 metric_type: _builtins.str,
                 rule_type: _builtins.str,
                 service: _builtins.str,
                 target: _builtins.float):
        """
        :param _builtins.str folder_id: Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        :param Mapping[str, _builtins.str] labels: A map of labels of metric.
        :param _builtins.str metric_name: The name of metric.
        :param _builtins.str metric_type: Metric type, `GAUGE` or `COUNTER`.
        :param _builtins.str rule_type: Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        :param _builtins.str service: Service of custom metric in Yandex Monitoring that should be used for scaling.
        :param _builtins.float target: Target metric value level.
        """
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "rule_type", rule_type)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A map of labels of metric.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        The name of metric.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Metric type, `GAUGE` or `COUNTER`.
        """
        return pulumi.get(self, "metric_type")

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Rule type: `UTILIZATION` - This type means that the metric applies to one instance. First, Instance Groups calculates the average metric value for each instance, then averages the values for instances in one availability zone. This type of metric must have the `instance_id` label. `WORKLOAD` - This type means that the metric applies to instances in one availability zone. This type of metric must have the `zone_id` label.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Service of custom metric in Yandex Monitoring that should be used for scaling.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.float:
        """
        Target metric value level.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class GetComputeInstanceHardwareGenerationResult(dict):
    def __init__(__self__, *,
                 generation2_features: Sequence['outputs.GetComputeInstanceHardwareGenerationGeneration2FeatureResult'],
                 legacy_features: Sequence['outputs.GetComputeInstanceHardwareGenerationLegacyFeatureResult']):
        pulumi.set(__self__, "generation2_features", generation2_features)
        pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Sequence['outputs.GetComputeInstanceHardwareGenerationGeneration2FeatureResult']:
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Sequence['outputs.GetComputeInstanceHardwareGenerationLegacyFeatureResult']:
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class GetComputeInstanceHardwareGenerationGeneration2FeatureResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeInstanceHardwareGenerationLegacyFeatureResult(dict):
    def __init__(__self__, *,
                 pci_topology: _builtins.str):
        pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> _builtins.str:
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class GetComputeInstanceLocalDiskResult(dict):
    def __init__(__self__, *,
                 device_name: _builtins.str,
                 size_bytes: _builtins.int):
        """
        :param _builtins.str device_name: The name of the local disk device.
        :param _builtins.int size_bytes: Size of the disk, specified in bytes.
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "size_bytes", size_bytes)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The name of the local disk device.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> _builtins.int:
        """
        Size of the disk, specified in bytes.
        """
        return pulumi.get(self, "size_bytes")


@pulumi.output_type
class GetComputeInstanceMetadataOptionsResult(dict):
    def __init__(__self__, *,
                 aws_v1_http_endpoint: _builtins.int,
                 aws_v1_http_token: _builtins.int,
                 gce_http_endpoint: _builtins.int,
                 gce_http_token: _builtins.int):
        pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        pulumi.set(__self__, "aws_v1_http_token", aws_v1_http_token)
        pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)
        pulumi.set(__self__, "gce_http_token", gce_http_token)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> _builtins.int:
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="awsV1HttpToken")
    def aws_v1_http_token(self) -> _builtins.int:
        return pulumi.get(self, "aws_v1_http_token")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> _builtins.int:
        return pulumi.get(self, "gce_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpToken")
    def gce_http_token(self) -> _builtins.int:
        return pulumi.get(self, "gce_http_token")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 dns_records: Sequence['outputs.GetComputeInstanceNetworkInterfaceDnsRecordResult'],
                 index: _builtins.int,
                 ip_address: _builtins.str,
                 ipv4: _builtins.bool,
                 ipv6: _builtins.bool,
                 ipv6_address: _builtins.str,
                 ipv6_dns_records: Sequence['outputs.GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult'],
                 mac_address: _builtins.str,
                 nat: _builtins.bool,
                 nat_dns_records: Sequence['outputs.GetComputeInstanceNetworkInterfaceNatDnsRecordResult'],
                 nat_ip_address: _builtins.str,
                 nat_ip_version: _builtins.str,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_id: _builtins.str):
        """
        :param Sequence['GetComputeInstanceNetworkInterfaceDnsRecordArgs'] dns_records: List of configurations for creating ipv4 DNS records.
        :param _builtins.int index: Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        :param _builtins.str ip_address: The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        :param _builtins.bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param _builtins.bool ipv6: If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param _builtins.str ipv6_address: The private IPv6 address to assign to the instance.
        :param Sequence['GetComputeInstanceNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of configurations for creating ipv6 DNS records.
        :param _builtins.bool nat: Provide a public address, for instance, to access the internet over NAT.
        :param Sequence['GetComputeInstanceNetworkInterfaceNatDnsRecordArgs'] nat_dns_records: List of configurations for creating ipv4 NAT DNS records.
        :param _builtins.str nat_ip_address: Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        :param Sequence[_builtins.str] security_group_ids: Security Group (SG) IDs for network interface.
        :param _builtins.str subnet_id: ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        """
        pulumi.set(__self__, "dns_records", dns_records)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_dns_records", nat_dns_records)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="dnsRecords")
    def dns_records(self) -> Sequence['outputs.GetComputeInstanceNetworkInterfaceDnsRecordResult']:
        """
        List of configurations for creating ipv4 DNS records.
        """
        return pulumi.get(self, "dns_records")

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        """
        Index of network interface, will be calculated automatically for instance create or update operations if not specified. Required for attach/detach operations.
        """
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        The private IP address to assign to the instance. If empty, the address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> _builtins.bool:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        If `true`, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        The private IPv6 address to assign to the instance.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Sequence['outputs.GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult']:
        """
        List of configurations for creating ipv6 DNS records.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> _builtins.str:
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> _builtins.bool:
        """
        Provide a public address, for instance, to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natDnsRecords")
    def nat_dns_records(self) -> Sequence['outputs.GetComputeInstanceNetworkInterfaceNatDnsRecordResult']:
        """
        List of configurations for creating ipv4 NAT DNS records.
        """
        return pulumi.get(self, "nat_dns_records")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> _builtins.str:
        """
        Provide a public address, for instance, to access the internet over NAT. Address should be already reserved in web UI.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> _builtins.str:
        return pulumi.get(self, "nat_ip_version")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Security Group (SG) IDs for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet to attach this interface to. The subnet must exist in the same zone where this instance will be created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param _builtins.str fqdn: DNS record FQDN (must have a dot at the end).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL in seconds.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL in seconds.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceIpv6DnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param _builtins.str fqdn: DNS record FQDN (must have a dot at the end).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL in seconds.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL in seconds.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstanceNetworkInterfaceNatDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone used).
        :param _builtins.str fqdn: DNS record FQDN (must have a dot at the end).
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL in seconds.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone ID (if not set, private zone used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN (must have a dot at the end).
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL in seconds.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetComputeInstancePlacementPolicyResult(dict):
    def __init__(__self__, *,
                 host_affinity_rules: Sequence['outputs.GetComputeInstancePlacementPolicyHostAffinityRuleResult'],
                 placement_group_id: Optional[_builtins.str] = None,
                 placement_group_partition: Optional[_builtins.int] = None):
        """
        :param Sequence['GetComputeInstancePlacementPolicyHostAffinityRuleArgs'] host_affinity_rules: List of host affinity rules.
        :param _builtins.str placement_group_id: Specifies the id of the Placement Group to assign to the instance.
        """
        pulumi.set(__self__, "host_affinity_rules", host_affinity_rules)
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @_builtins.property
    @pulumi.getter(name="hostAffinityRules")
    def host_affinity_rules(self) -> Sequence['outputs.GetComputeInstancePlacementPolicyHostAffinityRuleResult']:
        """
        List of host affinity rules.
        """
        return pulumi.get(self, "host_affinity_rules")

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the id of the Placement Group to assign to the instance.
        """
        return pulumi.get(self, "placement_group_id")

    @_builtins.property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "placement_group_partition")


@pulumi.output_type
class GetComputeInstancePlacementPolicyHostAffinityRuleResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 op: _builtins.str,
                 values: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetComputeInstanceResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: _builtins.int,
                 cores: _builtins.int,
                 gpus: _builtins.int,
                 memory: _builtins.float):
        """
        :param _builtins.int core_fraction: If provided, specifies baseline performance for a core as a percent.
        :param _builtins.int cores: CPU cores for the instance.
        :param _builtins.int gpus: If provided, specifies the number of GPU devices for the instance.
        :param _builtins.float memory: Memory size in GB.
        """
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> _builtins.int:
        """
        If provided, specifies baseline performance for a core as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> _builtins.int:
        """
        CPU cores for the instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> _builtins.int:
        """
        If provided, specifies the number of GPU devices for the instance.
        """
        return pulumi.get(self, "gpus")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Memory size in GB.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetComputeInstanceSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 preemptible: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool preemptible: Specifies if the instance is preemptible. Defaults to `false`.
        """
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Specifies if the instance is preemptible. Defaults to `false`.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetComputeInstanceSecondaryDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: _builtins.bool,
                 device_name: _builtins.str,
                 disk_id: _builtins.str,
                 mode: _builtins.str):
        """
        :param _builtins.bool auto_delete: Whether the disk is auto-deleted when the instance is deleted. The default value is `false`.
        :param _builtins.str device_name: Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: ID of the disk that is attached to the instance.
        :param _builtins.str mode: Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is `false`.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        Name that can be used to access an attached disk under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> _builtins.str:
        """
        ID of the disk that is attached to the instance.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Type of access to the disk resource. By default, a disk is attached in `READ_WRITE` mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetComputeSnapshotHardwareGenerationResult(dict):
    def __init__(__self__, *,
                 generation2_features: Sequence['outputs.GetComputeSnapshotHardwareGenerationGeneration2FeatureResult'],
                 legacy_features: Sequence['outputs.GetComputeSnapshotHardwareGenerationLegacyFeatureResult']):
        """
        :param Sequence['GetComputeSnapshotHardwareGenerationGeneration2FeatureArgs'] generation2_features: A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        :param Sequence['GetComputeSnapshotHardwareGenerationLegacyFeatureArgs'] legacy_features: Defines the first known hardware generation and its features.
        """
        pulumi.set(__self__, "generation2_features", generation2_features)
        pulumi.set(__self__, "legacy_features", legacy_features)

    @_builtins.property
    @pulumi.getter(name="generation2Features")
    def generation2_features(self) -> Sequence['outputs.GetComputeSnapshotHardwareGenerationGeneration2FeatureResult']:
        """
        A newer hardware generation, which always uses `PCI_TOPOLOGY_V2` and UEFI boot.
        """
        return pulumi.get(self, "generation2_features")

    @_builtins.property
    @pulumi.getter(name="legacyFeatures")
    def legacy_features(self) -> Sequence['outputs.GetComputeSnapshotHardwareGenerationLegacyFeatureResult']:
        """
        Defines the first known hardware generation and its features.
        """
        return pulumi.get(self, "legacy_features")


@pulumi.output_type
class GetComputeSnapshotHardwareGenerationGeneration2FeatureResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeSnapshotHardwareGenerationLegacyFeatureResult(dict):
    def __init__(__self__, *,
                 pci_topology: _builtins.str):
        """
        :param _builtins.str pci_topology: A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        pulumi.set(__self__, "pci_topology", pci_topology)

    @_builtins.property
    @pulumi.getter(name="pciTopology")
    def pci_topology(self) -> _builtins.str:
        """
        A variant of PCI topology, one of `PCI_TOPOLOGY_V1` or `PCI_TOPOLOGY_V2`.
        """
        return pulumi.get(self, "pci_topology")


@pulumi.output_type
class GetComputeSnapshotScheduleSchedulePolicyResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 start_at: _builtins.str):
        """
        :param _builtins.str expression: Cron expression to schedule snapshots (in cron format `" * ****"`).
        :param _builtins.str start_at: Time to start the snapshot schedule (in format RFC3339 `2006-01-02T15:04:05Z07:00`). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "start_at", start_at)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Cron expression to schedule snapshots (in cron format `" * ****"`).
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="startAt")
    def start_at(self) -> _builtins.str:
        """
        Time to start the snapshot schedule (in format RFC3339 `2006-01-02T15:04:05Z07:00`). If empty current time will be used. Unlike an `expression` that specifies regularity rules, the `start_at` parameter determines from what point these rules will be applied.
        """
        return pulumi.get(self, "start_at")


@pulumi.output_type
class GetComputeSnapshotScheduleSnapshotSpecResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 labels: Mapping[str, _builtins.str]):
        """
        :param _builtins.str description: Description to assign to snapshots created by this snapshot schedule.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description to assign to snapshots created by this snapshot schedule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value label pairs to assign to snapshots created by this snapshot schedule.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class GetContainerRepositoryLifecyclePolicyRuleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 expire_period: _builtins.str,
                 retained_top: _builtins.int,
                 tag_regexp: _builtins.str,
                 untagged: _builtins.bool):
        """
        :param _builtins.str description: Description of the lifecycle policy.
        :param _builtins.str expire_period: The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        :param _builtins.int retained_top: The number of images to be retained even if the `expire_period` already expired.
        :param _builtins.str tag_regexp: Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        :param _builtins.bool untagged: If enabled, rules apply to untagged Docker images.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expire_period", expire_period)
        pulumi.set(__self__, "retained_top", retained_top)
        pulumi.set(__self__, "tag_regexp", tag_regexp)
        pulumi.set(__self__, "untagged", untagged)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the lifecycle policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expirePeriod")
    def expire_period(self) -> _builtins.str:
        """
        The period of time that must pass after creating a image for it to suit the automatic deletion criteria. It must be a multiple of 24 hours.
        """
        return pulumi.get(self, "expire_period")

    @_builtins.property
    @pulumi.getter(name="retainedTop")
    def retained_top(self) -> _builtins.int:
        """
        The number of images to be retained even if the `expire_period` already expired.
        """
        return pulumi.get(self, "retained_top")

    @_builtins.property
    @pulumi.getter(name="tagRegexp")
    def tag_regexp(self) -> _builtins.str:
        """
        Tag to specify a filter as a regular expression. For example `.*` - all images with tags.
        """
        return pulumi.get(self, "tag_regexp")

    @_builtins.property
    @pulumi.getter
    def untagged(self) -> _builtins.bool:
        """
        If enabled, rules apply to untagged Docker images.
        """
        return pulumi.get(self, "untagged")


@pulumi.output_type
class GetDataprocClusterClusterConfigResult(dict):
    def __init__(__self__, *,
                 hadoops: Sequence['outputs.GetDataprocClusterClusterConfigHadoopResult'],
                 subcluster_specs: Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResult'],
                 version_id: _builtins.str):
        """
        :param Sequence['GetDataprocClusterClusterConfigHadoopArgs'] hadoops: Yandex Data Processing specific options.
        :param Sequence['GetDataprocClusterClusterConfigSubclusterSpecArgs'] subcluster_specs: Configuration of the Yandex Data Processing subcluster.
        :param _builtins.str version_id: Version of Yandex Data Processing image.
        """
        pulumi.set(__self__, "hadoops", hadoops)
        pulumi.set(__self__, "subcluster_specs", subcluster_specs)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter
    def hadoops(self) -> Sequence['outputs.GetDataprocClusterClusterConfigHadoopResult']:
        """
        Yandex Data Processing specific options.
        """
        return pulumi.get(self, "hadoops")

    @_builtins.property
    @pulumi.getter(name="subclusterSpecs")
    def subcluster_specs(self) -> Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResult']:
        """
        Configuration of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "subcluster_specs")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Version of Yandex Data Processing image.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class GetDataprocClusterClusterConfigHadoopResult(dict):
    def __init__(__self__, *,
                 initialization_actions: Sequence['outputs.GetDataprocClusterClusterConfigHadoopInitializationActionResult'],
                 oslogin: _builtins.bool,
                 properties: Mapping[str, _builtins.str],
                 services: Sequence[_builtins.str],
                 ssh_public_keys: Sequence[_builtins.str]):
        """
        :param Sequence['GetDataprocClusterClusterConfigHadoopInitializationActionArgs'] initialization_actions: List of initialization scripts.
        :param _builtins.bool oslogin: Whether to enable authorization via OS Login.
        :param Mapping[str, _builtins.str] properties: A set of key/value pairs that are used to configure cluster services.
        :param Sequence[_builtins.str] services: List of services to run on Yandex Data Processing cluster.
        :param Sequence[_builtins.str] ssh_public_keys: List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://yandex.cloud/docs/data-proc/operations/connect).
        """
        pulumi.set(__self__, "initialization_actions", initialization_actions)
        pulumi.set(__self__, "oslogin", oslogin)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @_builtins.property
    @pulumi.getter(name="initializationActions")
    def initialization_actions(self) -> Sequence['outputs.GetDataprocClusterClusterConfigHadoopInitializationActionResult']:
        """
        List of initialization scripts.
        """
        return pulumi.get(self, "initialization_actions")

    @_builtins.property
    @pulumi.getter
    def oslogin(self) -> _builtins.bool:
        """
        Whether to enable authorization via OS Login.
        """
        return pulumi.get(self, "oslogin")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value pairs that are used to configure cluster services.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence[_builtins.str]:
        """
        List of services to run on Yandex Data Processing cluster.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Sequence[_builtins.str]:
        """
        List of SSH public keys to put to the hosts of the cluster. For information on how to connect to the cluster, see [the official documentation](https://yandex.cloud/docs/data-proc/operations/connect).
        """
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class GetDataprocClusterClusterConfigHadoopInitializationActionResult(dict):
    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 timeout: _builtins.str,
                 uri: _builtins.str):
        """
        :param Sequence[_builtins.str] args: List of arguments of the initialization script.
        :param _builtins.str timeout: Script execution timeout, in seconds.
        :param _builtins.str uri: Script URI.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        List of arguments of the initialization script.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Script execution timeout, in seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        Script URI.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetDataprocClusterClusterConfigSubclusterSpecResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 autoscaling_configs: Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult'],
                 hosts_count: _builtins.int,
                 id: _builtins.str,
                 name: _builtins.str,
                 resources: Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResourceResult'],
                 role: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.bool assign_public_ip: If `true` then assign public IP addresses to the hosts of the subclusters.
        :param Sequence['GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigArgs'] autoscaling_configs: Autoscaling configuration for compute subclusters.
        :param _builtins.int hosts_count: Number of hosts within Yandex Data Processing subcluster.
        :param _builtins.str id: ID of the subcluster.
        :param _builtins.str name: Name of the Yandex Data Processing subcluster.
        :param Sequence['GetDataprocClusterClusterConfigSubclusterSpecResourceArgs'] resources: Resources allocated to each host of the Yandex Data Processing subcluster.
        :param _builtins.str role: Role of the subcluster in the Yandex Data Processing cluster.
        :param _builtins.str subnet_id: The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "autoscaling_configs", autoscaling_configs)
        pulumi.set(__self__, "hosts_count", hosts_count)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        """
        If `true` then assign public IP addresses to the hosts of the subclusters.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="autoscalingConfigs")
    def autoscaling_configs(self) -> Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult']:
        """
        Autoscaling configuration for compute subclusters.
        """
        return pulumi.get(self, "autoscaling_configs")

    @_builtins.property
    @pulumi.getter(name="hostsCount")
    def hosts_count(self) -> _builtins.int:
        """
        Number of hosts within Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "hosts_count")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the subcluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetDataprocClusterClusterConfigSubclusterSpecResourceResult']:
        """
        Resources allocated to each host of the Yandex Data Processing subcluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Role of the subcluster in the Yandex Data Processing cluster.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which hosts of the subcluster belong. Subnets of all the subclusters must belong to the same VPC network.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfigResult(dict):
    def __init__(__self__, *,
                 cpu_utilization_target: _builtins.str,
                 decommission_timeout: _builtins.str,
                 max_hosts_count: _builtins.int,
                 measurement_duration: _builtins.str,
                 preemptible: _builtins.bool,
                 stabilization_duration: _builtins.str,
                 warmup_duration: _builtins.str):
        """
        :param _builtins.str cpu_utilization_target: Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        :param _builtins.str decommission_timeout: Timeout to gracefully decommission nodes during downscaling. In seconds.
        :param _builtins.int max_hosts_count: Maximum number of nodes in autoscaling subclusters.
        :param _builtins.str measurement_duration: Time in seconds allotted for averaging metrics.
        :param _builtins.bool preemptible: Use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://yandex.cloud/docs/compute/concepts/preemptible-vm).
        :param _builtins.str stabilization_duration: Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        :param _builtins.str warmup_duration: The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        pulumi.set(__self__, "cpu_utilization_target", cpu_utilization_target)
        pulumi.set(__self__, "decommission_timeout", decommission_timeout)
        pulumi.set(__self__, "max_hosts_count", max_hosts_count)
        pulumi.set(__self__, "measurement_duration", measurement_duration)
        pulumi.set(__self__, "preemptible", preemptible)
        pulumi.set(__self__, "stabilization_duration", stabilization_duration)
        pulumi.set(__self__, "warmup_duration", warmup_duration)

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationTarget")
    def cpu_utilization_target(self) -> _builtins.str:
        """
        Defines an autoscaling rule based on the average CPU utilization of the instance group. If not set default autoscaling metric will be used.
        """
        return pulumi.get(self, "cpu_utilization_target")

    @_builtins.property
    @pulumi.getter(name="decommissionTimeout")
    def decommission_timeout(self) -> _builtins.str:
        """
        Timeout to gracefully decommission nodes during downscaling. In seconds.
        """
        return pulumi.get(self, "decommission_timeout")

    @_builtins.property
    @pulumi.getter(name="maxHostsCount")
    def max_hosts_count(self) -> _builtins.int:
        """
        Maximum number of nodes in autoscaling subclusters.
        """
        return pulumi.get(self, "max_hosts_count")

    @_builtins.property
    @pulumi.getter(name="measurementDuration")
    def measurement_duration(self) -> _builtins.str:
        """
        Time in seconds allotted for averaging metrics.
        """
        return pulumi.get(self, "measurement_duration")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> _builtins.bool:
        """
        Use preemptible compute instances. Preemptible instances are stopped at least once every 24 hours, and can be stopped at any time if their resources are needed by Compute. For more information, see [Preemptible Virtual Machines](https://yandex.cloud/docs/compute/concepts/preemptible-vm).
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="stabilizationDuration")
    def stabilization_duration(self) -> _builtins.str:
        """
        Minimum amount of time in seconds allotted for monitoring before Instance Groups can reduce the number of instances in the group. During this time, the group size doesn't decrease, even if the new metric values indicate that it should.
        """
        return pulumi.get(self, "stabilization_duration")

    @_builtins.property
    @pulumi.getter(name="warmupDuration")
    def warmup_duration(self) -> _builtins.str:
        """
        The warmup time of the instance in seconds. During this time, traffic is sent to the instance, but instance metrics are not collected.
        """
        return pulumi.get(self, "warmup_duration")


@pulumi.output_type
class GetDataprocClusterClusterConfigSubclusterSpecResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://yandex.cloud/docs/data-proc/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of a host. One of `network-hdd` (default) or `network-ssd`.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host. All available presets are listed in the [documentation](https://yandex.cloud/docs/data-proc/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetFunctionAsyncInvocationResult(dict):
    def __init__(__self__, *,
                 retries_count: _builtins.int,
                 service_account_id: _builtins.str,
                 ymq_failure_targets: Sequence['outputs.GetFunctionAsyncInvocationYmqFailureTargetResult'],
                 ymq_success_targets: Sequence['outputs.GetFunctionAsyncInvocationYmqSuccessTargetResult']):
        """
        :param _builtins.int retries_count: Maximum number of retries for async invocation.
        :param _builtins.str service_account_id: Service account used for async invocation.
        :param Sequence['GetFunctionAsyncInvocationYmqFailureTargetArgs'] ymq_failure_targets: Target for unsuccessful async invocation.
        :param Sequence['GetFunctionAsyncInvocationYmqSuccessTargetArgs'] ymq_success_targets: Target for successful async invocation.
        """
        pulumi.set(__self__, "retries_count", retries_count)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "ymq_failure_targets", ymq_failure_targets)
        pulumi.set(__self__, "ymq_success_targets", ymq_success_targets)

    @_builtins.property
    @pulumi.getter(name="retriesCount")
    def retries_count(self) -> _builtins.int:
        """
        Maximum number of retries for async invocation.
        """
        return pulumi.get(self, "retries_count")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account used for async invocation.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="ymqFailureTargets")
    def ymq_failure_targets(self) -> Sequence['outputs.GetFunctionAsyncInvocationYmqFailureTargetResult']:
        """
        Target for unsuccessful async invocation.
        """
        return pulumi.get(self, "ymq_failure_targets")

    @_builtins.property
    @pulumi.getter(name="ymqSuccessTargets")
    def ymq_success_targets(self) -> Sequence['outputs.GetFunctionAsyncInvocationYmqSuccessTargetResult']:
        """
        Target for successful async invocation.
        """
        return pulumi.get(self, "ymq_success_targets")


@pulumi.output_type
class GetFunctionAsyncInvocationYmqFailureTargetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str arn: YMQ ARN.
        :param _builtins.str service_account_id: Service account used for writing result to queue.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        YMQ ARN.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account used for writing result to queue.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetFunctionAsyncInvocationYmqSuccessTargetResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str arn: YMQ ARN.
        :param _builtins.str service_account_id: Service account used for writing result to queue.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        YMQ ARN.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account used for writing result to queue.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetFunctionConnectivityResult(dict):
    def __init__(__self__, *,
                 network_id: _builtins.str):
        """
        :param _builtins.str network_id: Network the version will have access to. It's essential to specify network with subnets in all availability zones.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network the version will have access to. It's essential to specify network with subnets in all availability zones.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class GetFunctionLogOptionResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 folder_id: _builtins.str,
                 log_group_id: _builtins.str,
                 min_level: _builtins.str):
        """
        :param _builtins.bool disabled: Is logging from function disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Is logging from function disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> _builtins.str:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class GetFunctionMetadataOptionsResult(dict):
    def __init__(__self__, *,
                 aws_v1_http_endpoint: _builtins.int,
                 gce_http_endpoint: _builtins.int):
        """
        :param _builtins.int aws_v1_http_endpoint: Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        :param _builtins.int gce_http_endpoint: Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> _builtins.int:
        """
        Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> _builtins.int:
        """
        Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "gce_http_endpoint")


@pulumi.output_type
class GetFunctionMountResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 name: _builtins.str,
                 ephemeral_disk: Optional['outputs.GetFunctionMountEphemeralDiskResult'] = None,
                 object_storage: Optional['outputs.GetFunctionMountObjectStorageResult'] = None):
        """
        :param _builtins.str mode: Mounts accessibility mode. Valid values are `ro` and `rw`.
        :param _builtins.str name: Name of the mount point. The directory where the target is mounted will be accessible at the `/function/storage/<mounts.0.name>` path.
        :param 'GetFunctionMountEphemeralDiskArgs' ephemeral_disk: One of the available mount types. Disk available during the function execution time.
        :param 'GetFunctionMountObjectStorageArgs' object_storage: One of the available mount types. Object storage as a mount.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "name", name)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the mount point. The directory where the target is mounted will be accessible at the `/function/storage/<mounts.0.name>` path.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional['outputs.GetFunctionMountEphemeralDiskResult']:
        """
        One of the available mount types. Disk available during the function execution time.
        """
        return pulumi.get(self, "ephemeral_disk")

    @_builtins.property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional['outputs.GetFunctionMountObjectStorageResult']:
        """
        One of the available mount types. Object storage as a mount.
        """
        return pulumi.get(self, "object_storage")


@pulumi.output_type
class GetFunctionMountEphemeralDiskResult(dict):
    def __init__(__self__, *,
                 block_size_kb: _builtins.int,
                 size_gb: _builtins.int):
        """
        :param _builtins.int block_size_kb: Optional block size of the ephemeral disk in KB.
        :param _builtins.int size_gb: Size of the ephemeral disk in GB.
        """
        pulumi.set(__self__, "block_size_kb", block_size_kb)
        pulumi.set(__self__, "size_gb", size_gb)

    @_builtins.property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> _builtins.int:
        """
        Optional block size of the ephemeral disk in KB.
        """
        return pulumi.get(self, "block_size_kb")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        """
        Size of the ephemeral disk in GB.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetFunctionMountObjectStorageResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetFunctionScalingPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 tag: _builtins.str,
                 zone_instances_limit: Optional[_builtins.int] = None,
                 zone_requests_limit: Optional[_builtins.int] = None):
        """
        :param _builtins.str tag: Yandex Cloud Function version tag for Yandex Cloud Function scaling policy.
        :param _builtins.int zone_instances_limit: Max number of instances in one zone for Yandex Cloud Function with tag.
        :param _builtins.int zone_requests_limit: Max number of requests in one zone for Yandex Cloud Function with tag.
        """
        pulumi.set(__self__, "tag", tag)
        if zone_instances_limit is not None:
            pulumi.set(__self__, "zone_instances_limit", zone_instances_limit)
        if zone_requests_limit is not None:
            pulumi.set(__self__, "zone_requests_limit", zone_requests_limit)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Yandex Cloud Function version tag for Yandex Cloud Function scaling policy.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="zoneInstancesLimit")
    def zone_instances_limit(self) -> Optional[_builtins.int]:
        """
        Max number of instances in one zone for Yandex Cloud Function with tag.
        """
        return pulumi.get(self, "zone_instances_limit")

    @_builtins.property
    @pulumi.getter(name="zoneRequestsLimit")
    def zone_requests_limit(self) -> Optional[_builtins.int]:
        """
        Max number of requests in one zone for Yandex Cloud Function with tag.
        """
        return pulumi.get(self, "zone_requests_limit")


@pulumi.output_type
class GetFunctionSecretResult(dict):
    def __init__(__self__, *,
                 environment_variable: _builtins.str,
                 id: _builtins.str,
                 key: _builtins.str,
                 version_id: _builtins.str):
        """
        :param _builtins.str environment_variable: Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        :param _builtins.str id: Secret's ID.
        :param _builtins.str key: Secret's entries key which value will be stored in environment variable.
        :param _builtins.str version_id: Secret's version ID.
        """
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> _builtins.str:
        """
        Function's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment_variable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Secret's ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Secret's entries key which value will be stored in environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Secret's version ID.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class GetFunctionStorageMountResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 mount_point_name: _builtins.str,
                 prefix: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str mount_point_name: Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        :param _builtins.bool read_only: Mount the bucket in read-only mode.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_name", mount_point_name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="mountPointName")
    def mount_point_name(self) -> _builtins.str:
        """
        Name of the mount point. The directory where the bucket is mounted will be accessible at the `/function/storage/<mount_point>` path.
        """
        return pulumi.get(self, "mount_point_name")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Mount the bucket in read-only mode.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetFunctionTriggerContainerResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 path: _builtins.str,
                 retry_attempts: _builtins.str,
                 retry_interval: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str id: Yandex Cloud Serverless Container ID for Yandex Cloud Functions Trigger.
        :param _builtins.str path: Path for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        :param _builtins.str retry_attempts: Retry attempts for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        :param _builtins.str retry_interval: Retry interval in seconds for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "retry_attempts", retry_attempts)
        pulumi.set(__self__, "retry_interval", retry_interval)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Yandex Cloud Serverless Container ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> _builtins.str:
        """
        Retry attempts for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_attempts")

    @_builtins.property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> _builtins.str:
        """
        Retry interval in seconds for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_interval")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account ID for Yandex Cloud Serverless Container for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetFunctionTriggerContainerRegistryResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 create_image: _builtins.bool,
                 create_image_tag: _builtins.bool,
                 delete_image: _builtins.bool,
                 delete_image_tag: _builtins.bool,
                 image_name: _builtins.str,
                 registry_id: _builtins.str,
                 tag: _builtins.str):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.bool create_image: Boolean flag for setting `create image` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool create_image_tag: Boolean flag for setting `create image tag` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool delete_image: Boolean flag for setting `delete image` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool delete_image_tag: Boolean flag for setting `delete image tag` event for Yandex Cloud Functions Trigger.
        :param _builtins.str image_name: Image name filter setting for Yandex Cloud Functions Trigger.
        :param _builtins.str registry_id: Container Registry ID for Yandex Cloud Functions Trigger.
        :param _builtins.str tag: Image tag filter setting for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "create_image", create_image)
        pulumi.set(__self__, "create_image_tag", create_image_tag)
        pulumi.set(__self__, "delete_image", delete_image)
        pulumi.set(__self__, "delete_image_tag", delete_image_tag)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "registry_id", registry_id)
        pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="createImage")
    def create_image(self) -> _builtins.bool:
        """
        Boolean flag for setting `create image` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "create_image")

    @_builtins.property
    @pulumi.getter(name="createImageTag")
    def create_image_tag(self) -> _builtins.bool:
        """
        Boolean flag for setting `create image tag` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "create_image_tag")

    @_builtins.property
    @pulumi.getter(name="deleteImage")
    def delete_image(self) -> _builtins.bool:
        """
        Boolean flag for setting `delete image` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "delete_image")

    @_builtins.property
    @pulumi.getter(name="deleteImageTag")
    def delete_image_tag(self) -> _builtins.bool:
        """
        Boolean flag for setting `delete image tag` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "delete_image_tag")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> _builtins.str:
        """
        Image name filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> _builtins.str:
        """
        Container Registry ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "registry_id")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Image tag filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetFunctionTriggerDataStreamResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 database: _builtins.str,
                 service_account_id: _builtins.bool,
                 stream_name: _builtins.str,
                 suffix: _builtins.str):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str database: Stream database for Yandex Cloud Functions Trigger.
        :param _builtins.bool service_account_id: Service account ID to access data stream for Yandex Cloud Functions Trigger.
        :param _builtins.str stream_name: Stream name for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)
        pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Stream database for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.bool:
        """
        Service account ID to access data stream for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Stream name for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "stream_name")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> _builtins.str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class GetFunctionTriggerDlqResult(dict):
    def __init__(__self__, *,
                 queue_id: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str queue_id: ID of Dead Letter Queue for Trigger (Queue ARN).
        :param _builtins.str service_account_id: Service Account ID for Dead Letter Queue for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.str:
        """
        ID of Dead Letter Queue for Trigger (Queue ARN).
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service Account ID for Dead Letter Queue for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetFunctionTriggerFunctionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 retry_attempts: _builtins.str,
                 retry_interval: _builtins.str,
                 service_account_id: _builtins.str,
                 tag: _builtins.str):
        """
        :param _builtins.str id: Yandex Cloud Function ID.
        :param _builtins.str retry_attempts: Retry attempts for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        :param _builtins.str retry_interval: Retry interval in seconds for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID for Yandex Cloud Function.
        :param _builtins.str tag: Tag for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retry_attempts", retry_attempts)
        pulumi.set(__self__, "retry_interval", retry_interval)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Yandex Cloud Function ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retryAttempts")
    def retry_attempts(self) -> _builtins.str:
        """
        Retry attempts for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_attempts")

    @_builtins.property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> _builtins.str:
        """
        Retry interval in seconds for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "retry_interval")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account ID for Yandex Cloud Function.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Tag for Yandex Cloud Function for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetFunctionTriggerIotResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 device_id: _builtins.str,
                 registry_id: _builtins.str,
                 topic: _builtins.str):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str device_id: IoT Device ID for Yandex Cloud Functions Trigger.
        :param _builtins.str registry_id: IoT Registry ID for Yandex Cloud Functions Trigger.
        :param _builtins.str topic: IoT Topic for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "registry_id", registry_id)
        pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        IoT Device ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> _builtins.str:
        """
        IoT Registry ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "registry_id")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        IoT Topic for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetFunctionTriggerLogGroupResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 log_group_ids: Sequence[_builtins.str]):
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "log_group_ids", log_group_ids)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="logGroupIds")
    def log_group_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "log_group_ids")


@pulumi.output_type
class GetFunctionTriggerLoggingResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 group_id: _builtins.str,
                 levels: Sequence[_builtins.str],
                 resource_ids: Sequence[_builtins.str],
                 resource_types: Sequence[_builtins.str],
                 stream_names: Sequence[_builtins.str]):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str group_id: Logging group ID for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] levels: Logging level filter setting for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] resource_ids: Resource ID filter setting for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] resource_types: Resource type filter setting for Yandex Cloud Functions Trigger.
        :param Sequence[_builtins.str] stream_names: Logging stream name filter setting for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "resource_ids", resource_ids)
        pulumi.set(__self__, "resource_types", resource_types)
        pulumi.set(__self__, "stream_names", stream_names)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Logging group ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def levels(self) -> Sequence[_builtins.str]:
        """
        Logging level filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "levels")

    @_builtins.property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Sequence[_builtins.str]:
        """
        Resource ID filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "resource_ids")

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Sequence[_builtins.str]:
        """
        Resource type filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "resource_types")

    @_builtins.property
    @pulumi.getter(name="streamNames")
    def stream_names(self) -> Sequence[_builtins.str]:
        """
        Logging stream name filter setting for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "stream_names")


@pulumi.output_type
class GetFunctionTriggerMailResult(dict):
    def __init__(__self__, *,
                 attachments_bucket_id: _builtins.str,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str attachments_bucket_id: Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Service account ID to access object storage for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "attachments_bucket_id", attachments_bucket_id)
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="attachmentsBucketId")
    def attachments_bucket_id(self) -> _builtins.str:
        """
        Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "attachments_bucket_id")

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account ID to access object storage for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetFunctionTriggerMessageQueueResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 queue_id: _builtins.str,
                 service_account_id: _builtins.str,
                 visibility_timeout: _builtins.str):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str queue_id: Message Queue ID for Yandex Cloud Functions Trigger.
        :param _builtins.str service_account_id: Message Queue Service Account ID for Yandex Cloud Functions Trigger.
        :param _builtins.str visibility_timeout: Visibility timeout for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.str:
        """
        Message Queue ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Message Queue Service Account ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> _builtins.str:
        """
        Visibility timeout for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class GetFunctionTriggerObjectStorageResult(dict):
    def __init__(__self__, *,
                 batch_cutoff: _builtins.str,
                 batch_size: _builtins.str,
                 bucket_id: _builtins.str,
                 create: _builtins.bool,
                 delete: _builtins.bool,
                 prefix: _builtins.str,
                 suffix: _builtins.str,
                 update: _builtins.bool):
        """
        :param _builtins.str batch_cutoff: Batch Duration in seconds for Yandex Cloud Functions Trigger.
        :param _builtins.str batch_size: Batch Size for Yandex Cloud Functions Trigger.
        :param _builtins.str bucket_id: Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        :param _builtins.bool create: Boolean flag for setting `create` event for Yandex Cloud Functions Trigger.
        :param _builtins.bool delete: Boolean flag for setting `delete` event for Yandex Cloud Functions Trigger.
        :param _builtins.str prefix: Prefix for Object Storage for Yandex Cloud Functions Trigger.
        :param _builtins.str suffix: Suffix for Object Storage for Yandex Cloud Functions Trigger.
        :param _builtins.bool update: Boolean flag for setting `update` event for Yandex Cloud Functions Trigger.
        """
        pulumi.set(__self__, "batch_cutoff", batch_cutoff)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "bucket_id", bucket_id)
        pulumi.set(__self__, "create", create)
        pulumi.set(__self__, "delete", delete)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "suffix", suffix)
        pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter(name="batchCutoff")
    def batch_cutoff(self) -> _builtins.str:
        """
        Batch Duration in seconds for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_cutoff")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.str:
        """
        Batch Size for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="bucketId")
    def bucket_id(self) -> _builtins.str:
        """
        Object Storage Bucket ID for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "bucket_id")

    @_builtins.property
    @pulumi.getter
    def create(self) -> _builtins.bool:
        """
        Boolean flag for setting `create` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> _builtins.bool:
        """
        Boolean flag for setting `delete` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        Prefix for Object Storage for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> _builtins.str:
        """
        Suffix for Object Storage for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "suffix")

    @_builtins.property
    @pulumi.getter
    def update(self) -> _builtins.bool:
        """
        Boolean flag for setting `update` event for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GetFunctionTriggerTimerResult(dict):
    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 payload: _builtins.str):
        """
        :param _builtins.str cron_expression: Cron expression for timer for Yandex Cloud Functions Trigger.
        :param _builtins.str payload: Payload to be passed to function.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        Cron expression for timer for Yandex Cloud Functions Trigger.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> _builtins.str:
        """
        Payload to be passed to function.
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class GetIamPolicyBindingResult(dict):
    def __init__(__self__, *,
                 members: Sequence[_builtins.str],
                 role: _builtins.str):
        """
        :param Sequence[_builtins.str] members: An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:
        :param _builtins.str role: The role/permission that will be granted to the members. See the [IAM Roles](https://yandex.cloud/docs/iam/concepts/access-control/roles) documentation for a complete list of roles.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence[_builtins.str]:
        """
        An array of identities that will be granted the privilege in the `role`. Each entry can have one of the following values:
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role/permission that will be granted to the members. See the [IAM Roles](https://yandex.cloud/docs/iam/concepts/access-control/roles) documentation for a complete list of roles.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetIotCoreBrokerLogOptionResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 folder_id: _builtins.str,
                 log_group_id: _builtins.str,
                 min_level: _builtins.str):
        """
        :param _builtins.bool disabled: Is logging for broker disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Is logging for broker disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> _builtins.str:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class GetIotCoreRegistryLogOptionResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 folder_id: _builtins.str,
                 log_group_id: _builtins.str,
                 min_level: _builtins.str):
        """
        :param _builtins.bool disabled: Is logging for registry disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Is logging for registry disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> _builtins.str:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class GetKubernetesClusterKmsProviderResult(dict):
    def __init__(__self__, *,
                 key_id: _builtins.str):
        """
        :param _builtins.str key_id: KMS key ID.
        """
        pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> _builtins.str:
        """
        KMS key ID.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class GetKubernetesClusterMasterResult(dict):
    def __init__(__self__, *,
                 cluster_ca_certificate: _builtins.str,
                 etcd_cluster_size: _builtins.int,
                 external_v4_address: _builtins.str,
                 external_v4_endpoint: _builtins.str,
                 external_v6_address: _builtins.str,
                 external_v6_endpoint: _builtins.str,
                 internal_v4_address: _builtins.str,
                 internal_v4_endpoint: _builtins.str,
                 maintenance_policies: Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyResult'],
                 master_locations: Sequence['outputs.GetKubernetesClusterMasterMasterLocationResult'],
                 master_loggings: Sequence['outputs.GetKubernetesClusterMasterMasterLoggingResult'],
                 public_ip: _builtins.bool,
                 regionals: Sequence['outputs.GetKubernetesClusterMasterRegionalResult'],
                 scale_policies: Sequence['outputs.GetKubernetesClusterMasterScalePolicyResult'],
                 security_group_ids: Sequence[_builtins.str],
                 version: _builtins.str,
                 version_infos: Sequence['outputs.GetKubernetesClusterMasterVersionInfoResult'],
                 zonals: Sequence['outputs.GetKubernetesClusterMasterZonalResult']):
        """
        :param _builtins.str cluster_ca_certificate: PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        :param _builtins.int etcd_cluster_size: Number of etcd clusters that will be used for the Kubernetes master.
        :param _builtins.str external_v4_address: An IPv4 external network address that is assigned to the master.
        :param _builtins.str external_v4_endpoint: External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param _builtins.str external_v6_address: An IPv6 external network address that is assigned to the master.
        :param _builtins.str external_v6_endpoint: External IPv6 endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        :param _builtins.str internal_v4_address: An IPv4 internal network address that is assigned to the master.
        :param _builtins.str internal_v4_endpoint: Internal endpoint that can be used to connect to the master from cloud networks.
        :param Sequence['GetKubernetesClusterMasterMaintenancePolicyArgs'] maintenance_policies: Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually.
        :param Sequence['GetKubernetesClusterMasterMasterLocationArgs'] master_locations: Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated in place. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend.
        :param Sequence['GetKubernetesClusterMasterMasterLoggingArgs'] master_loggings: Master Logging options.
        :param _builtins.bool public_ip: When `true`, Kubernetes master will have visible ipv4 address.
        :param Sequence['GetKubernetesClusterMasterRegionalArgs'] regionals: Initialize parameters for Regional Master (highly available master).
        :param Sequence['GetKubernetesClusterMasterScalePolicyArgs'] scale_policies: Scale policy of the master.
        :param Sequence[_builtins.str] security_group_ids: The list of security groups applied to resource or their components.
        :param _builtins.str version: Version of Kubernetes that will be used for master.
        :param Sequence['GetKubernetesClusterMasterVersionInfoArgs'] version_infos: Information about cluster version.
        :param Sequence['GetKubernetesClusterMasterZonalArgs'] zonals: Initialize parameters for Zonal Master (single node master).
        """
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        pulumi.set(__self__, "external_v4_address", external_v4_address)
        pulumi.set(__self__, "external_v4_endpoint", external_v4_endpoint)
        pulumi.set(__self__, "external_v6_address", external_v6_address)
        pulumi.set(__self__, "external_v6_endpoint", external_v6_endpoint)
        pulumi.set(__self__, "internal_v4_address", internal_v4_address)
        pulumi.set(__self__, "internal_v4_endpoint", internal_v4_endpoint)
        pulumi.set(__self__, "maintenance_policies", maintenance_policies)
        pulumi.set(__self__, "master_locations", master_locations)
        pulumi.set(__self__, "master_loggings", master_loggings)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "regionals", regionals)
        pulumi.set(__self__, "scale_policies", scale_policies)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "version_infos", version_infos)
        pulumi.set(__self__, "zonals", zonals)

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> _builtins.str:
        """
        PEM-encoded public certificate that is the root of trust for the Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> _builtins.int:
        """
        Number of etcd clusters that will be used for the Kubernetes master.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @_builtins.property
    @pulumi.getter(name="externalV4Address")
    def external_v4_address(self) -> _builtins.str:
        """
        An IPv4 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v4_address")

    @_builtins.property
    @pulumi.getter(name="externalV4Endpoint")
    def external_v4_endpoint(self) -> _builtins.str:
        """
        External endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v4_endpoint")

    @_builtins.property
    @pulumi.getter(name="externalV6Address")
    def external_v6_address(self) -> _builtins.str:
        """
        An IPv6 external network address that is assigned to the master.
        """
        return pulumi.get(self, "external_v6_address")

    @_builtins.property
    @pulumi.getter(name="externalV6Endpoint")
    def external_v6_endpoint(self) -> _builtins.str:
        """
        External IPv6 endpoint that can be used to access Kubernetes cluster API from the internet (outside of the cloud).
        """
        return pulumi.get(self, "external_v6_endpoint")

    @_builtins.property
    @pulumi.getter(name="internalV4Address")
    def internal_v4_address(self) -> _builtins.str:
        """
        An IPv4 internal network address that is assigned to the master.
        """
        return pulumi.get(self, "internal_v4_address")

    @_builtins.property
    @pulumi.getter(name="internalV4Endpoint")
    def internal_v4_endpoint(self) -> _builtins.str:
        """
        Internal endpoint that can be used to connect to the master from cloud networks.
        """
        return pulumi.get(self, "internal_v4_endpoint")

    @_builtins.property
    @pulumi.getter(name="maintenancePolicies")
    def maintenance_policies(self) -> Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyResult']:
        """
        Maintenance policy for Kubernetes master. If policy is omitted, automatic revision upgrades of the kubernetes master are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. 1.29. Minor version upgrades (e.g. 1.29->1.30) should be performed manually.
        """
        return pulumi.get(self, "maintenance_policies")

    @_builtins.property
    @pulumi.getter(name="masterLocations")
    def master_locations(self) -> Sequence['outputs.GetKubernetesClusterMasterMasterLocationResult']:
        """
        Cluster master's instances locations array (zone and subnet). Cannot be used together with `zonal` or `regional`. Currently, supports either one, for zonal master, or three instances of `master_location`. Can be updated in place. When creating regional cluster (three master instances), its `region` will be evaluated automatically by backend.
        """
        return pulumi.get(self, "master_locations")

    @_builtins.property
    @pulumi.getter(name="masterLoggings")
    def master_loggings(self) -> Sequence['outputs.GetKubernetesClusterMasterMasterLoggingResult']:
        """
        Master Logging options.
        """
        return pulumi.get(self, "master_loggings")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.bool:
        """
        When `true`, Kubernetes master will have visible ipv4 address.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def regionals(self) -> Sequence['outputs.GetKubernetesClusterMasterRegionalResult']:
        """
        Initialize parameters for Regional Master (highly available master).
        """
        return pulumi.get(self, "regionals")

    @_builtins.property
    @pulumi.getter(name="scalePolicies")
    def scale_policies(self) -> Sequence['outputs.GetKubernetesClusterMasterScalePolicyResult']:
        """
        Scale policy of the master.
        """
        return pulumi.get(self, "scale_policies")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        The list of security groups applied to resource or their components.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of Kubernetes that will be used for master.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="versionInfos")
    def version_infos(self) -> Sequence['outputs.GetKubernetesClusterMasterVersionInfoResult']:
        """
        Information about cluster version.
        """
        return pulumi.get(self, "version_infos")

    @_builtins.property
    @pulumi.getter
    def zonals(self) -> Sequence['outputs.GetKubernetesClusterMasterZonalResult']:
        """
        Initialize parameters for Zonal Master (single node master).
        """
        return pulumi.get(self, "zonals")


@pulumi.output_type
class GetKubernetesClusterMasterMaintenancePolicyResult(dict):
    def __init__(__self__, *,
                 auto_upgrade: _builtins.bool,
                 maintenance_windows: Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult']):
        """
        :param _builtins.bool auto_upgrade: Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        :param Sequence['GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> _builtins.bool:
        """
        Boolean flag that specifies if master can be upgraded automatically. When omitted, default value is TRUE.
        """
        return pulumi.get(self, "auto_upgrade")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult']:
        """
        This structure specifies maintenance window, when update for master is allowed. When omitted, it defaults to any time. To specify time of day interval, for all days, one element should be provided, with two fields set, `start_time` and `duration`. Please see `zonal_cluster_resource_name` config example.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 duration: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str day: The day of the week which you want to update.
        :param _builtins.str duration: The duration of the day of week you want to update.
        :param _builtins.str start_time: The start time of the day of week you want to update.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day of the week which you want to update.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        The duration of the day of week you want to update.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the day of week you want to update.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetKubernetesClusterMasterMasterLocationResult(dict):
    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 zone: _builtins.str):
        """
        :param _builtins.str subnet_id: ID of the subnet.
        :param _builtins.str zone: ID of the availability zone.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetKubernetesClusterMasterMasterLoggingResult(dict):
    def __init__(__self__, *,
                 audit_enabled: _builtins.bool,
                 cluster_autoscaler_enabled: _builtins.bool,
                 enabled: _builtins.bool,
                 events_enabled: _builtins.bool,
                 folder_id: _builtins.str,
                 kube_apiserver_enabled: _builtins.bool,
                 log_group_id: _builtins.str):
        """
        :param _builtins.bool audit_enabled: Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        :param _builtins.bool cluster_autoscaler_enabled: Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        :param _builtins.bool enabled: Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://yandex.cloud/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        :param _builtins.bool events_enabled: Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        :param _builtins.str folder_id: ID of the folder default Log group of which should be used to collect logs.
        :param _builtins.bool kube_apiserver_enabled: Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        :param _builtins.str log_group_id: ID of the Yandex Cloud Logging [Log group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        pulumi.set(__self__, "audit_enabled", audit_enabled)
        pulumi.set(__self__, "cluster_autoscaler_enabled", cluster_autoscaler_enabled)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "events_enabled", events_enabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "kube_apiserver_enabled", kube_apiserver_enabled)
        pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> _builtins.bool:
        """
        Boolean flag that specifies if kube-apiserver audit logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "audit_enabled")

    @_builtins.property
    @pulumi.getter(name="clusterAutoscalerEnabled")
    def cluster_autoscaler_enabled(self) -> _builtins.bool:
        """
        Boolean flag that specifies if cluster-autoscaler logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "cluster_autoscaler_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Boolean flag that specifies if master components logs should be sent to [Yandex Cloud Logging](https://yandex.cloud/docs/logging/). The exact components that will send their logs must be configured via the options described below.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="eventsEnabled")
    def events_enabled(self) -> _builtins.bool:
        """
        Boolean flag that specifies if kubernetes cluster events should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "events_enabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        ID of the folder default Log group of which should be used to collect logs.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="kubeApiserverEnabled")
    def kube_apiserver_enabled(self) -> _builtins.bool:
        """
        Boolean flag that specifies if kube-apiserver logs should be sent to Yandex Cloud Logging.
        """
        return pulumi.get(self, "kube_apiserver_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        ID of the Yandex Cloud Logging [Log group](https://yandex.cloud/docs/logging/concepts/log-group).
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class GetKubernetesClusterMasterRegionalResult(dict):
    def __init__(__self__, *,
                 region: _builtins.str):
        """
        :param _builtins.str region: Name of availability region (e.g. `ru-central1`), where master instances will be allocated.
        """
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of availability region (e.g. `ru-central1`), where master instances will be allocated.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetKubernetesClusterMasterScalePolicyResult(dict):
    def __init__(__self__, *,
                 auto_scales: Sequence['outputs.GetKubernetesClusterMasterScalePolicyAutoScaleResult']):
        """
        :param Sequence['GetKubernetesClusterMasterScalePolicyAutoScaleArgs'] auto_scales: Autoscaled master instance resources.
        """
        pulumi.set(__self__, "auto_scales", auto_scales)

    @_builtins.property
    @pulumi.getter(name="autoScales")
    def auto_scales(self) -> Sequence['outputs.GetKubernetesClusterMasterScalePolicyAutoScaleResult']:
        """
        Autoscaled master instance resources.
        """
        return pulumi.get(self, "auto_scales")


@pulumi.output_type
class GetKubernetesClusterMasterScalePolicyAutoScaleResult(dict):
    def __init__(__self__, *,
                 min_resource_preset_id: _builtins.str):
        """
        :param _builtins.str min_resource_preset_id: Minimal resource preset ID.
        """
        pulumi.set(__self__, "min_resource_preset_id", min_resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="minResourcePresetId")
    def min_resource_preset_id(self) -> _builtins.str:
        """
        Minimal resource preset ID.
        """
        return pulumi.get(self, "min_resource_preset_id")


@pulumi.output_type
class GetKubernetesClusterMasterVersionInfoResult(dict):
    def __init__(__self__, *,
                 current_version: _builtins.str,
                 new_revision_available: _builtins.bool,
                 new_revision_summary: _builtins.str,
                 version_deprecated: _builtins.bool):
        """
        :param _builtins.str current_version: Current Kubernetes version, major.minor (e.g. 1.30).
        :param _builtins.bool new_revision_available: Boolean flag. Newer revisions may include Kubernetes patches (e.g `1.30.1` > `1.30.2`) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or node
        :param _builtins.str new_revision_summary: Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        :param _builtins.bool version_deprecated: Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "new_revision_available", new_revision_available)
        pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        pulumi.set(__self__, "version_deprecated", version_deprecated)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> _builtins.str:
        """
        Current Kubernetes version, major.minor (e.g. 1.30).
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> _builtins.bool:
        """
        Boolean flag. Newer revisions may include Kubernetes patches (e.g `1.30.1` > `1.30.2`) as well as some internal component updates - new features or bug fixes in yandex-specific components either on the master or node
        """
        return pulumi.get(self, "new_revision_available")

    @_builtins.property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> _builtins.str:
        """
        Human readable description of the changes to be applied when updating to the latest revision. Empty if new_revision_available is false.
        """
        return pulumi.get(self, "new_revision_summary")

    @_builtins.property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> _builtins.bool:
        """
        Boolean flag. The current version is on the deprecation schedule, component (master or node group) should be upgraded.
        """
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class GetKubernetesClusterMasterZonalResult(dict):
    def __init__(__self__, *,
                 zone: _builtins.str):
        """
        :param _builtins.str zone: ID of the availability zone.
        """
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        ID of the availability zone.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetKubernetesClusterNetworkImplementationResult(dict):
    def __init__(__self__, *,
                 cilia: Sequence['outputs.GetKubernetesClusterNetworkImplementationCiliumResult']):
        """
        :param Sequence['GetKubernetesClusterNetworkImplementationCiliumArgs'] cilia: Cilium network implementation configuration. No options exist.
        """
        pulumi.set(__self__, "cilia", cilia)

    @_builtins.property
    @pulumi.getter
    def cilia(self) -> Sequence['outputs.GetKubernetesClusterNetworkImplementationCiliumResult']:
        """
        Cilium network implementation configuration. No options exist.
        """
        return pulumi.get(self, "cilia")


@pulumi.output_type
class GetKubernetesClusterNetworkImplementationCiliumResult(dict):
    def __init__(__self__, *,
                 routing_mode: _builtins.str):
        """
        :param _builtins.str routing_mode: The routing mode of the network interface.
        """
        pulumi.set(__self__, "routing_mode", routing_mode)

    @_builtins.property
    @pulumi.getter(name="routingMode")
    def routing_mode(self) -> _builtins.str:
        """
        The routing mode of the network interface.
        """
        return pulumi.get(self, "routing_mode")


@pulumi.output_type
class GetKubernetesClusterWorkloadIdentityFederationResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 issuer: _builtins.str,
                 jwks_uri: _builtins.str):
        """
        :param _builtins.bool enabled: Identifies whether Workload Identity Federation is enabled.
        :param _builtins.str issuer: Issuer URI for Kubernetes service account tokens.
        :param _builtins.str jwks_uri: JSON Web Key Set URI used to verify token signatures.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "jwks_uri", jwks_uri)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Identifies whether Workload Identity Federation is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> _builtins.str:
        """
        Issuer URI for Kubernetes service account tokens.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> _builtins.str:
        """
        JSON Web Key Set URI used to verify token signatures.
        """
        return pulumi.get(self, "jwks_uri")


@pulumi.output_type
class GetKubernetesNodeGroupAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 locations: Sequence['outputs.GetKubernetesNodeGroupAllocationPolicyLocationResult']):
        """
        :param Sequence['GetKubernetesNodeGroupAllocationPolicyLocationArgs'] locations: Repeated field, that specify subnets (zones), that will be used by node group compute instances. Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence['outputs.GetKubernetesNodeGroupAllocationPolicyLocationResult']:
        """
        Repeated field, that specify subnets (zones), that will be used by node group compute instances. Subnet specified by `subnet_id` should be allocated in zone specified by 'zone' argument.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetKubernetesNodeGroupAllocationPolicyLocationResult(dict):
    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 zone: _builtins.str):
        """
        :param _builtins.str subnet_id: ID of the subnet, that will be used by one compute instance in node group.
        :param _builtins.str zone: ID of the availability zone where for one compute instance in node group.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet, that will be used by one compute instance in node group.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        ID of the availability zone where for one compute instance in node group.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetKubernetesNodeGroupDeployPolicyResult(dict):
    def __init__(__self__, *,
                 max_expansion: _builtins.int,
                 max_unavailable: _builtins.int):
        """
        :param _builtins.int max_expansion: The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        :param _builtins.int max_unavailable: The maximum number of running instances that can be taken offline during update.
        """
        pulumi.set(__self__, "max_expansion", max_expansion)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxExpansion")
    def max_expansion(self) -> _builtins.int:
        """
        The maximum number of instances that can be temporarily allocated above the group's target size during the update.
        """
        return pulumi.get(self, "max_expansion")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> _builtins.int:
        """
        The maximum number of running instances that can be taken offline during update.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateResult(dict):
    def __init__(__self__, *,
                 boot_disks: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateBootDiskResult'],
                 container_networks: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateContainerNetworkResult'],
                 container_runtime: 'outputs.GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult',
                 gpu_settings: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateGpuSettingResult'],
                 labels: Mapping[str, _builtins.str],
                 metadata: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 nat: _builtins.bool,
                 network_acceleration_type: _builtins.str,
                 network_interfaces: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult'],
                 platform_id: _builtins.str,
                 resources: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateResourceResult'],
                 scheduling_policies: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult'],
                 placement_policies: Optional[Sequence['outputs.GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult']] = None):
        """
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateBootDiskArgs'] boot_disks: The specifications for boot disks that will be attached to the instance.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateContainerNetworkArgs'] container_networks: Container network configuration.
        :param 'GetKubernetesNodeGroupInstanceTemplateContainerRuntimeArgs' container_runtime: Container runtime configuration.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateGpuSettingArgs'] gpu_settings: GPU settings.
        :param Mapping[str, _builtins.str] labels: Labels that will be assigned to compute nodes (instances), created by the Node Group.
        :param Mapping[str, _builtins.str] metadata: The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key `user-data` won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.
        :param _builtins.str name: Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
        :param _builtins.bool nat: Enables NAT for node group compute instances.
        :param _builtins.str network_acceleration_type: Type of network acceleration. Values: `standard`, `software_accelerated`.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceArgs'] network_interfaces: An array with the network interfaces that will be attached to the instance.
        :param _builtins.str platform_id: The ID of the hardware platform configuration for the node group compute instances.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyArgs'] scheduling_policies: The scheduling policy for the instances in node group.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplatePlacementPolicyArgs'] placement_policies: The placement policy configuration.
        """
        pulumi.set(__self__, "boot_disks", boot_disks)
        pulumi.set(__self__, "container_networks", container_networks)
        pulumi.set(__self__, "container_runtime", container_runtime)
        pulumi.set(__self__, "gpu_settings", gpu_settings)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "network_acceleration_type", network_acceleration_type)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "platform_id", platform_id)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "scheduling_policies", scheduling_policies)
        if placement_policies is not None:
            pulumi.set(__self__, "placement_policies", placement_policies)

    @_builtins.property
    @pulumi.getter(name="bootDisks")
    def boot_disks(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateBootDiskResult']:
        """
        The specifications for boot disks that will be attached to the instance.
        """
        return pulumi.get(self, "boot_disks")

    @_builtins.property
    @pulumi.getter(name="containerNetworks")
    def container_networks(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateContainerNetworkResult']:
        """
        Container network configuration.
        """
        return pulumi.get(self, "container_networks")

    @_builtins.property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> 'outputs.GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult':
        """
        Container runtime configuration.
        """
        return pulumi.get(self, "container_runtime")

    @_builtins.property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateGpuSettingResult']:
        """
        GPU settings.
        """
        return pulumi.get(self, "gpu_settings")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Labels that will be assigned to compute nodes (instances), created by the Node Group.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The set of metadata `key:value` pairs assigned to this instance template. This includes custom metadata and predefined keys. **Note**: key `user-data` won't be provided into instances. It reserved for internal activity in `kubernetes_node_group` resource.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name template of the instance. In order to be unique it must contain at least one of instance unique placeholders:
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> _builtins.bool:
        """
        Enables NAT for node group compute instances.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="networkAccelerationType")
    def network_acceleration_type(self) -> _builtins.str:
        """
        Type of network acceleration. Values: `standard`, `software_accelerated`.
        """
        return pulumi.get(self, "network_acceleration_type")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult']:
        """
        An array with the network interfaces that will be attached to the instance.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> _builtins.str:
        """
        The ID of the hardware platform configuration for the node group compute instances.
        """
        return pulumi.get(self, "platform_id")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateResourceResult']:
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicies")
    def scheduling_policies(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult']:
        """
        The scheduling policy for the instances in node group.
        """
        return pulumi.get(self, "scheduling_policies")

    @_builtins.property
    @pulumi.getter(name="placementPolicies")
    def placement_policies(self) -> Optional[Sequence['outputs.GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult']]:
        """
        The placement policy configuration.
        """
        return pulumi.get(self, "placement_policies")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateBootDiskResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int size: The size of the disk in GB. Allowed minimal size: 64 GB.
        :param _builtins.str type: The disk type.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the disk in GB. Allowed minimal size: 64 GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateContainerNetworkResult(dict):
    def __init__(__self__, *,
                 pod_mtu: _builtins.int):
        """
        :param _builtins.int pod_mtu: MTU for pods.
        """
        pulumi.set(__self__, "pod_mtu", pod_mtu)

    @_builtins.property
    @pulumi.getter(name="podMtu")
    def pod_mtu(self) -> _builtins.int:
        """
        MTU for pods.
        """
        return pulumi.get(self, "pod_mtu")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateContainerRuntimeResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Type of container runtime. Values: `docker`, `containerd`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of container runtime. Values: `docker`, `containerd`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateGpuSettingResult(dict):
    def __init__(__self__, *,
                 gpu_cluster_id: _builtins.str,
                 gpu_environment: _builtins.str):
        """
        :param _builtins.str gpu_cluster_id: GPU cluster id.
        :param _builtins.str gpu_environment: GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
        pulumi.set(__self__, "gpu_cluster_id", gpu_cluster_id)
        pulumi.set(__self__, "gpu_environment", gpu_environment)

    @_builtins.property
    @pulumi.getter(name="gpuClusterId")
    def gpu_cluster_id(self) -> _builtins.str:
        """
        GPU cluster id.
        """
        return pulumi.get(self, "gpu_cluster_id")

    @_builtins.property
    @pulumi.getter(name="gpuEnvironment")
    def gpu_environment(self) -> _builtins.str:
        """
        GPU environment. Values: `runc`, `runc_drivers_cuda`.
        """
        return pulumi.get(self, "gpu_environment")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 ipv4: _builtins.bool,
                 ipv4_dns_records: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordResult'],
                 ipv6: _builtins.bool,
                 ipv6_dns_records: Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult'],
                 nat: _builtins.bool,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_ids: Sequence[_builtins.str]):
        """
        :param _builtins.bool ipv4: Allocate an IPv4 address for the interface. The default value is `true`.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordArgs'] ipv4_dns_records: List of configurations for creating ipv4 DNS records.
        :param _builtins.bool ipv6: If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        :param Sequence['GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordArgs'] ipv6_dns_records: List of configurations for creating ipv6 DNS records.
        :param _builtins.bool nat: A public address that can be used to access the internet over NAT.
        :param Sequence[_builtins.str] security_group_ids: Security group IDs for network interface.
        :param Sequence[_builtins.str] subnet_ids: The IDs of the subnets.
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv4_dns_records", ipv4_dns_records)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_dns_records", ipv6_dns_records)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> _builtins.bool:
        """
        Allocate an IPv4 address for the interface. The default value is `true`.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter(name="ipv4DnsRecords")
    def ipv4_dns_records(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordResult']:
        """
        List of configurations for creating ipv4 DNS records.
        """
        return pulumi.get(self, "ipv4_dns_records")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        If true, allocate an IPv6 address for the interface. The address will be automatically assigned from the specified subnet.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6DnsRecords")
    def ipv6_dns_records(self) -> Sequence['outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult']:
        """
        List of configurations for creating ipv6 DNS records.
        """
        return pulumi.get(self, "ipv6_dns_records")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> _builtins.bool:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Security group IDs for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param _builtins.str fqdn: DNS record FQDN.
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL (in seconds).
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL (in seconds).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone ID (if not set, private zone is used).
        :param _builtins.str fqdn: DNS record FQDN.
        :param _builtins.bool ptr: When set to `true`, also create a PTR DNS record.
        :param _builtins.int ttl: DNS record TTL (in seconds).
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone ID (if not set, private zone is used).
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        DNS record FQDN.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        When set to `true`, also create a PTR DNS record.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        DNS record TTL (in seconds).
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplatePlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: _builtins.str):
        """
        :param _builtins.str placement_group_id: Specifies the id of the Placement Group to assign to the instances.
        """
        pulumi.set(__self__, "placement_group_id", placement_group_id)

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> _builtins.str:
        """
        Specifies the id of the Placement Group to assign to the instances.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: _builtins.int,
                 cores: _builtins.int,
                 gpus: _builtins.int,
                 memory: _builtins.float):
        """
        :param _builtins.int core_fraction: Baseline core performance as a percent.
        :param _builtins.int cores: Number of CPU cores allocated to the instance.
        :param _builtins.int gpus: Number of GPU cores allocated to the instance.
        :param _builtins.float memory: The memory size allocated to the instance.
        """
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> _builtins.int:
        """
        Baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> _builtins.int:
        """
        Number of CPU cores allocated to the instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> _builtins.int:
        """
        Number of GPU cores allocated to the instance.
        """
        return pulumi.get(self, "gpus")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        The memory size allocated to the instance.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetKubernetesNodeGroupInstanceTemplateSchedulingPolicyResult(dict):
    def __init__(__self__, *,
                 preemptible: _builtins.bool):
        """
        :param _builtins.bool preemptible: Specifies if the instance is preemptible. Defaults to `false`.
        """
        pulumi.set(__self__, "preemptible", preemptible)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> _builtins.bool:
        """
        Specifies if the instance is preemptible. Defaults to `false`.
        """
        return pulumi.get(self, "preemptible")


@pulumi.output_type
class GetKubernetesNodeGroupMaintenancePolicyResult(dict):
    def __init__(__self__, *,
                 auto_repair: _builtins.bool,
                 auto_upgrade: _builtins.bool,
                 maintenance_windows: Sequence['outputs.GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult']):
        """
        :param _builtins.bool auto_repair: Flag that specifies if node group can be repaired automatically. When omitted, default value is `true`.
        :param _builtins.bool auto_upgrade: Flag specifies if node group can be upgraded automatically. When omitted, default value is `true`.
        :param Sequence['GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowArgs'] maintenance_windows: Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        pulumi.set(__self__, "maintenance_windows", maintenance_windows)

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> _builtins.bool:
        """
        Flag that specifies if node group can be repaired automatically. When omitted, default value is `true`.
        """
        return pulumi.get(self, "auto_repair")

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> _builtins.bool:
        """
        Flag specifies if node group can be upgraded automatically. When omitted, default value is `true`.
        """
        return pulumi.get(self, "auto_upgrade")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Sequence['outputs.GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult']:
        """
        Set of day intervals, when maintenance is allowed for this node group. When omitted, it defaults to any time.
        """
        return pulumi.get(self, "maintenance_windows")


@pulumi.output_type
class GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 duration: _builtins.str,
                 start_time: _builtins.str):
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetKubernetesNodeGroupScalePolicyResult(dict):
    def __init__(__self__, *,
                 auto_scales: Sequence['outputs.GetKubernetesNodeGroupScalePolicyAutoScaleResult'],
                 fixed_scales: Sequence['outputs.GetKubernetesNodeGroupScalePolicyFixedScaleResult']):
        """
        :param Sequence['GetKubernetesNodeGroupScalePolicyAutoScaleArgs'] auto_scales: Scale policy for an autoscaled node group.
        :param Sequence['GetKubernetesNodeGroupScalePolicyFixedScaleArgs'] fixed_scales: Scale policy for a fixed scale node group.
        """
        pulumi.set(__self__, "auto_scales", auto_scales)
        pulumi.set(__self__, "fixed_scales", fixed_scales)

    @_builtins.property
    @pulumi.getter(name="autoScales")
    def auto_scales(self) -> Sequence['outputs.GetKubernetesNodeGroupScalePolicyAutoScaleResult']:
        """
        Scale policy for an autoscaled node group.
        """
        return pulumi.get(self, "auto_scales")

    @_builtins.property
    @pulumi.getter(name="fixedScales")
    def fixed_scales(self) -> Sequence['outputs.GetKubernetesNodeGroupScalePolicyFixedScaleResult']:
        """
        Scale policy for a fixed scale node group.
        """
        return pulumi.get(self, "fixed_scales")


@pulumi.output_type
class GetKubernetesNodeGroupScalePolicyAutoScaleResult(dict):
    def __init__(__self__, *,
                 initial: _builtins.int,
                 max: _builtins.int,
                 min: _builtins.int):
        """
        :param _builtins.int initial: Initial number of instances in the node group.
        :param _builtins.int max: Maximum number of instances in the node group.
        :param _builtins.int min: Minimum number of instances in the node group.
        """
        pulumi.set(__self__, "initial", initial)
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def initial(self) -> _builtins.int:
        """
        Initial number of instances in the node group.
        """
        return pulumi.get(self, "initial")

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        """
        Maximum number of instances in the node group.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        Minimum number of instances in the node group.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetKubernetesNodeGroupScalePolicyFixedScaleResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        """
        :param _builtins.int size: The number of instances in the node group.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The number of instances in the node group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetKubernetesNodeGroupVersionInfoResult(dict):
    def __init__(__self__, *,
                 current_version: _builtins.str,
                 new_revision_available: _builtins.bool,
                 new_revision_summary: _builtins.str,
                 version_deprecated: _builtins.bool):
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "new_revision_available", new_revision_available)
        pulumi.set(__self__, "new_revision_summary", new_revision_summary)
        pulumi.set(__self__, "version_deprecated", version_deprecated)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> _builtins.str:
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="newRevisionAvailable")
    def new_revision_available(self) -> _builtins.bool:
        return pulumi.get(self, "new_revision_available")

    @_builtins.property
    @pulumi.getter(name="newRevisionSummary")
    def new_revision_summary(self) -> _builtins.str:
        return pulumi.get(self, "new_revision_summary")

    @_builtins.property
    @pulumi.getter(name="versionDeprecated")
    def version_deprecated(self) -> _builtins.bool:
        return pulumi.get(self, "version_deprecated")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupResult(dict):
    def __init__(__self__, *,
                 healthchecks: Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult'],
                 target_group_id: _builtins.str):
        """
        :param Sequence['GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckArgs'] healthchecks: A HealthCheck resource.
        :param _builtins.str target_group_id: ID of the target group.
        """
        pulumi.set(__self__, "healthchecks", healthchecks)
        pulumi.set(__self__, "target_group_id", target_group_id)

    @_builtins.property
    @pulumi.getter
    def healthchecks(self) -> Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult']:
        """
        A HealthCheck resource.
        """
        return pulumi.get(self, "healthchecks")

    @_builtins.property
    @pulumi.getter(name="targetGroupId")
    def target_group_id(self) -> _builtins.str:
        """
        ID of the target group.
        """
        return pulumi.get(self, "target_group_id")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckResult(dict):
    def __init__(__self__, *,
                 healthy_threshold: _builtins.int,
                 http_options: Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult'],
                 interval: _builtins.int,
                 name: _builtins.str,
                 tcp_options: Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult'],
                 timeout: _builtins.int,
                 unhealthy_threshold: _builtins.int):
        """
        :param _builtins.int healthy_threshold: Number of successful health checks required in order to set the `HEALTHY` status for the target.
        :param Sequence['GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionArgs'] http_options: Options for HTTP health check.
        :param _builtins.int interval: The interval between health checks. The default is 2 seconds.
        :param _builtins.str name: Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        :param Sequence['GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionArgs'] tcp_options: Options for TCP health check.
        :param _builtins.int timeout: Timeout for a target to return a response for the health check. The default is 1 second.
        :param _builtins.int unhealthy_threshold: Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "http_options", http_options)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tcp_options", tcp_options)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        Number of successful health checks required in order to set the `HEALTHY` status for the target.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult']:
        """
        Options for HTTP health check.
        """
        return pulumi.get(self, "http_options")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        The interval between health checks. The default is 2 seconds.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the health check. The name must be unique for each target group that attached to a single load balancer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Sequence['outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult']:
        """
        Options for TCP health check.
        """
        return pulumi.get(self, "tcp_options")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        Timeout for a target to return a response for the health check. The default is 1 second.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        Number of failed health checks before changing the status to `UNHEALTHY`. The default is 2.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptionResult(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str path: URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        :param _builtins.int port: Port to use for HTTP health checks.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        URL path to set for health checking requests for every target in the target group. For example `/ping`. The default path is `/`.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port to use for HTTP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptionResult(dict):
    def __init__(__self__, *,
                 port: _builtins.int):
        """
        :param _builtins.int port: Port to use for TCP health checks.
        """
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port to use for TCP health checks.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetLbNetworkLoadBalancerListenerResult(dict):
    def __init__(__self__, *,
                 external_address_specs: Sequence['outputs.GetLbNetworkLoadBalancerListenerExternalAddressSpecResult'],
                 internal_address_specs: Sequence['outputs.GetLbNetworkLoadBalancerListenerInternalAddressSpecResult'],
                 name: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 target_port: _builtins.int):
        """
        :param Sequence['GetLbNetworkLoadBalancerListenerExternalAddressSpecArgs'] external_address_specs: External IP address specification.
        :param Sequence['GetLbNetworkLoadBalancerListenerInternalAddressSpecArgs'] internal_address_specs: Internal IP address specification.
        :param _builtins.str name: Name of the listener. The name must be unique for each listener on a single load balancer.
        :param _builtins.int port: Port for incoming traffic.
        :param _builtins.str protocol: Protocol for incoming traffic. TCP or UDP and the default is TCP.
        :param _builtins.int target_port: Port of a target. The default is the same as listener's port.
        """
        pulumi.set(__self__, "external_address_specs", external_address_specs)
        pulumi.set(__self__, "internal_address_specs", internal_address_specs)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter(name="externalAddressSpecs")
    def external_address_specs(self) -> Sequence['outputs.GetLbNetworkLoadBalancerListenerExternalAddressSpecResult']:
        """
        External IP address specification.
        """
        return pulumi.get(self, "external_address_specs")

    @_builtins.property
    @pulumi.getter(name="internalAddressSpecs")
    def internal_address_specs(self) -> Sequence['outputs.GetLbNetworkLoadBalancerListenerInternalAddressSpecResult']:
        """
        Internal IP address specification.
        """
        return pulumi.get(self, "internal_address_specs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the listener. The name must be unique for each listener on a single load balancer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port for incoming traffic.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol for incoming traffic. TCP or UDP and the default is TCP.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> _builtins.int:
        """
        Port of a target. The default is the same as listener's port.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetLbNetworkLoadBalancerListenerExternalAddressSpecResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 ip_version: _builtins.str):
        """
        :param _builtins.str address: External IP address for a listener. IP address will be allocated if it wasn't been set.
        :param _builtins.str ip_version: IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ip_version", ip_version)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        External IP address for a listener. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> _builtins.str:
        """
        IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class GetLbNetworkLoadBalancerListenerInternalAddressSpecResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 ip_version: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str address: Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        :param _builtins.str ip_version: IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        :param _builtins.str subnet_id: ID of the subnet to which the internal IP address belongs.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Internal IP address for a listener. Must belong to the subnet that is referenced in subnet_id. IP address will be allocated if it wasn't been set.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> _builtins.str:
        """
        IP version of the external addresses that the load balancer works with. Must be one of `ipv4` or `ipv6`. The default is `ipv4`.
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet to which the internal IP address belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetLbTargetGroupTargetResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str address: IP address of the target.
        :param _builtins.str subnet_id: ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        IP address of the target.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        ID of the subnet that targets are connected to. All targets in the target group must be connected to the same subnet within a single availability zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetLoadtestingAgentComputeInstanceResult(dict):
    def __init__(__self__, *,
                 boot_disks: Sequence['outputs.GetLoadtestingAgentComputeInstanceBootDiskResult'],
                 computed_labels: Mapping[str, _builtins.str],
                 computed_metadata: Mapping[str, _builtins.str],
                 labels: Mapping[str, _builtins.str],
                 metadata: Mapping[str, _builtins.str],
                 network_interfaces: Sequence['outputs.GetLoadtestingAgentComputeInstanceNetworkInterfaceResult'],
                 platform_id: _builtins.str,
                 resources: Sequence['outputs.GetLoadtestingAgentComputeInstanceResourceResult'],
                 service_account_id: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param Sequence['GetLoadtestingAgentComputeInstanceBootDiskArgs'] boot_disks: Boot disk specifications for the instance.
        :param Mapping[str, _builtins.str] computed_labels: The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        :param Mapping[str, _builtins.str] computed_metadata: The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        :param Mapping[str, _builtins.str] labels: A set of key/value label pairs to assign to the instance.
        :param Mapping[str, _builtins.str] metadata: A set of metadata key/value pairs to make available from within the instance.
        :param Sequence['GetLoadtestingAgentComputeInstanceNetworkInterfaceArgs'] network_interfaces: Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        :param _builtins.str platform_id: The Compute platform for virtual machine.
        :param Sequence['GetLoadtestingAgentComputeInstanceResourceArgs'] resources: Compute resource specifications for the instance.
        :param _builtins.str service_account_id: The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "boot_disks", boot_disks)
        pulumi.set(__self__, "computed_labels", computed_labels)
        pulumi.set(__self__, "computed_metadata", computed_metadata)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "platform_id", platform_id)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="bootDisks")
    def boot_disks(self) -> Sequence['outputs.GetLoadtestingAgentComputeInstanceBootDiskResult']:
        """
        Boot disk specifications for the instance.
        """
        return pulumi.get(self, "boot_disks")

    @_builtins.property
    @pulumi.getter(name="computedLabels")
    def computed_labels(self) -> Mapping[str, _builtins.str]:
        """
        The set of labels `key:value` pairs assigned to this instance. This includes user custom `labels` and predefined items created by Yandex Cloud Load Testing.
        """
        return pulumi.get(self, "computed_labels")

    @_builtins.property
    @pulumi.getter(name="computedMetadata")
    def computed_metadata(self) -> Mapping[str, _builtins.str]:
        """
        The set of metadata `key:value` pairs assigned to this instance. This includes user custom `metadata`, and predefined items created by Yandex Cloud Load Testing.
        """
        return pulumi.get(self, "computed_metadata")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value label pairs to assign to the instance.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        A set of metadata key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetLoadtestingAgentComputeInstanceNetworkInterfaceResult']:
        """
        Network specifications for the instance. This can be used multiple times for adding multiple interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="platformId")
    def platform_id(self) -> _builtins.str:
        """
        The Compute platform for virtual machine.
        """
        return pulumi.get(self, "platform_id")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetLoadtestingAgentComputeInstanceResourceResult']:
        """
        Compute resource specifications for the instance.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        The ID of the service account authorized for this load testing agent. Service account should have `loadtesting.generatorClient` or `loadtesting.externalAgent` role in the folder.
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetLoadtestingAgentComputeInstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 auto_delete: _builtins.bool,
                 device_name: _builtins.str,
                 disk_id: _builtins.str,
                 initialize_params: Sequence['outputs.GetLoadtestingAgentComputeInstanceBootDiskInitializeParamResult']):
        """
        :param _builtins.bool auto_delete: Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        :param _builtins.str device_name: This value can be used to reference the device under `/dev/disk/by-id/`.
        :param _builtins.str disk_id: The ID of created disk.
        :param Sequence['GetLoadtestingAgentComputeInstanceBootDiskInitializeParamArgs'] initialize_params: Parameters for creating a disk alongside the instance.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "initialize_params", initialize_params)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Whether the disk is auto-deleted when the instance is deleted. The default value is true.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        This value can be used to reference the device under `/dev/disk/by-id/`.
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> _builtins.str:
        """
        The ID of created disk.
        """
        return pulumi.get(self, "disk_id")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Sequence['outputs.GetLoadtestingAgentComputeInstanceBootDiskInitializeParamResult']:
        """
        Parameters for creating a disk alongside the instance.
        """
        return pulumi.get(self, "initialize_params")


@pulumi.output_type
class GetLoadtestingAgentComputeInstanceBootDiskInitializeParamResult(dict):
    def __init__(__self__, *,
                 block_size: _builtins.int,
                 description: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int block_size: Block size of the disk, specified in bytes.
        :param _builtins.str description: A description of the boot disk.
        :param _builtins.str name: A name of the boot disk.
        :param _builtins.int size: The size of the disk in GB. Defaults to 15 GB.
        :param _builtins.str type: The disk type.
        """
        pulumi.set(__self__, "block_size", block_size)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> _builtins.int:
        """
        Block size of the disk, specified in bytes.
        """
        return pulumi.get(self, "block_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description of the boot disk.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name of the boot disk.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the disk in GB. Defaults to 15 GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The disk type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLoadtestingAgentComputeInstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 index: _builtins.int,
                 ip_address: _builtins.str,
                 ipv4: _builtins.bool,
                 ipv6: _builtins.bool,
                 ipv6_address: _builtins.str,
                 mac_address: _builtins.str,
                 nat: _builtins.bool,
                 nat_ip_address: _builtins.str,
                 nat_ip_version: _builtins.str,
                 security_group_ids: Sequence[_builtins.str],
                 subnet_id: _builtins.str):
        """
        :param _builtins.str ip_address: Manual set static IP address.
        :param _builtins.bool ipv4: Flag for allocating IPv4 address for the network interface.
        :param _builtins.bool ipv6: Flag for allocating IPv6 address for the network interface.
        :param _builtins.str ipv6_address: Manual set static IPv6 address.
        :param _builtins.bool nat: Flag for using NAT.
        :param _builtins.str nat_ip_address: A public address that can be used to access the internet over NAT.
        :param Sequence[_builtins.str] security_group_ids: Security group ids for network interface.
        :param _builtins.str subnet_id: The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "nat", nat)
        pulumi.set(__self__, "nat_ip_address", nat_ip_address)
        pulumi.set(__self__, "nat_ip_version", nat_ip_version)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.int:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        Manual set static IP address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> _builtins.bool:
        """
        Flag for allocating IPv4 address for the network interface.
        """
        return pulumi.get(self, "ipv4")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        Flag for allocating IPv6 address for the network interface.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        Manual set static IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> _builtins.str:
        return pulumi.get(self, "mac_address")

    @_builtins.property
    @pulumi.getter
    def nat(self) -> _builtins.bool:
        """
        Flag for using NAT.
        """
        return pulumi.get(self, "nat")

    @_builtins.property
    @pulumi.getter(name="natIpAddress")
    def nat_ip_address(self) -> _builtins.str:
        """
        A public address that can be used to access the internet over NAT.
        """
        return pulumi.get(self, "nat_ip_address")

    @_builtins.property
    @pulumi.getter(name="natIpVersion")
    def nat_ip_version(self) -> _builtins.str:
        return pulumi.get(self, "nat_ip_version")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        Security group ids for network interface.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet to attach this interface to. The subnet must reside in the same zone where this instance was created.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetLoadtestingAgentComputeInstanceResourceResult(dict):
    def __init__(__self__, *,
                 core_fraction: _builtins.int,
                 cores: _builtins.int,
                 memory: _builtins.float):
        """
        :param _builtins.int core_fraction: If provided, specifies baseline core performance as a percent.
        :param _builtins.int cores: The number of CPU cores for the instance. Defaults to 2 cores.
        :param _builtins.float memory: The memory size in GB. Defaults to 2 GB.
        """
        pulumi.set(__self__, "core_fraction", core_fraction)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="coreFraction")
    def core_fraction(self) -> _builtins.int:
        """
        If provided, specifies baseline core performance as a percent.
        """
        return pulumi.get(self, "core_fraction")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> _builtins.int:
        """
        The number of CPU cores for the instance. Defaults to 2 cores.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        The memory size in GB. Defaults to 2 GB.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetLoadtestingAgentLogSettingsResult(dict):
    def __init__(__self__, *,
                 log_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_group_id: The ID of cloud logging group to which the load testing agent sends logs.
        """
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of cloud logging group to which the load testing agent sends logs.
        """
        return pulumi.get(self, "log_group_id")


@pulumi.output_type
class GetLockboxSecretCurrentVersionResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 destroy_at: _builtins.str,
                 id: _builtins.str,
                 payload_entry_keys: Sequence[_builtins.str],
                 secret_id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str created_at: The version creation timestamp.
        :param _builtins.str description: The version description.
        :param _builtins.str destroy_at: The version destroy timestamp.
        :param _builtins.str id: The version ID.
        :param Sequence[_builtins.str] payload_entry_keys: List of keys that the version contains (doesn't include the values).
        :param _builtins.str secret_id: The secret ID the version belongs to (it's the same as the `secret_id` argument indicated above)
        :param _builtins.str status: The version status.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destroy_at", destroy_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "payload_entry_keys", payload_entry_keys)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The version creation timestamp.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The version description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destroyAt")
    def destroy_at(self) -> _builtins.str:
        """
        The version destroy timestamp.
        """
        return pulumi.get(self, "destroy_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The version ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="payloadEntryKeys")
    def payload_entry_keys(self) -> Sequence[_builtins.str]:
        """
        List of keys that the version contains (doesn't include the values).
        """
        return pulumi.get(self, "payload_entry_keys")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        The secret ID the version belongs to (it's the same as the `secret_id` argument indicated above)
        """
        return pulumi.get(self, "secret_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The version status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetLockboxSecretPasswordPayloadSpecificationResult(dict):
    def __init__(__self__, *,
                 excluded_punctuation: _builtins.str,
                 include_digits: _builtins.bool,
                 include_lowercase: _builtins.bool,
                 include_punctuation: _builtins.bool,
                 include_uppercase: _builtins.bool,
                 included_punctuation: _builtins.str,
                 length: _builtins.int,
                 password_key: _builtins.str):
        """
        :param _builtins.str excluded_punctuation: String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        :param _builtins.bool include_digits: Use digits in the generated password. Default is true.
        :param _builtins.bool include_lowercase: Use lowercase letters in the generated password. Default is true.
        :param _builtins.bool include_punctuation: Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        :param _builtins.bool include_uppercase: Use capital letters in the generated password. Default is true.
        :param _builtins.str included_punctuation: String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        :param _builtins.int length: Length of generated password. Default is `36`.
        :param _builtins.str password_key: The key with which the generated password will be placed in the secret version.
        """
        pulumi.set(__self__, "excluded_punctuation", excluded_punctuation)
        pulumi.set(__self__, "include_digits", include_digits)
        pulumi.set(__self__, "include_lowercase", include_lowercase)
        pulumi.set(__self__, "include_punctuation", include_punctuation)
        pulumi.set(__self__, "include_uppercase", include_uppercase)
        pulumi.set(__self__, "included_punctuation", included_punctuation)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "password_key", password_key)

    @_builtins.property
    @pulumi.getter(name="excludedPunctuation")
    def excluded_punctuation(self) -> _builtins.str:
        """
        String of punctuation characters to exclude from the default. Requires `include_punctuation = true`. Default is empty.
        """
        return pulumi.get(self, "excluded_punctuation")

    @_builtins.property
    @pulumi.getter(name="includeDigits")
    def include_digits(self) -> _builtins.bool:
        """
        Use digits in the generated password. Default is true.
        """
        return pulumi.get(self, "include_digits")

    @_builtins.property
    @pulumi.getter(name="includeLowercase")
    def include_lowercase(self) -> _builtins.bool:
        """
        Use lowercase letters in the generated password. Default is true.
        """
        return pulumi.get(self, "include_lowercase")

    @_builtins.property
    @pulumi.getter(name="includePunctuation")
    def include_punctuation(self) -> _builtins.bool:
        """
        Use punctuations (`!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`) in the generated password. Default is true.
        """
        return pulumi.get(self, "include_punctuation")

    @_builtins.property
    @pulumi.getter(name="includeUppercase")
    def include_uppercase(self) -> _builtins.bool:
        """
        Use capital letters in the generated password. Default is true.
        """
        return pulumi.get(self, "include_uppercase")

    @_builtins.property
    @pulumi.getter(name="includedPunctuation")
    def included_punctuation(self) -> _builtins.str:
        """
        String of specific punctuation characters to use. Requires `include_punctuation = true`. Default is empty.
        """
        return pulumi.get(self, "included_punctuation")

    @_builtins.property
    @pulumi.getter
    def length(self) -> _builtins.int:
        """
        Length of generated password. Default is `36`.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> _builtins.str:
        """
        The key with which the generated password will be placed in the secret version.
        """
        return pulumi.get(self, "password_key")


@pulumi.output_type
class GetLockboxSecretVersionEntryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 text_value: _builtins.str):
        """
        :param _builtins.str key: The key of the entry.
        :param _builtins.str text_value: The text value of the entry.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "text_value", text_value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the entry.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="textValue")
    def text_value(self) -> _builtins.str:
        """
        The text value of the entry.
        """
        return pulumi.get(self, "text_value")


@pulumi.output_type
class GetMdbClickhouseClusterAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 metrika: Optional[_builtins.bool] = None,
                 serverless: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None,
                 yandex_query: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for DataLens.
        :param _builtins.bool data_transfer: Allow access for DataTransfer.
        :param _builtins.bool metrika: Allow access for Yandex.Metrika.
        :param _builtins.bool serverless: Allow access for Serverless.
        :param _builtins.bool web_sql: Allow access for Web SQL.
        :param _builtins.bool yandex_query: Allow access for YandexQuery.
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if metrika is not None:
            pulumi.set(__self__, "metrika", metrika)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)
        if yandex_query is not None:
            pulumi.set(__self__, "yandex_query", yandex_query)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for DataLens.
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for DataTransfer.
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter
    def metrika(self) -> Optional[_builtins.bool]:
        """
        Allow access for Yandex.Metrika.
        """
        return pulumi.get(self, "metrika")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> Optional[_builtins.bool]:
        """
        Allow access for Serverless.
        """
        return pulumi.get(self, "serverless")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allow access for Web SQL.
        """
        return pulumi.get(self, "web_sql")

    @_builtins.property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> Optional[_builtins.bool]:
        """
        Allow access for YandexQuery.
        """
        return pulumi.get(self, "yandex_query")


@pulumi.output_type
class GetMdbClickhouseClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseResult(dict):
    def __init__(__self__, *,
                 config: 'outputs.GetMdbClickhouseClusterClickhouseConfigResult',
                 resources: 'outputs.GetMdbClickhouseClusterClickhouseResourcesResult'):
        """
        :param 'GetMdbClickhouseClusterClickhouseConfigArgs' config: ClickHouse server parameters. For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/settings-list).
        :param 'GetMdbClickhouseClusterClickhouseResourcesArgs' resources: Resources allocated to hosts of the ClickHouse subcluster.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def config(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigResult':
        """
        ClickHouse server parameters. For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/settings-list).
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbClickhouseClusterClickhouseResourcesResult':
        """
        Resources allocated to hosts of the ClickHouse subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigResult(dict):
    def __init__(__self__, *,
                 asynchronous_insert_log_enabled: _builtins.bool,
                 asynchronous_insert_log_retention_size: _builtins.int,
                 asynchronous_insert_log_retention_time: _builtins.int,
                 asynchronous_metric_log_enabled: _builtins.bool,
                 asynchronous_metric_log_retention_size: _builtins.int,
                 asynchronous_metric_log_retention_time: _builtins.int,
                 background_buffer_flush_schedule_pool_size: _builtins.int,
                 background_common_pool_size: _builtins.int,
                 background_distributed_schedule_pool_size: _builtins.int,
                 background_fetches_pool_size: _builtins.int,
                 background_merges_mutations_concurrency_ratio: _builtins.int,
                 background_message_broker_schedule_pool_size: _builtins.int,
                 background_move_pool_size: _builtins.int,
                 background_pool_size: _builtins.int,
                 background_schedule_pool_size: _builtins.int,
                 default_database: _builtins.str,
                 dictionaries_lazy_load: _builtins.bool,
                 geobase_enabled: _builtins.bool,
                 geobase_uri: _builtins.str,
                 jdbc_bridge: 'outputs.GetMdbClickhouseClusterClickhouseConfigJdbcBridgeResult',
                 kafka: 'outputs.GetMdbClickhouseClusterClickhouseConfigKafkaResult',
                 keep_alive_timeout: _builtins.int,
                 log_level: _builtins.str,
                 mark_cache_size: _builtins.int,
                 max_concurrent_queries: _builtins.int,
                 max_connections: _builtins.int,
                 max_partition_size_to_drop: _builtins.int,
                 max_table_size_to_drop: _builtins.int,
                 merge_tree: 'outputs.GetMdbClickhouseClusterClickhouseConfigMergeTreeResult',
                 metric_log_enabled: _builtins.bool,
                 metric_log_retention_size: _builtins.int,
                 metric_log_retention_time: _builtins.int,
                 opentelemetry_span_log_enabled: _builtins.bool,
                 opentelemetry_span_log_retention_size: _builtins.int,
                 opentelemetry_span_log_retention_time: _builtins.int,
                 part_log_retention_size: _builtins.int,
                 part_log_retention_time: _builtins.int,
                 query_cache: 'outputs.GetMdbClickhouseClusterClickhouseConfigQueryCacheResult',
                 query_log_retention_size: _builtins.int,
                 query_log_retention_time: _builtins.int,
                 query_thread_log_enabled: _builtins.bool,
                 query_thread_log_retention_size: _builtins.int,
                 query_thread_log_retention_time: _builtins.int,
                 query_views_log_enabled: _builtins.bool,
                 query_views_log_retention_size: _builtins.int,
                 query_views_log_retention_time: _builtins.int,
                 rabbitmq: 'outputs.GetMdbClickhouseClusterClickhouseConfigRabbitmqResult',
                 session_log_enabled: _builtins.bool,
                 session_log_retention_size: _builtins.int,
                 session_log_retention_time: _builtins.int,
                 text_log_enabled: _builtins.bool,
                 text_log_level: _builtins.str,
                 text_log_retention_size: _builtins.int,
                 text_log_retention_time: _builtins.int,
                 timezone: _builtins.str,
                 total_memory_profiler_step: _builtins.int,
                 trace_log_enabled: _builtins.bool,
                 trace_log_retention_size: _builtins.int,
                 trace_log_retention_time: _builtins.int,
                 uncompressed_cache_size: _builtins.int,
                 zookeeper_log_enabled: _builtins.bool,
                 zookeeper_log_retention_size: _builtins.int,
                 zookeeper_log_retention_time: _builtins.int,
                 compressions: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigCompressionResult']] = None,
                 graphite_rollups: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult']] = None,
                 kafka_topics: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult']] = None,
                 query_masking_rules: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleResult']] = None):
        """
        :param _builtins.bool asynchronous_insert_log_enabled: Enable or disable asynchronous_insert_log system table.
        :param _builtins.int asynchronous_insert_log_retention_size: The maximum size that asynchronous_insert_log can grow to before old data will be removed.
        :param _builtins.int asynchronous_insert_log_retention_time: The maximum time that asynchronous_insert_log records will be retained before removal.
        :param _builtins.bool asynchronous_metric_log_enabled: Enable or disable asynchronous_metric_log system table.
        :param _builtins.int asynchronous_metric_log_retention_size: The maximum size that asynchronous_metric_log can grow to before old data will be removed.
        :param _builtins.int asynchronous_metric_log_retention_time: The maximum time that asynchronous_metric_log records will be retained before removal.
        :param _builtins.int background_buffer_flush_schedule_pool_size: The maximum number of threads that will be used for performing flush operations for Buffer-engine tables in the background.
        :param _builtins.int background_common_pool_size: The maximum number of threads that will be used for performing a variety of operations (mostly garbage collection) for MergeTree-engine tables in a background.
        :param _builtins.int background_distributed_schedule_pool_size: The maximum number of threads that will be used for executing distributed sends.
        :param _builtins.int background_fetches_pool_size: The maximum number of threads that will be used for fetching data parts from another replica for MergeTree-engine tables in a background.
        :param _builtins.int background_merges_mutations_concurrency_ratio: Sets a ratio between the number of threads and the number of background merges and mutations that can be executed concurrently.
        :param _builtins.int background_message_broker_schedule_pool_size: The maximum number of threads that will be used for executing background operations for message streaming.
        :param _builtins.int background_move_pool_size: The maximum number of threads that will be used for moving data parts to another disk or volume for MergeTree-engine tables in a background.
        :param _builtins.int background_pool_size: Sets the number of threads performing background merges and mutations for MergeTree-engine tables.
        :param _builtins.int background_schedule_pool_size: The maximum number of threads that will be used for constantly executing some lightweight periodic operations for replicated tables, Kafka streaming, and DNS cache updates.
        :param _builtins.str default_database: Default database name.
        :param _builtins.bool dictionaries_lazy_load: Lazy loading of dictionaries. If true, then each dictionary is loaded on the first use.
        :param _builtins.bool geobase_enabled: Enable or disable geobase.
        :param _builtins.str geobase_uri: Address of the archive with the user geobase in Object Storage.
        :param 'GetMdbClickhouseClusterClickhouseConfigJdbcBridgeArgs' jdbc_bridge: JDBC bridge configuration.
        :param 'GetMdbClickhouseClusterClickhouseConfigKafkaArgs' kafka: Kafka connection configuration.
        :param _builtins.int keep_alive_timeout: The number of seconds that ClickHouse waits for incoming requests for HTTP protocol before closing the connection.
        :param _builtins.str log_level: Logging level.
        :param _builtins.int mark_cache_size: Maximum size of cache for marks
        :param _builtins.int max_concurrent_queries: Limit on total number of concurrently executed queries.
        :param _builtins.int max_connections: Max server connections.
        :param _builtins.int max_partition_size_to_drop: Restriction on dropping partitions.
        :param _builtins.int max_table_size_to_drop: Restriction on deleting tables.
        :param 'GetMdbClickhouseClusterClickhouseConfigMergeTreeArgs' merge_tree: MergeTree engine configuration.
        :param _builtins.bool metric_log_enabled: Enable or disable metric_log system table.
        :param _builtins.int metric_log_retention_size: The maximum size that metric_log can grow to before old data will be removed.
        :param _builtins.int metric_log_retention_time: The maximum time that metric_log records will be retained before removal.
        :param _builtins.bool opentelemetry_span_log_enabled: Enable or disable opentelemetry_span_log system table.
        :param _builtins.int opentelemetry_span_log_retention_size: The maximum size that opentelemetry_span_log can grow to before old data will be removed.
        :param _builtins.int opentelemetry_span_log_retention_time: The maximum time that opentelemetry_span_log records will be retained before removal.
        :param _builtins.int part_log_retention_size: The maximum size that part_log can grow to before old data will be removed.
        :param _builtins.int part_log_retention_time: The maximum time that part_log records will be retained before removal.
        :param 'GetMdbClickhouseClusterClickhouseConfigQueryCacheArgs' query_cache: Query cache configuration.
        :param _builtins.int query_log_retention_size: The maximum size that query_log can grow to before old data will be removed.
        :param _builtins.int query_log_retention_time: The maximum time that query_log records will be retained before removal.
        :param _builtins.bool query_thread_log_enabled: Enable or disable query_thread_log system table.
        :param _builtins.int query_thread_log_retention_size: The maximum size that query_thread_log can grow to before old data will be removed.
        :param _builtins.int query_thread_log_retention_time: The maximum time that query_thread_log records will be retained before removal.
        :param _builtins.bool query_views_log_enabled: Enable or disable query_views_log system table.
        :param _builtins.int query_views_log_retention_size: The maximum size that query_views_log can grow to before old data will be removed.
        :param _builtins.int query_views_log_retention_time: The maximum time that query_views_log records will be retained before removal.
        :param 'GetMdbClickhouseClusterClickhouseConfigRabbitmqArgs' rabbitmq: RabbitMQ connection configuration.
        :param _builtins.bool session_log_enabled: Enable or disable session_log system table.
        :param _builtins.int session_log_retention_size: The maximum size that session_log can grow to before old data will be removed.
        :param _builtins.int session_log_retention_time: The maximum time that session_log records will be retained before removal.
        :param _builtins.bool text_log_enabled: Enable or disable text_log system table.
        :param _builtins.str text_log_level: Logging level for text_log system table.
        :param _builtins.int text_log_retention_size: The maximum size that text_log can grow to before old data will be removed.
        :param _builtins.int text_log_retention_time: The maximum time that text_log records will be retained before removal.
        :param _builtins.str timezone: The server's time zone.
        :param _builtins.int total_memory_profiler_step: Whenever server memory usage becomes larger than every next step in number of bytes the memory profiler will collect the allocating stack trace.
        :param _builtins.bool trace_log_enabled: Enable or disable trace_log system table.
        :param _builtins.int trace_log_retention_size: The maximum size that trace_log can grow to before old data will be removed.
        :param _builtins.int trace_log_retention_time: The maximum time that trace_log records will be retained before removal.
        :param _builtins.int uncompressed_cache_size: Cache size (in bytes) for uncompressed data used by table engines from the MergeTree family. Zero means disabled.
        :param _builtins.bool zookeeper_log_enabled: Enable or disable zookeeper_log system table.
        :param _builtins.int zookeeper_log_retention_size: The maximum size that zookeeper_log can grow to before old data will be removed.
        :param _builtins.int zookeeper_log_retention_time: The maximum time that zookeeper_log records will be retained before removal.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigCompressionArgs'] compressions: Data compression configuration.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupArgs'] graphite_rollups: Graphite rollup configuration.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigKafkaTopicArgs'] kafka_topics: Kafka topic connection configuration.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleArgs'] query_masking_rules: Query masking rules configuration.
        """
        pulumi.set(__self__, "asynchronous_insert_log_enabled", asynchronous_insert_log_enabled)
        pulumi.set(__self__, "asynchronous_insert_log_retention_size", asynchronous_insert_log_retention_size)
        pulumi.set(__self__, "asynchronous_insert_log_retention_time", asynchronous_insert_log_retention_time)
        pulumi.set(__self__, "asynchronous_metric_log_enabled", asynchronous_metric_log_enabled)
        pulumi.set(__self__, "asynchronous_metric_log_retention_size", asynchronous_metric_log_retention_size)
        pulumi.set(__self__, "asynchronous_metric_log_retention_time", asynchronous_metric_log_retention_time)
        pulumi.set(__self__, "background_buffer_flush_schedule_pool_size", background_buffer_flush_schedule_pool_size)
        pulumi.set(__self__, "background_common_pool_size", background_common_pool_size)
        pulumi.set(__self__, "background_distributed_schedule_pool_size", background_distributed_schedule_pool_size)
        pulumi.set(__self__, "background_fetches_pool_size", background_fetches_pool_size)
        pulumi.set(__self__, "background_merges_mutations_concurrency_ratio", background_merges_mutations_concurrency_ratio)
        pulumi.set(__self__, "background_message_broker_schedule_pool_size", background_message_broker_schedule_pool_size)
        pulumi.set(__self__, "background_move_pool_size", background_move_pool_size)
        pulumi.set(__self__, "background_pool_size", background_pool_size)
        pulumi.set(__self__, "background_schedule_pool_size", background_schedule_pool_size)
        pulumi.set(__self__, "default_database", default_database)
        pulumi.set(__self__, "dictionaries_lazy_load", dictionaries_lazy_load)
        pulumi.set(__self__, "geobase_enabled", geobase_enabled)
        pulumi.set(__self__, "geobase_uri", geobase_uri)
        pulumi.set(__self__, "jdbc_bridge", jdbc_bridge)
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "mark_cache_size", mark_cache_size)
        pulumi.set(__self__, "max_concurrent_queries", max_concurrent_queries)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "max_partition_size_to_drop", max_partition_size_to_drop)
        pulumi.set(__self__, "max_table_size_to_drop", max_table_size_to_drop)
        pulumi.set(__self__, "merge_tree", merge_tree)
        pulumi.set(__self__, "metric_log_enabled", metric_log_enabled)
        pulumi.set(__self__, "metric_log_retention_size", metric_log_retention_size)
        pulumi.set(__self__, "metric_log_retention_time", metric_log_retention_time)
        pulumi.set(__self__, "opentelemetry_span_log_enabled", opentelemetry_span_log_enabled)
        pulumi.set(__self__, "opentelemetry_span_log_retention_size", opentelemetry_span_log_retention_size)
        pulumi.set(__self__, "opentelemetry_span_log_retention_time", opentelemetry_span_log_retention_time)
        pulumi.set(__self__, "part_log_retention_size", part_log_retention_size)
        pulumi.set(__self__, "part_log_retention_time", part_log_retention_time)
        pulumi.set(__self__, "query_cache", query_cache)
        pulumi.set(__self__, "query_log_retention_size", query_log_retention_size)
        pulumi.set(__self__, "query_log_retention_time", query_log_retention_time)
        pulumi.set(__self__, "query_thread_log_enabled", query_thread_log_enabled)
        pulumi.set(__self__, "query_thread_log_retention_size", query_thread_log_retention_size)
        pulumi.set(__self__, "query_thread_log_retention_time", query_thread_log_retention_time)
        pulumi.set(__self__, "query_views_log_enabled", query_views_log_enabled)
        pulumi.set(__self__, "query_views_log_retention_size", query_views_log_retention_size)
        pulumi.set(__self__, "query_views_log_retention_time", query_views_log_retention_time)
        pulumi.set(__self__, "rabbitmq", rabbitmq)
        pulumi.set(__self__, "session_log_enabled", session_log_enabled)
        pulumi.set(__self__, "session_log_retention_size", session_log_retention_size)
        pulumi.set(__self__, "session_log_retention_time", session_log_retention_time)
        pulumi.set(__self__, "text_log_enabled", text_log_enabled)
        pulumi.set(__self__, "text_log_level", text_log_level)
        pulumi.set(__self__, "text_log_retention_size", text_log_retention_size)
        pulumi.set(__self__, "text_log_retention_time", text_log_retention_time)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "total_memory_profiler_step", total_memory_profiler_step)
        pulumi.set(__self__, "trace_log_enabled", trace_log_enabled)
        pulumi.set(__self__, "trace_log_retention_size", trace_log_retention_size)
        pulumi.set(__self__, "trace_log_retention_time", trace_log_retention_time)
        pulumi.set(__self__, "uncompressed_cache_size", uncompressed_cache_size)
        pulumi.set(__self__, "zookeeper_log_enabled", zookeeper_log_enabled)
        pulumi.set(__self__, "zookeeper_log_retention_size", zookeeper_log_retention_size)
        pulumi.set(__self__, "zookeeper_log_retention_time", zookeeper_log_retention_time)
        if compressions is not None:
            pulumi.set(__self__, "compressions", compressions)
        if graphite_rollups is not None:
            pulumi.set(__self__, "graphite_rollups", graphite_rollups)
        if kafka_topics is not None:
            pulumi.set(__self__, "kafka_topics", kafka_topics)
        if query_masking_rules is not None:
            pulumi.set(__self__, "query_masking_rules", query_masking_rules)

    @_builtins.property
    @pulumi.getter(name="asynchronousInsertLogEnabled")
    def asynchronous_insert_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable asynchronous_insert_log system table.
        """
        return pulumi.get(self, "asynchronous_insert_log_enabled")

    @_builtins.property
    @pulumi.getter(name="asynchronousInsertLogRetentionSize")
    def asynchronous_insert_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that asynchronous_insert_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "asynchronous_insert_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="asynchronousInsertLogRetentionTime")
    def asynchronous_insert_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that asynchronous_insert_log records will be retained before removal.
        """
        return pulumi.get(self, "asynchronous_insert_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="asynchronousMetricLogEnabled")
    def asynchronous_metric_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable asynchronous_metric_log system table.
        """
        return pulumi.get(self, "asynchronous_metric_log_enabled")

    @_builtins.property
    @pulumi.getter(name="asynchronousMetricLogRetentionSize")
    def asynchronous_metric_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that asynchronous_metric_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "asynchronous_metric_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="asynchronousMetricLogRetentionTime")
    def asynchronous_metric_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that asynchronous_metric_log records will be retained before removal.
        """
        return pulumi.get(self, "asynchronous_metric_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="backgroundBufferFlushSchedulePoolSize")
    def background_buffer_flush_schedule_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for performing flush operations for Buffer-engine tables in the background.
        """
        return pulumi.get(self, "background_buffer_flush_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundCommonPoolSize")
    def background_common_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for performing a variety of operations (mostly garbage collection) for MergeTree-engine tables in a background.
        """
        return pulumi.get(self, "background_common_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundDistributedSchedulePoolSize")
    def background_distributed_schedule_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for executing distributed sends.
        """
        return pulumi.get(self, "background_distributed_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundFetchesPoolSize")
    def background_fetches_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for fetching data parts from another replica for MergeTree-engine tables in a background.
        """
        return pulumi.get(self, "background_fetches_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundMergesMutationsConcurrencyRatio")
    def background_merges_mutations_concurrency_ratio(self) -> _builtins.int:
        """
        Sets a ratio between the number of threads and the number of background merges and mutations that can be executed concurrently.
        """
        return pulumi.get(self, "background_merges_mutations_concurrency_ratio")

    @_builtins.property
    @pulumi.getter(name="backgroundMessageBrokerSchedulePoolSize")
    def background_message_broker_schedule_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for executing background operations for message streaming.
        """
        return pulumi.get(self, "background_message_broker_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundMovePoolSize")
    def background_move_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for moving data parts to another disk or volume for MergeTree-engine tables in a background.
        """
        return pulumi.get(self, "background_move_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundPoolSize")
    def background_pool_size(self) -> _builtins.int:
        """
        Sets the number of threads performing background merges and mutations for MergeTree-engine tables.
        """
        return pulumi.get(self, "background_pool_size")

    @_builtins.property
    @pulumi.getter(name="backgroundSchedulePoolSize")
    def background_schedule_pool_size(self) -> _builtins.int:
        """
        The maximum number of threads that will be used for constantly executing some lightweight periodic operations for replicated tables, Kafka streaming, and DNS cache updates.
        """
        return pulumi.get(self, "background_schedule_pool_size")

    @_builtins.property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> _builtins.str:
        """
        Default database name.
        """
        return pulumi.get(self, "default_database")

    @_builtins.property
    @pulumi.getter(name="dictionariesLazyLoad")
    def dictionaries_lazy_load(self) -> _builtins.bool:
        """
        Lazy loading of dictionaries. If true, then each dictionary is loaded on the first use.
        """
        return pulumi.get(self, "dictionaries_lazy_load")

    @_builtins.property
    @pulumi.getter(name="geobaseEnabled")
    def geobase_enabled(self) -> _builtins.bool:
        """
        Enable or disable geobase.
        """
        return pulumi.get(self, "geobase_enabled")

    @_builtins.property
    @pulumi.getter(name="geobaseUri")
    def geobase_uri(self) -> _builtins.str:
        """
        Address of the archive with the user geobase in Object Storage.
        """
        return pulumi.get(self, "geobase_uri")

    @_builtins.property
    @pulumi.getter(name="jdbcBridge")
    def jdbc_bridge(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigJdbcBridgeResult':
        """
        JDBC bridge configuration.
        """
        return pulumi.get(self, "jdbc_bridge")

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigKafkaResult':
        """
        Kafka connection configuration.
        """
        return pulumi.get(self, "kafka")

    @_builtins.property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> _builtins.int:
        """
        The number of seconds that ClickHouse waits for incoming requests for HTTP protocol before closing the connection.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> _builtins.str:
        """
        Logging level.
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="markCacheSize")
    def mark_cache_size(self) -> _builtins.int:
        """
        Maximum size of cache for marks
        """
        return pulumi.get(self, "mark_cache_size")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentQueries")
    def max_concurrent_queries(self) -> _builtins.int:
        """
        Limit on total number of concurrently executed queries.
        """
        return pulumi.get(self, "max_concurrent_queries")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> _builtins.int:
        """
        Max server connections.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPartitionSizeToDrop")
    def max_partition_size_to_drop(self) -> _builtins.int:
        """
        Restriction on dropping partitions.
        """
        return pulumi.get(self, "max_partition_size_to_drop")

    @_builtins.property
    @pulumi.getter(name="maxTableSizeToDrop")
    def max_table_size_to_drop(self) -> _builtins.int:
        """
        Restriction on deleting tables.
        """
        return pulumi.get(self, "max_table_size_to_drop")

    @_builtins.property
    @pulumi.getter(name="mergeTree")
    def merge_tree(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigMergeTreeResult':
        """
        MergeTree engine configuration.
        """
        return pulumi.get(self, "merge_tree")

    @_builtins.property
    @pulumi.getter(name="metricLogEnabled")
    def metric_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable metric_log system table.
        """
        return pulumi.get(self, "metric_log_enabled")

    @_builtins.property
    @pulumi.getter(name="metricLogRetentionSize")
    def metric_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that metric_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "metric_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="metricLogRetentionTime")
    def metric_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that metric_log records will be retained before removal.
        """
        return pulumi.get(self, "metric_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="opentelemetrySpanLogEnabled")
    def opentelemetry_span_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable opentelemetry_span_log system table.
        """
        return pulumi.get(self, "opentelemetry_span_log_enabled")

    @_builtins.property
    @pulumi.getter(name="opentelemetrySpanLogRetentionSize")
    def opentelemetry_span_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that opentelemetry_span_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "opentelemetry_span_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="opentelemetrySpanLogRetentionTime")
    def opentelemetry_span_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that opentelemetry_span_log records will be retained before removal.
        """
        return pulumi.get(self, "opentelemetry_span_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="partLogRetentionSize")
    def part_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that part_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "part_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="partLogRetentionTime")
    def part_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that part_log records will be retained before removal.
        """
        return pulumi.get(self, "part_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="queryCache")
    def query_cache(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigQueryCacheResult':
        """
        Query cache configuration.
        """
        return pulumi.get(self, "query_cache")

    @_builtins.property
    @pulumi.getter(name="queryLogRetentionSize")
    def query_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that query_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "query_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="queryLogRetentionTime")
    def query_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that query_log records will be retained before removal.
        """
        return pulumi.get(self, "query_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="queryThreadLogEnabled")
    def query_thread_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable query_thread_log system table.
        """
        return pulumi.get(self, "query_thread_log_enabled")

    @_builtins.property
    @pulumi.getter(name="queryThreadLogRetentionSize")
    def query_thread_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that query_thread_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "query_thread_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="queryThreadLogRetentionTime")
    def query_thread_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that query_thread_log records will be retained before removal.
        """
        return pulumi.get(self, "query_thread_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="queryViewsLogEnabled")
    def query_views_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable query_views_log system table.
        """
        return pulumi.get(self, "query_views_log_enabled")

    @_builtins.property
    @pulumi.getter(name="queryViewsLogRetentionSize")
    def query_views_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that query_views_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "query_views_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="queryViewsLogRetentionTime")
    def query_views_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that query_views_log records will be retained before removal.
        """
        return pulumi.get(self, "query_views_log_retention_time")

    @_builtins.property
    @pulumi.getter
    def rabbitmq(self) -> 'outputs.GetMdbClickhouseClusterClickhouseConfigRabbitmqResult':
        """
        RabbitMQ connection configuration.
        """
        return pulumi.get(self, "rabbitmq")

    @_builtins.property
    @pulumi.getter(name="sessionLogEnabled")
    def session_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable session_log system table.
        """
        return pulumi.get(self, "session_log_enabled")

    @_builtins.property
    @pulumi.getter(name="sessionLogRetentionSize")
    def session_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that session_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "session_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="sessionLogRetentionTime")
    def session_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that session_log records will be retained before removal.
        """
        return pulumi.get(self, "session_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="textLogEnabled")
    def text_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable text_log system table.
        """
        return pulumi.get(self, "text_log_enabled")

    @_builtins.property
    @pulumi.getter(name="textLogLevel")
    def text_log_level(self) -> _builtins.str:
        """
        Logging level for text_log system table.
        """
        return pulumi.get(self, "text_log_level")

    @_builtins.property
    @pulumi.getter(name="textLogRetentionSize")
    def text_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that text_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "text_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="textLogRetentionTime")
    def text_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that text_log records will be retained before removal.
        """
        return pulumi.get(self, "text_log_retention_time")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        The server's time zone.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="totalMemoryProfilerStep")
    def total_memory_profiler_step(self) -> _builtins.int:
        """
        Whenever server memory usage becomes larger than every next step in number of bytes the memory profiler will collect the allocating stack trace.
        """
        return pulumi.get(self, "total_memory_profiler_step")

    @_builtins.property
    @pulumi.getter(name="traceLogEnabled")
    def trace_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable trace_log system table.
        """
        return pulumi.get(self, "trace_log_enabled")

    @_builtins.property
    @pulumi.getter(name="traceLogRetentionSize")
    def trace_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that trace_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "trace_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="traceLogRetentionTime")
    def trace_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that trace_log records will be retained before removal.
        """
        return pulumi.get(self, "trace_log_retention_time")

    @_builtins.property
    @pulumi.getter(name="uncompressedCacheSize")
    def uncompressed_cache_size(self) -> _builtins.int:
        """
        Cache size (in bytes) for uncompressed data used by table engines from the MergeTree family. Zero means disabled.
        """
        return pulumi.get(self, "uncompressed_cache_size")

    @_builtins.property
    @pulumi.getter(name="zookeeperLogEnabled")
    def zookeeper_log_enabled(self) -> _builtins.bool:
        """
        Enable or disable zookeeper_log system table.
        """
        return pulumi.get(self, "zookeeper_log_enabled")

    @_builtins.property
    @pulumi.getter(name="zookeeperLogRetentionSize")
    def zookeeper_log_retention_size(self) -> _builtins.int:
        """
        The maximum size that zookeeper_log can grow to before old data will be removed.
        """
        return pulumi.get(self, "zookeeper_log_retention_size")

    @_builtins.property
    @pulumi.getter(name="zookeeperLogRetentionTime")
    def zookeeper_log_retention_time(self) -> _builtins.int:
        """
        The maximum time that zookeeper_log records will be retained before removal.
        """
        return pulumi.get(self, "zookeeper_log_retention_time")

    @_builtins.property
    @pulumi.getter
    def compressions(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigCompressionResult']]:
        """
        Data compression configuration.
        """
        return pulumi.get(self, "compressions")

    @_builtins.property
    @pulumi.getter(name="graphiteRollups")
    def graphite_rollups(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult']]:
        """
        Graphite rollup configuration.
        """
        return pulumi.get(self, "graphite_rollups")

    @_builtins.property
    @pulumi.getter(name="kafkaTopics")
    def kafka_topics(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult']]:
        """
        Kafka topic connection configuration.
        """
        return pulumi.get(self, "kafka_topics")

    @_builtins.property
    @pulumi.getter(name="queryMaskingRules")
    def query_masking_rules(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleResult']]:
        """
        Query masking rules configuration.
        """
        return pulumi.get(self, "query_masking_rules")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigCompressionResult(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.int] = None,
                 method: Optional[_builtins.str] = None,
                 min_part_size: Optional[_builtins.int] = None,
                 min_part_size_ratio: Optional[_builtins.float] = None):
        """
        :param _builtins.int level: Compression level for `ZSTD` method.
        :param _builtins.str method: Compression method. Two methods are available: `LZ4` and `zstd`.
        :param _builtins.int min_part_size: Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        :param _builtins.float min_part_size_ratio: Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if min_part_size is not None:
            pulumi.set(__self__, "min_part_size", min_part_size)
        if min_part_size_ratio is not None:
            pulumi.set(__self__, "min_part_size_ratio", min_part_size_ratio)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.int]:
        """
        Compression level for `ZSTD` method.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Compression method. Two methods are available: `LZ4` and `zstd`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="minPartSize")
    def min_part_size(self) -> Optional[_builtins.int]:
        """
        Min part size: Minimum size (in bytes) of a data part in a table. ClickHouse only applies the rule to tables with data parts greater than or equal to the Min part size value.
        """
        return pulumi.get(self, "min_part_size")

    @_builtins.property
    @pulumi.getter(name="minPartSizeRatio")
    def min_part_size_ratio(self) -> Optional[_builtins.float]:
        """
        Min part size ratio: Minimum table part size to total table size ratio. ClickHouse only applies the rule to tables in which this ratio is greater than or equal to the Min part size ratio value.
        """
        return pulumi.get(self, "min_part_size_ratio")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupResult(dict):
    def __init__(__self__, *,
                 path_column_name: _builtins.str,
                 time_column_name: _builtins.str,
                 value_column_name: _builtins.str,
                 version_column_name: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 patterns: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult']] = None):
        """
        :param _builtins.str path_column_name: The name of the column storing the metric name (Graphite sensor). Default value: Path.
        :param _builtins.str time_column_name: The name of the column storing the time of measuring the metric. Default value: Time.
        :param _builtins.str value_column_name: The name of the column storing the value of the metric at the time set in `time_column_name`. Default value: Value.
        :param _builtins.str version_column_name: The name of the column storing the version of the metric. Default value: Timestamp.
        :param _builtins.str name: Graphite rollup configuration name.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternArgs'] patterns: Set of thinning rules.
        """
        pulumi.set(__self__, "path_column_name", path_column_name)
        pulumi.set(__self__, "time_column_name", time_column_name)
        pulumi.set(__self__, "value_column_name", value_column_name)
        pulumi.set(__self__, "version_column_name", version_column_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @_builtins.property
    @pulumi.getter(name="pathColumnName")
    def path_column_name(self) -> _builtins.str:
        """
        The name of the column storing the metric name (Graphite sensor). Default value: Path.
        """
        return pulumi.get(self, "path_column_name")

    @_builtins.property
    @pulumi.getter(name="timeColumnName")
    def time_column_name(self) -> _builtins.str:
        """
        The name of the column storing the time of measuring the metric. Default value: Time.
        """
        return pulumi.get(self, "time_column_name")

    @_builtins.property
    @pulumi.getter(name="valueColumnName")
    def value_column_name(self) -> _builtins.str:
        """
        The name of the column storing the value of the metric at the time set in `time_column_name`. Default value: Value.
        """
        return pulumi.get(self, "value_column_name")

    @_builtins.property
    @pulumi.getter(name="versionColumnName")
    def version_column_name(self) -> _builtins.str:
        """
        The name of the column storing the version of the metric. Default value: Timestamp.
        """
        return pulumi.get(self, "version_column_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Graphite rollup configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult']]:
        """
        Set of thinning rules.
        """
        return pulumi.get(self, "patterns")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternResult(dict):
    def __init__(__self__, *,
                 regexp: _builtins.str,
                 function: Optional[_builtins.str] = None,
                 retentions: Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult']] = None):
        """
        :param _builtins.str regexp: Regular expression that the metric name must match.
        :param _builtins.str function: Aggregation function name.
        :param Sequence['GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionArgs'] retentions: Retain parameters.
        """
        pulumi.set(__self__, "regexp", regexp)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if retentions is not None:
            pulumi.set(__self__, "retentions", retentions)

    @_builtins.property
    @pulumi.getter
    def regexp(self) -> _builtins.str:
        """
        Regular expression that the metric name must match.
        """
        return pulumi.get(self, "regexp")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional[_builtins.str]:
        """
        Aggregation function name.
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def retentions(self) -> Optional[Sequence['outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult']]:
        """
        Retain parameters.
        """
        return pulumi.get(self, "retentions")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetentionResult(dict):
    def __init__(__self__, *,
                 age: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None):
        """
        :param _builtins.int age: Minimum data age in seconds.
        :param _builtins.int precision: Accuracy of determining the age of the data in seconds.
        """
        if age is not None:
            pulumi.set(__self__, "age", age)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)

    @_builtins.property
    @pulumi.getter
    def age(self) -> Optional[_builtins.int]:
        """
        Minimum data age in seconds.
        """
        return pulumi.get(self, "age")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        Accuracy of determining the age of the data in seconds.
        """
        return pulumi.get(self, "precision")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigJdbcBridgeResult(dict):
    def __init__(__self__, *,
                 port: _builtins.int,
                 host: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: Port of jdbc bridge. Default value: 9019.
        :param _builtins.str host: Host of jdbc bridge.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port of jdbc bridge. Default value: 9019.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host of jdbc bridge.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigKafkaResult(dict):
    def __init__(__self__, *,
                 auto_offset_reset: _builtins.str,
                 debug: _builtins.str,
                 enable_ssl_certificate_verification: _builtins.bool,
                 max_poll_interval_ms: _builtins.int,
                 sasl_mechanism: _builtins.str,
                 sasl_password: _builtins.str,
                 sasl_username: _builtins.str,
                 security_protocol: _builtins.str,
                 session_timeout_ms: _builtins.int):
        """
        :param _builtins.str auto_offset_reset: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param _builtins.str debug: A comma-separated list of debug contexts to enable.
        :param _builtins.bool enable_ssl_certificate_verification: Enable verification of SSL certificates.
        :param _builtins.int max_poll_interval_ms: Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param _builtins.str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param _builtins.str sasl_password: User password on kafka server.
        :param _builtins.str sasl_username: Username on kafka server.
        :param _builtins.str security_protocol: Security protocol used to connect to kafka server.
        :param _builtins.int session_timeout_ms: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        pulumi.set(__self__, "sasl_password", sasl_password)
        pulumi.set(__self__, "sasl_username", sasl_username)
        pulumi.set(__self__, "security_protocol", security_protocol)
        pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)

    @_builtins.property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> _builtins.str:
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> _builtins.str:
        """
        A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> _builtins.bool:
        """
        Enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> _builtins.int:
        """
        Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> _builtins.str:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> _builtins.str:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> _builtins.str:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> _builtins.str:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> _builtins.int:
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigKafkaTopicResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 settings: Optional['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult'] = None):
        """
        :param _builtins.str name: Kafka topic name.
        :param 'GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsArgs' settings: Kafka connection settings.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Kafka topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional['outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult']:
        """
        Kafka connection settings.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettingsResult(dict):
    def __init__(__self__, *,
                 auto_offset_reset: _builtins.str,
                 debug: _builtins.str,
                 enable_ssl_certificate_verification: _builtins.bool,
                 max_poll_interval_ms: _builtins.int,
                 session_timeout_ms: _builtins.int,
                 sasl_mechanism: Optional[_builtins.str] = None,
                 sasl_password: Optional[_builtins.str] = None,
                 sasl_username: Optional[_builtins.str] = None,
                 security_protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str auto_offset_reset: Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        :param _builtins.str debug: A comma-separated list of debug contexts to enable.
        :param _builtins.bool enable_ssl_certificate_verification: Enable verification of SSL certificates.
        :param _builtins.int max_poll_interval_ms: Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        :param _builtins.int session_timeout_ms: Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        :param _builtins.str sasl_mechanism: SASL mechanism used in kafka authentication.
        :param _builtins.str sasl_password: User password on kafka server.
        :param _builtins.str sasl_username: Username on kafka server.
        :param _builtins.str security_protocol: Security protocol used to connect to kafka server.
        """
        pulumi.set(__self__, "auto_offset_reset", auto_offset_reset)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "enable_ssl_certificate_verification", enable_ssl_certificate_verification)
        pulumi.set(__self__, "max_poll_interval_ms", max_poll_interval_ms)
        pulumi.set(__self__, "session_timeout_ms", session_timeout_ms)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if sasl_password is not None:
            pulumi.set(__self__, "sasl_password", sasl_password)
        if sasl_username is not None:
            pulumi.set(__self__, "sasl_username", sasl_username)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)

    @_builtins.property
    @pulumi.getter(name="autoOffsetReset")
    def auto_offset_reset(self) -> _builtins.str:
        """
        Action to take when there is no initial offset in offset store or the desired offset is out of range: 'smallest','earliest' - automatically reset the offset to the smallest offset, 'largest','latest' - automatically reset the offset to the largest offset, 'error' - trigger an error (ERR__AUTO_OFFSET_RESET) which is retrieved by consuming messages and checking 'message->err'.
        """
        return pulumi.get(self, "auto_offset_reset")

    @_builtins.property
    @pulumi.getter
    def debug(self) -> _builtins.str:
        """
        A comma-separated list of debug contexts to enable.
        """
        return pulumi.get(self, "debug")

    @_builtins.property
    @pulumi.getter(name="enableSslCertificateVerification")
    def enable_ssl_certificate_verification(self) -> _builtins.bool:
        """
        Enable verification of SSL certificates.
        """
        return pulumi.get(self, "enable_ssl_certificate_verification")

    @_builtins.property
    @pulumi.getter(name="maxPollIntervalMs")
    def max_poll_interval_ms(self) -> _builtins.int:
        """
        Maximum allowed time between calls to consume messages (e.g., `rd_kafka_consumer_poll()` for high-level consumers. If this interval is exceeded the consumer is considered failed and the group will rebalance in order to reassign the partitions to another consumer group member.
        """
        return pulumi.get(self, "max_poll_interval_ms")

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutMs")
    def session_timeout_ms(self) -> _builtins.int:
        """
        Client group session and failure detection timeout. The consumer sends periodic heartbeats (heartbeat.interval.ms) to indicate its liveness to the broker. If no hearts are received by the broker for a group member within the session timeout, the broker will remove the consumer from the group and trigger a rebalance.
        """
        return pulumi.get(self, "session_timeout_ms")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[_builtins.str]:
        """
        SASL mechanism used in kafka authentication.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> Optional[_builtins.str]:
        """
        User password on kafka server.
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> Optional[_builtins.str]:
        """
        Username on kafka server.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[_builtins.str]:
        """
        Security protocol used to connect to kafka server.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigMergeTreeResult(dict):
    def __init__(__self__, *,
                 allow_remote_fs_zero_copy_replication: _builtins.bool,
                 check_sample_column_is_correct: _builtins.bool,
                 cleanup_delay_period: _builtins.int,
                 inactive_parts_to_delay_insert: _builtins.int,
                 inactive_parts_to_throw_insert: _builtins.int,
                 max_avg_part_size_for_too_many_parts: _builtins.int,
                 max_bytes_to_merge_at_max_space_in_pool: _builtins.int,
                 max_bytes_to_merge_at_min_space_in_pool: _builtins.int,
                 max_cleanup_delay_period: _builtins.int,
                 max_merge_selecting_sleep_ms: _builtins.int,
                 max_number_of_merges_with_ttl_in_pool: _builtins.int,
                 max_parts_in_total: _builtins.int,
                 max_replicated_merges_in_queue: _builtins.int,
                 merge_max_block_size: _builtins.int,
                 merge_selecting_sleep_ms: _builtins.int,
                 merge_with_recompression_ttl_timeout: _builtins.int,
                 merge_with_ttl_timeout: _builtins.int,
                 min_age_to_force_merge_on_partition_only: _builtins.bool,
                 min_age_to_force_merge_seconds: _builtins.int,
                 min_bytes_for_wide_part: _builtins.int,
                 min_rows_for_wide_part: _builtins.int,
                 number_of_free_entries_in_pool_to_execute_mutation: _builtins.int,
                 number_of_free_entries_in_pool_to_lower_max_size_of_merge: _builtins.int,
                 parts_to_delay_insert: _builtins.int,
                 parts_to_throw_insert: _builtins.int,
                 replicated_deduplication_window: _builtins.int,
                 replicated_deduplication_window_seconds: _builtins.int,
                 ttl_only_drop_parts: _builtins.bool):
        """
        :param _builtins.bool allow_remote_fs_zero_copy_replication: When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        :param _builtins.bool check_sample_column_is_correct: Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        :param _builtins.int cleanup_delay_period: Minimum period to clean old queue logs, blocks hashes and parts.
        :param _builtins.int inactive_parts_to_delay_insert: If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        :param _builtins.int inactive_parts_to_throw_insert: If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the `Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts` exception.
        :param _builtins.int max_avg_part_size_for_too_many_parts: The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        :param _builtins.int max_bytes_to_merge_at_max_space_in_pool: The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        :param _builtins.int max_bytes_to_merge_at_min_space_in_pool: Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        :param _builtins.int max_cleanup_delay_period: Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        :param _builtins.int max_merge_selecting_sleep_ms: Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        :param _builtins.int max_number_of_merges_with_ttl_in_pool: When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        :param _builtins.int max_parts_in_total: Maximum number of parts in all partitions.
        :param _builtins.int max_replicated_merges_in_queue: Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        :param _builtins.int merge_max_block_size: The number of rows that are read from the merged parts into memory. Default value: 8192.
        :param _builtins.int merge_selecting_sleep_ms: Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        :param _builtins.int merge_with_recompression_ttl_timeout: Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        :param _builtins.int merge_with_ttl_timeout: Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        :param _builtins.bool min_age_to_force_merge_on_partition_only: Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        :param _builtins.int min_age_to_force_merge_seconds: Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        :param _builtins.int min_bytes_for_wide_part: Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param _builtins.int min_rows_for_wide_part: Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        :param _builtins.int number_of_free_entries_in_pool_to_execute_mutation: When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid `Too many parts`. Default value: 20.
        :param _builtins.int number_of_free_entries_in_pool_to_lower_max_size_of_merge: Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        :param _builtins.int parts_to_delay_insert: Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table
        :param _builtins.int parts_to_throw_insert: Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        :param _builtins.int replicated_deduplication_window: Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        :param _builtins.int replicated_deduplication_window_seconds: Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        :param _builtins.bool ttl_only_drop_parts: Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        pulumi.set(__self__, "allow_remote_fs_zero_copy_replication", allow_remote_fs_zero_copy_replication)
        pulumi.set(__self__, "check_sample_column_is_correct", check_sample_column_is_correct)
        pulumi.set(__self__, "cleanup_delay_period", cleanup_delay_period)
        pulumi.set(__self__, "inactive_parts_to_delay_insert", inactive_parts_to_delay_insert)
        pulumi.set(__self__, "inactive_parts_to_throw_insert", inactive_parts_to_throw_insert)
        pulumi.set(__self__, "max_avg_part_size_for_too_many_parts", max_avg_part_size_for_too_many_parts)
        pulumi.set(__self__, "max_bytes_to_merge_at_max_space_in_pool", max_bytes_to_merge_at_max_space_in_pool)
        pulumi.set(__self__, "max_bytes_to_merge_at_min_space_in_pool", max_bytes_to_merge_at_min_space_in_pool)
        pulumi.set(__self__, "max_cleanup_delay_period", max_cleanup_delay_period)
        pulumi.set(__self__, "max_merge_selecting_sleep_ms", max_merge_selecting_sleep_ms)
        pulumi.set(__self__, "max_number_of_merges_with_ttl_in_pool", max_number_of_merges_with_ttl_in_pool)
        pulumi.set(__self__, "max_parts_in_total", max_parts_in_total)
        pulumi.set(__self__, "max_replicated_merges_in_queue", max_replicated_merges_in_queue)
        pulumi.set(__self__, "merge_max_block_size", merge_max_block_size)
        pulumi.set(__self__, "merge_selecting_sleep_ms", merge_selecting_sleep_ms)
        pulumi.set(__self__, "merge_with_recompression_ttl_timeout", merge_with_recompression_ttl_timeout)
        pulumi.set(__self__, "merge_with_ttl_timeout", merge_with_ttl_timeout)
        pulumi.set(__self__, "min_age_to_force_merge_on_partition_only", min_age_to_force_merge_on_partition_only)
        pulumi.set(__self__, "min_age_to_force_merge_seconds", min_age_to_force_merge_seconds)
        pulumi.set(__self__, "min_bytes_for_wide_part", min_bytes_for_wide_part)
        pulumi.set(__self__, "min_rows_for_wide_part", min_rows_for_wide_part)
        pulumi.set(__self__, "number_of_free_entries_in_pool_to_execute_mutation", number_of_free_entries_in_pool_to_execute_mutation)
        pulumi.set(__self__, "number_of_free_entries_in_pool_to_lower_max_size_of_merge", number_of_free_entries_in_pool_to_lower_max_size_of_merge)
        pulumi.set(__self__, "parts_to_delay_insert", parts_to_delay_insert)
        pulumi.set(__self__, "parts_to_throw_insert", parts_to_throw_insert)
        pulumi.set(__self__, "replicated_deduplication_window", replicated_deduplication_window)
        pulumi.set(__self__, "replicated_deduplication_window_seconds", replicated_deduplication_window_seconds)
        pulumi.set(__self__, "ttl_only_drop_parts", ttl_only_drop_parts)

    @_builtins.property
    @pulumi.getter(name="allowRemoteFsZeroCopyReplication")
    def allow_remote_fs_zero_copy_replication(self) -> _builtins.bool:
        """
        When this setting has a value greater than zero only a single replica starts the merge immediately if merged part on shared storage and allow_remote_fs_zero_copy_replication is enabled.
        """
        return pulumi.get(self, "allow_remote_fs_zero_copy_replication")

    @_builtins.property
    @pulumi.getter(name="checkSampleColumnIsCorrect")
    def check_sample_column_is_correct(self) -> _builtins.bool:
        """
        Enables the check at table creation, that the data type of a column for sampling or sampling expression is correct. The data type must be one of unsigned integer types: UInt8, UInt16, UInt32, UInt64. Default value: true.
        """
        return pulumi.get(self, "check_sample_column_is_correct")

    @_builtins.property
    @pulumi.getter(name="cleanupDelayPeriod")
    def cleanup_delay_period(self) -> _builtins.int:
        """
        Minimum period to clean old queue logs, blocks hashes and parts.
        """
        return pulumi.get(self, "cleanup_delay_period")

    @_builtins.property
    @pulumi.getter(name="inactivePartsToDelayInsert")
    def inactive_parts_to_delay_insert(self) -> _builtins.int:
        """
        If the number of inactive parts in a single partition in the table at least that many the inactive_parts_to_delay_insert value, an INSERT artificially slows down. It is useful when a server fails to clean up parts quickly enough.
        """
        return pulumi.get(self, "inactive_parts_to_delay_insert")

    @_builtins.property
    @pulumi.getter(name="inactivePartsToThrowInsert")
    def inactive_parts_to_throw_insert(self) -> _builtins.int:
        """
        If the number of inactive parts in a single partition more than the inactive_parts_to_throw_insert value, INSERT is interrupted with the `Too many inactive parts (N). Parts cleaning are processing significantly slower than inserts` exception.
        """
        return pulumi.get(self, "inactive_parts_to_throw_insert")

    @_builtins.property
    @pulumi.getter(name="maxAvgPartSizeForTooManyParts")
    def max_avg_part_size_for_too_many_parts(self) -> _builtins.int:
        """
        The `too many parts` check according to `parts_to_delay_insert` and `parts_to_throw_insert` will be active only if the average part size (in the relevant partition) is not larger than the specified threshold. If it is larger than the specified threshold, the INSERTs will be neither delayed or rejected. This allows to have hundreds of terabytes in a single table on a single server if the parts are successfully merged to larger parts. This does not affect the thresholds on inactive parts or total parts.
        """
        return pulumi.get(self, "max_avg_part_size_for_too_many_parts")

    @_builtins.property
    @pulumi.getter(name="maxBytesToMergeAtMaxSpaceInPool")
    def max_bytes_to_merge_at_max_space_in_pool(self) -> _builtins.int:
        """
        The maximum total parts size (in bytes) to be merged into one part, if there are enough resources available. max_bytes_to_merge_at_max_space_in_pool -- roughly corresponds to the maximum possible part size created by an automatic background merge.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_max_space_in_pool")

    @_builtins.property
    @pulumi.getter(name="maxBytesToMergeAtMinSpaceInPool")
    def max_bytes_to_merge_at_min_space_in_pool(self) -> _builtins.int:
        """
        Max bytes to merge at min space in pool: Maximum total size of a data part to merge when the number of free threads in the background pool is minimum.
        """
        return pulumi.get(self, "max_bytes_to_merge_at_min_space_in_pool")

    @_builtins.property
    @pulumi.getter(name="maxCleanupDelayPeriod")
    def max_cleanup_delay_period(self) -> _builtins.int:
        """
        Maximum period to clean old queue logs, blocks hashes and parts. Default value: 300 seconds.
        """
        return pulumi.get(self, "max_cleanup_delay_period")

    @_builtins.property
    @pulumi.getter(name="maxMergeSelectingSleepMs")
    def max_merge_selecting_sleep_ms(self) -> _builtins.int:
        """
        Maximum sleep time for merge selecting, a lower setting will trigger selecting tasks in background_schedule_pool frequently which result in large amount of requests to zookeeper in large-scale clusters. Default value: 60000 milliseconds (60 seconds).
        """
        return pulumi.get(self, "max_merge_selecting_sleep_ms")

    @_builtins.property
    @pulumi.getter(name="maxNumberOfMergesWithTtlInPool")
    def max_number_of_merges_with_ttl_in_pool(self) -> _builtins.int:
        """
        When there is more than specified number of merges with TTL entries in pool, do not assign new merge with TTL.
        """
        return pulumi.get(self, "max_number_of_merges_with_ttl_in_pool")

    @_builtins.property
    @pulumi.getter(name="maxPartsInTotal")
    def max_parts_in_total(self) -> _builtins.int:
        """
        Maximum number of parts in all partitions.
        """
        return pulumi.get(self, "max_parts_in_total")

    @_builtins.property
    @pulumi.getter(name="maxReplicatedMergesInQueue")
    def max_replicated_merges_in_queue(self) -> _builtins.int:
        """
        Max replicated merges in queue: Maximum number of merge tasks that can be in the ReplicatedMergeTree queue at the same time.
        """
        return pulumi.get(self, "max_replicated_merges_in_queue")

    @_builtins.property
    @pulumi.getter(name="mergeMaxBlockSize")
    def merge_max_block_size(self) -> _builtins.int:
        """
        The number of rows that are read from the merged parts into memory. Default value: 8192.
        """
        return pulumi.get(self, "merge_max_block_size")

    @_builtins.property
    @pulumi.getter(name="mergeSelectingSleepMs")
    def merge_selecting_sleep_ms(self) -> _builtins.int:
        """
        Sleep time for merge selecting when no part is selected. A lower setting triggers selecting tasks in background_schedule_pool frequently, which results in a large number of requests to ClickHouse Keeper in large-scale clusters.
        """
        return pulumi.get(self, "merge_selecting_sleep_ms")

    @_builtins.property
    @pulumi.getter(name="mergeWithRecompressionTtlTimeout")
    def merge_with_recompression_ttl_timeout(self) -> _builtins.int:
        """
        Minimum delay in seconds before repeating a merge with recompression TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_recompression_ttl_timeout")

    @_builtins.property
    @pulumi.getter(name="mergeWithTtlTimeout")
    def merge_with_ttl_timeout(self) -> _builtins.int:
        """
        Minimum delay in seconds before repeating a merge with delete TTL. Default value: 14400 seconds (4 hours).
        """
        return pulumi.get(self, "merge_with_ttl_timeout")

    @_builtins.property
    @pulumi.getter(name="minAgeToForceMergeOnPartitionOnly")
    def min_age_to_force_merge_on_partition_only(self) -> _builtins.bool:
        """
        Whether min_age_to_force_merge_seconds should be applied only on the entire partition and not on subset.
        """
        return pulumi.get(self, "min_age_to_force_merge_on_partition_only")

    @_builtins.property
    @pulumi.getter(name="minAgeToForceMergeSeconds")
    def min_age_to_force_merge_seconds(self) -> _builtins.int:
        """
        Merge parts if every part in the range is older than the value of `min_age_to_force_merge_seconds`.
        """
        return pulumi.get(self, "min_age_to_force_merge_seconds")

    @_builtins.property
    @pulumi.getter(name="minBytesForWidePart")
    def min_bytes_for_wide_part(self) -> _builtins.int:
        """
        Minimum number of bytes in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_bytes_for_wide_part")

    @_builtins.property
    @pulumi.getter(name="minRowsForWidePart")
    def min_rows_for_wide_part(self) -> _builtins.int:
        """
        Minimum number of rows in a data part that can be stored in Wide format. You can set one, both or none of these settings.
        """
        return pulumi.get(self, "min_rows_for_wide_part")

    @_builtins.property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToExecuteMutation")
    def number_of_free_entries_in_pool_to_execute_mutation(self) -> _builtins.int:
        """
        When there is less than specified number of free entries in pool, do not execute part mutations. This is to leave free threads for regular merges and avoid `Too many parts`. Default value: 20.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_execute_mutation")

    @_builtins.property
    @pulumi.getter(name="numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge")
    def number_of_free_entries_in_pool_to_lower_max_size_of_merge(self) -> _builtins.int:
        """
        Number of free entries in pool to lower max size of merge: Threshold value of free entries in the pool. If the number of entries in the pool falls below this value, ClickHouse reduces the maximum size of a data part to merge. This helps handle small merges faster, rather than filling the pool with lengthy merges.
        """
        return pulumi.get(self, "number_of_free_entries_in_pool_to_lower_max_size_of_merge")

    @_builtins.property
    @pulumi.getter(name="partsToDelayInsert")
    def parts_to_delay_insert(self) -> _builtins.int:
        """
        Parts to delay insert: Number of active data parts in a table, on exceeding which ClickHouse starts artificially reduce the rate of inserting data into the table
        """
        return pulumi.get(self, "parts_to_delay_insert")

    @_builtins.property
    @pulumi.getter(name="partsToThrowInsert")
    def parts_to_throw_insert(self) -> _builtins.int:
        """
        Parts to throw insert: Threshold value of active data parts in a table, on exceeding which ClickHouse throws the 'Too many parts ...' exception.
        """
        return pulumi.get(self, "parts_to_throw_insert")

    @_builtins.property
    @pulumi.getter(name="replicatedDeduplicationWindow")
    def replicated_deduplication_window(self) -> _builtins.int:
        """
        Replicated deduplication window: Number of recent hash blocks that ZooKeeper will store (the old ones will be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window")

    @_builtins.property
    @pulumi.getter(name="replicatedDeduplicationWindowSeconds")
    def replicated_deduplication_window_seconds(self) -> _builtins.int:
        """
        Replicated deduplication window seconds: Time during which ZooKeeper stores the hash blocks (the old ones wil be deleted).
        """
        return pulumi.get(self, "replicated_deduplication_window_seconds")

    @_builtins.property
    @pulumi.getter(name="ttlOnlyDropParts")
    def ttl_only_drop_parts(self) -> _builtins.bool:
        """
        Enables zero-copy replication when a replica is located on a remote filesystem.
        """
        return pulumi.get(self, "ttl_only_drop_parts")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigQueryCacheResult(dict):
    def __init__(__self__, *,
                 max_entries: _builtins.int,
                 max_entry_size_in_bytes: _builtins.int,
                 max_entry_size_in_rows: _builtins.int,
                 max_size_in_bytes: _builtins.int):
        """
        :param _builtins.int max_entries: The maximum number of SELECT query results stored in the cache. Default value: 1024.
        :param _builtins.int max_entry_size_in_bytes: The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        :param _builtins.int max_entry_size_in_rows: The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        :param _builtins.int max_size_in_bytes: The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        pulumi.set(__self__, "max_entries", max_entries)
        pulumi.set(__self__, "max_entry_size_in_bytes", max_entry_size_in_bytes)
        pulumi.set(__self__, "max_entry_size_in_rows", max_entry_size_in_rows)
        pulumi.set(__self__, "max_size_in_bytes", max_size_in_bytes)

    @_builtins.property
    @pulumi.getter(name="maxEntries")
    def max_entries(self) -> _builtins.int:
        """
        The maximum number of SELECT query results stored in the cache. Default value: 1024.
        """
        return pulumi.get(self, "max_entries")

    @_builtins.property
    @pulumi.getter(name="maxEntrySizeInBytes")
    def max_entry_size_in_bytes(self) -> _builtins.int:
        """
        The maximum size in bytes SELECT query results may have to be saved in the cache. Default value: 1048576 (1 MiB).
        """
        return pulumi.get(self, "max_entry_size_in_bytes")

    @_builtins.property
    @pulumi.getter(name="maxEntrySizeInRows")
    def max_entry_size_in_rows(self) -> _builtins.int:
        """
        The maximum number of rows SELECT query results may have to be saved in the cache. Default value: 30000000 (30 mil).
        """
        return pulumi.get(self, "max_entry_size_in_rows")

    @_builtins.property
    @pulumi.getter(name="maxSizeInBytes")
    def max_size_in_bytes(self) -> _builtins.int:
        """
        The maximum cache size in bytes. 0 means the query cache is disabled. Default value: 1073741824 (1 GiB).
        """
        return pulumi.get(self, "max_size_in_bytes")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigQueryMaskingRuleResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 replace: _builtins.str,
                 regexp: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name for the rule.
        :param _builtins.str replace: Substitution string for sensitive data. Default value: six asterisks.
        :param _builtins.str regexp: RE2 compatible regular expression.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replace", replace)
        if regexp is not None:
            pulumi.set(__self__, "regexp", regexp)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def replace(self) -> _builtins.str:
        """
        Substitution string for sensitive data. Default value: six asterisks.
        """
        return pulumi.get(self, "replace")

    @_builtins.property
    @pulumi.getter
    def regexp(self) -> Optional[_builtins.str]:
        """
        RE2 compatible regular expression.
        """
        return pulumi.get(self, "regexp")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseConfigRabbitmqResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str,
                 vhost: _builtins.str):
        """
        :param _builtins.str password: RabbitMQ user password.
        :param _builtins.str username: RabbitMQ username.
        :param _builtins.str vhost: RabbitMQ vhost. Default: `\\`.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        RabbitMQ user password.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        RabbitMQ username.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> _builtins.str:
        """
        RabbitMQ vhost. Default: `\\`.
        """
        return pulumi.get(self, "vhost")


@pulumi.output_type
class GetMdbClickhouseClusterClickhouseResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ClickHouse host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a ClickHouse host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbClickhouseClusterCloudStorageResult(dict):
    def __init__(__self__, *,
                 data_cache_enabled: _builtins.bool,
                 data_cache_max_size: _builtins.int,
                 move_factor: _builtins.float,
                 prefer_not_to_merge: _builtins.bool,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_cache_enabled: Enables temporary storage in the cluster repository of data requested from the object repository.
        :param _builtins.int data_cache_max_size: Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        :param _builtins.float move_factor: Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        :param _builtins.bool prefer_not_to_merge: Disables merging of data parts in `Yandex Object Storage`.
        :param _builtins.bool enabled: Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        pulumi.set(__self__, "data_cache_enabled", data_cache_enabled)
        pulumi.set(__self__, "data_cache_max_size", data_cache_max_size)
        pulumi.set(__self__, "move_factor", move_factor)
        pulumi.set(__self__, "prefer_not_to_merge", prefer_not_to_merge)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="dataCacheEnabled")
    def data_cache_enabled(self) -> _builtins.bool:
        """
        Enables temporary storage in the cluster repository of data requested from the object repository.
        """
        return pulumi.get(self, "data_cache_enabled")

    @_builtins.property
    @pulumi.getter(name="dataCacheMaxSize")
    def data_cache_max_size(self) -> _builtins.int:
        """
        Defines the maximum amount of memory (in bytes) allocated in the cluster storage for temporary storage of data requested from the object storage.
        """
        return pulumi.get(self, "data_cache_max_size")

    @_builtins.property
    @pulumi.getter(name="moveFactor")
    def move_factor(self) -> _builtins.float:
        """
        Sets the minimum free space ratio in the cluster storage. If the free space is lower than this value, the data is transferred to Yandex Object Storage. Acceptable values are 0 to 1, inclusive.
        """
        return pulumi.get(self, "move_factor")

    @_builtins.property
    @pulumi.getter(name="preferNotToMerge")
    def prefer_not_to_merge(self) -> _builtins.bool:
        """
        Disables merging of data parts in `Yandex Object Storage`.
        """
        return pulumi.get(self, "prefer_not_to_merge")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to use Yandex Object Storage for storing ClickHouse data. Can be either `true` or `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetMdbClickhouseClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the database.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbClickhouseClusterFormatSchemaResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the format schema.
        :param _builtins.str type: Type of the format schema.
        :param _builtins.str uri: Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the format schema.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the format schema.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        Format schema file URL. You can only use format schemas stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetMdbClickhouseClusterHostResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 shard_name: _builtins.str,
                 subnet_id: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str shard_name: The name of the shard to which the host belongs.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        :param _builtins.str type: The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "shard_name", shard_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> _builtins.str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Sets whether the host should get a public IP address on creation. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the host to be deployed. Can be either `CLICKHOUSE` or `ZOOKEEPER`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbClickhouseClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbClickhouseClusterMlModelResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the ml model.
        :param _builtins.str type: Type of the model.
        :param _builtins.str uri: Model file URL. You can only use models stored in Yandex Object Storage.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the ml model.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the model.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        Model file URL. You can only use models stored in Yandex Object Storage.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetMdbClickhouseClusterShardResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbClickhouseClusterShardResourcesResult',
                 weight: _builtins.int,
                 name: Optional[_builtins.str] = None):
        """
        :param 'GetMdbClickhouseClusterShardResourcesArgs' resources: Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster.
        :param _builtins.int weight: The weight of shard.
        :param _builtins.str name: The name of shard.
        """
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "weight", weight)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbClickhouseClusterShardResourcesResult':
        """
        Resources allocated to host of the shard. The resources specified for the shard takes precedence over the resources specified for the cluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight of shard.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of shard.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbClickhouseClusterShardGroupResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 shard_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str description: Description of the shard group.
        :param _builtins.str name: The name of the shard group, used as cluster name in Distributed tables.
        :param Sequence[_builtins.str] shard_names: List of shards names that belong to the shard group.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shard_names is not None:
            pulumi.set(__self__, "shard_names", shard_names)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the shard group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the shard group, used as cluster name in Distributed tables.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="shardNames")
    def shard_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of shards names that belong to the shard group.
        """
        return pulumi.get(self, "shard_names")


@pulumi.output_type
class GetMdbClickhouseClusterShardResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ClickHouse host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a ClickHouse host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of ClickHouse hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a ClickHouse host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbClickhouseClusterUserResult(dict):
    def __init__(__self__, *,
                 connection_manager: Mapping[str, _builtins.str],
                 permissions: Sequence['outputs.GetMdbClickhouseClusterUserPermissionResult'],
                 quotas: Sequence['outputs.GetMdbClickhouseClusterUserQuotaResult'],
                 settings: 'outputs.GetMdbClickhouseClusterUserSettingsResult',
                 generate_password: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] connection_manager: Connection Manager connection configuration. Filled in by the server automatically.
        :param Sequence['GetMdbClickhouseClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        :param Sequence['GetMdbClickhouseClusterUserQuotaArgs'] quotas: Set of user quotas.
        :param 'GetMdbClickhouseClusterUserSettingsArgs' settings: Custom settings for user.
        :param _builtins.bool generate_password: Generate password using Connection Manager. Allowed values: `true` or `false`. It's used only during user creation and is ignored during updating.
               
               > **Must specify either password or generate_password**.
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        """
        pulumi.set(__self__, "connection_manager", connection_manager)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "quotas", quotas)
        pulumi.set(__self__, "settings", settings)
        if generate_password is not None:
            pulumi.set(__self__, "generate_password", generate_password)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="connectionManager")
    def connection_manager(self) -> Mapping[str, _builtins.str]:
        """
        Connection Manager connection configuration. Filled in by the server automatically.
        """
        return pulumi.get(self, "connection_manager")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbClickhouseClusterUserPermissionResult']:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def quotas(self) -> Sequence['outputs.GetMdbClickhouseClusterUserQuotaResult']:
        """
        Set of user quotas.
        """
        return pulumi.get(self, "quotas")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> 'outputs.GetMdbClickhouseClusterUserSettingsResult':
        """
        Custom settings for user.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="generatePassword")
    def generate_password(self) -> Optional[_builtins.bool]:
        """
        Generate password using Connection Manager. Allowed values: `true` or `false`. It's used only during user creation and is ignored during updating.

        > **Must specify either password or generate_password**.
        """
        return pulumi.get(self, "generate_password")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetMdbClickhouseClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetMdbClickhouseClusterUserQuotaResult(dict):
    def __init__(__self__, *,
                 errors: _builtins.int,
                 execution_time: _builtins.int,
                 queries: _builtins.int,
                 read_rows: _builtins.int,
                 result_rows: _builtins.int,
                 interval_duration: Optional[_builtins.int] = None):
        """
        :param _builtins.int errors: The number of queries that threw exception.
        :param _builtins.int execution_time: The total query execution time, in milliseconds (wall time).
        :param _builtins.int queries: The total number of queries.
        :param _builtins.int read_rows: The total number of source rows read from tables for running the query, on all remote servers.
        :param _builtins.int result_rows: The total number of rows given as the result.
        :param _builtins.int interval_duration: Duration of interval for quota in milliseconds.
        """
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "execution_time", execution_time)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "read_rows", read_rows)
        pulumi.set(__self__, "result_rows", result_rows)
        if interval_duration is not None:
            pulumi.set(__self__, "interval_duration", interval_duration)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> _builtins.int:
        """
        The number of queries that threw exception.
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> _builtins.int:
        """
        The total query execution time, in milliseconds (wall time).
        """
        return pulumi.get(self, "execution_time")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> _builtins.int:
        """
        The total number of queries.
        """
        return pulumi.get(self, "queries")

    @_builtins.property
    @pulumi.getter(name="readRows")
    def read_rows(self) -> _builtins.int:
        """
        The total number of source rows read from tables for running the query, on all remote servers.
        """
        return pulumi.get(self, "read_rows")

    @_builtins.property
    @pulumi.getter(name="resultRows")
    def result_rows(self) -> _builtins.int:
        """
        The total number of rows given as the result.
        """
        return pulumi.get(self, "result_rows")

    @_builtins.property
    @pulumi.getter(name="intervalDuration")
    def interval_duration(self) -> Optional[_builtins.int]:
        """
        Duration of interval for quota in milliseconds.
        """
        return pulumi.get(self, "interval_duration")


@pulumi.output_type
class GetMdbClickhouseClusterUserSettingsResult(dict):
    def __init__(__self__, *,
                 add_http_cors_header: _builtins.bool,
                 allow_ddl: _builtins.bool,
                 allow_introspection_functions: _builtins.bool,
                 allow_suspicious_low_cardinality_types: _builtins.bool,
                 any_join_distinct_right_table_keys: _builtins.bool,
                 async_insert: _builtins.bool,
                 async_insert_busy_timeout: _builtins.int,
                 async_insert_max_data_size: _builtins.int,
                 async_insert_stale_timeout: _builtins.int,
                 async_insert_threads: _builtins.int,
                 async_insert_use_adaptive_busy_timeout: _builtins.bool,
                 cancel_http_readonly_queries_on_client_close: _builtins.bool,
                 compile: _builtins.bool,
                 compile_expressions: _builtins.bool,
                 connect_timeout: _builtins.int,
                 connect_timeout_with_failover: _builtins.int,
                 count_distinct_implementation: _builtins.str,
                 data_type_default_nullable: _builtins.bool,
                 date_time_input_format: _builtins.str,
                 date_time_output_format: _builtins.str,
                 deduplicate_blocks_in_dependent_materialized_views: _builtins.bool,
                 distinct_overflow_mode: _builtins.str,
                 distributed_aggregation_memory_efficient: _builtins.bool,
                 distributed_ddl_task_timeout: _builtins.int,
                 distributed_product_mode: _builtins.str,
                 do_not_merge_across_partitions_select_final: _builtins.bool,
                 empty_result_for_aggregation_by_empty_set: _builtins.bool,
                 enable_analyzer: _builtins.bool,
                 enable_http_compression: _builtins.bool,
                 enable_reads_from_query_cache: _builtins.bool,
                 enable_writes_to_query_cache: _builtins.bool,
                 fallback_to_stale_replicas_for_distributed_queries: _builtins.bool,
                 flatten_nested: _builtins.bool,
                 force_index_by_date: _builtins.bool,
                 force_primary_key: _builtins.bool,
                 format_avro_schema_registry_url: _builtins.str,
                 format_regexp: _builtins.str,
                 format_regexp_skip_unmatched: _builtins.bool,
                 group_by_overflow_mode: _builtins.str,
                 group_by_two_level_threshold: _builtins.int,
                 group_by_two_level_threshold_bytes: _builtins.int,
                 hedged_connection_timeout_ms: _builtins.int,
                 http_connection_timeout: _builtins.int,
                 http_headers_progress_interval: _builtins.int,
                 http_max_field_name_size: _builtins.int,
                 http_max_field_value_size: _builtins.int,
                 http_receive_timeout: _builtins.int,
                 http_send_timeout: _builtins.int,
                 idle_connection_timeout: _builtins.int,
                 ignore_materialized_views_with_dropped_target_table: _builtins.bool,
                 input_format_defaults_for_omitted_fields: _builtins.bool,
                 input_format_import_nested_json: _builtins.bool,
                 input_format_null_as_default: _builtins.bool,
                 input_format_parallel_parsing: _builtins.bool,
                 input_format_values_interpret_expressions: _builtins.bool,
                 input_format_with_names_use_header: _builtins.bool,
                 insert_keeper_max_retries: _builtins.int,
                 insert_null_as_default: _builtins.bool,
                 insert_quorum: _builtins.int,
                 insert_quorum_parallel: _builtins.bool,
                 insert_quorum_timeout: _builtins.int,
                 join_algorithms: Sequence[_builtins.str],
                 join_overflow_mode: _builtins.str,
                 join_use_nulls: _builtins.bool,
                 joined_subquery_requires_alias: _builtins.bool,
                 load_balancing: _builtins.str,
                 local_filesystem_read_method: _builtins.str,
                 log_processors_profiles: _builtins.bool,
                 log_queries_probability: _builtins.float,
                 log_query_threads: _builtins.bool,
                 log_query_views: _builtins.bool,
                 low_cardinality_allow_in_native_format: _builtins.bool,
                 max_ast_depth: _builtins.int,
                 max_ast_elements: _builtins.int,
                 max_block_size: _builtins.int,
                 max_bytes_before_external_group_by: _builtins.int,
                 max_bytes_before_external_sort: _builtins.int,
                 max_bytes_in_distinct: _builtins.int,
                 max_bytes_in_join: _builtins.int,
                 max_bytes_in_set: _builtins.int,
                 max_bytes_to_read: _builtins.int,
                 max_bytes_to_sort: _builtins.int,
                 max_bytes_to_transfer: _builtins.int,
                 max_columns_to_read: _builtins.int,
                 max_concurrent_queries_for_user: _builtins.int,
                 max_execution_time: _builtins.int,
                 max_expanded_ast_elements: _builtins.int,
                 max_final_threads: _builtins.int,
                 max_http_get_redirects: _builtins.int,
                 max_insert_block_size: _builtins.int,
                 max_insert_threads: _builtins.int,
                 max_memory_usage: _builtins.int,
                 max_memory_usage_for_user: _builtins.int,
                 max_network_bandwidth: _builtins.int,
                 max_network_bandwidth_for_user: _builtins.int,
                 max_parser_depth: _builtins.int,
                 max_query_size: _builtins.int,
                 max_read_buffer_size: _builtins.int,
                 max_replica_delay_for_distributed_queries: _builtins.int,
                 max_result_bytes: _builtins.int,
                 max_result_rows: _builtins.int,
                 max_rows_in_distinct: _builtins.int,
                 max_rows_in_join: _builtins.int,
                 max_rows_in_set: _builtins.int,
                 max_rows_to_group_by: _builtins.int,
                 max_rows_to_read: _builtins.int,
                 max_rows_to_sort: _builtins.int,
                 max_rows_to_transfer: _builtins.int,
                 max_temporary_columns: _builtins.int,
                 max_temporary_data_on_disk_size_for_query: _builtins.int,
                 max_temporary_data_on_disk_size_for_user: _builtins.int,
                 max_temporary_non_const_columns: _builtins.int,
                 max_threads: _builtins.int,
                 memory_overcommit_ratio_denominator: _builtins.int,
                 memory_overcommit_ratio_denominator_for_user: _builtins.int,
                 memory_profiler_sample_probability: _builtins.float,
                 memory_profiler_step: _builtins.int,
                 memory_usage_overcommit_max_wait_microseconds: _builtins.int,
                 merge_tree_max_bytes_to_use_cache: _builtins.int,
                 merge_tree_max_rows_to_use_cache: _builtins.int,
                 merge_tree_min_bytes_for_concurrent_read: _builtins.int,
                 merge_tree_min_rows_for_concurrent_read: _builtins.int,
                 min_bytes_to_use_direct_io: _builtins.int,
                 min_count_to_compile: _builtins.int,
                 min_count_to_compile_expression: _builtins.int,
                 min_execution_speed: _builtins.int,
                 min_execution_speed_bytes: _builtins.int,
                 min_insert_block_size_bytes: _builtins.int,
                 min_insert_block_size_rows: _builtins.int,
                 output_format_json_quote64bit_integers: _builtins.bool,
                 output_format_json_quote_denormals: _builtins.bool,
                 prefer_localhost_replica: _builtins.bool,
                 priority: _builtins.int,
                 query_cache_max_entries: _builtins.int,
                 query_cache_max_size_in_bytes: _builtins.int,
                 query_cache_min_query_duration: _builtins.int,
                 query_cache_min_query_runs: _builtins.int,
                 query_cache_share_between_users: _builtins.bool,
                 query_cache_tag: _builtins.str,
                 query_cache_ttl: _builtins.int,
                 quota_mode: _builtins.str,
                 read_overflow_mode: _builtins.str,
                 readonly: _builtins.int,
                 receive_timeout: _builtins.int,
                 remote_filesystem_read_method: _builtins.str,
                 replication_alter_partitions_sync: _builtins.int,
                 result_overflow_mode: _builtins.str,
                 s3_use_adaptive_timeouts: _builtins.bool,
                 select_sequential_consistency: _builtins.bool,
                 send_progress_in_http_headers: _builtins.bool,
                 send_timeout: _builtins.int,
                 set_overflow_mode: _builtins.str,
                 skip_unavailable_shards: _builtins.bool,
                 sort_overflow_mode: _builtins.str,
                 timeout_before_checking_execution_speed: _builtins.int,
                 timeout_overflow_mode: _builtins.str,
                 transfer_overflow_mode: _builtins.str,
                 transform_null_in: _builtins.bool,
                 use_hedged_requests: _builtins.bool,
                 use_query_cache: _builtins.bool,
                 use_uncompressed_cache: _builtins.bool,
                 wait_for_async_insert: _builtins.bool,
                 wait_for_async_insert_timeout: _builtins.int):
        """
        :param _builtins.bool add_http_cors_header: Include CORS headers in HTTP responses.
        :param _builtins.bool allow_ddl: Allows or denies DDL queries.
        :param _builtins.bool allow_introspection_functions: Enables introspections functions for query profiling.
        :param _builtins.bool allow_suspicious_low_cardinality_types: Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        :param _builtins.bool any_join_distinct_right_table_keys: Enables legacy ClickHouse server behavior in ANY INNER|LEFT JOIN operations.
        :param _builtins.bool async_insert: Enables asynchronous inserts. Disabled by default.
        :param _builtins.int async_insert_busy_timeout: The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        :param _builtins.int async_insert_max_data_size: The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        :param _builtins.int async_insert_stale_timeout: The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        :param _builtins.int async_insert_threads: The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        :param _builtins.bool async_insert_use_adaptive_busy_timeout: If it is set to true, use adaptive busy timeout for asynchronous inserts.
        :param _builtins.bool cancel_http_readonly_queries_on_client_close: Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        :param _builtins.bool compile: Enable compilation of queries.
        :param _builtins.bool compile_expressions: Turn on expression compilation.
        :param _builtins.int connect_timeout: Connect timeout in milliseconds on the socket used for communicating with the client.
        :param _builtins.int connect_timeout_with_failover: The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        :param _builtins.str count_distinct_implementation: Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        :param _builtins.bool data_type_default_nullable: Allows data types without explicit modifiers NULL or NOT NULL in column definition will be Nullable.
        :param _builtins.str date_time_input_format: Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        :param _builtins.str date_time_output_format: Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        :param _builtins.bool deduplicate_blocks_in_dependent_materialized_views: Enables or disables the deduplication check for materialized views that receive data from `Replicated` tables.
        :param _builtins.str distinct_overflow_mode: Sets behavior on overflow when using DISTINCT. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool distributed_aggregation_memory_efficient: Determine the behavior of distributed subqueries.
        :param _builtins.int distributed_ddl_task_timeout: Timeout for DDL queries, in milliseconds.
        :param _builtins.str distributed_product_mode: Changes the behavior of distributed subqueries.
        :param _builtins.bool do_not_merge_across_partitions_select_final: Enable or disable independent processing of partitions for **SELECT** queries with **FINAL**.
        :param _builtins.bool empty_result_for_aggregation_by_empty_set: Allows to return empty result.
        :param _builtins.bool enable_analyzer: Enable new query analyzer.
        :param _builtins.bool enable_http_compression: Enables or disables data compression in the response to an HTTP request.
        :param _builtins.bool enable_reads_from_query_cache: If turned on, results of SELECT queries are retrieved from the query cache.
        :param _builtins.bool enable_writes_to_query_cache: If turned on, results of SELECT queries are stored in the query cache.
        :param _builtins.bool fallback_to_stale_replicas_for_distributed_queries: Forces a query to an out-of-date replica if updated data is not available.
        :param _builtins.bool flatten_nested: Sets the data format of a nested columns.
        :param _builtins.bool force_index_by_date: Disables query execution if the index cant be used by date.
        :param _builtins.bool force_primary_key: Disables query execution if indexing by the primary key is not possible.
        :param _builtins.str format_avro_schema_registry_url: Avro schema registry URL.
        :param _builtins.str format_regexp: Regular expression (for Regexp format).
        :param _builtins.bool format_regexp_skip_unmatched: Skip lines unmatched by regular expression.
        :param _builtins.str group_by_overflow_mode: Sets behavior on overflow while GROUP BY operation. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
               * `any` - perform approximate GROUP BY operation by continuing aggregation for the keys that got into the set, but dont add new keys to the set.
        :param _builtins.int group_by_two_level_threshold: Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        :param _builtins.int group_by_two_level_threshold_bytes: Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        :param _builtins.int hedged_connection_timeout_ms: Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        :param _builtins.int http_connection_timeout: Timeout for HTTP connection in milliseconds.
        :param _builtins.int http_headers_progress_interval: Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        :param _builtins.int http_max_field_name_size: Maximum length of field name in HTTP header.
        :param _builtins.int http_max_field_value_size: Maximum length of field value in HTTP header.
        :param _builtins.int http_receive_timeout: Timeout for HTTP connection in milliseconds.
        :param _builtins.int http_send_timeout: Timeout for HTTP connection in milliseconds.
        :param _builtins.int idle_connection_timeout: Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        :param _builtins.bool ignore_materialized_views_with_dropped_target_table: Ignore materialized views with dropped target table during pushing to views.
        :param _builtins.bool input_format_defaults_for_omitted_fields: When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        :param _builtins.bool input_format_import_nested_json: Enables or disables the insertion of JSON data with nested objects.
        :param _builtins.bool input_format_null_as_default: Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        :param _builtins.bool input_format_parallel_parsing: Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        :param _builtins.bool input_format_values_interpret_expressions: Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        :param _builtins.bool input_format_with_names_use_header: Enables or disables checking the column order when inserting data.
        :param _builtins.int insert_keeper_max_retries: The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        :param _builtins.bool insert_null_as_default: Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        :param _builtins.int insert_quorum: Enables the quorum writes.
        :param _builtins.bool insert_quorum_parallel: Enables or disables parallelism for quorum INSERT queries.
        :param _builtins.int insert_quorum_timeout: Write to a quorum timeout in milliseconds.
        :param Sequence[_builtins.str] join_algorithms: Specifies which JOIN algorithm is used. Possible values:
               * `hash` - hash join algorithm is used. The most generic implementation that supports all combinations of kind and strictness and multiple join keys that are combined with OR in the JOIN ON section.
               * `parallel_hash` - a variation of hash join that splits the data into buckets and builds several hash tables instead of one concurrently to speed up this process.
               * `partial_merge` - a variation of the sort-merge algorithm, where only the right table is fully sorted.
               * `direct` - this algorithm can be applied when the storage for the right table supports key-value requests.
               * `auto` - when set to auto, hash join is tried first, and the algorithm is switched on the fly to another algorithm if the memory limit is violated.
               * `full_sorting_merge` - sort-merge algorithm with full sorting joined tables before joining.
               * `prefer_partial_merge` - clickHouse always tries to use partial_merge join if possible, otherwise, it uses hash. Deprecated, same as partial_merge,hash.
        :param _builtins.str join_overflow_mode: Sets behavior on overflow in JOIN. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool join_use_nulls: Sets the type of JOIN behavior. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        :param _builtins.bool joined_subquery_requires_alias: Require aliases for subselects and table functions in FROM that more than one table is present.
        :param _builtins.str load_balancing: Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        :param _builtins.str local_filesystem_read_method: Method of reading data from local filesystem. Possible values:
               * `read` - abort query execution, return an error.
               * `pread` - abort query execution, return an error.
               * `pread_threadpool` - stop query execution, return partial result. If the parameter is set to 0 (default), no hops is allowed.
        :param _builtins.bool log_processors_profiles: Enabled or disable logging of processors level profiling data to the the system.log_processors_profiles table.
        :param _builtins.float log_queries_probability: Log queries with the specified probability.
        :param _builtins.bool log_query_threads: Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: `true`.
        :param _builtins.bool log_query_views: Enables or disables query views logging to the the system.query_views_log table.
        :param _builtins.bool low_cardinality_allow_in_native_format: Allows or restricts using the LowCardinality data type with the Native format.
        :param _builtins.int max_ast_depth: Maximum abstract syntax tree depth.
        :param _builtins.int max_ast_elements: Maximum abstract syntax tree elements.
        :param _builtins.int max_block_size: A recommendation for what size of the block (in a count of rows) to load from tables.
        :param _builtins.int max_bytes_before_external_group_by: Limit in bytes for using memory for GROUP BY before using swap on disk.
        :param _builtins.int max_bytes_before_external_sort: This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        :param _builtins.int max_bytes_in_distinct: Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        :param _builtins.int max_bytes_in_join: Limit on maximum size of the hash table for JOIN, in bytes.
        :param _builtins.int max_bytes_in_set: Limit on the number of bytes in the set resulting from the execution of the IN section.
        :param _builtins.int max_bytes_to_read: Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        :param _builtins.int max_bytes_to_sort: Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        :param _builtins.int max_bytes_to_transfer: Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param _builtins.int max_columns_to_read: Limits the maximum number of columns that can be read from a table in a single query.
        :param _builtins.int max_concurrent_queries_for_user: The maximum number of concurrent requests per user. Default value: 0 (no limit).
        :param _builtins.int max_execution_time: Limits the maximum query execution time in milliseconds.
        :param _builtins.int max_expanded_ast_elements: Maximum abstract syntax tree depth after after expansion of aliases.
        :param _builtins.int max_final_threads: Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        :param _builtins.int max_http_get_redirects: Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        :param _builtins.int max_insert_block_size: The size of blocks (in a count of rows) to form for insertion into a table.
        :param _builtins.int max_insert_threads: The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        :param _builtins.int max_memory_usage: Limits the maximum memory usage (in bytes) for processing queries on a single server.
        :param _builtins.int max_memory_usage_for_user: Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        :param _builtins.int max_network_bandwidth: Limits the speed of the data exchange over the network in bytes per second.
        :param _builtins.int max_network_bandwidth_for_user: Limits the speed of the data exchange over the network in bytes per second.
        :param _builtins.int max_parser_depth: Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        :param _builtins.int max_query_size: The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        :param _builtins.int max_read_buffer_size: The maximum size of the buffer to read from the filesystem.
        :param _builtins.int max_replica_delay_for_distributed_queries: Disables lagging replicas for distributed queries.
        :param _builtins.int max_result_bytes: Limits the number of bytes in the result.
        :param _builtins.int max_result_rows: Limits the number of rows in the result.
        :param _builtins.int max_rows_in_distinct: Limits the maximum number of different rows when using DISTINCT.
        :param _builtins.int max_rows_in_join: Limit on maximum size of the hash table for JOIN, in rows.
        :param _builtins.int max_rows_in_set: Limit on the number of rows in the set resulting from the execution of the IN section.
        :param _builtins.int max_rows_to_group_by: Limits the maximum number of unique keys received from aggregation function.
        :param _builtins.int max_rows_to_read: Limits the maximum number of rows that can be read from a table when running a query.
        :param _builtins.int max_rows_to_sort: Limits the maximum number of rows that can be read from a table for sorting.
        :param _builtins.int max_rows_to_transfer: Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        :param _builtins.int max_temporary_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        :param _builtins.int max_temporary_data_on_disk_size_for_query: The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        :param _builtins.int max_temporary_data_on_disk_size_for_user: The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        :param _builtins.int max_temporary_non_const_columns: Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        :param _builtins.int max_threads: The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        :param _builtins.int memory_overcommit_ratio_denominator: It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param _builtins.int memory_overcommit_ratio_denominator_for_user: It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        :param _builtins.float memory_profiler_sample_probability: Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        :param _builtins.int memory_profiler_step: Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        :param _builtins.int memory_usage_overcommit_max_wait_microseconds: Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        :param _builtins.int merge_tree_max_bytes_to_use_cache: If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        :param _builtins.int merge_tree_max_rows_to_use_cache: If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        :param _builtins.int merge_tree_min_bytes_for_concurrent_read: If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        :param _builtins.int merge_tree_min_rows_for_concurrent_read: If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        :param _builtins.int min_bytes_to_use_direct_io: The minimum data volume required for using direct I/O access to the storage disk.
        :param _builtins.int min_count_to_compile: How many times to potentially use a compiled chunk of code before running compilation.
        :param _builtins.int min_count_to_compile_expression: A query waits for expression compilation process to complete prior to continuing execution.
        :param _builtins.int min_execution_speed: Minimal execution speed in rows per second.
        :param _builtins.int min_execution_speed_bytes: Minimal execution speed in bytes per second.
        :param _builtins.int min_insert_block_size_bytes: Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        :param _builtins.int min_insert_block_size_rows: Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        :param _builtins.bool output_format_json_quote64bit_integers: If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        :param _builtins.bool output_format_json_quote_denormals: Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        :param _builtins.bool prefer_localhost_replica: Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        :param _builtins.int priority: Query priority.
        :param _builtins.int query_cache_max_entries: The maximum number of query results the current user may store in the query cache. 0 means unlimited.
        :param _builtins.int query_cache_max_size_in_bytes: The maximum amount of memory (in bytes) the current user may allocate in the query cache. 0 means unlimited.
        :param _builtins.int query_cache_min_query_duration: Minimum duration in milliseconds a query needs to run for its result to be stored in the query cache.
        :param _builtins.int query_cache_min_query_runs: Minimum number of times a SELECT query must run before its result is stored in the query cache.
        :param _builtins.bool query_cache_share_between_users: If turned on, the result of SELECT queries cached in the query cache can be read by other users. It is not recommended to enable this setting due to security reasons.
        :param _builtins.str query_cache_tag: A string which acts as a label for query cache entries. The same queries with different tags are considered different by the query cache.
        :param _builtins.int query_cache_ttl: After this time in seconds entries in the query cache become stale.
        :param _builtins.str quota_mode: Quota accounting mode.
        :param _builtins.str read_overflow_mode: Sets behavior on overflow while read. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.int readonly: Restricts permissions for reading data, write data and change settings queries.
        :param _builtins.int receive_timeout: Receive timeout in milliseconds on the socket used for communicating with the client.
        :param _builtins.str remote_filesystem_read_method: Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        :param _builtins.int replication_alter_partitions_sync: For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        :param _builtins.str result_overflow_mode: Sets behavior on overflow in result. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool s3_use_adaptive_timeouts: Enables or disables adaptive timeouts for S3 requests.
        :param _builtins.bool select_sequential_consistency: Enables or disables sequential consistency for SELECT queries.
        :param _builtins.bool send_progress_in_http_headers: Enables or disables `X-ClickHouse-Progress` HTTP response headers in clickhouse-server responses.
        :param _builtins.int send_timeout: Send timeout in milliseconds on the socket used for communicating with the client.
        :param _builtins.str set_overflow_mode: Sets behavior on overflow in the set resulting. Possible values:
                 * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool skip_unavailable_shards: Enables or disables silently skipping of unavailable shards.
        :param _builtins.str sort_overflow_mode: Sets behavior on overflow while sort. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.int timeout_before_checking_execution_speed: Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        :param _builtins.str timeout_overflow_mode: Sets behavior on overflow. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.str transfer_overflow_mode: Sets behavior on overflow. Possible values:
               * `throw` - abort query execution, return an error.
               * `break` - stop query execution, return partial result.
        :param _builtins.bool transform_null_in: Enables equality of NULL values for IN operator.
        :param _builtins.bool use_hedged_requests: Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        :param _builtins.bool use_query_cache: If turned on, SELECT queries may utilize the query cache.
        :param _builtins.bool use_uncompressed_cache: Whether to use a cache of uncompressed blocks.
        :param _builtins.bool wait_for_async_insert: Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        :param _builtins.int wait_for_async_insert_timeout: The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        pulumi.set(__self__, "add_http_cors_header", add_http_cors_header)
        pulumi.set(__self__, "allow_ddl", allow_ddl)
        pulumi.set(__self__, "allow_introspection_functions", allow_introspection_functions)
        pulumi.set(__self__, "allow_suspicious_low_cardinality_types", allow_suspicious_low_cardinality_types)
        pulumi.set(__self__, "any_join_distinct_right_table_keys", any_join_distinct_right_table_keys)
        pulumi.set(__self__, "async_insert", async_insert)
        pulumi.set(__self__, "async_insert_busy_timeout", async_insert_busy_timeout)
        pulumi.set(__self__, "async_insert_max_data_size", async_insert_max_data_size)
        pulumi.set(__self__, "async_insert_stale_timeout", async_insert_stale_timeout)
        pulumi.set(__self__, "async_insert_threads", async_insert_threads)
        pulumi.set(__self__, "async_insert_use_adaptive_busy_timeout", async_insert_use_adaptive_busy_timeout)
        pulumi.set(__self__, "cancel_http_readonly_queries_on_client_close", cancel_http_readonly_queries_on_client_close)
        pulumi.set(__self__, "compile", compile)
        pulumi.set(__self__, "compile_expressions", compile_expressions)
        pulumi.set(__self__, "connect_timeout", connect_timeout)
        pulumi.set(__self__, "connect_timeout_with_failover", connect_timeout_with_failover)
        pulumi.set(__self__, "count_distinct_implementation", count_distinct_implementation)
        pulumi.set(__self__, "data_type_default_nullable", data_type_default_nullable)
        pulumi.set(__self__, "date_time_input_format", date_time_input_format)
        pulumi.set(__self__, "date_time_output_format", date_time_output_format)
        pulumi.set(__self__, "deduplicate_blocks_in_dependent_materialized_views", deduplicate_blocks_in_dependent_materialized_views)
        pulumi.set(__self__, "distinct_overflow_mode", distinct_overflow_mode)
        pulumi.set(__self__, "distributed_aggregation_memory_efficient", distributed_aggregation_memory_efficient)
        pulumi.set(__self__, "distributed_ddl_task_timeout", distributed_ddl_task_timeout)
        pulumi.set(__self__, "distributed_product_mode", distributed_product_mode)
        pulumi.set(__self__, "do_not_merge_across_partitions_select_final", do_not_merge_across_partitions_select_final)
        pulumi.set(__self__, "empty_result_for_aggregation_by_empty_set", empty_result_for_aggregation_by_empty_set)
        pulumi.set(__self__, "enable_analyzer", enable_analyzer)
        pulumi.set(__self__, "enable_http_compression", enable_http_compression)
        pulumi.set(__self__, "enable_reads_from_query_cache", enable_reads_from_query_cache)
        pulumi.set(__self__, "enable_writes_to_query_cache", enable_writes_to_query_cache)
        pulumi.set(__self__, "fallback_to_stale_replicas_for_distributed_queries", fallback_to_stale_replicas_for_distributed_queries)
        pulumi.set(__self__, "flatten_nested", flatten_nested)
        pulumi.set(__self__, "force_index_by_date", force_index_by_date)
        pulumi.set(__self__, "force_primary_key", force_primary_key)
        pulumi.set(__self__, "format_avro_schema_registry_url", format_avro_schema_registry_url)
        pulumi.set(__self__, "format_regexp", format_regexp)
        pulumi.set(__self__, "format_regexp_skip_unmatched", format_regexp_skip_unmatched)
        pulumi.set(__self__, "group_by_overflow_mode", group_by_overflow_mode)
        pulumi.set(__self__, "group_by_two_level_threshold", group_by_two_level_threshold)
        pulumi.set(__self__, "group_by_two_level_threshold_bytes", group_by_two_level_threshold_bytes)
        pulumi.set(__self__, "hedged_connection_timeout_ms", hedged_connection_timeout_ms)
        pulumi.set(__self__, "http_connection_timeout", http_connection_timeout)
        pulumi.set(__self__, "http_headers_progress_interval", http_headers_progress_interval)
        pulumi.set(__self__, "http_max_field_name_size", http_max_field_name_size)
        pulumi.set(__self__, "http_max_field_value_size", http_max_field_value_size)
        pulumi.set(__self__, "http_receive_timeout", http_receive_timeout)
        pulumi.set(__self__, "http_send_timeout", http_send_timeout)
        pulumi.set(__self__, "idle_connection_timeout", idle_connection_timeout)
        pulumi.set(__self__, "ignore_materialized_views_with_dropped_target_table", ignore_materialized_views_with_dropped_target_table)
        pulumi.set(__self__, "input_format_defaults_for_omitted_fields", input_format_defaults_for_omitted_fields)
        pulumi.set(__self__, "input_format_import_nested_json", input_format_import_nested_json)
        pulumi.set(__self__, "input_format_null_as_default", input_format_null_as_default)
        pulumi.set(__self__, "input_format_parallel_parsing", input_format_parallel_parsing)
        pulumi.set(__self__, "input_format_values_interpret_expressions", input_format_values_interpret_expressions)
        pulumi.set(__self__, "input_format_with_names_use_header", input_format_with_names_use_header)
        pulumi.set(__self__, "insert_keeper_max_retries", insert_keeper_max_retries)
        pulumi.set(__self__, "insert_null_as_default", insert_null_as_default)
        pulumi.set(__self__, "insert_quorum", insert_quorum)
        pulumi.set(__self__, "insert_quorum_parallel", insert_quorum_parallel)
        pulumi.set(__self__, "insert_quorum_timeout", insert_quorum_timeout)
        pulumi.set(__self__, "join_algorithms", join_algorithms)
        pulumi.set(__self__, "join_overflow_mode", join_overflow_mode)
        pulumi.set(__self__, "join_use_nulls", join_use_nulls)
        pulumi.set(__self__, "joined_subquery_requires_alias", joined_subquery_requires_alias)
        pulumi.set(__self__, "load_balancing", load_balancing)
        pulumi.set(__self__, "local_filesystem_read_method", local_filesystem_read_method)
        pulumi.set(__self__, "log_processors_profiles", log_processors_profiles)
        pulumi.set(__self__, "log_queries_probability", log_queries_probability)
        pulumi.set(__self__, "log_query_threads", log_query_threads)
        pulumi.set(__self__, "log_query_views", log_query_views)
        pulumi.set(__self__, "low_cardinality_allow_in_native_format", low_cardinality_allow_in_native_format)
        pulumi.set(__self__, "max_ast_depth", max_ast_depth)
        pulumi.set(__self__, "max_ast_elements", max_ast_elements)
        pulumi.set(__self__, "max_block_size", max_block_size)
        pulumi.set(__self__, "max_bytes_before_external_group_by", max_bytes_before_external_group_by)
        pulumi.set(__self__, "max_bytes_before_external_sort", max_bytes_before_external_sort)
        pulumi.set(__self__, "max_bytes_in_distinct", max_bytes_in_distinct)
        pulumi.set(__self__, "max_bytes_in_join", max_bytes_in_join)
        pulumi.set(__self__, "max_bytes_in_set", max_bytes_in_set)
        pulumi.set(__self__, "max_bytes_to_read", max_bytes_to_read)
        pulumi.set(__self__, "max_bytes_to_sort", max_bytes_to_sort)
        pulumi.set(__self__, "max_bytes_to_transfer", max_bytes_to_transfer)
        pulumi.set(__self__, "max_columns_to_read", max_columns_to_read)
        pulumi.set(__self__, "max_concurrent_queries_for_user", max_concurrent_queries_for_user)
        pulumi.set(__self__, "max_execution_time", max_execution_time)
        pulumi.set(__self__, "max_expanded_ast_elements", max_expanded_ast_elements)
        pulumi.set(__self__, "max_final_threads", max_final_threads)
        pulumi.set(__self__, "max_http_get_redirects", max_http_get_redirects)
        pulumi.set(__self__, "max_insert_block_size", max_insert_block_size)
        pulumi.set(__self__, "max_insert_threads", max_insert_threads)
        pulumi.set(__self__, "max_memory_usage", max_memory_usage)
        pulumi.set(__self__, "max_memory_usage_for_user", max_memory_usage_for_user)
        pulumi.set(__self__, "max_network_bandwidth", max_network_bandwidth)
        pulumi.set(__self__, "max_network_bandwidth_for_user", max_network_bandwidth_for_user)
        pulumi.set(__self__, "max_parser_depth", max_parser_depth)
        pulumi.set(__self__, "max_query_size", max_query_size)
        pulumi.set(__self__, "max_read_buffer_size", max_read_buffer_size)
        pulumi.set(__self__, "max_replica_delay_for_distributed_queries", max_replica_delay_for_distributed_queries)
        pulumi.set(__self__, "max_result_bytes", max_result_bytes)
        pulumi.set(__self__, "max_result_rows", max_result_rows)
        pulumi.set(__self__, "max_rows_in_distinct", max_rows_in_distinct)
        pulumi.set(__self__, "max_rows_in_join", max_rows_in_join)
        pulumi.set(__self__, "max_rows_in_set", max_rows_in_set)
        pulumi.set(__self__, "max_rows_to_group_by", max_rows_to_group_by)
        pulumi.set(__self__, "max_rows_to_read", max_rows_to_read)
        pulumi.set(__self__, "max_rows_to_sort", max_rows_to_sort)
        pulumi.set(__self__, "max_rows_to_transfer", max_rows_to_transfer)
        pulumi.set(__self__, "max_temporary_columns", max_temporary_columns)
        pulumi.set(__self__, "max_temporary_data_on_disk_size_for_query", max_temporary_data_on_disk_size_for_query)
        pulumi.set(__self__, "max_temporary_data_on_disk_size_for_user", max_temporary_data_on_disk_size_for_user)
        pulumi.set(__self__, "max_temporary_non_const_columns", max_temporary_non_const_columns)
        pulumi.set(__self__, "max_threads", max_threads)
        pulumi.set(__self__, "memory_overcommit_ratio_denominator", memory_overcommit_ratio_denominator)
        pulumi.set(__self__, "memory_overcommit_ratio_denominator_for_user", memory_overcommit_ratio_denominator_for_user)
        pulumi.set(__self__, "memory_profiler_sample_probability", memory_profiler_sample_probability)
        pulumi.set(__self__, "memory_profiler_step", memory_profiler_step)
        pulumi.set(__self__, "memory_usage_overcommit_max_wait_microseconds", memory_usage_overcommit_max_wait_microseconds)
        pulumi.set(__self__, "merge_tree_max_bytes_to_use_cache", merge_tree_max_bytes_to_use_cache)
        pulumi.set(__self__, "merge_tree_max_rows_to_use_cache", merge_tree_max_rows_to_use_cache)
        pulumi.set(__self__, "merge_tree_min_bytes_for_concurrent_read", merge_tree_min_bytes_for_concurrent_read)
        pulumi.set(__self__, "merge_tree_min_rows_for_concurrent_read", merge_tree_min_rows_for_concurrent_read)
        pulumi.set(__self__, "min_bytes_to_use_direct_io", min_bytes_to_use_direct_io)
        pulumi.set(__self__, "min_count_to_compile", min_count_to_compile)
        pulumi.set(__self__, "min_count_to_compile_expression", min_count_to_compile_expression)
        pulumi.set(__self__, "min_execution_speed", min_execution_speed)
        pulumi.set(__self__, "min_execution_speed_bytes", min_execution_speed_bytes)
        pulumi.set(__self__, "min_insert_block_size_bytes", min_insert_block_size_bytes)
        pulumi.set(__self__, "min_insert_block_size_rows", min_insert_block_size_rows)
        pulumi.set(__self__, "output_format_json_quote64bit_integers", output_format_json_quote64bit_integers)
        pulumi.set(__self__, "output_format_json_quote_denormals", output_format_json_quote_denormals)
        pulumi.set(__self__, "prefer_localhost_replica", prefer_localhost_replica)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "query_cache_max_entries", query_cache_max_entries)
        pulumi.set(__self__, "query_cache_max_size_in_bytes", query_cache_max_size_in_bytes)
        pulumi.set(__self__, "query_cache_min_query_duration", query_cache_min_query_duration)
        pulumi.set(__self__, "query_cache_min_query_runs", query_cache_min_query_runs)
        pulumi.set(__self__, "query_cache_share_between_users", query_cache_share_between_users)
        pulumi.set(__self__, "query_cache_tag", query_cache_tag)
        pulumi.set(__self__, "query_cache_ttl", query_cache_ttl)
        pulumi.set(__self__, "quota_mode", quota_mode)
        pulumi.set(__self__, "read_overflow_mode", read_overflow_mode)
        pulumi.set(__self__, "readonly", readonly)
        pulumi.set(__self__, "receive_timeout", receive_timeout)
        pulumi.set(__self__, "remote_filesystem_read_method", remote_filesystem_read_method)
        pulumi.set(__self__, "replication_alter_partitions_sync", replication_alter_partitions_sync)
        pulumi.set(__self__, "result_overflow_mode", result_overflow_mode)
        pulumi.set(__self__, "s3_use_adaptive_timeouts", s3_use_adaptive_timeouts)
        pulumi.set(__self__, "select_sequential_consistency", select_sequential_consistency)
        pulumi.set(__self__, "send_progress_in_http_headers", send_progress_in_http_headers)
        pulumi.set(__self__, "send_timeout", send_timeout)
        pulumi.set(__self__, "set_overflow_mode", set_overflow_mode)
        pulumi.set(__self__, "skip_unavailable_shards", skip_unavailable_shards)
        pulumi.set(__self__, "sort_overflow_mode", sort_overflow_mode)
        pulumi.set(__self__, "timeout_before_checking_execution_speed", timeout_before_checking_execution_speed)
        pulumi.set(__self__, "timeout_overflow_mode", timeout_overflow_mode)
        pulumi.set(__self__, "transfer_overflow_mode", transfer_overflow_mode)
        pulumi.set(__self__, "transform_null_in", transform_null_in)
        pulumi.set(__self__, "use_hedged_requests", use_hedged_requests)
        pulumi.set(__self__, "use_query_cache", use_query_cache)
        pulumi.set(__self__, "use_uncompressed_cache", use_uncompressed_cache)
        pulumi.set(__self__, "wait_for_async_insert", wait_for_async_insert)
        pulumi.set(__self__, "wait_for_async_insert_timeout", wait_for_async_insert_timeout)

    @_builtins.property
    @pulumi.getter(name="addHttpCorsHeader")
    def add_http_cors_header(self) -> _builtins.bool:
        """
        Include CORS headers in HTTP responses.
        """
        return pulumi.get(self, "add_http_cors_header")

    @_builtins.property
    @pulumi.getter(name="allowDdl")
    def allow_ddl(self) -> _builtins.bool:
        """
        Allows or denies DDL queries.
        """
        return pulumi.get(self, "allow_ddl")

    @_builtins.property
    @pulumi.getter(name="allowIntrospectionFunctions")
    def allow_introspection_functions(self) -> _builtins.bool:
        """
        Enables introspections functions for query profiling.
        """
        return pulumi.get(self, "allow_introspection_functions")

    @_builtins.property
    @pulumi.getter(name="allowSuspiciousLowCardinalityTypes")
    def allow_suspicious_low_cardinality_types(self) -> _builtins.bool:
        """
        Allows specifying LowCardinality modifier for types of small fixed size (8 or less) in CREATE TABLE statements. Enabling this may increase merge times and memory consumption.
        """
        return pulumi.get(self, "allow_suspicious_low_cardinality_types")

    @_builtins.property
    @pulumi.getter(name="anyJoinDistinctRightTableKeys")
    def any_join_distinct_right_table_keys(self) -> _builtins.bool:
        """
        Enables legacy ClickHouse server behavior in ANY INNER|LEFT JOIN operations.
        """
        return pulumi.get(self, "any_join_distinct_right_table_keys")

    @_builtins.property
    @pulumi.getter(name="asyncInsert")
    def async_insert(self) -> _builtins.bool:
        """
        Enables asynchronous inserts. Disabled by default.
        """
        return pulumi.get(self, "async_insert")

    @_builtins.property
    @pulumi.getter(name="asyncInsertBusyTimeout")
    def async_insert_busy_timeout(self) -> _builtins.int:
        """
        The maximum timeout in milliseconds since the first INSERT query before inserting collected data. If the parameter is set to 0, the timeout is disabled. Default value: 200.
        """
        return pulumi.get(self, "async_insert_busy_timeout")

    @_builtins.property
    @pulumi.getter(name="asyncInsertMaxDataSize")
    def async_insert_max_data_size(self) -> _builtins.int:
        """
        The maximum size of the unparsed data in bytes collected per query before being inserted. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 100000.
        """
        return pulumi.get(self, "async_insert_max_data_size")

    @_builtins.property
    @pulumi.getter(name="asyncInsertStaleTimeout")
    def async_insert_stale_timeout(self) -> _builtins.int:
        """
        The maximum timeout in milliseconds since the last INSERT query before dumping collected data. If enabled, the settings prolongs the async_insert_busy_timeout with every INSERT query as long as async_insert_max_data_size is not exceeded.
        """
        return pulumi.get(self, "async_insert_stale_timeout")

    @_builtins.property
    @pulumi.getter(name="asyncInsertThreads")
    def async_insert_threads(self) -> _builtins.int:
        """
        The maximum number of threads for background data parsing and insertion. If the parameter is set to 0, asynchronous insertions are disabled. Default value: 16.
        """
        return pulumi.get(self, "async_insert_threads")

    @_builtins.property
    @pulumi.getter(name="asyncInsertUseAdaptiveBusyTimeout")
    def async_insert_use_adaptive_busy_timeout(self) -> _builtins.bool:
        """
        If it is set to true, use adaptive busy timeout for asynchronous inserts.
        """
        return pulumi.get(self, "async_insert_use_adaptive_busy_timeout")

    @_builtins.property
    @pulumi.getter(name="cancelHttpReadonlyQueriesOnClientClose")
    def cancel_http_readonly_queries_on_client_close(self) -> _builtins.bool:
        """
        Cancels HTTP read-only queries (e.g. SELECT) when a client closes the connection without waiting for the response. Default value: false.
        """
        return pulumi.get(self, "cancel_http_readonly_queries_on_client_close")

    @_builtins.property
    @pulumi.getter
    def compile(self) -> _builtins.bool:
        """
        Enable compilation of queries.
        """
        return pulumi.get(self, "compile")

    @_builtins.property
    @pulumi.getter(name="compileExpressions")
    def compile_expressions(self) -> _builtins.bool:
        """
        Turn on expression compilation.
        """
        return pulumi.get(self, "compile_expressions")

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> _builtins.int:
        """
        Connect timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "connect_timeout")

    @_builtins.property
    @pulumi.getter(name="connectTimeoutWithFailover")
    def connect_timeout_with_failover(self) -> _builtins.int:
        """
        The timeout in milliseconds for connecting to a remote server for a Distributed table engine, if the shard and replica sections are used in the cluster definition. If unsuccessful, several attempts are made to connect to various replicas. Default value: 50.
        """
        return pulumi.get(self, "connect_timeout_with_failover")

    @_builtins.property
    @pulumi.getter(name="countDistinctImplementation")
    def count_distinct_implementation(self) -> _builtins.str:
        """
        Specifies which of the uniq* functions should be used to perform the COUNT(DISTINCT ) construction.
        """
        return pulumi.get(self, "count_distinct_implementation")

    @_builtins.property
    @pulumi.getter(name="dataTypeDefaultNullable")
    def data_type_default_nullable(self) -> _builtins.bool:
        """
        Allows data types without explicit modifiers NULL or NOT NULL in column definition will be Nullable.
        """
        return pulumi.get(self, "data_type_default_nullable")

    @_builtins.property
    @pulumi.getter(name="dateTimeInputFormat")
    def date_time_input_format(self) -> _builtins.str:
        """
        Allows choosing a parser of the text representation of date and time, one of: `best_effort`, `basic`, `best_effort_us`. Default value: `basic`. Cloud default value: `best_effort`.
        """
        return pulumi.get(self, "date_time_input_format")

    @_builtins.property
    @pulumi.getter(name="dateTimeOutputFormat")
    def date_time_output_format(self) -> _builtins.str:
        """
        Allows choosing different output formats of the text representation of date and time, one of: `simple`, `iso`, `unix_timestamp`. Default value: `simple`.
        """
        return pulumi.get(self, "date_time_output_format")

    @_builtins.property
    @pulumi.getter(name="deduplicateBlocksInDependentMaterializedViews")
    def deduplicate_blocks_in_dependent_materialized_views(self) -> _builtins.bool:
        """
        Enables or disables the deduplication check for materialized views that receive data from `Replicated` tables.
        """
        return pulumi.get(self, "deduplicate_blocks_in_dependent_materialized_views")

    @_builtins.property
    @pulumi.getter(name="distinctOverflowMode")
    def distinct_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow when using DISTINCT. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "distinct_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="distributedAggregationMemoryEfficient")
    def distributed_aggregation_memory_efficient(self) -> _builtins.bool:
        """
        Determine the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_aggregation_memory_efficient")

    @_builtins.property
    @pulumi.getter(name="distributedDdlTaskTimeout")
    def distributed_ddl_task_timeout(self) -> _builtins.int:
        """
        Timeout for DDL queries, in milliseconds.
        """
        return pulumi.get(self, "distributed_ddl_task_timeout")

    @_builtins.property
    @pulumi.getter(name="distributedProductMode")
    def distributed_product_mode(self) -> _builtins.str:
        """
        Changes the behavior of distributed subqueries.
        """
        return pulumi.get(self, "distributed_product_mode")

    @_builtins.property
    @pulumi.getter(name="doNotMergeAcrossPartitionsSelectFinal")
    def do_not_merge_across_partitions_select_final(self) -> _builtins.bool:
        """
        Enable or disable independent processing of partitions for **SELECT** queries with **FINAL**.
        """
        return pulumi.get(self, "do_not_merge_across_partitions_select_final")

    @_builtins.property
    @pulumi.getter(name="emptyResultForAggregationByEmptySet")
    def empty_result_for_aggregation_by_empty_set(self) -> _builtins.bool:
        """
        Allows to return empty result.
        """
        return pulumi.get(self, "empty_result_for_aggregation_by_empty_set")

    @_builtins.property
    @pulumi.getter(name="enableAnalyzer")
    def enable_analyzer(self) -> _builtins.bool:
        """
        Enable new query analyzer.
        """
        return pulumi.get(self, "enable_analyzer")

    @_builtins.property
    @pulumi.getter(name="enableHttpCompression")
    def enable_http_compression(self) -> _builtins.bool:
        """
        Enables or disables data compression in the response to an HTTP request.
        """
        return pulumi.get(self, "enable_http_compression")

    @_builtins.property
    @pulumi.getter(name="enableReadsFromQueryCache")
    def enable_reads_from_query_cache(self) -> _builtins.bool:
        """
        If turned on, results of SELECT queries are retrieved from the query cache.
        """
        return pulumi.get(self, "enable_reads_from_query_cache")

    @_builtins.property
    @pulumi.getter(name="enableWritesToQueryCache")
    def enable_writes_to_query_cache(self) -> _builtins.bool:
        """
        If turned on, results of SELECT queries are stored in the query cache.
        """
        return pulumi.get(self, "enable_writes_to_query_cache")

    @_builtins.property
    @pulumi.getter(name="fallbackToStaleReplicasForDistributedQueries")
    def fallback_to_stale_replicas_for_distributed_queries(self) -> _builtins.bool:
        """
        Forces a query to an out-of-date replica if updated data is not available.
        """
        return pulumi.get(self, "fallback_to_stale_replicas_for_distributed_queries")

    @_builtins.property
    @pulumi.getter(name="flattenNested")
    def flatten_nested(self) -> _builtins.bool:
        """
        Sets the data format of a nested columns.
        """
        return pulumi.get(self, "flatten_nested")

    @_builtins.property
    @pulumi.getter(name="forceIndexByDate")
    def force_index_by_date(self) -> _builtins.bool:
        """
        Disables query execution if the index cant be used by date.
        """
        return pulumi.get(self, "force_index_by_date")

    @_builtins.property
    @pulumi.getter(name="forcePrimaryKey")
    def force_primary_key(self) -> _builtins.bool:
        """
        Disables query execution if indexing by the primary key is not possible.
        """
        return pulumi.get(self, "force_primary_key")

    @_builtins.property
    @pulumi.getter(name="formatAvroSchemaRegistryUrl")
    def format_avro_schema_registry_url(self) -> _builtins.str:
        """
        Avro schema registry URL.
        """
        return pulumi.get(self, "format_avro_schema_registry_url")

    @_builtins.property
    @pulumi.getter(name="formatRegexp")
    def format_regexp(self) -> _builtins.str:
        """
        Regular expression (for Regexp format).
        """
        return pulumi.get(self, "format_regexp")

    @_builtins.property
    @pulumi.getter(name="formatRegexpSkipUnmatched")
    def format_regexp_skip_unmatched(self) -> _builtins.bool:
        """
        Skip lines unmatched by regular expression.
        """
        return pulumi.get(self, "format_regexp_skip_unmatched")

    @_builtins.property
    @pulumi.getter(name="groupByOverflowMode")
    def group_by_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow while GROUP BY operation. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        * `any` - perform approximate GROUP BY operation by continuing aggregation for the keys that got into the set, but dont add new keys to the set.
        """
        return pulumi.get(self, "group_by_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="groupByTwoLevelThreshold")
    def group_by_two_level_threshold(self) -> _builtins.int:
        """
        Sets the threshold of the number of keys, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold")

    @_builtins.property
    @pulumi.getter(name="groupByTwoLevelThresholdBytes")
    def group_by_two_level_threshold_bytes(self) -> _builtins.int:
        """
        Sets the threshold of the number of bytes, after that the two-level aggregation should be used.
        """
        return pulumi.get(self, "group_by_two_level_threshold_bytes")

    @_builtins.property
    @pulumi.getter(name="hedgedConnectionTimeoutMs")
    def hedged_connection_timeout_ms(self) -> _builtins.int:
        """
        Connection timeout for establishing connection with replica for Hedged requests. Default value: 50 milliseconds.
        """
        return pulumi.get(self, "hedged_connection_timeout_ms")

    @_builtins.property
    @pulumi.getter(name="httpConnectionTimeout")
    def http_connection_timeout(self) -> _builtins.int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_connection_timeout")

    @_builtins.property
    @pulumi.getter(name="httpHeadersProgressInterval")
    def http_headers_progress_interval(self) -> _builtins.int:
        """
        Sets minimal interval between notifications about request process in HTTP header X-ClickHouse-Progress.
        """
        return pulumi.get(self, "http_headers_progress_interval")

    @_builtins.property
    @pulumi.getter(name="httpMaxFieldNameSize")
    def http_max_field_name_size(self) -> _builtins.int:
        """
        Maximum length of field name in HTTP header.
        """
        return pulumi.get(self, "http_max_field_name_size")

    @_builtins.property
    @pulumi.getter(name="httpMaxFieldValueSize")
    def http_max_field_value_size(self) -> _builtins.int:
        """
        Maximum length of field value in HTTP header.
        """
        return pulumi.get(self, "http_max_field_value_size")

    @_builtins.property
    @pulumi.getter(name="httpReceiveTimeout")
    def http_receive_timeout(self) -> _builtins.int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_receive_timeout")

    @_builtins.property
    @pulumi.getter(name="httpSendTimeout")
    def http_send_timeout(self) -> _builtins.int:
        """
        Timeout for HTTP connection in milliseconds.
        """
        return pulumi.get(self, "http_send_timeout")

    @_builtins.property
    @pulumi.getter(name="idleConnectionTimeout")
    def idle_connection_timeout(self) -> _builtins.int:
        """
        Timeout to close idle TCP connections after specified number of seconds. Default value: 3600 seconds.
        """
        return pulumi.get(self, "idle_connection_timeout")

    @_builtins.property
    @pulumi.getter(name="ignoreMaterializedViewsWithDroppedTargetTable")
    def ignore_materialized_views_with_dropped_target_table(self) -> _builtins.bool:
        """
        Ignore materialized views with dropped target table during pushing to views.
        """
        return pulumi.get(self, "ignore_materialized_views_with_dropped_target_table")

    @_builtins.property
    @pulumi.getter(name="inputFormatDefaultsForOmittedFields")
    def input_format_defaults_for_omitted_fields(self) -> _builtins.bool:
        """
        When performing INSERT queries, replace omitted input column values with default values of the respective columns.
        """
        return pulumi.get(self, "input_format_defaults_for_omitted_fields")

    @_builtins.property
    @pulumi.getter(name="inputFormatImportNestedJson")
    def input_format_import_nested_json(self) -> _builtins.bool:
        """
        Enables or disables the insertion of JSON data with nested objects.
        """
        return pulumi.get(self, "input_format_import_nested_json")

    @_builtins.property
    @pulumi.getter(name="inputFormatNullAsDefault")
    def input_format_null_as_default(self) -> _builtins.bool:
        """
        Enables or disables the initialization of NULL fields with default values, if data type of these fields is not nullable.
        """
        return pulumi.get(self, "input_format_null_as_default")

    @_builtins.property
    @pulumi.getter(name="inputFormatParallelParsing")
    def input_format_parallel_parsing(self) -> _builtins.bool:
        """
        Enables or disables order-preserving parallel parsing of data formats. Supported only for TSV, TKSV, CSV and JSONEachRow formats.
        """
        return pulumi.get(self, "input_format_parallel_parsing")

    @_builtins.property
    @pulumi.getter(name="inputFormatValuesInterpretExpressions")
    def input_format_values_interpret_expressions(self) -> _builtins.bool:
        """
        Enables or disables the full SQL parser if the fast stream parser cant parse the data.
        """
        return pulumi.get(self, "input_format_values_interpret_expressions")

    @_builtins.property
    @pulumi.getter(name="inputFormatWithNamesUseHeader")
    def input_format_with_names_use_header(self) -> _builtins.bool:
        """
        Enables or disables checking the column order when inserting data.
        """
        return pulumi.get(self, "input_format_with_names_use_header")

    @_builtins.property
    @pulumi.getter(name="insertKeeperMaxRetries")
    def insert_keeper_max_retries(self) -> _builtins.int:
        """
        The setting sets the maximum number of retries for ClickHouse Keeper (or ZooKeeper) requests during insert into replicated MergeTree. Only Keeper requests which failed due to network error, Keeper session timeout, or request timeout are considered for retries.
        """
        return pulumi.get(self, "insert_keeper_max_retries")

    @_builtins.property
    @pulumi.getter(name="insertNullAsDefault")
    def insert_null_as_default(self) -> _builtins.bool:
        """
        Enables the insertion of default values instead of NULL into columns with not nullable data type. Default value: true.
        """
        return pulumi.get(self, "insert_null_as_default")

    @_builtins.property
    @pulumi.getter(name="insertQuorum")
    def insert_quorum(self) -> _builtins.int:
        """
        Enables the quorum writes.
        """
        return pulumi.get(self, "insert_quorum")

    @_builtins.property
    @pulumi.getter(name="insertQuorumParallel")
    def insert_quorum_parallel(self) -> _builtins.bool:
        """
        Enables or disables parallelism for quorum INSERT queries.
        """
        return pulumi.get(self, "insert_quorum_parallel")

    @_builtins.property
    @pulumi.getter(name="insertQuorumTimeout")
    def insert_quorum_timeout(self) -> _builtins.int:
        """
        Write to a quorum timeout in milliseconds.
        """
        return pulumi.get(self, "insert_quorum_timeout")

    @_builtins.property
    @pulumi.getter(name="joinAlgorithms")
    def join_algorithms(self) -> Sequence[_builtins.str]:
        """
        Specifies which JOIN algorithm is used. Possible values:
        * `hash` - hash join algorithm is used. The most generic implementation that supports all combinations of kind and strictness and multiple join keys that are combined with OR in the JOIN ON section.
        * `parallel_hash` - a variation of hash join that splits the data into buckets and builds several hash tables instead of one concurrently to speed up this process.
        * `partial_merge` - a variation of the sort-merge algorithm, where only the right table is fully sorted.
        * `direct` - this algorithm can be applied when the storage for the right table supports key-value requests.
        * `auto` - when set to auto, hash join is tried first, and the algorithm is switched on the fly to another algorithm if the memory limit is violated.
        * `full_sorting_merge` - sort-merge algorithm with full sorting joined tables before joining.
        * `prefer_partial_merge` - clickHouse always tries to use partial_merge join if possible, otherwise, it uses hash. Deprecated, same as partial_merge,hash.
        """
        return pulumi.get(self, "join_algorithms")

    @_builtins.property
    @pulumi.getter(name="joinOverflowMode")
    def join_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow in JOIN. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "join_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="joinUseNulls")
    def join_use_nulls(self) -> _builtins.bool:
        """
        Sets the type of JOIN behavior. When merging tables, empty cells may appear. ClickHouse fills them differently based on this setting.
        """
        return pulumi.get(self, "join_use_nulls")

    @_builtins.property
    @pulumi.getter(name="joinedSubqueryRequiresAlias")
    def joined_subquery_requires_alias(self) -> _builtins.bool:
        """
        Require aliases for subselects and table functions in FROM that more than one table is present.
        """
        return pulumi.get(self, "joined_subquery_requires_alias")

    @_builtins.property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> _builtins.str:
        """
        Specifies the algorithm of replicas selection that is used for distributed query processing, one of: random, nearest_hostname, in_order, first_or_random, round_robin. Default value: random.
        """
        return pulumi.get(self, "load_balancing")

    @_builtins.property
    @pulumi.getter(name="localFilesystemReadMethod")
    def local_filesystem_read_method(self) -> _builtins.str:
        """
        Method of reading data from local filesystem. Possible values:
        * `read` - abort query execution, return an error.
        * `pread` - abort query execution, return an error.
        * `pread_threadpool` - stop query execution, return partial result. If the parameter is set to 0 (default), no hops is allowed.
        """
        return pulumi.get(self, "local_filesystem_read_method")

    @_builtins.property
    @pulumi.getter(name="logProcessorsProfiles")
    def log_processors_profiles(self) -> _builtins.bool:
        """
        Enabled or disable logging of processors level profiling data to the the system.log_processors_profiles table.
        """
        return pulumi.get(self, "log_processors_profiles")

    @_builtins.property
    @pulumi.getter(name="logQueriesProbability")
    def log_queries_probability(self) -> _builtins.float:
        """
        Log queries with the specified probability.
        """
        return pulumi.get(self, "log_queries_probability")

    @_builtins.property
    @pulumi.getter(name="logQueryThreads")
    def log_query_threads(self) -> _builtins.bool:
        """
        Setting up query threads logging. Query threads log into the system.query_thread_log table. This setting has effect only when log_queries is true. Queries threads run by ClickHouse with this setup are logged according to the rules in the query_thread_log server configuration parameter. Default value: `true`.
        """
        return pulumi.get(self, "log_query_threads")

    @_builtins.property
    @pulumi.getter(name="logQueryViews")
    def log_query_views(self) -> _builtins.bool:
        """
        Enables or disables query views logging to the the system.query_views_log table.
        """
        return pulumi.get(self, "log_query_views")

    @_builtins.property
    @pulumi.getter(name="lowCardinalityAllowInNativeFormat")
    def low_cardinality_allow_in_native_format(self) -> _builtins.bool:
        """
        Allows or restricts using the LowCardinality data type with the Native format.
        """
        return pulumi.get(self, "low_cardinality_allow_in_native_format")

    @_builtins.property
    @pulumi.getter(name="maxAstDepth")
    def max_ast_depth(self) -> _builtins.int:
        """
        Maximum abstract syntax tree depth.
        """
        return pulumi.get(self, "max_ast_depth")

    @_builtins.property
    @pulumi.getter(name="maxAstElements")
    def max_ast_elements(self) -> _builtins.int:
        """
        Maximum abstract syntax tree elements.
        """
        return pulumi.get(self, "max_ast_elements")

    @_builtins.property
    @pulumi.getter(name="maxBlockSize")
    def max_block_size(self) -> _builtins.int:
        """
        A recommendation for what size of the block (in a count of rows) to load from tables.
        """
        return pulumi.get(self, "max_block_size")

    @_builtins.property
    @pulumi.getter(name="maxBytesBeforeExternalGroupBy")
    def max_bytes_before_external_group_by(self) -> _builtins.int:
        """
        Limit in bytes for using memory for GROUP BY before using swap on disk.
        """
        return pulumi.get(self, "max_bytes_before_external_group_by")

    @_builtins.property
    @pulumi.getter(name="maxBytesBeforeExternalSort")
    def max_bytes_before_external_sort(self) -> _builtins.int:
        """
        This setting is equivalent of the max_bytes_before_external_group_by setting, except for it is for sort operation (ORDER BY), not aggregation.
        """
        return pulumi.get(self, "max_bytes_before_external_sort")

    @_builtins.property
    @pulumi.getter(name="maxBytesInDistinct")
    def max_bytes_in_distinct(self) -> _builtins.int:
        """
        Limits the maximum size of a hash table in bytes (uncompressed data) when using DISTINCT.
        """
        return pulumi.get(self, "max_bytes_in_distinct")

    @_builtins.property
    @pulumi.getter(name="maxBytesInJoin")
    def max_bytes_in_join(self) -> _builtins.int:
        """
        Limit on maximum size of the hash table for JOIN, in bytes.
        """
        return pulumi.get(self, "max_bytes_in_join")

    @_builtins.property
    @pulumi.getter(name="maxBytesInSet")
    def max_bytes_in_set(self) -> _builtins.int:
        """
        Limit on the number of bytes in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_bytes_in_set")

    @_builtins.property
    @pulumi.getter(name="maxBytesToRead")
    def max_bytes_to_read(self) -> _builtins.int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_bytes_to_read")

    @_builtins.property
    @pulumi.getter(name="maxBytesToSort")
    def max_bytes_to_sort(self) -> _builtins.int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_bytes_to_sort")

    @_builtins.property
    @pulumi.getter(name="maxBytesToTransfer")
    def max_bytes_to_transfer(self) -> _builtins.int:
        """
        Limits the maximum number of bytes (uncompressed data) that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_bytes_to_transfer")

    @_builtins.property
    @pulumi.getter(name="maxColumnsToRead")
    def max_columns_to_read(self) -> _builtins.int:
        """
        Limits the maximum number of columns that can be read from a table in a single query.
        """
        return pulumi.get(self, "max_columns_to_read")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentQueriesForUser")
    def max_concurrent_queries_for_user(self) -> _builtins.int:
        """
        The maximum number of concurrent requests per user. Default value: 0 (no limit).
        """
        return pulumi.get(self, "max_concurrent_queries_for_user")

    @_builtins.property
    @pulumi.getter(name="maxExecutionTime")
    def max_execution_time(self) -> _builtins.int:
        """
        Limits the maximum query execution time in milliseconds.
        """
        return pulumi.get(self, "max_execution_time")

    @_builtins.property
    @pulumi.getter(name="maxExpandedAstElements")
    def max_expanded_ast_elements(self) -> _builtins.int:
        """
        Maximum abstract syntax tree depth after after expansion of aliases.
        """
        return pulumi.get(self, "max_expanded_ast_elements")

    @_builtins.property
    @pulumi.getter(name="maxFinalThreads")
    def max_final_threads(self) -> _builtins.int:
        """
        Sets the maximum number of parallel threads for the SELECT query data read phase with the FINAL modifier.
        """
        return pulumi.get(self, "max_final_threads")

    @_builtins.property
    @pulumi.getter(name="maxHttpGetRedirects")
    def max_http_get_redirects(self) -> _builtins.int:
        """
        Limits the maximum number of HTTP GET redirect hops for URL-engine tables.
        """
        return pulumi.get(self, "max_http_get_redirects")

    @_builtins.property
    @pulumi.getter(name="maxInsertBlockSize")
    def max_insert_block_size(self) -> _builtins.int:
        """
        The size of blocks (in a count of rows) to form for insertion into a table.
        """
        return pulumi.get(self, "max_insert_block_size")

    @_builtins.property
    @pulumi.getter(name="maxInsertThreads")
    def max_insert_threads(self) -> _builtins.int:
        """
        The maximum number of threads to execute the INSERT SELECT query. Default value: 0.
        """
        return pulumi.get(self, "max_insert_threads")

    @_builtins.property
    @pulumi.getter(name="maxMemoryUsage")
    def max_memory_usage(self) -> _builtins.int:
        """
        Limits the maximum memory usage (in bytes) for processing queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage")

    @_builtins.property
    @pulumi.getter(name="maxMemoryUsageForUser")
    def max_memory_usage_for_user(self) -> _builtins.int:
        """
        Limits the maximum memory usage (in bytes) for processing of user's queries on a single server.
        """
        return pulumi.get(self, "max_memory_usage_for_user")

    @_builtins.property
    @pulumi.getter(name="maxNetworkBandwidth")
    def max_network_bandwidth(self) -> _builtins.int:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth")

    @_builtins.property
    @pulumi.getter(name="maxNetworkBandwidthForUser")
    def max_network_bandwidth_for_user(self) -> _builtins.int:
        """
        Limits the speed of the data exchange over the network in bytes per second.
        """
        return pulumi.get(self, "max_network_bandwidth_for_user")

    @_builtins.property
    @pulumi.getter(name="maxParserDepth")
    def max_parser_depth(self) -> _builtins.int:
        """
        Limits maximum recursion depth in the recursive descent parser. Allows controlling the stack size. Zero means unlimited.
        """
        return pulumi.get(self, "max_parser_depth")

    @_builtins.property
    @pulumi.getter(name="maxQuerySize")
    def max_query_size(self) -> _builtins.int:
        """
        The maximum part of a query that can be taken to RAM for parsing with the SQL parser.
        """
        return pulumi.get(self, "max_query_size")

    @_builtins.property
    @pulumi.getter(name="maxReadBufferSize")
    def max_read_buffer_size(self) -> _builtins.int:
        """
        The maximum size of the buffer to read from the filesystem.
        """
        return pulumi.get(self, "max_read_buffer_size")

    @_builtins.property
    @pulumi.getter(name="maxReplicaDelayForDistributedQueries")
    def max_replica_delay_for_distributed_queries(self) -> _builtins.int:
        """
        Disables lagging replicas for distributed queries.
        """
        return pulumi.get(self, "max_replica_delay_for_distributed_queries")

    @_builtins.property
    @pulumi.getter(name="maxResultBytes")
    def max_result_bytes(self) -> _builtins.int:
        """
        Limits the number of bytes in the result.
        """
        return pulumi.get(self, "max_result_bytes")

    @_builtins.property
    @pulumi.getter(name="maxResultRows")
    def max_result_rows(self) -> _builtins.int:
        """
        Limits the number of rows in the result.
        """
        return pulumi.get(self, "max_result_rows")

    @_builtins.property
    @pulumi.getter(name="maxRowsInDistinct")
    def max_rows_in_distinct(self) -> _builtins.int:
        """
        Limits the maximum number of different rows when using DISTINCT.
        """
        return pulumi.get(self, "max_rows_in_distinct")

    @_builtins.property
    @pulumi.getter(name="maxRowsInJoin")
    def max_rows_in_join(self) -> _builtins.int:
        """
        Limit on maximum size of the hash table for JOIN, in rows.
        """
        return pulumi.get(self, "max_rows_in_join")

    @_builtins.property
    @pulumi.getter(name="maxRowsInSet")
    def max_rows_in_set(self) -> _builtins.int:
        """
        Limit on the number of rows in the set resulting from the execution of the IN section.
        """
        return pulumi.get(self, "max_rows_in_set")

    @_builtins.property
    @pulumi.getter(name="maxRowsToGroupBy")
    def max_rows_to_group_by(self) -> _builtins.int:
        """
        Limits the maximum number of unique keys received from aggregation function.
        """
        return pulumi.get(self, "max_rows_to_group_by")

    @_builtins.property
    @pulumi.getter(name="maxRowsToRead")
    def max_rows_to_read(self) -> _builtins.int:
        """
        Limits the maximum number of rows that can be read from a table when running a query.
        """
        return pulumi.get(self, "max_rows_to_read")

    @_builtins.property
    @pulumi.getter(name="maxRowsToSort")
    def max_rows_to_sort(self) -> _builtins.int:
        """
        Limits the maximum number of rows that can be read from a table for sorting.
        """
        return pulumi.get(self, "max_rows_to_sort")

    @_builtins.property
    @pulumi.getter(name="maxRowsToTransfer")
    def max_rows_to_transfer(self) -> _builtins.int:
        """
        Limits the maximum number of rows that can be passed to a remote server or saved in a temporary table when using GLOBAL IN.
        """
        return pulumi.get(self, "max_rows_to_transfer")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryColumns")
    def max_temporary_columns(self) -> _builtins.int:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, including constant columns.
        """
        return pulumi.get(self, "max_temporary_columns")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForQuery")
    def max_temporary_data_on_disk_size_for_query(self) -> _builtins.int:
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_query")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryDataOnDiskSizeForUser")
    def max_temporary_data_on_disk_size_for_user(self) -> _builtins.int:
        """
        The maximum amount of data consumed by temporary files on disk in bytes for all concurrently running user queries. Zero means unlimited.
        """
        return pulumi.get(self, "max_temporary_data_on_disk_size_for_user")

    @_builtins.property
    @pulumi.getter(name="maxTemporaryNonConstColumns")
    def max_temporary_non_const_columns(self) -> _builtins.int:
        """
        Limits the maximum number of temporary columns that must be kept in RAM at the same time when running a query, excluding constant columns.
        """
        return pulumi.get(self, "max_temporary_non_const_columns")

    @_builtins.property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> _builtins.int:
        """
        The maximum number of query processing threads, excluding threads for retrieving data from remote servers.
        """
        return pulumi.get(self, "max_threads")

    @_builtins.property
    @pulumi.getter(name="memoryOvercommitRatioDenominator")
    def memory_overcommit_ratio_denominator(self) -> _builtins.int:
        """
        It represents soft memory limit in case when hard limit is reached on user level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator")

    @_builtins.property
    @pulumi.getter(name="memoryOvercommitRatioDenominatorForUser")
    def memory_overcommit_ratio_denominator_for_user(self) -> _builtins.int:
        """
        It represents soft memory limit in case when hard limit is reached on global level. This value is used to compute overcommit ratio for the query. Zero means skip the query.
        """
        return pulumi.get(self, "memory_overcommit_ratio_denominator_for_user")

    @_builtins.property
    @pulumi.getter(name="memoryProfilerSampleProbability")
    def memory_profiler_sample_probability(self) -> _builtins.float:
        """
        Collect random allocations and deallocations and write them into system.trace_log with 'MemorySample' trace_type. The probability is for every alloc/free regardless to the size of the allocation. Possible values: from 0 to 1. Default: 0.
        """
        return pulumi.get(self, "memory_profiler_sample_probability")

    @_builtins.property
    @pulumi.getter(name="memoryProfilerStep")
    def memory_profiler_step(self) -> _builtins.int:
        """
        Memory profiler step (in bytes). If the next query step requires more memory than this parameter specifies, the memory profiler collects the allocating stack trace. Values lower than a few megabytes slow down query processing. Default value: 4194304 (4 MB). Zero means disabled memory profiler.
        """
        return pulumi.get(self, "memory_profiler_step")

    @_builtins.property
    @pulumi.getter(name="memoryUsageOvercommitMaxWaitMicroseconds")
    def memory_usage_overcommit_max_wait_microseconds(self) -> _builtins.int:
        """
        Maximum time thread will wait for memory to be freed in the case of memory overcommit on a user level. If the timeout is reached and memory is not freed, an exception is thrown.
        """
        return pulumi.get(self, "memory_usage_overcommit_max_wait_microseconds")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMaxBytesToUseCache")
    def merge_tree_max_bytes_to_use_cache(self) -> _builtins.int:
        """
        If ClickHouse should read more than merge_tree_max_bytes_to_use_cache bytes in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_bytes_to_use_cache")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMaxRowsToUseCache")
    def merge_tree_max_rows_to_use_cache(self) -> _builtins.int:
        """
        If ClickHouse should read more than merge_tree_max_rows_to_use_cache rows in one query, it doesnt use the cache of uncompressed blocks.
        """
        return pulumi.get(self, "merge_tree_max_rows_to_use_cache")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMinBytesForConcurrentRead")
    def merge_tree_min_bytes_for_concurrent_read(self) -> _builtins.int:
        """
        If the number of bytes to read from one file of a MergeTree-engine table exceeds merge_tree_min_bytes_for_concurrent_read, then ClickHouse tries to concurrently read from this file in several threads.
        """
        return pulumi.get(self, "merge_tree_min_bytes_for_concurrent_read")

    @_builtins.property
    @pulumi.getter(name="mergeTreeMinRowsForConcurrentRead")
    def merge_tree_min_rows_for_concurrent_read(self) -> _builtins.int:
        """
        If the number of rows to be read from a file of a MergeTree table exceeds merge_tree_min_rows_for_concurrent_read then ClickHouse tries to perform a concurrent reading from this file on several threads.
        """
        return pulumi.get(self, "merge_tree_min_rows_for_concurrent_read")

    @_builtins.property
    @pulumi.getter(name="minBytesToUseDirectIo")
    def min_bytes_to_use_direct_io(self) -> _builtins.int:
        """
        The minimum data volume required for using direct I/O access to the storage disk.
        """
        return pulumi.get(self, "min_bytes_to_use_direct_io")

    @_builtins.property
    @pulumi.getter(name="minCountToCompile")
    def min_count_to_compile(self) -> _builtins.int:
        """
        How many times to potentially use a compiled chunk of code before running compilation.
        """
        return pulumi.get(self, "min_count_to_compile")

    @_builtins.property
    @pulumi.getter(name="minCountToCompileExpression")
    def min_count_to_compile_expression(self) -> _builtins.int:
        """
        A query waits for expression compilation process to complete prior to continuing execution.
        """
        return pulumi.get(self, "min_count_to_compile_expression")

    @_builtins.property
    @pulumi.getter(name="minExecutionSpeed")
    def min_execution_speed(self) -> _builtins.int:
        """
        Minimal execution speed in rows per second.
        """
        return pulumi.get(self, "min_execution_speed")

    @_builtins.property
    @pulumi.getter(name="minExecutionSpeedBytes")
    def min_execution_speed_bytes(self) -> _builtins.int:
        """
        Minimal execution speed in bytes per second.
        """
        return pulumi.get(self, "min_execution_speed_bytes")

    @_builtins.property
    @pulumi.getter(name="minInsertBlockSizeBytes")
    def min_insert_block_size_bytes(self) -> _builtins.int:
        """
        Sets the minimum number of bytes in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_bytes")

    @_builtins.property
    @pulumi.getter(name="minInsertBlockSizeRows")
    def min_insert_block_size_rows(self) -> _builtins.int:
        """
        Sets the minimum number of rows in the block which can be inserted into a table by an INSERT query.
        """
        return pulumi.get(self, "min_insert_block_size_rows")

    @_builtins.property
    @pulumi.getter(name="outputFormatJsonQuote64bitIntegers")
    def output_format_json_quote64bit_integers(self) -> _builtins.bool:
        """
        If the value is true, integers appear in quotes when using JSON* Int64 and UInt64 formats (for compatibility with most JavaScript implementations); otherwise, integers are output without the quotes.
        """
        return pulumi.get(self, "output_format_json_quote64bit_integers")

    @_builtins.property
    @pulumi.getter(name="outputFormatJsonQuoteDenormals")
    def output_format_json_quote_denormals(self) -> _builtins.bool:
        """
        Enables +nan, -nan, +inf, -inf outputs in JSON output format.
        """
        return pulumi.get(self, "output_format_json_quote_denormals")

    @_builtins.property
    @pulumi.getter(name="preferLocalhostReplica")
    def prefer_localhost_replica(self) -> _builtins.bool:
        """
        Enables/disables preferable using the localhost replica when processing distributed queries. Default value: true.
        """
        return pulumi.get(self, "prefer_localhost_replica")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Query priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="queryCacheMaxEntries")
    def query_cache_max_entries(self) -> _builtins.int:
        """
        The maximum number of query results the current user may store in the query cache. 0 means unlimited.
        """
        return pulumi.get(self, "query_cache_max_entries")

    @_builtins.property
    @pulumi.getter(name="queryCacheMaxSizeInBytes")
    def query_cache_max_size_in_bytes(self) -> _builtins.int:
        """
        The maximum amount of memory (in bytes) the current user may allocate in the query cache. 0 means unlimited.
        """
        return pulumi.get(self, "query_cache_max_size_in_bytes")

    @_builtins.property
    @pulumi.getter(name="queryCacheMinQueryDuration")
    def query_cache_min_query_duration(self) -> _builtins.int:
        """
        Minimum duration in milliseconds a query needs to run for its result to be stored in the query cache.
        """
        return pulumi.get(self, "query_cache_min_query_duration")

    @_builtins.property
    @pulumi.getter(name="queryCacheMinQueryRuns")
    def query_cache_min_query_runs(self) -> _builtins.int:
        """
        Minimum number of times a SELECT query must run before its result is stored in the query cache.
        """
        return pulumi.get(self, "query_cache_min_query_runs")

    @_builtins.property
    @pulumi.getter(name="queryCacheShareBetweenUsers")
    def query_cache_share_between_users(self) -> _builtins.bool:
        """
        If turned on, the result of SELECT queries cached in the query cache can be read by other users. It is not recommended to enable this setting due to security reasons.
        """
        return pulumi.get(self, "query_cache_share_between_users")

    @_builtins.property
    @pulumi.getter(name="queryCacheTag")
    def query_cache_tag(self) -> _builtins.str:
        """
        A string which acts as a label for query cache entries. The same queries with different tags are considered different by the query cache.
        """
        return pulumi.get(self, "query_cache_tag")

    @_builtins.property
    @pulumi.getter(name="queryCacheTtl")
    def query_cache_ttl(self) -> _builtins.int:
        """
        After this time in seconds entries in the query cache become stale.
        """
        return pulumi.get(self, "query_cache_ttl")

    @_builtins.property
    @pulumi.getter(name="quotaMode")
    def quota_mode(self) -> _builtins.str:
        """
        Quota accounting mode.
        """
        return pulumi.get(self, "quota_mode")

    @_builtins.property
    @pulumi.getter(name="readOverflowMode")
    def read_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow while read. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "read_overflow_mode")

    @_builtins.property
    @pulumi.getter
    def readonly(self) -> _builtins.int:
        """
        Restricts permissions for reading data, write data and change settings queries.
        """
        return pulumi.get(self, "readonly")

    @_builtins.property
    @pulumi.getter(name="receiveTimeout")
    def receive_timeout(self) -> _builtins.int:
        """
        Receive timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "receive_timeout")

    @_builtins.property
    @pulumi.getter(name="remoteFilesystemReadMethod")
    def remote_filesystem_read_method(self) -> _builtins.str:
        """
        Method of reading data from remote filesystem, one of: `read`, `threadpool`.
        """
        return pulumi.get(self, "remote_filesystem_read_method")

    @_builtins.property
    @pulumi.getter(name="replicationAlterPartitionsSync")
    def replication_alter_partitions_sync(self) -> _builtins.int:
        """
        For ALTER ... ATTACH|DETACH|DROP queries, you can use the replication_alter_partitions_sync setting to set up waiting.
        """
        return pulumi.get(self, "replication_alter_partitions_sync")

    @_builtins.property
    @pulumi.getter(name="resultOverflowMode")
    def result_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow in result. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "result_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="s3UseAdaptiveTimeouts")
    def s3_use_adaptive_timeouts(self) -> _builtins.bool:
        """
        Enables or disables adaptive timeouts for S3 requests.
        """
        return pulumi.get(self, "s3_use_adaptive_timeouts")

    @_builtins.property
    @pulumi.getter(name="selectSequentialConsistency")
    def select_sequential_consistency(self) -> _builtins.bool:
        """
        Enables or disables sequential consistency for SELECT queries.
        """
        return pulumi.get(self, "select_sequential_consistency")

    @_builtins.property
    @pulumi.getter(name="sendProgressInHttpHeaders")
    def send_progress_in_http_headers(self) -> _builtins.bool:
        """
        Enables or disables `X-ClickHouse-Progress` HTTP response headers in clickhouse-server responses.
        """
        return pulumi.get(self, "send_progress_in_http_headers")

    @_builtins.property
    @pulumi.getter(name="sendTimeout")
    def send_timeout(self) -> _builtins.int:
        """
        Send timeout in milliseconds on the socket used for communicating with the client.
        """
        return pulumi.get(self, "send_timeout")

    @_builtins.property
    @pulumi.getter(name="setOverflowMode")
    def set_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow in the set resulting. Possible values:
          * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "set_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="skipUnavailableShards")
    def skip_unavailable_shards(self) -> _builtins.bool:
        """
        Enables or disables silently skipping of unavailable shards.
        """
        return pulumi.get(self, "skip_unavailable_shards")

    @_builtins.property
    @pulumi.getter(name="sortOverflowMode")
    def sort_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow while sort. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "sort_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="timeoutBeforeCheckingExecutionSpeed")
    def timeout_before_checking_execution_speed(self) -> _builtins.int:
        """
        Timeout (in seconds) between checks of execution speed. It is checked that execution speed is not less that specified in min_execution_speed parameter. Must be at least 1000.
        """
        return pulumi.get(self, "timeout_before_checking_execution_speed")

    @_builtins.property
    @pulumi.getter(name="timeoutOverflowMode")
    def timeout_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "timeout_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="transferOverflowMode")
    def transfer_overflow_mode(self) -> _builtins.str:
        """
        Sets behavior on overflow. Possible values:
        * `throw` - abort query execution, return an error.
        * `break` - stop query execution, return partial result.
        """
        return pulumi.get(self, "transfer_overflow_mode")

    @_builtins.property
    @pulumi.getter(name="transformNullIn")
    def transform_null_in(self) -> _builtins.bool:
        """
        Enables equality of NULL values for IN operator.
        """
        return pulumi.get(self, "transform_null_in")

    @_builtins.property
    @pulumi.getter(name="useHedgedRequests")
    def use_hedged_requests(self) -> _builtins.bool:
        """
        Enables hedged requests logic for remote queries. It allows to establish many connections with different replicas for query. New connection is enabled in case existent connection(s) with replica(s) were not established within hedged_connection_timeout or no data was received within receive_data_timeout. Query uses the first connection which send non empty progress packet (or data packet, if allow_changing_replica_until_first_data_packet); other connections are cancelled. Queries with max_parallel_replicas > 1 are supported. Default value: true.
        """
        return pulumi.get(self, "use_hedged_requests")

    @_builtins.property
    @pulumi.getter(name="useQueryCache")
    def use_query_cache(self) -> _builtins.bool:
        """
        If turned on, SELECT queries may utilize the query cache.
        """
        return pulumi.get(self, "use_query_cache")

    @_builtins.property
    @pulumi.getter(name="useUncompressedCache")
    def use_uncompressed_cache(self) -> _builtins.bool:
        """
        Whether to use a cache of uncompressed blocks.
        """
        return pulumi.get(self, "use_uncompressed_cache")

    @_builtins.property
    @pulumi.getter(name="waitForAsyncInsert")
    def wait_for_async_insert(self) -> _builtins.bool:
        """
        Enables waiting for processing of asynchronous insertion. If enabled, server returns OK only after the data is inserted.
        """
        return pulumi.get(self, "wait_for_async_insert")

    @_builtins.property
    @pulumi.getter(name="waitForAsyncInsertTimeout")
    def wait_for_async_insert_timeout(self) -> _builtins.int:
        """
        The timeout (in seconds) for waiting for processing of asynchronous insertion. Value must be at least 1000 (1 second).
        """
        return pulumi.get(self, "wait_for_async_insert_timeout")


@pulumi.output_type
class GetMdbClickhouseClusterZookeeperResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbClickhouseClusterZookeeperResourcesResult'):
        """
        :param 'GetMdbClickhouseClusterZookeeperResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbClickhouseClusterZookeeperResourcesResult':
        """
        Resources allocated to hosts of the ZooKeeper subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbClickhouseClusterZookeeperResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbGreenplumClusterAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: _builtins.bool,
                 data_transfer: _builtins.bool,
                 web_sql: _builtins.bool,
                 yandex_query: _builtins.bool):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer)
        :param _builtins.bool web_sql: Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        :param _builtins.bool yandex_query: Allow access for [Yandex Query](https://yandex.cloud/services/query)
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "data_transfer", data_transfer)
        pulumi.set(__self__, "web_sql", web_sql)
        pulumi.set(__self__, "yandex_query", yandex_query)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> _builtins.bool:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> _builtins.bool:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer)
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> _builtins.bool:
        """
        Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")

    @_builtins.property
    @pulumi.getter(name="yandexQuery")
    def yandex_query(self) -> _builtins.bool:
        """
        Allow access for [Yandex Query](https://yandex.cloud/services/query)
        """
        return pulumi.get(self, "yandex_query")


@pulumi.output_type
class GetMdbGreenplumClusterBackgroundActivityResult(dict):
    def __init__(__self__, *,
                 analyze_and_vacuums: Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumResult'],
                 query_killer_idle_in_transactions: Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionResult'],
                 query_killer_idles: Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleResult'],
                 query_killer_long_runnings: Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningResult']):
        """
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumArgs'] analyze_and_vacuums: Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionArgs'] query_killer_idle_in_transactions: Block to configure script that kills long running queries that are in `idle in transaction` state.
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleArgs'] query_killer_idles: Block to configure script that kills long running queries that are in `idle` state.
        :param Sequence['GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningArgs'] query_killer_long_runnings: Block to configure script that kills long running queries (in any state).
        """
        pulumi.set(__self__, "analyze_and_vacuums", analyze_and_vacuums)
        pulumi.set(__self__, "query_killer_idle_in_transactions", query_killer_idle_in_transactions)
        pulumi.set(__self__, "query_killer_idles", query_killer_idles)
        pulumi.set(__self__, "query_killer_long_runnings", query_killer_long_runnings)

    @_builtins.property
    @pulumi.getter(name="analyzeAndVacuums")
    def analyze_and_vacuums(self) -> Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumResult']:
        """
        Block to configure 'ANALYZE' and 'VACUUM' daily operations.
        """
        return pulumi.get(self, "analyze_and_vacuums")

    @_builtins.property
    @pulumi.getter(name="queryKillerIdleInTransactions")
    def query_killer_idle_in_transactions(self) -> Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionResult']:
        """
        Block to configure script that kills long running queries that are in `idle in transaction` state.
        """
        return pulumi.get(self, "query_killer_idle_in_transactions")

    @_builtins.property
    @pulumi.getter(name="queryKillerIdles")
    def query_killer_idles(self) -> Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleResult']:
        """
        Block to configure script that kills long running queries that are in `idle` state.
        """
        return pulumi.get(self, "query_killer_idles")

    @_builtins.property
    @pulumi.getter(name="queryKillerLongRunnings")
    def query_killer_long_runnings(self) -> Sequence['outputs.GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningResult']:
        """
        Block to configure script that kills long running queries (in any state).
        """
        return pulumi.get(self, "query_killer_long_runnings")


@pulumi.output_type
class GetMdbGreenplumClusterBackgroundActivityAnalyzeAndVacuumResult(dict):
    def __init__(__self__, *,
                 analyze_timeout: _builtins.int,
                 start_time: _builtins.str,
                 vacuum_timeout: _builtins.int):
        """
        :param _builtins.int analyze_timeout: Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        :param _builtins.str start_time: Time of day in 'HH:MM' format when scripts should run.
        :param _builtins.int vacuum_timeout: Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        pulumi.set(__self__, "analyze_timeout", analyze_timeout)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "vacuum_timeout", vacuum_timeout)

    @_builtins.property
    @pulumi.getter(name="analyzeTimeout")
    def analyze_timeout(self) -> _builtins.int:
        """
        Maximum duration of the `ANALYZE` operation, in seconds. The default value is `36000`. As soon as this period expires, the `ANALYZE` operation will be forced to terminate.
        """
        return pulumi.get(self, "analyze_timeout")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Time of day in 'HH:MM' format when scripts should run.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="vacuumTimeout")
    def vacuum_timeout(self) -> _builtins.int:
        """
        Maximum duration of the `VACUUM` operation, in seconds. The default value is `36000`. As soon as this period expires, the `VACUUM` operation will be forced to terminate.
        """
        return pulumi.get(self, "vacuum_timeout")


@pulumi.output_type
class GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 ignore_users: Sequence[_builtins.str],
                 max_age: _builtins.int):
        """
        :param _builtins.bool enable: Flag that indicates whether script is enabled.
        :param Sequence[_builtins.str] ignore_users: List of users to ignore when considering queries to terminate.
        :param _builtins.int max_age: Maximum duration for this type of queries (in seconds).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "ignore_users", ignore_users)
        pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Sequence[_builtins.str]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> _builtins.int:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetMdbGreenplumClusterBackgroundActivityQueryKillerIdleInTransactionResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 ignore_users: Sequence[_builtins.str],
                 max_age: _builtins.int):
        """
        :param _builtins.bool enable: Flag that indicates whether script is enabled.
        :param Sequence[_builtins.str] ignore_users: List of users to ignore when considering queries to terminate.
        :param _builtins.int max_age: Maximum duration for this type of queries (in seconds).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "ignore_users", ignore_users)
        pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Sequence[_builtins.str]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> _builtins.int:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetMdbGreenplumClusterBackgroundActivityQueryKillerLongRunningResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 ignore_users: Sequence[_builtins.str],
                 max_age: _builtins.int):
        """
        :param _builtins.bool enable: Flag that indicates whether script is enabled.
        :param Sequence[_builtins.str] ignore_users: List of users to ignore when considering queries to terminate.
        :param _builtins.int max_age: Maximum duration for this type of queries (in seconds).
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "ignore_users", ignore_users)
        pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Flag that indicates whether script is enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="ignoreUsers")
    def ignore_users(self) -> Sequence[_builtins.str]:
        """
        List of users to ignore when considering queries to terminate.
        """
        return pulumi.get(self, "ignore_users")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> _builtins.int:
        """
        Maximum duration for this type of queries (in seconds).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetMdbGreenplumClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        """
        :param _builtins.int hours: The hour at which backup will be started (UTC).
        :param _builtins.int minutes: The minute at which backup will be started (UTC).
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbGreenplumClusterCloudStorageResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        """
        :param _builtins.bool enable: Whether to use cloud storage or not.
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Whether to use cloud storage or not.
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetMdbGreenplumClusterLoggingResult(dict):
    def __init__(__self__, *,
                 command_center_enabled: _builtins.bool,
                 enabled: _builtins.bool,
                 folder_id: _builtins.str,
                 greenplum_enabled: _builtins.bool,
                 log_group_id: _builtins.str,
                 pooler_enabled: _builtins.bool):
        """
        :param _builtins.bool command_center_enabled: Deliver Yandex Command Center's logs to Cloud Logging.
        :param _builtins.bool enabled: Flag that indicates whether log delivery to Cloud Logging is enabled.
        :param _builtins.str folder_id: ID of folder to which deliver logs.
        :param _builtins.bool greenplum_enabled: Deliver Greenplum's logs to Cloud Logging.
        :param _builtins.str log_group_id: Cloud Logging group ID to send logs to.
        :param _builtins.bool pooler_enabled: Deliver connection pooler's logs to Cloud Logging.
        """
        pulumi.set(__self__, "command_center_enabled", command_center_enabled)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "greenplum_enabled", greenplum_enabled)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "pooler_enabled", pooler_enabled)

    @_builtins.property
    @pulumi.getter(name="commandCenterEnabled")
    def command_center_enabled(self) -> _builtins.bool:
        """
        Deliver Yandex Command Center's logs to Cloud Logging.
        """
        return pulumi.get(self, "command_center_enabled")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether log delivery to Cloud Logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        ID of folder to which deliver logs.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="greenplumEnabled")
    def greenplum_enabled(self) -> _builtins.bool:
        """
        Deliver Greenplum's logs to Cloud Logging.
        """
        return pulumi.get(self, "greenplum_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Cloud Logging group ID to send logs to.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="poolerEnabled")
    def pooler_enabled(self) -> _builtins.bool:
        """
        Deliver connection pooler's logs to Cloud Logging.
        """
        return pulumi.get(self, "pooler_enabled")


@pulumi.output_type
class GetMdbGreenplumClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.int:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 0 and 23.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbGreenplumClusterMasterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 fqdn: _builtins.str):
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetMdbGreenplumClusterMasterSubclusterResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbGreenplumClusterMasterSubclusterResourceResult']):
        """
        :param Sequence['GetMdbGreenplumClusterMasterSubclusterResourceArgs'] resources: Resources allocated to hosts for master subcluster of the Greenplum cluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbGreenplumClusterMasterSubclusterResourceResult']:
        """
        Resources allocated to hosts for master subcluster of the Greenplum cluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbGreenplumClusterMasterSubclusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Greenplum hosts - environment default is used if missing.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Greenplum hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbGreenplumClusterPoolerConfigResult(dict):
    def __init__(__self__, *,
                 pool_client_idle_timeout: Optional[_builtins.int] = None,
                 pool_size: Optional[_builtins.int] = None,
                 pooling_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.int pool_client_idle_timeout: Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        :param _builtins.int pool_size: Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        :param _builtins.str pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        if pool_client_idle_timeout is not None:
            pulumi.set(__self__, "pool_client_idle_timeout", pool_client_idle_timeout)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @_builtins.property
    @pulumi.getter(name="poolClientIdleTimeout")
    def pool_client_idle_timeout(self) -> Optional[_builtins.int]:
        """
        Value for `pool_client_idle_timeout` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_ttl-integer).
        """
        return pulumi.get(self, "pool_client_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[_builtins.int]:
        """
        Value for `pool_size` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_size-integer).
        """
        return pulumi.get(self, "pool_size")

    @_builtins.property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[_builtins.str]:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class GetMdbGreenplumClusterPxfConfigResult(dict):
    def __init__(__self__, *,
                 connection_timeout: Optional[_builtins.int] = None,
                 max_threads: Optional[_builtins.int] = None,
                 pool_allow_core_thread_timeout: Optional[_builtins.bool] = None,
                 pool_core_size: Optional[_builtins.int] = None,
                 pool_max_size: Optional[_builtins.int] = None,
                 pool_queue_capacity: Optional[_builtins.int] = None,
                 upload_timeout: Optional[_builtins.int] = None,
                 xms: Optional[_builtins.int] = None,
                 xmx: Optional[_builtins.int] = None):
        """
        :param _builtins.int connection_timeout: The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        :param _builtins.int max_threads: The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        :param _builtins.bool pool_allow_core_thread_timeout: Identifies whether or not core streaming threads are allowed to time out.
        :param _builtins.int pool_core_size: The number of core streaming threads. Value is between 1 and 1024.
        :param _builtins.int pool_max_size: The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        :param _builtins.int pool_queue_capacity: The capacity of the core streaming thread pool queue. Value is positive.
        :param _builtins.int upload_timeout: The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        :param _builtins.int xms: Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        :param _builtins.int xmx: Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if max_threads is not None:
            pulumi.set(__self__, "max_threads", max_threads)
        if pool_allow_core_thread_timeout is not None:
            pulumi.set(__self__, "pool_allow_core_thread_timeout", pool_allow_core_thread_timeout)
        if pool_core_size is not None:
            pulumi.set(__self__, "pool_core_size", pool_core_size)
        if pool_max_size is not None:
            pulumi.set(__self__, "pool_max_size", pool_max_size)
        if pool_queue_capacity is not None:
            pulumi.set(__self__, "pool_queue_capacity", pool_queue_capacity)
        if upload_timeout is not None:
            pulumi.set(__self__, "upload_timeout", upload_timeout)
        if xms is not None:
            pulumi.set(__self__, "xms", xms)
        if xmx is not None:
            pulumi.set(__self__, "xmx", xmx)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        The Tomcat server connection timeout for read operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="maxThreads")
    def max_threads(self) -> Optional[_builtins.int]:
        """
        The maximum number of PXF tomcat threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "max_threads")

    @_builtins.property
    @pulumi.getter(name="poolAllowCoreThreadTimeout")
    def pool_allow_core_thread_timeout(self) -> Optional[_builtins.bool]:
        """
        Identifies whether or not core streaming threads are allowed to time out.
        """
        return pulumi.get(self, "pool_allow_core_thread_timeout")

    @_builtins.property
    @pulumi.getter(name="poolCoreSize")
    def pool_core_size(self) -> Optional[_builtins.int]:
        """
        The number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_core_size")

    @_builtins.property
    @pulumi.getter(name="poolMaxSize")
    def pool_max_size(self) -> Optional[_builtins.int]:
        """
        The maximum allowed number of core streaming threads. Value is between 1 and 1024.
        """
        return pulumi.get(self, "pool_max_size")

    @_builtins.property
    @pulumi.getter(name="poolQueueCapacity")
    def pool_queue_capacity(self) -> Optional[_builtins.int]:
        """
        The capacity of the core streaming thread pool queue. Value is positive.
        """
        return pulumi.get(self, "pool_queue_capacity")

    @_builtins.property
    @pulumi.getter(name="uploadTimeout")
    def upload_timeout(self) -> Optional[_builtins.int]:
        """
        The Tomcat server connection timeout for write operations in seconds. Value is between 5 and 600.
        """
        return pulumi.get(self, "upload_timeout")

    @_builtins.property
    @pulumi.getter
    def xms(self) -> Optional[_builtins.int]:
        """
        Maximum JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xms")

    @_builtins.property
    @pulumi.getter
    def xmx(self) -> Optional[_builtins.int]:
        """
        Initial JVM heap size for PXF daemon. Value is between 64 and 16384.
        """
        return pulumi.get(self, "xmx")


@pulumi.output_type
class GetMdbGreenplumClusterSegmentHostResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str):
        pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetMdbGreenplumClusterSegmentSubclusterResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetMdbGreenplumClusterSegmentSubclusterResourceResult']):
        """
        :param Sequence['GetMdbGreenplumClusterSegmentSubclusterResourceArgs'] resources: Resources allocated to hosts for segment subcluster of the Greenplum cluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbGreenplumClusterSegmentSubclusterResourceResult']:
        """
        Resources allocated to hosts for segment subcluster of the Greenplum cluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbGreenplumClusterSegmentSubclusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Greenplum hosts - environment default is used if missing.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Greenplum hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/ru/docs/managed-greenplum/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterConfigResult(dict):
    def __init__(__self__, *,
                 access: 'outputs.GetMdbKafkaClusterConfigAccessResult',
                 disk_size_autoscaling: 'outputs.GetMdbKafkaClusterConfigDiskSizeAutoscalingResult',
                 kafka: 'outputs.GetMdbKafkaClusterConfigKafkaResult',
                 kafka_ui: 'outputs.GetMdbKafkaClusterConfigKafkaUiResult',
                 kraft: 'outputs.GetMdbKafkaClusterConfigKraftResult',
                 rest_api: 'outputs.GetMdbKafkaClusterConfigRestApiResult',
                 version: _builtins.str,
                 zones: Sequence[_builtins.str],
                 zookeeper: 'outputs.GetMdbKafkaClusterConfigZookeeperResult',
                 assign_public_ip: Optional[_builtins.bool] = None,
                 brokers_count: Optional[_builtins.int] = None,
                 schema_registry: Optional[_builtins.bool] = None,
                 unmanaged_topics: Optional[_builtins.bool] = None):
        """
        :param 'GetMdbKafkaClusterConfigAccessArgs' access: Access policy to the Kafka cluster.
        :param 'GetMdbKafkaClusterConfigDiskSizeAutoscalingArgs' disk_size_autoscaling: Disk autoscaling settings of the Kafka cluster.
        :param 'GetMdbKafkaClusterConfigKafkaArgs' kafka: Configuration of the Kafka subcluster.
        :param 'GetMdbKafkaClusterConfigKafkaUiArgs' kafka_ui: KAFKA UI settings of the Kafka cluster.
        :param 'GetMdbKafkaClusterConfigKraftArgs' kraft: Configuration of the KRaft-controller subcluster.
        :param 'GetMdbKafkaClusterConfigRestApiArgs' rest_api: REST API settings of the Kafka cluster.
        :param _builtins.str version: Version of the Kafka server software. Version of the Kafka server software.
        :param Sequence[_builtins.str] zones: List of availability zones. List of availability zones.
        :param 'GetMdbKafkaClusterConfigZookeeperArgs' zookeeper: Configuration of the ZooKeeper subcluster.
        :param _builtins.bool assign_public_ip: Determines whether each broker will be assigned a public IP address. The default is `false`. Determines whether each broker will be assigned a public IP address. The default is `false`.
        :param _builtins.int brokers_count: Count of brokers per availability zone. The default is `1`. Count of brokers per availability zone. The default is `1`.
        :param _builtins.bool schema_registry: Enables managed schema registry on cluster. The default is `false`. Enables managed schema registry on cluster. The default is `false`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "disk_size_autoscaling", disk_size_autoscaling)
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "kafka_ui", kafka_ui)
        pulumi.set(__self__, "kraft", kraft)
        pulumi.set(__self__, "rest_api", rest_api)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zones", zones)
        pulumi.set(__self__, "zookeeper", zookeeper)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if brokers_count is not None:
            pulumi.set(__self__, "brokers_count", brokers_count)
        if schema_registry is not None:
            pulumi.set(__self__, "schema_registry", schema_registry)
        if unmanaged_topics is not None:
            pulumi.set(__self__, "unmanaged_topics", unmanaged_topics)

    @_builtins.property
    @pulumi.getter
    def access(self) -> 'outputs.GetMdbKafkaClusterConfigAccessResult':
        """
        Access policy to the Kafka cluster.
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter(name="diskSizeAutoscaling")
    def disk_size_autoscaling(self) -> 'outputs.GetMdbKafkaClusterConfigDiskSizeAutoscalingResult':
        """
        Disk autoscaling settings of the Kafka cluster.
        """
        return pulumi.get(self, "disk_size_autoscaling")

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> 'outputs.GetMdbKafkaClusterConfigKafkaResult':
        """
        Configuration of the Kafka subcluster.
        """
        return pulumi.get(self, "kafka")

    @_builtins.property
    @pulumi.getter(name="kafkaUi")
    def kafka_ui(self) -> 'outputs.GetMdbKafkaClusterConfigKafkaUiResult':
        """
        KAFKA UI settings of the Kafka cluster.
        """
        return pulumi.get(self, "kafka_ui")

    @_builtins.property
    @pulumi.getter
    def kraft(self) -> 'outputs.GetMdbKafkaClusterConfigKraftResult':
        """
        Configuration of the KRaft-controller subcluster.
        """
        return pulumi.get(self, "kraft")

    @_builtins.property
    @pulumi.getter(name="restApi")
    def rest_api(self) -> 'outputs.GetMdbKafkaClusterConfigRestApiResult':
        """
        REST API settings of the Kafka cluster.
        """
        return pulumi.get(self, "rest_api")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the Kafka server software. Version of the Kafka server software.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Sequence[_builtins.str]:
        """
        List of availability zones. List of availability zones.
        """
        return pulumi.get(self, "zones")

    @_builtins.property
    @pulumi.getter
    def zookeeper(self) -> 'outputs.GetMdbKafkaClusterConfigZookeeperResult':
        """
        Configuration of the ZooKeeper subcluster.
        """
        return pulumi.get(self, "zookeeper")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Determines whether each broker will be assigned a public IP address. The default is `false`. Determines whether each broker will be assigned a public IP address. The default is `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="brokersCount")
    def brokers_count(self) -> Optional[_builtins.int]:
        """
        Count of brokers per availability zone. The default is `1`. Count of brokers per availability zone. The default is `1`.
        """
        return pulumi.get(self, "brokers_count")

    @_builtins.property
    @pulumi.getter(name="schemaRegistry")
    def schema_registry(self) -> Optional[_builtins.bool]:
        """
        Enables managed schema registry on cluster. The default is `false`. Enables managed schema registry on cluster. The default is `false`.
        """
        return pulumi.get(self, "schema_registry")

    @_builtins.property
    @pulumi.getter(name="unmanagedTopics")
    @_utilities.deprecated("""The 'unmanaged_topics' field has been deprecated, because feature enabled permanently and can't be disabled.""")
    def unmanaged_topics(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "unmanaged_topics")


@pulumi.output_type
class GetMdbKafkaClusterConfigAccessResult(dict):
    def __init__(__self__, *,
                 data_transfer: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer). Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer). Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")


@pulumi.output_type
class GetMdbKafkaClusterConfigDiskSizeAutoscalingResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Maximum possible size of disk in bytes. Maximum possible size of disk in bytes.
        :param _builtins.int emergency_usage_threshold: Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned*usage*threshold' value. Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned*usage*threshold' value.
        :param _builtins.int planned_usage_threshold: Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Maximum possible size of disk in bytes. Maximum possible size of disk in bytes.
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned*usage*threshold' value. Percent of disk utilization. Disk will autoscale immediately, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Must be not less then 'planned*usage*threshold' value.
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled). Percent of disk utilization. During maintenance disk will autoscale, if this threshold reached. Value is between 0 and 100. Default value is 0 (autoscaling disabled).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbKafkaClusterConfigKafkaResourcesResult',
                 kafka_config: Optional['outputs.GetMdbKafkaClusterConfigKafkaKafkaConfigResult'] = None):
        """
        :param 'GetMdbKafkaClusterConfigKafkaResourcesArgs' resources: Resources allocated to hosts of the Kafka subcluster.
        :param 'GetMdbKafkaClusterConfigKafkaKafkaConfigArgs' kafka_config: User-defined settings for the Kafka cluster. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        pulumi.set(__self__, "resources", resources)
        if kafka_config is not None:
            pulumi.set(__self__, "kafka_config", kafka_config)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbKafkaClusterConfigKafkaResourcesResult':
        """
        Resources allocated to hosts of the Kafka subcluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="kafkaConfig")
    def kafka_config(self) -> Optional['outputs.GetMdbKafkaClusterConfigKafkaKafkaConfigResult']:
        """
        User-defined settings for the Kafka cluster. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-update) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "kafka_config")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaKafkaConfigResult(dict):
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[_builtins.bool] = None,
                 compression_type: Optional[_builtins.str] = None,
                 default_replication_factor: Optional[_builtins.str] = None,
                 log_flush_interval_messages: Optional[_builtins.str] = None,
                 log_flush_interval_ms: Optional[_builtins.str] = None,
                 log_flush_scheduler_interval_ms: Optional[_builtins.str] = None,
                 log_preallocate: Optional[_builtins.bool] = None,
                 log_retention_bytes: Optional[_builtins.str] = None,
                 log_retention_hours: Optional[_builtins.str] = None,
                 log_retention_minutes: Optional[_builtins.str] = None,
                 log_retention_ms: Optional[_builtins.str] = None,
                 log_segment_bytes: Optional[_builtins.str] = None,
                 message_max_bytes: Optional[_builtins.str] = None,
                 num_partitions: Optional[_builtins.str] = None,
                 offsets_retention_minutes: Optional[_builtins.str] = None,
                 replica_fetch_max_bytes: Optional[_builtins.str] = None,
                 sasl_enabled_mechanisms: Optional[Sequence[_builtins.str]] = None,
                 socket_receive_buffer_bytes: Optional[_builtins.str] = None,
                 socket_send_buffer_bytes: Optional[_builtins.str] = None,
                 ssl_cipher_suites: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool auto_create_topics_enable: Enable auto creation of topic on the server. Enable auto creation of topic on the server.
        :param _builtins.str compression_type: Compression type of kafka topics. Compression type of kafka topics.
        :param _builtins.str default_replication_factor: The replication factor for automatically created topics, and for topics created with -1 as the replication factor. The replication factor for automatically created topics, and for topics created with -1 as the replication factor.
        :param _builtins.str log_flush_interval_messages: The number of messages accumulated on a log partition before messages are flushed to disk. The number of messages accumulated on a log partition before messages are flushed to disk.
        :param _builtins.str log_flush_interval_ms: The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used. The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
        :param _builtins.str log_flush_scheduler_interval_ms: The frequency in ms that the log flusher checks whether any log needs to be flushed to disk. The frequency in ms that the log flusher checks whether any log needs to be flushed to disk.
        :param _builtins.bool log_preallocate: Should pre allocate file when create new segment? Should pre allocate file when create new segment?
        :param _builtins.str log_retention_bytes: The maximum size of the log before deleting it. The maximum size of the log before deleting it.
        :param _builtins.str log_retention_hours: The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property. The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property.
        :param _builtins.str log_retention_minutes: The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used. The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used.
        :param _builtins.str log_retention_ms: The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
        :param _builtins.str log_segment_bytes: The maximum size of a single log file. The maximum size of a single log file.
        :param _builtins.str message_max_bytes: The largest record batch size allowed by Kafka (after compression if compression is enabled). The largest record batch size allowed by Kafka (after compression if compression is enabled).
        :param _builtins.str num_partitions: The default number of log partitions per topic. The default number of log partitions per topic.
        :param _builtins.str offsets_retention_minutes: For subscribed consumers, committed offset of a specific partition will be expired and discarded after this period of time. For subscribed consumers, committed offset of a specific partition will be expired and discarded after this period of time.
        :param _builtins.str replica_fetch_max_bytes: The number of bytes of messages to attempt to fetch for each partition. The number of bytes of messages to attempt to fetch for each partition.
        :param Sequence[_builtins.str] sasl_enabled_mechanisms: The list of SASL mechanisms enabled in the Kafka server. The list of SASL mechanisms enabled in the Kafka server.
        :param _builtins.str socket_receive_buffer_bytes: The SO*RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used. The SO*RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        :param _builtins.str socket_send_buffer_bytes: The SO*SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used. The SO*SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        :param Sequence[_builtins.str] ssl_cipher_suites: A list of cipher suites. A list of cipher suites.
        """
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if default_replication_factor is not None:
            pulumi.set(__self__, "default_replication_factor", default_replication_factor)
        if log_flush_interval_messages is not None:
            pulumi.set(__self__, "log_flush_interval_messages", log_flush_interval_messages)
        if log_flush_interval_ms is not None:
            pulumi.set(__self__, "log_flush_interval_ms", log_flush_interval_ms)
        if log_flush_scheduler_interval_ms is not None:
            pulumi.set(__self__, "log_flush_scheduler_interval_ms", log_flush_scheduler_interval_ms)
        if log_preallocate is not None:
            pulumi.set(__self__, "log_preallocate", log_preallocate)
        if log_retention_bytes is not None:
            pulumi.set(__self__, "log_retention_bytes", log_retention_bytes)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if log_retention_minutes is not None:
            pulumi.set(__self__, "log_retention_minutes", log_retention_minutes)
        if log_retention_ms is not None:
            pulumi.set(__self__, "log_retention_ms", log_retention_ms)
        if log_segment_bytes is not None:
            pulumi.set(__self__, "log_segment_bytes", log_segment_bytes)
        if message_max_bytes is not None:
            pulumi.set(__self__, "message_max_bytes", message_max_bytes)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)
        if offsets_retention_minutes is not None:
            pulumi.set(__self__, "offsets_retention_minutes", offsets_retention_minutes)
        if replica_fetch_max_bytes is not None:
            pulumi.set(__self__, "replica_fetch_max_bytes", replica_fetch_max_bytes)
        if sasl_enabled_mechanisms is not None:
            pulumi.set(__self__, "sasl_enabled_mechanisms", sasl_enabled_mechanisms)
        if socket_receive_buffer_bytes is not None:
            pulumi.set(__self__, "socket_receive_buffer_bytes", socket_receive_buffer_bytes)
        if socket_send_buffer_bytes is not None:
            pulumi.set(__self__, "socket_send_buffer_bytes", socket_send_buffer_bytes)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)

    @_builtins.property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[_builtins.bool]:
        """
        Enable auto creation of topic on the server. Enable auto creation of topic on the server.
        """
        return pulumi.get(self, "auto_create_topics_enable")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        Compression type of kafka topics. Compression type of kafka topics.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="defaultReplicationFactor")
    def default_replication_factor(self) -> Optional[_builtins.str]:
        """
        The replication factor for automatically created topics, and for topics created with -1 as the replication factor. The replication factor for automatically created topics, and for topics created with -1 as the replication factor.
        """
        return pulumi.get(self, "default_replication_factor")

    @_builtins.property
    @pulumi.getter(name="logFlushIntervalMessages")
    def log_flush_interval_messages(self) -> Optional[_builtins.str]:
        """
        The number of messages accumulated on a log partition before messages are flushed to disk. The number of messages accumulated on a log partition before messages are flushed to disk.
        """
        return pulumi.get(self, "log_flush_interval_messages")

    @_builtins.property
    @pulumi.getter(name="logFlushIntervalMs")
    def log_flush_interval_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used. The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
        """
        return pulumi.get(self, "log_flush_interval_ms")

    @_builtins.property
    @pulumi.getter(name="logFlushSchedulerIntervalMs")
    def log_flush_scheduler_interval_ms(self) -> Optional[_builtins.str]:
        """
        The frequency in ms that the log flusher checks whether any log needs to be flushed to disk. The frequency in ms that the log flusher checks whether any log needs to be flushed to disk.
        """
        return pulumi.get(self, "log_flush_scheduler_interval_ms")

    @_builtins.property
    @pulumi.getter(name="logPreallocate")
    @_utilities.deprecated("""The 'log_preallocate' field has been deprecated, because feature not useful for Yandex Cloud.""")
    def log_preallocate(self) -> Optional[_builtins.bool]:
        """
        Should pre allocate file when create new segment? Should pre allocate file when create new segment?
        """
        return pulumi.get(self, "log_preallocate")

    @_builtins.property
    @pulumi.getter(name="logRetentionBytes")
    def log_retention_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size of the log before deleting it. The maximum size of the log before deleting it.
        """
        return pulumi.get(self, "log_retention_bytes")

    @_builtins.property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[_builtins.str]:
        """
        The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property. The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property.
        """
        return pulumi.get(self, "log_retention_hours")

    @_builtins.property
    @pulumi.getter(name="logRetentionMinutes")
    def log_retention_minutes(self) -> Optional[_builtins.str]:
        """
        The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used. The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used.
        """
        return pulumi.get(self, "log_retention_minutes")

    @_builtins.property
    @pulumi.getter(name="logRetentionMs")
    def log_retention_ms(self) -> Optional[_builtins.str]:
        """
        The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied. The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
        """
        return pulumi.get(self, "log_retention_ms")

    @_builtins.property
    @pulumi.getter(name="logSegmentBytes")
    def log_segment_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size of a single log file. The maximum size of a single log file.
        """
        return pulumi.get(self, "log_segment_bytes")

    @_builtins.property
    @pulumi.getter(name="messageMaxBytes")
    def message_max_bytes(self) -> Optional[_builtins.str]:
        """
        The largest record batch size allowed by Kafka (after compression if compression is enabled). The largest record batch size allowed by Kafka (after compression if compression is enabled).
        """
        return pulumi.get(self, "message_max_bytes")

    @_builtins.property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[_builtins.str]:
        """
        The default number of log partitions per topic. The default number of log partitions per topic.
        """
        return pulumi.get(self, "num_partitions")

    @_builtins.property
    @pulumi.getter(name="offsetsRetentionMinutes")
    def offsets_retention_minutes(self) -> Optional[_builtins.str]:
        """
        For subscribed consumers, committed offset of a specific partition will be expired and discarded after this period of time. For subscribed consumers, committed offset of a specific partition will be expired and discarded after this period of time.
        """
        return pulumi.get(self, "offsets_retention_minutes")

    @_builtins.property
    @pulumi.getter(name="replicaFetchMaxBytes")
    def replica_fetch_max_bytes(self) -> Optional[_builtins.str]:
        """
        The number of bytes of messages to attempt to fetch for each partition. The number of bytes of messages to attempt to fetch for each partition.
        """
        return pulumi.get(self, "replica_fetch_max_bytes")

    @_builtins.property
    @pulumi.getter(name="saslEnabledMechanisms")
    def sasl_enabled_mechanisms(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of SASL mechanisms enabled in the Kafka server. The list of SASL mechanisms enabled in the Kafka server.
        """
        return pulumi.get(self, "sasl_enabled_mechanisms")

    @_builtins.property
    @pulumi.getter(name="socketReceiveBufferBytes")
    def socket_receive_buffer_bytes(self) -> Optional[_builtins.str]:
        """
        The SO*RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used. The SO*RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        """
        return pulumi.get(self, "socket_receive_buffer_bytes")

    @_builtins.property
    @pulumi.getter(name="socketSendBufferBytes")
    def socket_send_buffer_bytes(self) -> Optional[_builtins.str]:
        """
        The SO*SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used. The SO*SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.
        """
        return pulumi.get(self, "socket_send_buffer_bytes")

    @_builtins.property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of cipher suites. A list of cipher suites.
        """
        return pulumi.get(self, "ssl_cipher_suites")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a Kafka host, in gigabytes. Volume of the storage available to a Kafka host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Kafka hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage). Type of the storage of Kafka hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a Kafka host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts). The ID of the preset for computational resources available to a Kafka host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a Kafka host, in gigabytes. Volume of the storage available to a Kafka host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Kafka hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage). Type of the storage of Kafka hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a Kafka host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts). The ID of the preset for computational resources available to a Kafka host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterConfigKafkaUiResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables KAFKA UI on cluster. The default is `false`. Enables KAFKA UI on cluster. The default is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables KAFKA UI on cluster. The default is `false`. Enables KAFKA UI on cluster. The default is `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetMdbKafkaClusterConfigKraftResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbKafkaClusterConfigKraftResourcesResult'):
        """
        :param 'GetMdbKafkaClusterConfigKraftResourcesArgs' resources: Resources allocated to hosts of the KRaft-controller subcluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbKafkaClusterConfigKraftResourcesResult':
        """
        Resources allocated to hosts of the KRaft-controller subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbKafkaClusterConfigKraftResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a KRaft-controller host, in gigabytes. Volume of the storage available to a KRaft-controller host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage). Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a KRaft-controller host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts). The ID of the preset for computational resources available to a KRaft-controller host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a KRaft-controller host, in gigabytes. Volume of the storage available to a KRaft-controller host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage). Type of the storage of KRaft-controller hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a KRaft-controller host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts). The ID of the preset for computational resources available to a KRaft-controller host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterConfigRestApiResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables REST API on cluster. The default is `false`. Enables REST API on cluster. The default is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables REST API on cluster. The default is `false`. Enables REST API on cluster. The default is `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetMdbKafkaClusterConfigZookeeperResult(dict):
    def __init__(__self__, *,
                 resources: 'outputs.GetMdbKafkaClusterConfigZookeeperResourcesResult'):
        """
        :param 'GetMdbKafkaClusterConfigZookeeperResourcesArgs' resources: Resources allocated to hosts of the ZooKeeper subcluster.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMdbKafkaClusterConfigZookeeperResourcesResult':
        """
        Resources allocated to hosts of the ZooKeeper subcluster.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMdbKafkaClusterConfigZookeeperResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a ZooKeeper host, in gigabytes. Volume of the storage available to a ZooKeeper host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage). Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts). The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a ZooKeeper host, in gigabytes. Volume of the storage available to a ZooKeeper host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage). Type of the storage of ZooKeeper hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts). The ID of the preset for computational resources available to a ZooKeeper host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbKafkaClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 health: _builtins.str,
                 name: _builtins.str,
                 role: _builtins.str,
                 subnet_id: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.bool assign_public_ip: The flag that defines whether a public IP address is assigned to the node.
        :param _builtins.str health: Health of the host.
        :param _builtins.str name: The fully qualified domain name of the host.
        :param _builtins.str role: Role of the host in the cluster.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        """
        The flag that defines whether a public IP address is assigned to the node.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def health(self) -> _builtins.str:
        """
        Health of the host.
        """
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Role of the host in the cluster.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetMdbKafkaClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.int:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbKafkaClusterTopicResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 partitions: _builtins.int,
                 replication_factor: _builtins.int,
                 topic_config: Optional['outputs.GetMdbKafkaClusterTopicTopicConfigResult'] = None):
        """
        :param _builtins.str name: The name of the topic. The name of the topic.
        :param _builtins.int partitions: The number of the topic's partitions. The number of the topic's partitions.
        :param _builtins.int replication_factor: Amount of data copies (replicas) for the topic in the cluster. Amount of data copies (replicas) for the topic in the cluster.
        :param 'GetMdbKafkaClusterTopicTopicConfigArgs' topic_config: User-defined settings for the topic. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replication_factor", replication_factor)
        if topic_config is not None:
            pulumi.set(__self__, "topic_config", topic_config)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the topic. The name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> _builtins.int:
        """
        The number of the topic's partitions. The number of the topic's partitions.
        """
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        """
        Amount of data copies (replicas) for the topic in the cluster. Amount of data copies (replicas) for the topic in the cluster.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="topicConfig")
    def topic_config(self) -> Optional['outputs.GetMdbKafkaClusterTopicTopicConfigResult']:
        """
        User-defined settings for the topic. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kafka/operations/cluster-topics#update-topic) and [the Kafka documentation](https://kafka.apache.org/documentation/#configuration).
        """
        return pulumi.get(self, "topic_config")


@pulumi.output_type
class GetMdbKafkaClusterTopicTopicConfigResult(dict):
    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 compression_type: Optional[_builtins.str] = None,
                 delete_retention_ms: Optional[_builtins.str] = None,
                 file_delete_delay_ms: Optional[_builtins.str] = None,
                 flush_messages: Optional[_builtins.str] = None,
                 flush_ms: Optional[_builtins.str] = None,
                 max_message_bytes: Optional[_builtins.str] = None,
                 min_compaction_lag_ms: Optional[_builtins.str] = None,
                 min_insync_replicas: Optional[_builtins.str] = None,
                 preallocate: Optional[_builtins.bool] = None,
                 retention_bytes: Optional[_builtins.str] = None,
                 retention_ms: Optional[_builtins.str] = None,
                 segment_bytes: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: Retention policy to use on log segments. Retention policy to use on log segments.
        :param _builtins.str compression_type: Compression type of kafka topic. Compression type of kafka topic.
        :param _builtins.str delete_retention_ms: The amount of time to retain delete tombstone markers for log compacted topics. The amount of time to retain delete tombstone markers for log compacted topics.
        :param _builtins.str file_delete_delay_ms: The time to wait before deleting a file from the filesystem. The time to wait before deleting a file from the filesystem.
        :param _builtins.str flush_messages: This setting allows specifying an interval at which we will force an fsync of data written to the log. This setting allows specifying an interval at which we will force an fsync of data written to the log.
        :param _builtins.str flush_ms: This setting allows specifying a time interval at which we will force an fsync of data written to the log. This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        :param _builtins.str max_message_bytes: The largest record batch size allowed by Kafka (after compression if compression is enabled). The largest record batch size allowed by Kafka (after compression if compression is enabled).
        :param _builtins.str min_compaction_lag_ms: The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        :param _builtins.str min_insync_replicas: When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        :param _builtins.bool preallocate: True if we should preallocate the file on disk when creating a new log segment. True if we should preallocate the file on disk when creating a new log segment.
        :param _builtins.str retention_bytes: This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy. This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str retention_ms: This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy. This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str segment_bytes: This configuration controls the segment file size for the log. This configuration controls the segment file size for the log.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        Retention policy to use on log segments. Retention policy to use on log segments.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        Compression type of kafka topic. Compression type of kafka topic.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[_builtins.str]:
        """
        The amount of time to retain delete tombstone markers for log compacted topics. The amount of time to retain delete tombstone markers for log compacted topics.
        """
        return pulumi.get(self, "delete_retention_ms")

    @_builtins.property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[_builtins.str]:
        """
        The time to wait before deleting a file from the filesystem. The time to wait before deleting a file from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @_builtins.property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[_builtins.str]:
        """
        This setting allows specifying an interval at which we will force an fsync of data written to the log. This setting allows specifying an interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_messages")

    @_builtins.property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[_builtins.str]:
        """
        This setting allows specifying a time interval at which we will force an fsync of data written to the log. This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_ms")

    @_builtins.property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[_builtins.str]:
        """
        The largest record batch size allowed by Kafka (after compression if compression is enabled). The largest record batch size allowed by Kafka (after compression if compression is enabled).
        """
        return pulumi.get(self, "max_message_bytes")

    @_builtins.property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[_builtins.str]:
        """
        The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted. The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        """
        return pulumi.get(self, "min_compaction_lag_ms")

    @_builtins.property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[_builtins.str]:
        """
        When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'preallocate' field has been deprecated, because feature not useful for Yandex Cloud.""")
    def preallocate(self) -> Optional[_builtins.bool]:
        """
        True if we should preallocate the file on disk when creating a new log segment. True if we should preallocate the file on disk when creating a new log segment.
        """
        return pulumi.get(self, "preallocate")

    @_builtins.property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[_builtins.str]:
        """
        This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy. This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_bytes")

    @_builtins.property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[_builtins.str]:
        """
        This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy. This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_ms")

    @_builtins.property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[_builtins.str]:
        """
        This configuration controls the segment file size for the log. This configuration controls the segment file size for the log.
        """
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class GetMdbKafkaClusterUserResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 permissions: Optional[Sequence['outputs.GetMdbKafkaClusterUserPermissionResult']] = None):
        """
        :param _builtins.str name: The name of the user. The name of the user.
        :param _builtins.str password: The password of the user. The password of the user.
        :param Sequence['GetMdbKafkaClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user. The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user. The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.GetMdbKafkaClusterUserPermissionResult']]:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbKafkaClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 role: _builtins.str,
                 topic_name: _builtins.str,
                 allow_hosts: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str role: The role type to grant to the topic. The role type to grant to the topic.
        :param _builtins.str topic_name: The name of the topic that the permission grants access to. The name of the topic that the permission grants access to.
        :param Sequence[_builtins.str] allow_hosts: Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host. Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)
        if allow_hosts is not None:
            pulumi.set(__self__, "allow_hosts", allow_hosts)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role type to grant to the topic. The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        The name of the topic that the permission grants access to. The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host. Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        return pulumi.get(self, "allow_hosts")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerResult(dict):
    def __init__(__self__, *,
                 replication_factor: _builtins.int,
                 source_clusters: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterResult'],
                 target_clusters: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterResult'],
                 topics: _builtins.str):
        """
        :param _builtins.int replication_factor: Replication factor for topics created in target cluster.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterArgs'] source_clusters: Settings for source cluster.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterArgs'] target_clusters: Settings for target cluster.
        :param _builtins.str topics: The pattern for topic names to be replicated.
        """
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "source_clusters", source_clusters)
        pulumi.set(__self__, "target_clusters", target_clusters)
        pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        """
        Replication factor for topics created in target cluster.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="sourceClusters")
    def source_clusters(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterResult']:
        """
        Settings for source cluster.
        """
        return pulumi.get(self, "source_clusters")

    @_builtins.property
    @pulumi.getter(name="targetClusters")
    def target_clusters(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterResult']:
        """
        Settings for target cluster.
        """
        return pulumi.get(self, "target_clusters")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> _builtins.str:
        """
        The pattern for topic names to be replicated.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 external_clusters: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterResult'],
                 this_clusters: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterResult']):
        """
        :param _builtins.str alias: Name of the cluster. Used also as a topic prefix.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterArgs'] external_clusters: Connection settings for external cluster.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterArgs'] this_clusters: Using this section in the cluster definition (source or target) means it's this cluster.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "external_clusters", external_clusters)
        pulumi.set(__self__, "this_clusters", this_clusters)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        Name of the cluster. Used also as a topic prefix.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="externalClusters")
    def external_clusters(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterResult']:
        """
        Connection settings for external cluster.
        """
        return pulumi.get(self, "external_clusters")

    @_builtins.property
    @pulumi.getter(name="thisClusters")
    def this_clusters(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterResult']:
        """
        Using this section in the cluster definition (source or target) means it's this cluster.
        """
        return pulumi.get(self, "this_clusters")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalClusterResult(dict):
    def __init__(__self__, *,
                 bootstrap_servers: _builtins.str,
                 sasl_mechanism: _builtins.str,
                 sasl_password: _builtins.str,
                 sasl_username: _builtins.str,
                 security_protocol: _builtins.str):
        """
        :param _builtins.str bootstrap_servers: List of bootstrap servers to connect to cluster.
        :param _builtins.str sasl_mechanism: Type of SASL authentification mechanism to use.
        :param _builtins.str sasl_password: Password to use in SASL authentification mechanism
        :param _builtins.str sasl_username: Username to use in SASL authentification mechanism.
        :param _builtins.str security_protocol: Security protocol to use.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        pulumi.set(__self__, "sasl_password", sasl_password)
        pulumi.set(__self__, "sasl_username", sasl_username)
        pulumi.set(__self__, "security_protocol", security_protocol)

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> _builtins.str:
        """
        List of bootstrap servers to connect to cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> _builtins.str:
        """
        Type of SASL authentification mechanism to use.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> _builtins.str:
        """
        Password to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> _builtins.str:
        """
        Username to use in SASL authentification mechanism.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> _builtins.str:
        """
        Security protocol to use.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisClusterResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 external_clusters: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterResult'],
                 this_clusters: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterResult']):
        """
        :param _builtins.str alias: Name of the cluster. Used also as a topic prefix.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterArgs'] external_clusters: Connection settings for external cluster.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterArgs'] this_clusters: Using this section in the cluster definition (source or target) means it's this cluster.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "external_clusters", external_clusters)
        pulumi.set(__self__, "this_clusters", this_clusters)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        Name of the cluster. Used also as a topic prefix.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter(name="externalClusters")
    def external_clusters(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterResult']:
        """
        Connection settings for external cluster.
        """
        return pulumi.get(self, "external_clusters")

    @_builtins.property
    @pulumi.getter(name="thisClusters")
    def this_clusters(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterResult']:
        """
        Using this section in the cluster definition (source or target) means it's this cluster.
        """
        return pulumi.get(self, "this_clusters")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalClusterResult(dict):
    def __init__(__self__, *,
                 bootstrap_servers: _builtins.str,
                 sasl_mechanism: _builtins.str,
                 sasl_password: _builtins.str,
                 sasl_username: _builtins.str,
                 security_protocol: _builtins.str):
        """
        :param _builtins.str bootstrap_servers: List of bootstrap servers to connect to cluster.
        :param _builtins.str sasl_mechanism: Type of SASL authentification mechanism to use.
        :param _builtins.str sasl_password: Password to use in SASL authentification mechanism
        :param _builtins.str sasl_username: Username to use in SASL authentification mechanism.
        :param _builtins.str security_protocol: Security protocol to use.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        pulumi.set(__self__, "sasl_password", sasl_password)
        pulumi.set(__self__, "sasl_username", sasl_username)
        pulumi.set(__self__, "security_protocol", security_protocol)

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> _builtins.str:
        """
        List of bootstrap servers to connect to cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> _builtins.str:
        """
        Type of SASL authentification mechanism to use.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="saslPassword")
    def sasl_password(self) -> _builtins.str:
        """
        Password to use in SASL authentification mechanism
        """
        return pulumi.get(self, "sasl_password")

    @_builtins.property
    @pulumi.getter(name="saslUsername")
    def sasl_username(self) -> _builtins.str:
        """
        Username to use in SASL authentification mechanism.
        """
        return pulumi.get(self, "sasl_username")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> _builtins.str:
        """
        Security protocol to use.
        """
        return pulumi.get(self, "security_protocol")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisClusterResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigS3SinkResult(dict):
    def __init__(__self__, *,
                 file_compression_type: _builtins.str,
                 file_max_records: _builtins.int,
                 s3_connections: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionResult'],
                 topics: _builtins.str):
        """
        :param _builtins.str file_compression_type: Compression type for messages. Cannot be changed.
        :param _builtins.int file_max_records: Max records per file.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionArgs'] s3_connections: Settings for connection to s3-compatible storage.
        :param _builtins.str topics: The pattern for topic names to be copied to s3 bucket.
        """
        pulumi.set(__self__, "file_compression_type", file_compression_type)
        pulumi.set(__self__, "file_max_records", file_max_records)
        pulumi.set(__self__, "s3_connections", s3_connections)
        pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter(name="fileCompressionType")
    def file_compression_type(self) -> _builtins.str:
        """
        Compression type for messages. Cannot be changed.
        """
        return pulumi.get(self, "file_compression_type")

    @_builtins.property
    @pulumi.getter(name="fileMaxRecords")
    def file_max_records(self) -> _builtins.int:
        """
        Max records per file.
        """
        return pulumi.get(self, "file_max_records")

    @_builtins.property
    @pulumi.getter(name="s3Connections")
    def s3_connections(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionResult']:
        """
        Settings for connection to s3-compatible storage.
        """
        return pulumi.get(self, "s3_connections")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> _builtins.str:
        """
        The pattern for topic names to be copied to s3 bucket.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 external_s3s: Sequence['outputs.GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Result']):
        """
        :param _builtins.str bucket_name: Name of the bucket in s3-compatible storage.
        :param Sequence['GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Args'] external_s3s: Connection params for external s3-compatible storage.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "external_s3s", external_s3s)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Name of the bucket in s3-compatible storage.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="externalS3s")
    def external_s3s(self) -> Sequence['outputs.GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Result']:
        """
        Connection params for external s3-compatible storage.
        """
        return pulumi.get(self, "external_s3s")


@pulumi.output_type
class GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3Result(dict):
    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 endpoint: _builtins.str,
                 region: _builtins.str,
                 secret_access_key: _builtins.str):
        """
        :param _builtins.str access_key_id: ID of aws-compatible static key.
        :param _builtins.str endpoint: URL of s3-compatible storage.
        :param _builtins.str region: Region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        :param _builtins.str secret_access_key: Secret key of aws-compatible static key.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        ID of aws-compatible static key.
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        URL of s3-compatible storage.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region of s3-compatible storage. [Available region list](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/regions/Regions.html).
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        Secret key of aws-compatible static key.
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class GetMdbKafkaTopicTopicConfigResult(dict):
    def __init__(__self__, *,
                 cleanup_policy: _builtins.str,
                 compression_type: _builtins.str,
                 delete_retention_ms: _builtins.str,
                 file_delete_delay_ms: _builtins.str,
                 flush_messages: _builtins.str,
                 flush_ms: _builtins.str,
                 max_message_bytes: _builtins.str,
                 min_compaction_lag_ms: _builtins.str,
                 min_insync_replicas: _builtins.str,
                 preallocate: _builtins.bool,
                 retention_bytes: _builtins.str,
                 retention_ms: _builtins.str,
                 segment_bytes: _builtins.str):
        """
        :param _builtins.str cleanup_policy: Retention policy to use on log segments.
        :param _builtins.str compression_type: Compression type of kafka topic.
        :param _builtins.str delete_retention_ms: The amount of time to retain delete tombstone markers for log compacted topics.
        :param _builtins.str file_delete_delay_ms: The time to wait before deleting a file from the filesystem.
        :param _builtins.str flush_messages: This setting allows specifying an interval at which we will force an fsync of data written to the log.
        :param _builtins.str flush_ms: This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        :param _builtins.str max_message_bytes: The largest record batch size allowed by Kafka (after compression if compression is enabled).
        :param _builtins.str min_compaction_lag_ms: The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        :param _builtins.str min_insync_replicas: When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        :param _builtins.bool preallocate: True if we should preallocate the file on disk when creating a new log segment.
        :param _builtins.str retention_bytes: This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str retention_ms: This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        :param _builtins.str segment_bytes: This configuration controls the segment file size for the log.
        """
        pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        pulumi.set(__self__, "compression_type", compression_type)
        pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        pulumi.set(__self__, "flush_messages", flush_messages)
        pulumi.set(__self__, "flush_ms", flush_ms)
        pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        pulumi.set(__self__, "preallocate", preallocate)
        pulumi.set(__self__, "retention_bytes", retention_bytes)
        pulumi.set(__self__, "retention_ms", retention_ms)
        pulumi.set(__self__, "segment_bytes", segment_bytes)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> _builtins.str:
        """
        Retention policy to use on log segments.
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> _builtins.str:
        """
        Compression type of kafka topic.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> _builtins.str:
        """
        The amount of time to retain delete tombstone markers for log compacted topics.
        """
        return pulumi.get(self, "delete_retention_ms")

    @_builtins.property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> _builtins.str:
        """
        The time to wait before deleting a file from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @_builtins.property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> _builtins.str:
        """
        This setting allows specifying an interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_messages")

    @_builtins.property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> _builtins.str:
        """
        This setting allows specifying a time interval at which we will force an fsync of data written to the log.
        """
        return pulumi.get(self, "flush_ms")

    @_builtins.property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> _builtins.str:
        """
        The largest record batch size allowed by Kafka (after compression if compression is enabled).
        """
        return pulumi.get(self, "max_message_bytes")

    @_builtins.property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> _builtins.str:
        """
        The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
        """
        return pulumi.get(self, "min_compaction_lag_ms")

    @_builtins.property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> _builtins.str:
        """
        When a producer sets acks to "all" (or "-1"), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'preallocate' field has been deprecated, because feature not useful for Yandex Cloud.""")
    def preallocate(self) -> _builtins.bool:
        """
        True if we should preallocate the file on disk when creating a new log segment.
        """
        return pulumi.get(self, "preallocate")

    @_builtins.property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> _builtins.str:
        """
        This configuration controls the maximum size a partition (which consists of log segments) can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_bytes")

    @_builtins.property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> _builtins.str:
        """
        This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy.
        """
        return pulumi.get(self, "retention_ms")

    @_builtins.property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> _builtins.str:
        """
        This configuration controls the segment file size for the log.
        """
        return pulumi.get(self, "segment_bytes")


@pulumi.output_type
class GetMdbKafkaUserPermissionResult(dict):
    def __init__(__self__, *,
                 allow_hosts: Sequence[_builtins.str],
                 role: _builtins.str,
                 topic_name: _builtins.str):
        """
        :param Sequence[_builtins.str] allow_hosts: Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        :param _builtins.str role: The role type to grant to the topic.
        :param _builtins.str topic_name: The name of the topic that the permission grants access to.
        """
        pulumi.set(__self__, "allow_hosts", allow_hosts)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter(name="allowHosts")
    def allow_hosts(self) -> Sequence[_builtins.str]:
        """
        Set of hosts, to which this permission grants access to. Only ip-addresses allowed as value of single host.
        """
        return pulumi.get(self, "allow_hosts")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role type to grant to the topic.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        The name of the topic that the permission grants access to.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigResult(dict):
    def __init__(__self__, *,
                 access: 'outputs.GetMdbMongodbClusterClusterConfigAccessResult',
                 backup_retain_period_days: _builtins.int,
                 backup_window_start: 'outputs.GetMdbMongodbClusterClusterConfigBackupWindowStartResult',
                 feature_compatibility_version: _builtins.str,
                 mongocfg: 'outputs.GetMdbMongodbClusterClusterConfigMongocfgResult',
                 mongod: 'outputs.GetMdbMongodbClusterClusterConfigMongodResult',
                 mongos: 'outputs.GetMdbMongodbClusterClusterConfigMongosResult',
                 performance_diagnostics: 'outputs.GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsResult',
                 version: Optional[_builtins.str] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigAccessArgs' access: Access policy to the MongoDB cluster.
        :param _builtins.int backup_retain_period_days: Retain period of automatically created backup in days. Retain period of automatically created backup in days.
        :param 'GetMdbMongodbClusterClusterConfigBackupWindowStartArgs' backup_window_start: Time to start the daily backup, in the UTC timezone.
        :param _builtins.str feature_compatibility_version: Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`. Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        :param 'GetMdbMongodbClusterClusterConfigMongocfgArgs' mongocfg: Configuration of the mongocfg service.
        :param 'GetMdbMongodbClusterClusterConfigMongodArgs' mongod: Configuration of the mongod service.
        :param 'GetMdbMongodbClusterClusterConfigMongosArgs' mongos: Configuration of the mongos service.
        :param 'GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsArgs' performance_diagnostics: Performance diagnostics to the MongoDB cluster.
        :param _builtins.str version: Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`. Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        pulumi.set(__self__, "backup_window_start", backup_window_start)
        pulumi.set(__self__, "feature_compatibility_version", feature_compatibility_version)
        pulumi.set(__self__, "mongocfg", mongocfg)
        pulumi.set(__self__, "mongod", mongod)
        pulumi.set(__self__, "mongos", mongos)
        pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def access(self) -> 'outputs.GetMdbMongodbClusterClusterConfigAccessResult':
        """
        Access policy to the MongoDB cluster.
        """
        return pulumi.get(self, "access")

    @_builtins.property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> _builtins.int:
        """
        Retain period of automatically created backup in days. Retain period of automatically created backup in days.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @_builtins.property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> 'outputs.GetMdbMongodbClusterClusterConfigBackupWindowStartResult':
        """
        Time to start the daily backup, in the UTC timezone.
        """
        return pulumi.get(self, "backup_window_start")

    @_builtins.property
    @pulumi.getter(name="featureCompatibilityVersion")
    def feature_compatibility_version(self) -> _builtins.str:
        """
        Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`. Feature compatibility version of MongoDB. If not provided version is taken. Can be either `6.0`, `5.0`, `4.4` and `4.2`.
        """
        return pulumi.get(self, "feature_compatibility_version")

    @_builtins.property
    @pulumi.getter
    def mongocfg(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongocfgResult':
        """
        Configuration of the mongocfg service.
        """
        return pulumi.get(self, "mongocfg")

    @_builtins.property
    @pulumi.getter
    def mongod(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongodResult':
        """
        Configuration of the mongod service.
        """
        return pulumi.get(self, "mongod")

    @_builtins.property
    @pulumi.getter
    def mongos(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongosResult':
        """
        Configuration of the mongos service.
        """
        return pulumi.get(self, "mongos")

    @_builtins.property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> 'outputs.GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsResult':
        """
        Performance diagnostics to the MongoDB cluster.
        """
        return pulumi.get(self, "performance_diagnostics")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`. Version of the MongoDB server software. Can be either `4.2`, `4.4`, `4.4-enterprise`, `5.0`, `5.0-enterprise`, `6.0` and `6.0-enterprise`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: Optional[_builtins.bool] = None,
                 data_transfer: Optional[_builtins.bool] = None,
                 web_sql: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens). Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer). Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        :param _builtins.bool web_sql: Allow access for [WebSQL](https://yandex.cloud/ru/docs/websql/). Allow access for [WebSQL](https://yandex.cloud/ru/docs/websql/).
        """
        if data_lens is not None:
            pulumi.set(__self__, "data_lens", data_lens)
        if data_transfer is not None:
            pulumi.set(__self__, "data_transfer", data_transfer)
        if web_sql is not None:
            pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> Optional[_builtins.bool]:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens). Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> Optional[_builtins.bool]:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer). Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> Optional[_builtins.bool]:
        """
        Allow access for [WebSQL](https://yandex.cloud/ru/docs/websql/). Allow access for [WebSQL](https://yandex.cloud/ru/docs/websql/).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started. The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started. The minute at which backup will be started.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started. The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started. The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongocfgResult(dict):
    def __init__(__self__, *,
                 net: Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgNetResult'] = None,
                 operation_profiling: Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingResult'] = None,
                 storage: Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgStorageResult'] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongocfgNetArgs' net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        :param 'GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingArgs' operation_profiling: A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        :param 'GetMdbMongodbClusterClusterConfigMongocfgStorageArgs' storage: A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def net(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgNetResult']:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        return pulumi.get(self, "net")

    @_builtins.property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingResult']:
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        """
        return pulumi.get(self, "operation_profiling")

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgStorageResult']:
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongocfgNetResult(dict):
    def __init__(__self__, *,
                 max_incoming_connections: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation. The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @_builtins.property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation. The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongocfgOperationProfilingResult(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 slow_op_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str mode: Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation. Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        :param _builtins.int slow_op_threshold: The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation. The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation. Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[_builtins.int]:
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation. The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_threshold")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongocfgStorageResult(dict):
    def __init__(__self__, *,
                 wired_tiger: Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerResult'] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerArgs' wired_tiger: The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option).
        """
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @_builtins.property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerResult']:
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option).
        """
        return pulumi.get(self, "wired_tiger")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTigerResult(dict):
    def __init__(__self__, *,
                 cache_size_gb: Optional[_builtins.float] = None):
        """
        :param _builtins.float cache_size_gb: Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation. Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)

    @_builtins.property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[_builtins.float]:
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation. Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        return pulumi.get(self, "cache_size_gb")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodResult(dict):
    def __init__(__self__, *,
                 audit_log: 'outputs.GetMdbMongodbClusterClusterConfigMongodAuditLogResult',
                 security: 'outputs.GetMdbMongodbClusterClusterConfigMongodSecurityResult',
                 set_parameter: 'outputs.GetMdbMongodbClusterClusterConfigMongodSetParameterResult',
                 net: Optional['outputs.GetMdbMongodbClusterClusterConfigMongodNetResult'] = None,
                 operation_profiling: Optional['outputs.GetMdbMongodbClusterClusterConfigMongodOperationProfilingResult'] = None,
                 storage: Optional['outputs.GetMdbMongodbClusterClusterConfigMongodStorageResult'] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongodAuditLogArgs' audit_log: A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). Available only in enterprise edition.
        :param 'GetMdbMongodbClusterClusterConfigMongodSecurityArgs' security: A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). Available only in enterprise edition.
        :param 'GetMdbMongodbClusterClusterConfigMongodSetParameterArgs' set_parameter: A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option).
        :param 'GetMdbMongodbClusterClusterConfigMongodNetArgs' net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        :param 'GetMdbMongodbClusterClusterConfigMongodOperationProfilingArgs' operation_profiling: A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        :param 'GetMdbMongodbClusterClusterConfigMongodStorageArgs' storage: A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        pulumi.set(__self__, "audit_log", audit_log)
        pulumi.set(__self__, "security", security)
        pulumi.set(__self__, "set_parameter", set_parameter)
        if net is not None:
            pulumi.set(__self__, "net", net)
        if operation_profiling is not None:
            pulumi.set(__self__, "operation_profiling", operation_profiling)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongodAuditLogResult':
        """
        A set of audit log settings (see the [auditLog](https://www.mongodb.com/docs/manual/reference/configuration-options/#auditlog-options) option). Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_log")

    @_builtins.property
    @pulumi.getter
    def security(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongodSecurityResult':
        """
        A set of MongoDB Security settings (see the [security](https://www.mongodb.com/docs/manual/reference/configuration-options/#security-options) option). Available only in enterprise edition.
        """
        return pulumi.get(self, "security")

    @_builtins.property
    @pulumi.getter(name="setParameter")
    def set_parameter(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongodSetParameterResult':
        """
        A set of MongoDB Server Parameters (see the [setParameter](https://www.mongodb.com/docs/manual/reference/configuration-options/#setparameter-option) option).
        """
        return pulumi.get(self, "set_parameter")

    @_builtins.property
    @pulumi.getter
    def net(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongodNetResult']:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        return pulumi.get(self, "net")

    @_builtins.property
    @pulumi.getter(name="operationProfiling")
    def operation_profiling(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongodOperationProfilingResult']:
        """
        A set of profiling settings (see the [operationProfiling](https://www.mongodb.com/docs/manual/reference/configuration-options/#operationprofiling-options) option).
        """
        return pulumi.get(self, "operation_profiling")

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongodStorageResult']:
        """
        A set of storage settings (see the [storage](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage-options) option).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodAuditLogResult(dict):
    def __init__(__self__, *,
                 filter: Optional[_builtins.str] = None,
                 runtime_configuration: Optional[_builtins.bool] = None):
        """
        :param _builtins.str filter: Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition. Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        :param _builtins.bool runtime_configuration: Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition. Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if runtime_configuration is not None:
            pulumi.set(__self__, "runtime_configuration", runtime_configuration)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition. Configuration of the audit log filter in JSON format. For more information see [auditLog.filter](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.filter) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="runtimeConfiguration")
    def runtime_configuration(self) -> Optional[_builtins.bool]:
        """
        Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition. Specifies if a node allows runtime configuration of audit filters and the auditAuthorizationSuccess variable. For more information see [auditLog.runtimeConfiguration](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-auditLog.runtimeConfiguration) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "runtime_configuration")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodNetResult(dict):
    def __init__(__self__, *,
                 compressors: Optional[Sequence[_builtins.str]] = None,
                 max_incoming_connections: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] compressors: Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation. Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        :param _builtins.int max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation. The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @_builtins.property
    @pulumi.getter
    def compressors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation. Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        return pulumi.get(self, "compressors")

    @_builtins.property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation. The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodOperationProfilingResult(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 slow_op_sample_rate: Optional[_builtins.float] = None,
                 slow_op_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.str mode: Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation. Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        :param _builtins.float slow_op_sample_rate: The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation. The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        :param _builtins.int slow_op_threshold: The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation. The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if slow_op_sample_rate is not None:
            pulumi.set(__self__, "slow_op_sample_rate", slow_op_sample_rate)
        if slow_op_threshold is not None:
            pulumi.set(__self__, "slow_op_threshold", slow_op_threshold)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation. Specifies which operations should be profiled. The following profiler levels are available: off, slow*op, all. For more information, see the [operationProfiling.mode](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.mode) description in the official documentation.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="slowOpSampleRate")
    def slow_op_sample_rate(self) -> Optional[_builtins.float]:
        """
        The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation. The fraction of slow operations that should be profiled or logged. Accepts values between 0 and 1, inclusive. For more information, see the [operationProfiling.slowOpSampleRate](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpSampleRate) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_sample_rate")

    @_builtins.property
    @pulumi.getter(name="slowOpThreshold")
    def slow_op_threshold(self) -> Optional[_builtins.int]:
        """
        The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation. The slow operation time threshold, in milliseconds. Operations that run for longer than this threshold are considered slow. For more information, see the [operationProfiling.slowOpThresholdMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-operationProfiling.slowOpThresholdMs) description in the official documentation.
        """
        return pulumi.get(self, "slow_op_threshold")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodSecurityResult(dict):
    def __init__(__self__, *,
                 kmip: 'outputs.GetMdbMongodbClusterClusterConfigMongodSecurityKmipResult',
                 enable_encryption: Optional[_builtins.bool] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongodSecurityKmipArgs' kmip: Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        :param _builtins.bool enable_encryption: Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition. Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        pulumi.set(__self__, "kmip", kmip)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)

    @_builtins.property
    @pulumi.getter
    def kmip(self) -> 'outputs.GetMdbMongodbClusterClusterConfigMongodSecurityKmipResult':
        """
        Configuration of the third party key management appliance via the Key Management Interoperability Protocol (KMIP) (see [Encryption tutorial](https://www.mongodb.com/docs/rapid/tutorial/configure-encryption) ). Requires `enable_encryption` to be true. The structure is documented below. Available only in enterprise edition.
        """
        return pulumi.get(self, "kmip")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        """
        Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition. Enables the encryption for the WiredTiger storage engine. Can be either true or false. For more information see [security.enableEncryption](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.enableEncryption) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "enable_encryption")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodSecurityKmipResult(dict):
    def __init__(__self__, *,
                 client_certificate: Optional[_builtins.str] = None,
                 key_identifier: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 server_ca: Optional[_builtins.str] = None,
                 server_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate: String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation. String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        :param _builtins.str key_identifier: Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation. Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        :param _builtins.int port: Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation. Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        :param _builtins.str server_ca: Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation. Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        :param _builtins.str server_name: Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation. Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server_ca is not None:
            pulumi.set(__self__, "server_ca", server_ca)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation. String containing the client certificate used for authenticating MongoDB to the KMIP server. For more information see [security.kmip.clientCertificateFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.clientCertificateFile) description in the official documentation.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[_builtins.str]:
        """
        Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation. Unique KMIP identifier for an existing key within the KMIP server. For more information see [security.kmip.keyIdentifier](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.keyIdentifier) description in the official documentation.
        """
        return pulumi.get(self, "key_identifier")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation. Port number to use to communicate with the KMIP server. Default: 5696 For more information see [security.kmip.port](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.port) description in the official documentation.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="serverCa")
    def server_ca(self) -> Optional[_builtins.str]:
        """
        Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation. Path to CA File. Used for validating secure client connection to KMIP server. For more information see [security.kmip.serverCAFile](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverCAFile) description in the official documentation.
        """
        return pulumi.get(self, "server_ca")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation. Hostname or IP address of the KMIP server to connect to. For more information see [security.kmip.serverName](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-security.kmip.serverName) description in the official documentation.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodSetParameterResult(dict):
    def __init__(__self__, *,
                 audit_authorization_success: Optional[_builtins.bool] = None,
                 enable_flow_control: Optional[_builtins.bool] = None,
                 min_snapshot_history_window_in_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.bool audit_authorization_success: Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition. Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        :param _builtins.bool enable_flow_control: Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation. Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        :param _builtins.int min_snapshot_history_window_in_seconds: The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation. The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
        if audit_authorization_success is not None:
            pulumi.set(__self__, "audit_authorization_success", audit_authorization_success)
        if enable_flow_control is not None:
            pulumi.set(__self__, "enable_flow_control", enable_flow_control)
        if min_snapshot_history_window_in_seconds is not None:
            pulumi.set(__self__, "min_snapshot_history_window_in_seconds", min_snapshot_history_window_in_seconds)

    @_builtins.property
    @pulumi.getter(name="auditAuthorizationSuccess")
    def audit_authorization_success(self) -> Optional[_builtins.bool]:
        """
        Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition. Enables the auditing of authorization successes. Can be either true or false. For more information, see the [auditAuthorizationSuccess](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.auditAuthorizationSuccess) description in the official documentation. Available only in enterprise edition.
        """
        return pulumi.get(self, "audit_authorization_success")

    @_builtins.property
    @pulumi.getter(name="enableFlowControl")
    def enable_flow_control(self) -> Optional[_builtins.bool]:
        """
        Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation. Enables the flow control. Can be either true or false. For more information, see the [enableFlowControl](https://www.mongodb.com/docs/rapid/reference/parameters/#mongodb-parameter-param.enableFlowControl) description in the official documentation.
        """
        return pulumi.get(self, "enable_flow_control")

    @_builtins.property
    @pulumi.getter(name="minSnapshotHistoryWindowInSeconds")
    def min_snapshot_history_window_in_seconds(self) -> Optional[_builtins.int]:
        """
        The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation. The minimum time window in seconds for which the storage engine keeps the snapshot history. For more information, see the [minSnapshotHistoryWindowInSeconds](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.minSnapshotHistoryWindowInSeconds) description in the official documentation.
        """
        return pulumi.get(self, "min_snapshot_history_window_in_seconds")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodStorageResult(dict):
    def __init__(__self__, *,
                 journal: Optional['outputs.GetMdbMongodbClusterClusterConfigMongodStorageJournalResult'] = None,
                 wired_tiger: Optional['outputs.GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerResult'] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongodStorageJournalArgs' journal: The durability journal to ensure data files remain valid and recoverable.
        :param 'GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerArgs' wired_tiger: The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts.
        """
        if journal is not None:
            pulumi.set(__self__, "journal", journal)
        if wired_tiger is not None:
            pulumi.set(__self__, "wired_tiger", wired_tiger)

    @_builtins.property
    @pulumi.getter
    def journal(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongodStorageJournalResult']:
        """
        The durability journal to ensure data files remain valid and recoverable.
        """
        return pulumi.get(self, "journal")

    @_builtins.property
    @pulumi.getter(name="wiredTiger")
    def wired_tiger(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerResult']:
        """
        The WiredTiger engine settings. (see the [storage.wiredTiger](https://www.mongodb.com/docs/manual/reference/configuration-options/#storage.wiredtiger-options) option). These settings available only on `mongod` hosts.
        """
        return pulumi.get(self, "wired_tiger")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodStorageJournalResult(dict):
    def __init__(__self__, *,
                 commit_interval: Optional[_builtins.int] = None):
        """
        :param _builtins.int commit_interval: The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation. The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
        if commit_interval is not None:
            pulumi.set(__self__, "commit_interval", commit_interval)

    @_builtins.property
    @pulumi.getter(name="commitInterval")
    def commit_interval(self) -> Optional[_builtins.int]:
        """
        The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation. The maximum amount of time in milliseconds that the mongod process allows between journal operations. For more information, see the [storage.journal.commitIntervalMs](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.journal.commitIntervalMs) description in the official documentation.
        """
        return pulumi.get(self, "commit_interval")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongodStorageWiredTigerResult(dict):
    def __init__(__self__, *,
                 block_compressor: Optional[_builtins.str] = None,
                 cache_size_gb: Optional[_builtins.float] = None,
                 prefix_compression: Optional[_builtins.bool] = None):
        """
        :param _builtins.str block_compressor: Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation. Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        :param _builtins.float cache_size_gb: Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation. Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        :param _builtins.bool prefix_compression: Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation. Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
        if block_compressor is not None:
            pulumi.set(__self__, "block_compressor", block_compressor)
        if cache_size_gb is not None:
            pulumi.set(__self__, "cache_size_gb", cache_size_gb)
        if prefix_compression is not None:
            pulumi.set(__self__, "prefix_compression", prefix_compression)

    @_builtins.property
    @pulumi.getter(name="blockCompressor")
    def block_compressor(self) -> Optional[_builtins.str]:
        """
        Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation. Specifies the default compression for collection data. You can override this on a per-collection basis when creating collections. Available compressors are: none, snappy, zlib, zstd. This setting available only on `mongod` hosts. For more information, see the [storage.wiredTiger.collectionConfig.blockCompressor](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.collectionConfig.blockCompressor) description in the official documentation.
        """
        return pulumi.get(self, "block_compressor")

    @_builtins.property
    @pulumi.getter(name="cacheSizeGb")
    def cache_size_gb(self) -> Optional[_builtins.float]:
        """
        Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation. Defines the maximum size of the internal cache that WiredTiger will use for all data. For more information, see the [storage.wiredTiger.engineConfig.cacheSizeGB](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.engineConfig.cacheSizeGB) description in the official documentation.
        """
        return pulumi.get(self, "cache_size_gb")

    @_builtins.property
    @pulumi.getter(name="prefixCompression")
    def prefix_compression(self) -> Optional[_builtins.bool]:
        """
        Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation. Enables or disables prefix compression for index data. an be either true or false. For more information, see the [storage.wiredTiger.indexConfig.prefixCompression](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-storage.wiredTiger.indexConfig.prefixCompression) description in the official documentation.
        """
        return pulumi.get(self, "prefix_compression")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongosResult(dict):
    def __init__(__self__, *,
                 net: Optional['outputs.GetMdbMongodbClusterClusterConfigMongosNetResult'] = None):
        """
        :param 'GetMdbMongodbClusterClusterConfigMongosNetArgs' net: A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        if net is not None:
            pulumi.set(__self__, "net", net)

    @_builtins.property
    @pulumi.getter
    def net(self) -> Optional['outputs.GetMdbMongodbClusterClusterConfigMongosNetResult']:
        """
        A set of network settings (see the [net](https://www.mongodb.com/docs/manual/reference/configuration-options/#net-options) option).
        """
        return pulumi.get(self, "net")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigMongosNetResult(dict):
    def __init__(__self__, *,
                 compressors: Optional[Sequence[_builtins.str]] = None,
                 max_incoming_connections: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] compressors: Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation. Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        :param _builtins.int max_incoming_connections: The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation. The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        if compressors is not None:
            pulumi.set(__self__, "compressors", compressors)
        if max_incoming_connections is not None:
            pulumi.set(__self__, "max_incoming_connections", max_incoming_connections)

    @_builtins.property
    @pulumi.getter
    def compressors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation. Specifies the default compressor(s) to use for communication between this mongod or mongos. Accepts array of compressors. Order matters. Available compressors: snappy, zlib, zstd, disabled. To disable network compression, make `disabled` the only value. For more information, see the [net.Compression.Compressors](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.compression.compressors) description in the official documentation.
        """
        return pulumi.get(self, "compressors")

    @_builtins.property
    @pulumi.getter(name="maxIncomingConnections")
    def max_incoming_connections(self) -> Optional[_builtins.int]:
        """
        The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation. The maximum number of simultaneous connections that host will accept. For more information, see the [net.maxIncomingConnections](https://www.mongodb.com/docs/manual/reference/configuration-options/#mongodb-setting-net.maxIncomingConnections) description in the official documentation.
        """
        return pulumi.get(self, "max_incoming_connections")


@pulumi.output_type
class GetMdbMongodbClusterClusterConfigPerformanceDiagnosticsResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable or disable performance diagnostics. Enable or disable performance diagnostics.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable performance diagnostics. Enable or disable performance diagnostics.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetMdbMongodbClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the database. The name of the database.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the database. The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongocfgResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: Optional[_builtins.int] = None,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[_builtins.int]:
        """
        Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongodResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: Optional[_builtins.int] = None,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[_builtins.int]:
        """
        Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongoinfraResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: Optional[_builtins.int] = None,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[_builtins.int]:
        """
        Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbMongodbClusterDiskSizeAutoscalingMongosResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: Optional[_builtins.int] = None,
                 emergency_usage_threshold: Optional[_builtins.int] = None,
                 planned_usage_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        if disk_size_limit is not None:
            pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        if emergency_usage_threshold is not None:
            pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        if planned_usage_threshold is not None:
            pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> Optional[_builtins.int]:
        """
        Limit of disk size after autoscaling (GiB). Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Immediate autoscaling disk usage (percent). Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> Optional[_builtins.int]:
        """
        Maintenance window autoscaling disk usage (percent). Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbMongodbClusterHostResult(dict):
    def __init__(__self__, *,
                 health: _builtins.str,
                 host_parameters: 'outputs.GetMdbMongodbClusterHostHostParametersResult',
                 name: _builtins.str,
                 role: _builtins.str,
                 shard_name: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str health: The health of the host. The health of the host.
        :param 'GetMdbMongodbClusterHostHostParametersArgs' host_parameters: The parameters of mongod host in replicaset.
        :param _builtins.str name: The fully qualified domain name of the host. Computed on server side. The fully qualified domain name of the host. Computed on server side.
        :param _builtins.str role: The role of the cluster (either PRIMARY or SECONDARY). The role of the cluster (either PRIMARY or SECONDARY).
        :param _builtins.str shard_name: The name of the shard to which the host belongs. Only for sharded cluster. The name of the shard to which the host belongs. Only for sharded cluster.
        :param _builtins.bool assign_public_ip: Should this host have assigned public IP assigned. Can be either `true` or `false`. Should this host have assigned public IP assigned. Can be either `true` or `false`.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs. The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.str type: Type of Mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to `mongod`. Type of Mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to `mongod`.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used. The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "health", health)
        pulumi.set(__self__, "host_parameters", host_parameters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "shard_name", shard_name)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def health(self) -> _builtins.str:
        """
        The health of the host. The health of the host.
        """
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="hostParameters")
    def host_parameters(self) -> 'outputs.GetMdbMongodbClusterHostHostParametersResult':
        """
        The parameters of mongod host in replicaset.
        """
        return pulumi.get(self, "host_parameters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The fully qualified domain name of the host. Computed on server side. The fully qualified domain name of the host. Computed on server side.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the cluster (either PRIMARY or SECONDARY). The role of the cluster (either PRIMARY or SECONDARY).
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> _builtins.str:
        """
        The name of the shard to which the host belongs. Only for sharded cluster. The name of the shard to which the host belongs. Only for sharded cluster.
        """
        return pulumi.get(self, "shard_name")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Should this host have assigned public IP assigned. Can be either `true` or `false`. Should this host have assigned public IP assigned. Can be either `true` or `false`.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs. The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to `mongod`. Type of Mongo daemon which runs on this host (mongod, mongos, mongocfg, mongoinfra). Defaults to `mongod`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used. The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetMdbMongodbClusterHostHostParametersResult(dict):
    def __init__(__self__, *,
                 hidden: Optional[_builtins.bool] = None,
                 priority: Optional[_builtins.float] = None,
                 secondary_delay_secs: Optional[_builtins.int] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.bool hidden: Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden). Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden).
        :param _builtins.float priority: A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority). A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority).
        :param _builtins.int secondary_delay_secs: The number of seconds `behind` the primary that this replica set member should `lag`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs). The number of seconds `behind` the primary that this replica set member should `lag`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs).
        :param Mapping[str, _builtins.str] tags: A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags). A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags).
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if secondary_delay_secs is not None:
            pulumi.set(__self__, "secondary_delay_secs", secondary_delay_secs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> Optional[_builtins.bool]:
        """
        Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden). Should this host be hidden in replicaset. Can be either `true` of `false`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.hidden).
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority). A floating point number that indicates the relative likelihood of a replica set member to become the primary. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.priority).
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="secondaryDelaySecs")
    def secondary_delay_secs(self) -> Optional[_builtins.int]:
        """
        The number of seconds `behind` the primary that this replica set member should `lag`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs). The number of seconds `behind` the primary that this replica set member should `lag`. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.secondaryDelaySecs).
        """
        return pulumi.get(self, "secondary_delay_secs")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags). A set of key/value pairs to assign for the replica set member. For more information see [the official documentation](https://www.mongodb.com/docs/current/reference/replica-configuration/#mongodb-rsconf-rsconf.members-n-.tags).
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetMdbMongodbClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: Optional[_builtins.str] = None,
                 hour: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`. Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly. Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window. Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`. Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly. Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window. Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbMongodbClusterResourcesResult(dict):
    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMongodbClusterResourcesMongocfgResult(dict):
    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMongodbClusterResourcesMongodResult(dict):
    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMongodbClusterResourcesMongoinfraResult(dict):
    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMongodbClusterResourcesMongosResult(dict):
    def __init__(__self__, *,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type_id: Optional[_builtins.str] = None,
                 resource_preset_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type_id is not None:
            pulumi.set(__self__, "disk_type_id", disk_type_id)
        if resource_preset_id is not None:
            pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        Volume of the storage available to a MongoDB host, in gigabytes. Volume of the storage available to a MongoDB host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> Optional[_builtins.str]:
        """
        Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage). Type of the storage of MongoDB hosts. For more information see [the official documentation](https://yandex.cloud/docs/managed-clickhouse/concepts/storage).
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> Optional[_builtins.str]:
        """
        The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts). The ID of the preset for computational resources available to a MongoDB host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMongodbClusterRestoreResult(dict):
    def __init__(__self__, *,
                 backup_id: Optional[_builtins.str] = None,
                 time: Optional[_builtins.str] = None):
        """
        :param _builtins.str backup_id: Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups). Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups).
        :param _builtins.str time: Timestamp of the moment to which the MongoDB cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used. Timestamp of the moment to which the MongoDB cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[_builtins.str]:
        """
        Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups). Backup ID. The cluster will be created from the specified backup. [How to get a list of PostgreSQL backups](https://yandex.cloud/docs/managed-mongodb/operations/cluster-backups).
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[_builtins.str]:
        """
        Timestamp of the moment to which the MongoDB cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used. Timestamp of the moment to which the MongoDB cluster should be restored. (Format: `2006-01-02T15:04:05` - UTC). When not set, current time is used.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetMdbMongodbClusterUserResult(dict):
    def __init__(__self__, *,
                 permissions: Sequence['outputs.GetMdbMongodbClusterUserPermissionResult'],
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param Sequence['GetMdbMongodbClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        :param _builtins.str name: The name of the user. The name of the user.
        :param _builtins.str password: The password of the user. The password of the user.
        """
        pulumi.set(__self__, "permissions", permissions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbMongodbClusterUserPermissionResult']:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the user. The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password of the user. The password of the user.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetMdbMongodbClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: Optional[_builtins.str] = None,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to. The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: The roles of the user in this database. For more information see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts/users-and-roles). The roles of the user in this database. For more information see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts/users-and-roles).
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The name of the database that the permission grants access to. The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        The roles of the user in this database. For more information see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts/users-and-roles). The roles of the user in this database. For more information see [the official documentation](https://yandex.cloud/docs/managed-mongodb/concepts/users-and-roles).
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetMdbMysqlClusterAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: _builtins.bool,
                 data_transfer: _builtins.bool,
                 web_sql: _builtins.bool):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens). Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer). Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        :param _builtins.bool web_sql: Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query). Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "data_transfer", data_transfer)
        pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> _builtins.bool:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens). Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> _builtins.bool:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer). Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> _builtins.bool:
        """
        Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query). Allows access for [SQL queries in the management console](https://yandex.cloud/docs/managed-mysql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbMysqlClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: The hour at which backup will be started (UTC).
        :param _builtins.int minutes: The minute at which backup will be started (UTC).
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        The minute at which backup will be started (UTC).
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbMysqlClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbMysqlClusterDiskSizeAutoscalingResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: _builtins.int,
                 planned_usage_threshold: _builtins.int):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> _builtins.int:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> _builtins.int:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbMysqlClusterHostResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 replication_source: _builtins.str,
                 subnet_id: _builtins.str,
                 zone: _builtins.str,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 backup_priority: Optional[_builtins.int] = None,
                 priority: Optional[_builtins.int] = None):
        """
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        :param _builtins.int backup_priority: Host backup priority. Value is between 0 and 100, default is 0.
        :param _builtins.int priority: Host master promotion priority. Value is between 0 and 100, default is 0.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "replication_source", replication_source)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if backup_priority is not None:
            pulumi.set(__self__, "backup_priority", backup_priority)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> _builtins.str:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        """
        Sets whether the host should get a public IP address. It can be changed on the fly only when `name` is set.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="backupPriority")
    def backup_priority(self) -> Optional[_builtins.int]:
        """
        Host backup priority. Value is between 0 and 100, default is 0.
        """
        return pulumi.get(self, "backup_priority")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Host master promotion priority. Value is between 0 and 100, default is 0.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetMdbMysqlClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.int:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbMysqlClusterPerformanceDiagnosticResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 sessions_sampling_interval: _builtins.int,
                 statements_sampling_interval: _builtins.int):
        """
        :param _builtins.bool enabled: Enable performance diagnostics.
        :param _builtins.int sessions_sampling_interval: Interval (in seconds) for my*stat*activity sampling Acceptable values are 1 to 86400, inclusive.
        :param _builtins.int statements_sampling_interval: Interval (in seconds) for my*stat*statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable performance diagnostics.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for my*stat*activity sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @_builtins.property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for my*stat*statements sampling Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")


@pulumi.output_type
class GetMdbMysqlClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a MySQL host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of MySQL hosts.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a MySQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mysql/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a MySQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of MySQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a MySQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-mysql/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbMysqlClusterUserResult(dict):
    def __init__(__self__, *,
                 authentication_plugin: _builtins.str,
                 connection_limits: Sequence['outputs.GetMdbMysqlClusterUserConnectionLimitResult'],
                 global_permissions: Sequence[_builtins.str],
                 name: _builtins.str,
                 password: _builtins.str,
                 permissions: Sequence['outputs.GetMdbMysqlClusterUserPermissionResult']):
        """
        :param _builtins.str authentication_plugin: Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH`).
        :param Sequence['GetMdbMysqlClusterUserConnectionLimitArgs'] connection_limits: User's connection limits. If not specified there will be no changes. Default value is -1. When these parameters are set to -1, backend default values will be actually used.
        :param Sequence[_builtins.str] global_permissions: List user's global permissions. Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS`, `FLUSH_OPTIMIZER_COSTS`, `SHOW_ROUTINE`, `MDB_ADMIN` for clear list use empty list. If the attribute is not specified there will be no changes.
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param Sequence['GetMdbMysqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "authentication_plugin", authentication_plugin)
        pulumi.set(__self__, "connection_limits", connection_limits)
        pulumi.set(__self__, "global_permissions", global_permissions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter(name="authenticationPlugin")
    def authentication_plugin(self) -> _builtins.str:
        """
        Authentication plugin. Allowed values: `MYSQL_NATIVE_PASSWORD`, `CACHING_SHA2_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH` (for version 5.7 `MYSQL_NATIVE_PASSWORD`, `SHA256_PASSWORD`, `MYSQL_NO_LOGIN`, `MDB_IAMPROXY_AUTH`).
        """
        return pulumi.get(self, "authentication_plugin")

    @_builtins.property
    @pulumi.getter(name="connectionLimits")
    def connection_limits(self) -> Sequence['outputs.GetMdbMysqlClusterUserConnectionLimitResult']:
        """
        User's connection limits. If not specified there will be no changes. Default value is -1. When these parameters are set to -1, backend default values will be actually used.
        """
        return pulumi.get(self, "connection_limits")

    @_builtins.property
    @pulumi.getter(name="globalPermissions")
    def global_permissions(self) -> Sequence[_builtins.str]:
        """
        List user's global permissions. Allowed permissions: `REPLICATION_CLIENT`, `REPLICATION_SLAVE`, `PROCESS`, `FLUSH_OPTIMIZER_COSTS`, `SHOW_ROUTINE`, `MDB_ADMIN` for clear list use empty list. If the attribute is not specified there will be no changes.
        """
        return pulumi.get(self, "global_permissions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbMysqlClusterUserPermissionResult']:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbMysqlClusterUserConnectionLimitResult(dict):
    def __init__(__self__, *,
                 max_connections_per_hour: _builtins.int,
                 max_questions_per_hour: _builtins.int,
                 max_updates_per_hour: _builtins.int,
                 max_user_connections: _builtins.int):
        """
        :param _builtins.int max_connections_per_hour: Max connections per hour.
        :param _builtins.int max_questions_per_hour: Max questions per hour.
        :param _builtins.int max_updates_per_hour: Max updates per hour.
        :param _builtins.int max_user_connections: Max user connections.
        """
        pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        pulumi.set(__self__, "max_user_connections", max_user_connections)

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> _builtins.int:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> _builtins.int:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> _builtins.int:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> _builtins.int:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")


@pulumi.output_type
class GetMdbMysqlClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetMdbMysqlUserConnectionLimitResult(dict):
    def __init__(__self__, *,
                 max_connections_per_hour: _builtins.int,
                 max_questions_per_hour: _builtins.int,
                 max_updates_per_hour: _builtins.int,
                 max_user_connections: _builtins.int):
        """
        :param _builtins.int max_connections_per_hour: Max connections per hour.
        :param _builtins.int max_questions_per_hour: Max questions per hour.
        :param _builtins.int max_updates_per_hour: Max updates per hour.
        :param _builtins.int max_user_connections: Max user connections.
        """
        pulumi.set(__self__, "max_connections_per_hour", max_connections_per_hour)
        pulumi.set(__self__, "max_questions_per_hour", max_questions_per_hour)
        pulumi.set(__self__, "max_updates_per_hour", max_updates_per_hour)
        pulumi.set(__self__, "max_user_connections", max_user_connections)

    @_builtins.property
    @pulumi.getter(name="maxConnectionsPerHour")
    def max_connections_per_hour(self) -> _builtins.int:
        """
        Max connections per hour.
        """
        return pulumi.get(self, "max_connections_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxQuestionsPerHour")
    def max_questions_per_hour(self) -> _builtins.int:
        """
        Max questions per hour.
        """
        return pulumi.get(self, "max_questions_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUpdatesPerHour")
    def max_updates_per_hour(self) -> _builtins.int:
        """
        Max updates per hour.
        """
        return pulumi.get(self, "max_updates_per_hour")

    @_builtins.property
    @pulumi.getter(name="maxUserConnections")
    def max_user_connections(self) -> _builtins.int:
        """
        Max user connections.
        """
        return pulumi.get(self, "max_user_connections")


@pulumi.output_type
class GetMdbMysqlUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        List user's roles in the database. Allowed roles: `ALL`,`ALTER`,`ALTER_ROUTINE`,`CREATE`,`CREATE_ROUTINE`,`CREATE_TEMPORARY_TABLES`, `CREATE_VIEW`,`DELETE`,`DROP`,`EVENT`,`EXECUTE`,`INDEX`,`INSERT`,`LOCK_TABLES`,`SELECT`,`SHOW_VIEW`,`TRIGGER`,`UPDATE`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigResult(dict):
    def __init__(__self__, *,
                 accesses: Sequence['outputs.GetMdbPostgresqlClusterConfigAccessResult'],
                 autofailover: _builtins.bool,
                 backup_retain_period_days: _builtins.int,
                 backup_window_starts: Sequence['outputs.GetMdbPostgresqlClusterConfigBackupWindowStartResult'],
                 disk_size_autoscalings: Sequence['outputs.GetMdbPostgresqlClusterConfigDiskSizeAutoscalingResult'],
                 performance_diagnostics: Sequence['outputs.GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult'],
                 pooler_configs: Sequence['outputs.GetMdbPostgresqlClusterConfigPoolerConfigResult'],
                 postgresql_config: Mapping[str, _builtins.str],
                 resources: Sequence['outputs.GetMdbPostgresqlClusterConfigResourceResult'],
                 version: _builtins.str):
        """
        :param Sequence['GetMdbPostgresqlClusterConfigAccessArgs'] accesses: Access policy to the PostgreSQL cluster.
        :param _builtins.bool autofailover: Configuration setting which enables/disables autofailover in cluster.
        :param _builtins.int backup_retain_period_days: The period in days during which backups are stored.
        :param Sequence['GetMdbPostgresqlClusterConfigBackupWindowStartArgs'] backup_window_starts: Time to start the daily backup, in the UTC timezone.
        :param Sequence['GetMdbPostgresqlClusterConfigDiskSizeAutoscalingArgs'] disk_size_autoscalings: Cluster disk size autoscaling settings.
        :param Sequence['GetMdbPostgresqlClusterConfigPerformanceDiagnosticArgs'] performance_diagnostics: Cluster performance diagnostics settings. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics).
        :param Sequence['GetMdbPostgresqlClusterConfigPoolerConfigArgs'] pooler_configs: Configuration of the connection pooler.
        :param Mapping[str, _builtins.str] postgresql_config: PostgreSQL cluster configuration. For detailed information specific to your PostgreSQL version, please refer to the [API proto specifications](https://github.com/yandex-cloud/cloudapi/tree/master/yandex/cloud/mdb/postgresql/v1/config).
        :param Sequence['GetMdbPostgresqlClusterConfigResourceArgs'] resources: Resources allocated to hosts of the PostgreSQL cluster.
        :param _builtins.str version: Version of the PostgreSQL cluster. (allowed versions are: 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17).
        """
        pulumi.set(__self__, "accesses", accesses)
        pulumi.set(__self__, "autofailover", autofailover)
        pulumi.set(__self__, "backup_retain_period_days", backup_retain_period_days)
        pulumi.set(__self__, "backup_window_starts", backup_window_starts)
        pulumi.set(__self__, "disk_size_autoscalings", disk_size_autoscalings)
        pulumi.set(__self__, "performance_diagnostics", performance_diagnostics)
        pulumi.set(__self__, "pooler_configs", pooler_configs)
        pulumi.set(__self__, "postgresql_config", postgresql_config)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def accesses(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigAccessResult']:
        """
        Access policy to the PostgreSQL cluster.
        """
        return pulumi.get(self, "accesses")

    @_builtins.property
    @pulumi.getter
    def autofailover(self) -> _builtins.bool:
        """
        Configuration setting which enables/disables autofailover in cluster.
        """
        return pulumi.get(self, "autofailover")

    @_builtins.property
    @pulumi.getter(name="backupRetainPeriodDays")
    def backup_retain_period_days(self) -> _builtins.int:
        """
        The period in days during which backups are stored.
        """
        return pulumi.get(self, "backup_retain_period_days")

    @_builtins.property
    @pulumi.getter(name="backupWindowStarts")
    def backup_window_starts(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigBackupWindowStartResult']:
        """
        Time to start the daily backup, in the UTC timezone.
        """
        return pulumi.get(self, "backup_window_starts")

    @_builtins.property
    @pulumi.getter(name="diskSizeAutoscalings")
    def disk_size_autoscalings(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigDiskSizeAutoscalingResult']:
        """
        Cluster disk size autoscaling settings.
        """
        return pulumi.get(self, "disk_size_autoscalings")

    @_builtins.property
    @pulumi.getter(name="performanceDiagnostics")
    def performance_diagnostics(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult']:
        """
        Cluster performance diagnostics settings. [YC Documentation](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/cluster_service#PerformanceDiagnostics).
        """
        return pulumi.get(self, "performance_diagnostics")

    @_builtins.property
    @pulumi.getter(name="poolerConfigs")
    def pooler_configs(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigPoolerConfigResult']:
        """
        Configuration of the connection pooler.
        """
        return pulumi.get(self, "pooler_configs")

    @_builtins.property
    @pulumi.getter(name="postgresqlConfig")
    def postgresql_config(self) -> Mapping[str, _builtins.str]:
        """
        PostgreSQL cluster configuration. For detailed information specific to your PostgreSQL version, please refer to the [API proto specifications](https://github.com/yandex-cloud/cloudapi/tree/master/yandex/cloud/mdb/postgresql/v1/config).
        """
        return pulumi.get(self, "postgresql_config")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetMdbPostgresqlClusterConfigResourceResult']:
        """
        Resources allocated to hosts of the PostgreSQL cluster.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the PostgreSQL cluster. (allowed versions are: 13, 13-1c, 14, 14-1c, 15, 15-1c, 16, 17).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigAccessResult(dict):
    def __init__(__self__, *,
                 data_lens: _builtins.bool,
                 data_transfer: _builtins.bool,
                 serverless: _builtins.bool,
                 web_sql: _builtins.bool):
        """
        :param _builtins.bool data_lens: Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        :param _builtins.bool data_transfer: Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        :param _builtins.bool serverless: Allow access for [connection to managed databases from functions](https://yandex.cloud/docs/functions/operations/database-connection).
        :param _builtins.bool web_sql: Allow access for [SQL queries in the management console](https://yandex.cloud/docs/managed-postgresql/operations/web-sql-query).
        """
        pulumi.set(__self__, "data_lens", data_lens)
        pulumi.set(__self__, "data_transfer", data_transfer)
        pulumi.set(__self__, "serverless", serverless)
        pulumi.set(__self__, "web_sql", web_sql)

    @_builtins.property
    @pulumi.getter(name="dataLens")
    def data_lens(self) -> _builtins.bool:
        """
        Allow access for [Yandex DataLens](https://yandex.cloud/services/datalens).
        """
        return pulumi.get(self, "data_lens")

    @_builtins.property
    @pulumi.getter(name="dataTransfer")
    def data_transfer(self) -> _builtins.bool:
        """
        Allow access for [DataTransfer](https://yandex.cloud/services/data-transfer).
        """
        return pulumi.get(self, "data_transfer")

    @_builtins.property
    @pulumi.getter
    def serverless(self) -> _builtins.bool:
        """
        Allow access for [connection to managed databases from functions](https://yandex.cloud/docs/functions/operations/database-connection).
        """
        return pulumi.get(self, "serverless")

    @_builtins.property
    @pulumi.getter(name="webSql")
    def web_sql(self) -> _builtins.bool:
        """
        Allow access for [SQL queries in the management console](https://yandex.cloud/docs/managed-postgresql/operations/web-sql-query).
        """
        return pulumi.get(self, "web_sql")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        """
        :param _builtins.int hours: The hour at which backup will be started (UTC).
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        """
        The hour at which backup will be started (UTC).
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigDiskSizeAutoscalingResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: _builtins.int,
                 planned_usage_threshold: _builtins.int):
        """
        :param _builtins.int disk_size_limit: The overall maximum for disk size that limit all autoscaling iterations. See the [documentation](https://yandex.cloud/en/docs/managed-postgresql/concepts/storage#auto-rescale) for details.
        :param _builtins.int emergency_usage_threshold: Threshold of storage usage (in percent) that triggers immediate automatic scaling of the storage. Zero value means disabled threshold.
        :param _builtins.int planned_usage_threshold: Threshold of storage usage (in percent) that triggers automatic scaling of the storage during the maintenance window. Zero value means disabled threshold.
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        The overall maximum for disk size that limit all autoscaling iterations. See the [documentation](https://yandex.cloud/en/docs/managed-postgresql/concepts/storage#auto-rescale) for details.
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> _builtins.int:
        """
        Threshold of storage usage (in percent) that triggers immediate automatic scaling of the storage. Zero value means disabled threshold.
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> _builtins.int:
        """
        Threshold of storage usage (in percent) that triggers automatic scaling of the storage during the maintenance window. Zero value means disabled threshold.
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigPerformanceDiagnosticResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 sessions_sampling_interval: _builtins.int,
                 statements_sampling_interval: _builtins.int):
        """
        :param _builtins.bool enabled: Enable performance diagnostics.
        :param _builtins.int sessions_sampling_interval: Interval (in seconds) for pg*stat*activity sampling. Acceptable values are 1 to 86400, inclusive.
        :param _builtins.int statements_sampling_interval: Interval (in seconds) for pg*stat*statements sampling. Acceptable values are 1 to 86400, inclusive.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "sessions_sampling_interval", sessions_sampling_interval)
        pulumi.set(__self__, "statements_sampling_interval", statements_sampling_interval)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable performance diagnostics.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="sessionsSamplingInterval")
    def sessions_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for pg*stat*activity sampling. Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "sessions_sampling_interval")

    @_builtins.property
    @pulumi.getter(name="statementsSamplingInterval")
    def statements_sampling_interval(self) -> _builtins.int:
        """
        Interval (in seconds) for pg*stat*statements sampling. Acceptable values are 1 to 86400, inclusive.
        """
        return pulumi.get(self, "statements_sampling_interval")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigPoolerConfigResult(dict):
    def __init__(__self__, *,
                 pool_discard: _builtins.bool,
                 pooling_mode: _builtins.str):
        """
        :param _builtins.bool pool_discard: Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        :param _builtins.str pooling_mode: Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        pulumi.set(__self__, "pool_discard", pool_discard)
        pulumi.set(__self__, "pooling_mode", pooling_mode)

    @_builtins.property
    @pulumi.getter(name="poolDiscard")
    def pool_discard(self) -> _builtins.bool:
        """
        Setting `pool_discard` [parameter in Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool_discard-yesno).
        """
        return pulumi.get(self, "pool_discard")

    @_builtins.property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> _builtins.str:
        """
        Mode that the connection pooler is working in. See descriptions of all modes in the [documentation for Odyssey](https://github.com/yandex/odyssey/blob/master/documentation/configuration.md#pool-string.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class GetMdbPostgresqlClusterConfigResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a PostgreSQL host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of PostgreSQL hosts.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a PostgreSQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-postgresql/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a PostgreSQL host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of PostgreSQL hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a PostgreSQL host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-postgresql/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbPostgresqlClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 owner: _builtins.str,
                 extensions: Optional[Sequence['outputs.GetMdbPostgresqlClusterDatabaseExtensionResult']] = None,
                 lc_collate: Optional[_builtins.str] = None,
                 lc_type: Optional[_builtins.str] = None,
                 template_db: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The resource name.
        :param _builtins.str owner: Name of the user assigned as the owner of the database. Forbidden to change in an existing database.
        :param Sequence['GetMdbPostgresqlClusterDatabaseExtensionArgs'] extensions: Set of database extensions.
        :param _builtins.str lc_collate: POSIX locale for string sorting order. Forbidden to change in an existing database.
        :param _builtins.str lc_type: POSIX locale for character classification. Forbidden to change in an existing database.
        :param _builtins.str template_db: Name of the template database.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if lc_collate is not None:
            pulumi.set(__self__, "lc_collate", lc_collate)
        if lc_type is not None:
            pulumi.set(__self__, "lc_type", lc_type)
        if template_db is not None:
            pulumi.set(__self__, "template_db", template_db)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        Name of the user assigned as the owner of the database. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.GetMdbPostgresqlClusterDatabaseExtensionResult']]:
        """
        Set of database extensions.
        """
        return pulumi.get(self, "extensions")

    @_builtins.property
    @pulumi.getter(name="lcCollate")
    def lc_collate(self) -> Optional[_builtins.str]:
        """
        POSIX locale for string sorting order. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "lc_collate")

    @_builtins.property
    @pulumi.getter(name="lcType")
    def lc_type(self) -> Optional[_builtins.str]:
        """
        POSIX locale for character classification. Forbidden to change in an existing database.
        """
        return pulumi.get(self, "lc_type")

    @_builtins.property
    @pulumi.getter(name="templateDb")
    def template_db(self) -> Optional[_builtins.str]:
        """
        Name of the template database.
        """
        return pulumi.get(self, "template_db")


@pulumi.output_type
class GetMdbPostgresqlClusterDatabaseExtensionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        :param _builtins.str version: Version of the extension.
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the extension.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMdbPostgresqlClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 fqdn: _builtins.str,
                 priority: _builtins.int,
                 replication_source: _builtins.str,
                 role: _builtins.str,
                 subnet_id: _builtins.str,
                 zone: _builtins.str):
        """
        :param _builtins.bool assign_public_ip: Whether the host should get a public IP address.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.int priority: Host priority in HA group. It works only when `name` is set.
        :param _builtins.str replication_source: Host replication source (fqdn), when replication_source is empty then host is in HA group.
        :param _builtins.str role: Host's role (replica|primary), computed by server.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "replication_source", replication_source)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        """
        Whether the host should get a public IP address.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The field has not affected anything. You can safely delete it.""")
    def priority(self) -> _builtins.int:
        """
        Host priority in HA group. It works only when `name` is set.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="replicationSource")
    def replication_source(self) -> _builtins.str:
        """
        Host replication source (fqdn), when replication_source is empty then host is in HA group.
        """
        return pulumi.get(self, "replication_source")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Host's role (replica|primary), computed by server.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbPostgresqlClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str day: Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        :param _builtins.int hour: Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        Day of the week (in `DDD` format). Allowed values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.int:
        """
        Hour of the day in UTC (in `HH` format). Allowed value is between 1 and 24.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbPostgresqlClusterUserResult(dict):
    def __init__(__self__, *,
                 conn_limit: _builtins.int,
                 grants: Sequence[_builtins.str],
                 name: _builtins.str,
                 permissions: Sequence['outputs.GetMdbPostgresqlClusterUserPermissionResult'],
                 settings: Mapping[str, _builtins.str],
                 login: Optional[_builtins.bool] = None):
        """
        :param _builtins.int conn_limit: The maximum number of connections per user. (Default 50).
        :param Sequence[_builtins.str] grants: List of the user's grants.
        :param _builtins.str name: The name of the user.
        :param Sequence['GetMdbPostgresqlClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        :param Mapping[str, _builtins.str] settings: Map of user settings. [Full description](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/Cluster/create#yandex.cloud.mdb.postgresql.v1.UserSettings).
        :param _builtins.bool login: User's ability to login.
        """
        pulumi.set(__self__, "conn_limit", conn_limit)
        pulumi.set(__self__, "grants", grants)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "settings", settings)
        if login is not None:
            pulumi.set(__self__, "login", login)

    @_builtins.property
    @pulumi.getter(name="connLimit")
    def conn_limit(self) -> _builtins.int:
        """
        The maximum number of connections per user. (Default 50).
        """
        return pulumi.get(self, "conn_limit")

    @_builtins.property
    @pulumi.getter
    def grants(self) -> Sequence[_builtins.str]:
        """
        List of the user's grants.
        """
        return pulumi.get(self, "grants")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbPostgresqlClusterUserPermissionResult']:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Mapping[str, _builtins.str]:
        """
        Map of user settings. [Full description](https://yandex.cloud/docs/managed-postgresql/api-ref/grpc/Cluster/create#yandex.cloud.mdb.postgresql.v1.UserSettings).
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional[_builtins.bool]:
        """
        User's ability to login.
        """
        return pulumi.get(self, "login")


@pulumi.output_type
class GetMdbPostgresqlClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetMdbPostgresqlDatabaseExtensionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions). Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions). Name of the database extension. For more information on available extensions see [the official documentation](https://yandex.cloud/docs/managed-postgresql/operations/cluster-extensions).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbPostgresqlUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetMdbRedisClusterConfigResult(dict):
    def __init__(__self__, *,
                 allow_data_loss: _builtins.bool,
                 backup_window_starts: Sequence['outputs.GetMdbRedisClusterConfigBackupWindowStartResult'],
                 client_output_buffer_limit_normal: _builtins.str,
                 client_output_buffer_limit_pubsub: _builtins.str,
                 cluster_allow_pubsubshard_when_down: _builtins.bool,
                 cluster_allow_reads_when_down: _builtins.bool,
                 cluster_require_full_coverage: _builtins.bool,
                 databases: _builtins.int,
                 io_threads_allowed: _builtins.bool,
                 lfu_decay_time: _builtins.int,
                 lfu_log_factor: _builtins.int,
                 lua_time_limit: _builtins.int,
                 maxmemory_percent: _builtins.int,
                 maxmemory_policy: _builtins.str,
                 notify_keyspace_events: _builtins.str,
                 repl_backlog_size_percent: _builtins.int,
                 slowlog_log_slower_than: _builtins.int,
                 slowlog_max_len: _builtins.int,
                 timeout: _builtins.int,
                 turn_before_switchover: _builtins.bool,
                 use_luajit: _builtins.bool,
                 version: _builtins.str,
                 zset_max_listpack_entries: _builtins.int):
        """
        :param _builtins.bool allow_data_loss: Allows some data to be lost in favor of faster switchover/restart by RDSync.
        :param Sequence['GetMdbRedisClusterConfigBackupWindowStartArgs'] backup_window_starts: Time to start the daily backup, in the UTC timezone.
        :param _builtins.str client_output_buffer_limit_normal: Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        :param _builtins.str client_output_buffer_limit_pubsub: Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        :param _builtins.bool cluster_allow_pubsubshard_when_down: Permits Pub/Sub shard operations when cluster is down.
        :param _builtins.bool cluster_allow_reads_when_down: Allows read operations when cluster is down.
        :param _builtins.bool cluster_require_full_coverage: Controls whether all hash slots must be covered by nodes.
        :param _builtins.int databases: Number of databases (changing requires redis-server restart).
        :param _builtins.bool io_threads_allowed: Allow Redis to use io-threads.
        :param _builtins.int lfu_decay_time: The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        :param _builtins.int lfu_log_factor: Determines how the frequency counter represents key hits.
        :param _builtins.int lua_time_limit: Maximum time in milliseconds for Lua scripts.
        :param _builtins.int maxmemory_percent: Redis maxmemory usage in percent
        :param _builtins.str maxmemory_policy: Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        :param _builtins.str notify_keyspace_events: Select the events that Redis will notify among a set of classes.
        :param _builtins.int repl_backlog_size_percent: Replication backlog size as a percentage of flavor maxmemory.
        :param _builtins.int slowlog_log_slower_than: Log slow queries below this number in microseconds.
        :param _builtins.int slowlog_max_len: Slow queries log length.
        :param _builtins.int timeout: Close the connection after a client is idle for N seconds.
        :param _builtins.bool turn_before_switchover: Allows to turn before switchover in RDSync.
        :param _builtins.bool use_luajit: Use JIT for lua scripts and functions.
        :param _builtins.str version: Version of Redis.
        :param _builtins.int zset_max_listpack_entries: Controls max number of entries in zset before conversion from memory-efficient listpack to CPU-efficient hash table and skiplist
        """
        pulumi.set(__self__, "allow_data_loss", allow_data_loss)
        pulumi.set(__self__, "backup_window_starts", backup_window_starts)
        pulumi.set(__self__, "client_output_buffer_limit_normal", client_output_buffer_limit_normal)
        pulumi.set(__self__, "client_output_buffer_limit_pubsub", client_output_buffer_limit_pubsub)
        pulumi.set(__self__, "cluster_allow_pubsubshard_when_down", cluster_allow_pubsubshard_when_down)
        pulumi.set(__self__, "cluster_allow_reads_when_down", cluster_allow_reads_when_down)
        pulumi.set(__self__, "cluster_require_full_coverage", cluster_require_full_coverage)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "io_threads_allowed", io_threads_allowed)
        pulumi.set(__self__, "lfu_decay_time", lfu_decay_time)
        pulumi.set(__self__, "lfu_log_factor", lfu_log_factor)
        pulumi.set(__self__, "lua_time_limit", lua_time_limit)
        pulumi.set(__self__, "maxmemory_percent", maxmemory_percent)
        pulumi.set(__self__, "maxmemory_policy", maxmemory_policy)
        pulumi.set(__self__, "notify_keyspace_events", notify_keyspace_events)
        pulumi.set(__self__, "repl_backlog_size_percent", repl_backlog_size_percent)
        pulumi.set(__self__, "slowlog_log_slower_than", slowlog_log_slower_than)
        pulumi.set(__self__, "slowlog_max_len", slowlog_max_len)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "turn_before_switchover", turn_before_switchover)
        pulumi.set(__self__, "use_luajit", use_luajit)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "zset_max_listpack_entries", zset_max_listpack_entries)

    @_builtins.property
    @pulumi.getter(name="allowDataLoss")
    def allow_data_loss(self) -> _builtins.bool:
        """
        Allows some data to be lost in favor of faster switchover/restart by RDSync.
        """
        return pulumi.get(self, "allow_data_loss")

    @_builtins.property
    @pulumi.getter(name="backupWindowStarts")
    def backup_window_starts(self) -> Sequence['outputs.GetMdbRedisClusterConfigBackupWindowStartResult']:
        """
        Time to start the daily backup, in the UTC timezone.
        """
        return pulumi.get(self, "backup_window_starts")

    @_builtins.property
    @pulumi.getter(name="clientOutputBufferLimitNormal")
    def client_output_buffer_limit_normal(self) -> _builtins.str:
        """
        Normal clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1841).
        """
        return pulumi.get(self, "client_output_buffer_limit_normal")

    @_builtins.property
    @pulumi.getter(name="clientOutputBufferLimitPubsub")
    def client_output_buffer_limit_pubsub(self) -> _builtins.str:
        """
        Pubsub clients output buffer limits. See [redis config file](https://github.com/redis/redis/blob/6.2/redis.conf#L1843).
        """
        return pulumi.get(self, "client_output_buffer_limit_pubsub")

    @_builtins.property
    @pulumi.getter(name="clusterAllowPubsubshardWhenDown")
    def cluster_allow_pubsubshard_when_down(self) -> _builtins.bool:
        """
        Permits Pub/Sub shard operations when cluster is down.
        """
        return pulumi.get(self, "cluster_allow_pubsubshard_when_down")

    @_builtins.property
    @pulumi.getter(name="clusterAllowReadsWhenDown")
    def cluster_allow_reads_when_down(self) -> _builtins.bool:
        """
        Allows read operations when cluster is down.
        """
        return pulumi.get(self, "cluster_allow_reads_when_down")

    @_builtins.property
    @pulumi.getter(name="clusterRequireFullCoverage")
    def cluster_require_full_coverage(self) -> _builtins.bool:
        """
        Controls whether all hash slots must be covered by nodes.
        """
        return pulumi.get(self, "cluster_require_full_coverage")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> _builtins.int:
        """
        Number of databases (changing requires redis-server restart).
        """
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="ioThreadsAllowed")
    def io_threads_allowed(self) -> _builtins.bool:
        """
        Allow Redis to use io-threads.
        """
        return pulumi.get(self, "io_threads_allowed")

    @_builtins.property
    @pulumi.getter(name="lfuDecayTime")
    def lfu_decay_time(self) -> _builtins.int:
        """
        The time, in minutes, that must elapse in order for the key counter to be divided by two (or decremented if it has a value less <= 10).
        """
        return pulumi.get(self, "lfu_decay_time")

    @_builtins.property
    @pulumi.getter(name="lfuLogFactor")
    def lfu_log_factor(self) -> _builtins.int:
        """
        Determines how the frequency counter represents key hits.
        """
        return pulumi.get(self, "lfu_log_factor")

    @_builtins.property
    @pulumi.getter(name="luaTimeLimit")
    def lua_time_limit(self) -> _builtins.int:
        """
        Maximum time in milliseconds for Lua scripts.
        """
        return pulumi.get(self, "lua_time_limit")

    @_builtins.property
    @pulumi.getter(name="maxmemoryPercent")
    def maxmemory_percent(self) -> _builtins.int:
        """
        Redis maxmemory usage in percent
        """
        return pulumi.get(self, "maxmemory_percent")

    @_builtins.property
    @pulumi.getter(name="maxmemoryPolicy")
    def maxmemory_policy(self) -> _builtins.str:
        """
        Redis key eviction policy for a dataset that reaches maximum memory. Can be any of the listed in [the official RedisDB documentation](https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/).
        """
        return pulumi.get(self, "maxmemory_policy")

    @_builtins.property
    @pulumi.getter(name="notifyKeyspaceEvents")
    def notify_keyspace_events(self) -> _builtins.str:
        """
        Select the events that Redis will notify among a set of classes.
        """
        return pulumi.get(self, "notify_keyspace_events")

    @_builtins.property
    @pulumi.getter(name="replBacklogSizePercent")
    def repl_backlog_size_percent(self) -> _builtins.int:
        """
        Replication backlog size as a percentage of flavor maxmemory.
        """
        return pulumi.get(self, "repl_backlog_size_percent")

    @_builtins.property
    @pulumi.getter(name="slowlogLogSlowerThan")
    def slowlog_log_slower_than(self) -> _builtins.int:
        """
        Log slow queries below this number in microseconds.
        """
        return pulumi.get(self, "slowlog_log_slower_than")

    @_builtins.property
    @pulumi.getter(name="slowlogMaxLen")
    def slowlog_max_len(self) -> _builtins.int:
        """
        Slow queries log length.
        """
        return pulumi.get(self, "slowlog_max_len")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        Close the connection after a client is idle for N seconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="turnBeforeSwitchover")
    def turn_before_switchover(self) -> _builtins.bool:
        """
        Allows to turn before switchover in RDSync.
        """
        return pulumi.get(self, "turn_before_switchover")

    @_builtins.property
    @pulumi.getter(name="useLuajit")
    def use_luajit(self) -> _builtins.bool:
        """
        Use JIT for lua scripts and functions.
        """
        return pulumi.get(self, "use_luajit")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of Redis.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="zsetMaxListpackEntries")
    def zset_max_listpack_entries(self) -> _builtins.int:
        """
        Controls max number of entries in zset before conversion from memory-efficient listpack to CPU-efficient hash table and skiplist
        """
        return pulumi.get(self, "zset_max_listpack_entries")


@pulumi.output_type
class GetMdbRedisClusterConfigBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbRedisClusterDiskSizeAutoscalingResult(dict):
    def __init__(__self__, *,
                 disk_size_limit: _builtins.int,
                 emergency_usage_threshold: _builtins.int,
                 planned_usage_threshold: _builtins.int):
        """
        :param _builtins.int disk_size_limit: Limit of disk size after autoscaling (GiB).
        :param _builtins.int emergency_usage_threshold: Immediate autoscaling disk usage (percent).
        :param _builtins.int planned_usage_threshold: Maintenance window autoscaling disk usage (percent).
        """
        pulumi.set(__self__, "disk_size_limit", disk_size_limit)
        pulumi.set(__self__, "emergency_usage_threshold", emergency_usage_threshold)
        pulumi.set(__self__, "planned_usage_threshold", planned_usage_threshold)

    @_builtins.property
    @pulumi.getter(name="diskSizeLimit")
    def disk_size_limit(self) -> _builtins.int:
        """
        Limit of disk size after autoscaling (GiB).
        """
        return pulumi.get(self, "disk_size_limit")

    @_builtins.property
    @pulumi.getter(name="emergencyUsageThreshold")
    def emergency_usage_threshold(self) -> _builtins.int:
        """
        Immediate autoscaling disk usage (percent).
        """
        return pulumi.get(self, "emergency_usage_threshold")

    @_builtins.property
    @pulumi.getter(name="plannedUsageThreshold")
    def planned_usage_threshold(self) -> _builtins.int:
        """
        Maintenance window autoscaling disk usage (percent).
        """
        return pulumi.get(self, "planned_usage_threshold")


@pulumi.output_type
class GetMdbRedisClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 fqdn: _builtins.str,
                 replica_priority: _builtins.int,
                 shard_name: _builtins.str,
                 subnet_id: _builtins.str,
                 zone: _builtins.str):
        """
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address or not.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.int replica_priority: Replica priority of a current replica (usable for non-sharded only).
        :param _builtins.str shard_name: The name of the shard to which the host belongs.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "replica_priority", replica_priority)
        pulumi.set(__self__, "shard_name", shard_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        """
        Sets whether the host should get a public IP address or not.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="replicaPriority")
    def replica_priority(self) -> _builtins.int:
        """
        Replica priority of a current replica (usable for non-sharded only).
        """
        return pulumi.get(self, "replica_priority")

    @_builtins.property
    @pulumi.getter(name="shardName")
    def shard_name(self) -> _builtins.str:
        """
        The name of the shard to which the host belongs.
        """
        return pulumi.get(self, "shard_name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbRedisClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str day: Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        :param _builtins.int hour: Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        :param _builtins.str type: Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        Day of week for maintenance window if window type is weekly. Possible values: `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`, `SUN`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.int:
        """
        Hour of day in UTC time zone (1-24) for maintenance window if window type is weekly.
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of maintenance window. Can be either `ANYTIME` or `WEEKLY`. A day and hour of window need to be specified with weekly window.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMdbRedisClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of Redis hosts - environment default is used if missing.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-redis/concepts).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of Redis hosts - environment default is used if missing.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-redis/concepts).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbSqlserverClusterBackupWindowStartResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        """
        :param _builtins.int hours: The hour at which backup will be started.
        :param _builtins.int minutes: The minute at which backup will be started.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        """
        The hour at which backup will be started.
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        """
        The minute at which backup will be started.
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetMdbSqlserverClusterDatabaseResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the database.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the database.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMdbSqlserverClusterHostResult(dict):
    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 fqdn: _builtins.str,
                 subnet_id: _builtins.str,
                 zone: _builtins.str):
        """
        :param _builtins.bool assign_public_ip: Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        :param _builtins.str fqdn: The fully qualified domain name of the host.
        :param _builtins.str subnet_id: The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        :param _builtins.str zone: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        """
        Sets whether the host should get a public IP address on creation. Changing this parameter for an existing host is not supported at the moment.
        """
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        The fully qualified domain name of the host.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet, to which the host belongs. The subnet must be a part of the network to which the cluster belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetMdbSqlserverClusterResourceResult(dict):
    def __init__(__self__, *,
                 disk_size: _builtins.int,
                 disk_type_id: _builtins.str,
                 resource_preset_id: _builtins.str):
        """
        :param _builtins.int disk_size: Volume of the storage available to a SQLServer host, in gigabytes.
        :param _builtins.str disk_type_id: Type of the storage of SQLServer hosts.
        :param _builtins.str resource_preset_id: The ID of the preset for computational resources available to a SQLServer host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-sqlserver/concepts/instance-types).
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type_id", disk_type_id)
        pulumi.set(__self__, "resource_preset_id", resource_preset_id)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.int:
        """
        Volume of the storage available to a SQLServer host, in gigabytes.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskTypeId")
    def disk_type_id(self) -> _builtins.str:
        """
        Type of the storage of SQLServer hosts.
        """
        return pulumi.get(self, "disk_type_id")

    @_builtins.property
    @pulumi.getter(name="resourcePresetId")
    def resource_preset_id(self) -> _builtins.str:
        """
        The ID of the preset for computational resources available to a SQLServer host (CPU, memory etc.). For more information, see [the official documentation](https://yandex.cloud/docs/managed-sqlserver/concepts/instance-types).
        """
        return pulumi.get(self, "resource_preset_id")


@pulumi.output_type
class GetMdbSqlserverClusterUserResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 password: _builtins.str,
                 permissions: Sequence['outputs.GetMdbSqlserverClusterUserPermissionResult']):
        """
        :param _builtins.str name: The name of the user.
        :param _builtins.str password: The password of the user.
        :param Sequence['GetMdbSqlserverClusterUserPermissionArgs'] permissions: Set of permissions granted to the user.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence['outputs.GetMdbSqlserverClusterUserPermissionResult']:
        """
        Set of permissions granted to the user.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetMdbSqlserverClusterUserPermissionResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 roles: Sequence[_builtins.str]):
        """
        :param _builtins.str database_name: The name of the database that the permission grants access to.
        :param Sequence[_builtins.str] roles: List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of the database that the permission grants access to.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        List user's roles in the database. Allowed roles: `OWNER`, `SECURITYADMIN`, `ACCESSADMIN`, `BACKUPOPERATOR`, `DDLADMIN`, `DATAWRITER`, `DATAREADER`, `DENYDATAWRITER`, `DENYDATAREADER`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetMonitoringDashboardParametrizationResult(dict):
    def __init__(__self__, *,
                 parameters: Sequence['outputs.GetMonitoringDashboardParametrizationParameterResult'],
                 selectors: _builtins.str):
        """
        :param Sequence['GetMonitoringDashboardParametrizationParameterArgs'] parameters: Dashboard parameters.
        :param _builtins.str selectors: Dashboard predefined parameters selector.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetMonitoringDashboardParametrizationParameterResult']:
        """
        Dashboard parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> _builtins.str:
        """
        Dashboard predefined parameters selector.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class GetMonitoringDashboardParametrizationParameterResult(dict):
    def __init__(__self__, *,
                 customs: Sequence['outputs.GetMonitoringDashboardParametrizationParameterCustomResult'],
                 description: _builtins.str,
                 hidden: _builtins.bool,
                 id: _builtins.str,
                 label_values: Sequence['outputs.GetMonitoringDashboardParametrizationParameterLabelValueResult'],
                 texts: Sequence['outputs.GetMonitoringDashboardParametrizationParameterTextResult'],
                 title: _builtins.str):
        """
        :param Sequence['GetMonitoringDashboardParametrizationParameterCustomArgs'] customs: Custom values parameter. Oneof: label_values, custom, text.
        :param _builtins.str description: Parameter description.
        :param _builtins.bool hidden: UI-visibility
        :param _builtins.str id: Parameter identifier.
        :param Sequence['GetMonitoringDashboardParametrizationParameterLabelValueArgs'] label_values: Label values parameter. Oneof: label*values, custom, text.
        :param Sequence['GetMonitoringDashboardParametrizationParameterTextArgs'] texts: Text parameter. Oneof: label_values, custom, text.
        :param _builtins.str title: UI-visible title of the parameter.
        """
        pulumi.set(__self__, "customs", customs)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "hidden", hidden)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label_values", label_values)
        pulumi.set(__self__, "texts", texts)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Sequence['outputs.GetMonitoringDashboardParametrizationParameterCustomResult']:
        """
        Custom values parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> _builtins.bool:
        """
        UI-visibility
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Parameter identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="labelValues")
    def label_values(self) -> Sequence['outputs.GetMonitoringDashboardParametrizationParameterLabelValueResult']:
        """
        Label values parameter. Oneof: label*values, custom, text.
        """
        return pulumi.get(self, "label_values")

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Sequence['outputs.GetMonitoringDashboardParametrizationParameterTextResult']:
        """
        Text parameter. Oneof: label_values, custom, text.
        """
        return pulumi.get(self, "texts")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        UI-visible title of the parameter.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetMonitoringDashboardParametrizationParameterCustomResult(dict):
    def __init__(__self__, *,
                 default_values: Sequence[_builtins.str],
                 multiselectable: _builtins.bool,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] default_values: Default value.
        :param _builtins.bool multiselectable: Specifies the multiselectable values of parameter.
        :param Sequence[_builtins.str] values: Parameter values.
        """
        pulumi.set(__self__, "default_values", default_values)
        pulumi.set(__self__, "multiselectable", multiselectable)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Sequence[_builtins.str]:
        """
        Default value.
        """
        return pulumi.get(self, "default_values")

    @_builtins.property
    @pulumi.getter
    def multiselectable(self) -> _builtins.bool:
        """
        Specifies the multiselectable values of parameter.
        """
        return pulumi.get(self, "multiselectable")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetMonitoringDashboardParametrizationParameterLabelValueResult(dict):
    def __init__(__self__, *,
                 default_values: Sequence[_builtins.str],
                 folder_id: _builtins.str,
                 label_key: _builtins.str,
                 multiselectable: _builtins.bool,
                 selectors: _builtins.str):
        """
        :param Sequence[_builtins.str] default_values: Default value.
        :param _builtins.str folder_id: Folder ID.
        :param _builtins.str label_key: Label key to list label values.
        :param _builtins.bool multiselectable: Specifies the multiselectable values of parameter.
        :param _builtins.str selectors: Selectors to select metric label values.
        """
        pulumi.set(__self__, "default_values", default_values)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "label_key", label_key)
        pulumi.set(__self__, "multiselectable", multiselectable)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter(name="defaultValues")
    def default_values(self) -> Sequence[_builtins.str]:
        """
        Default value.
        """
        return pulumi.get(self, "default_values")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="labelKey")
    def label_key(self) -> _builtins.str:
        """
        Label key to list label values.
        """
        return pulumi.get(self, "label_key")

    @_builtins.property
    @pulumi.getter
    def multiselectable(self) -> _builtins.bool:
        """
        Specifies the multiselectable values of parameter.
        """
        return pulumi.get(self, "multiselectable")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> _builtins.str:
        """
        Selectors to select metric label values.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class GetMonitoringDashboardParametrizationParameterTextResult(dict):
    def __init__(__self__, *,
                 default_value: _builtins.str):
        """
        :param _builtins.str default_value: Default value.
        """
        pulumi.set(__self__, "default_value", default_value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        Default value.
        """
        return pulumi.get(self, "default_value")


@pulumi.output_type
class GetMonitoringDashboardWidgetResult(dict):
    def __init__(__self__, *,
                 charts: Sequence['outputs.GetMonitoringDashboardWidgetChartResult'],
                 positions: Sequence['outputs.GetMonitoringDashboardWidgetPositionResult'],
                 texts: Sequence['outputs.GetMonitoringDashboardWidgetTextResult'],
                 titles: Sequence['outputs.GetMonitoringDashboardWidgetTitleResult']):
        """
        :param Sequence['GetMonitoringDashboardWidgetChartArgs'] charts: Chart widget settings.
        :param Sequence['GetMonitoringDashboardWidgetPositionArgs'] positions: Widget layout position.
        :param Sequence['GetMonitoringDashboardWidgetTextArgs'] texts: Text widget settings.
        :param Sequence['GetMonitoringDashboardWidgetTitleArgs'] titles: Title widget settings.
        """
        pulumi.set(__self__, "charts", charts)
        pulumi.set(__self__, "positions", positions)
        pulumi.set(__self__, "texts", texts)
        pulumi.set(__self__, "titles", titles)

    @_builtins.property
    @pulumi.getter
    def charts(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartResult']:
        """
        Chart widget settings.
        """
        return pulumi.get(self, "charts")

    @_builtins.property
    @pulumi.getter
    def positions(self) -> Sequence['outputs.GetMonitoringDashboardWidgetPositionResult']:
        """
        Widget layout position.
        """
        return pulumi.get(self, "positions")

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Sequence['outputs.GetMonitoringDashboardWidgetTextResult']:
        """
        Text widget settings.
        """
        return pulumi.get(self, "texts")

    @_builtins.property
    @pulumi.getter
    def titles(self) -> Sequence['outputs.GetMonitoringDashboardWidgetTitleResult']:
        """
        Title widget settings.
        """
        return pulumi.get(self, "titles")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartResult(dict):
    def __init__(__self__, *,
                 chart_id: _builtins.str,
                 description: _builtins.str,
                 display_legend: _builtins.bool,
                 freeze: _builtins.str,
                 name_hiding_settings: Sequence['outputs.GetMonitoringDashboardWidgetChartNameHidingSettingResult'],
                 queries: Sequence['outputs.GetMonitoringDashboardWidgetChartQueryResult'],
                 series_overrides: Sequence['outputs.GetMonitoringDashboardWidgetChartSeriesOverrideResult'],
                 title: _builtins.str,
                 visualization_settings: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingResult']):
        """
        :param _builtins.str chart_id: Chart ID.
        :param _builtins.str description: Chart description in dashboard (not enabled in UI).
        :param _builtins.bool display_legend: Enable legend under chart.
        :param _builtins.str freeze: Fixed time interval for chart. Values:
        :param Sequence['GetMonitoringDashboardWidgetChartNameHidingSettingArgs'] name_hiding_settings: Name hiding settings
        :param Sequence['GetMonitoringDashboardWidgetChartQueryArgs'] queries: Queries settings.
        :param Sequence['GetMonitoringDashboardWidgetChartSeriesOverrideArgs'] series_overrides: Time series settings.
        :param _builtins.str title: Chart widget title.
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingArgs'] visualization_settings: Visualization settings.
        """
        pulumi.set(__self__, "chart_id", chart_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_legend", display_legend)
        pulumi.set(__self__, "freeze", freeze)
        pulumi.set(__self__, "name_hiding_settings", name_hiding_settings)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "series_overrides", series_overrides)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "visualization_settings", visualization_settings)

    @_builtins.property
    @pulumi.getter(name="chartId")
    def chart_id(self) -> _builtins.str:
        """
        Chart ID.
        """
        return pulumi.get(self, "chart_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Chart description in dashboard (not enabled in UI).
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayLegend")
    def display_legend(self) -> _builtins.bool:
        """
        Enable legend under chart.
        """
        return pulumi.get(self, "display_legend")

    @_builtins.property
    @pulumi.getter
    def freeze(self) -> _builtins.str:
        """
        Fixed time interval for chart. Values:
        """
        return pulumi.get(self, "freeze")

    @_builtins.property
    @pulumi.getter(name="nameHidingSettings")
    def name_hiding_settings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartNameHidingSettingResult']:
        """
        Name hiding settings
        """
        return pulumi.get(self, "name_hiding_settings")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartQueryResult']:
        """
        Queries settings.
        """
        return pulumi.get(self, "queries")

    @_builtins.property
    @pulumi.getter(name="seriesOverrides")
    def series_overrides(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartSeriesOverrideResult']:
        """
        Time series settings.
        """
        return pulumi.get(self, "series_overrides")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Chart widget title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="visualizationSettings")
    def visualization_settings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingResult']:
        """
        Visualization settings.
        """
        return pulumi.get(self, "visualization_settings")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartNameHidingSettingResult(dict):
    def __init__(__self__, *,
                 names: Sequence[_builtins.str],
                 positive: _builtins.bool):
        """
        :param _builtins.bool positive: True if we want to show concrete series names only, false if we want to hide concrete series names
        """
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "positive", positive)

    @_builtins.property
    @pulumi.getter
    def names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "names")

    @_builtins.property
    @pulumi.getter
    def positive(self) -> _builtins.bool:
        """
        True if we want to show concrete series names only, false if we want to hide concrete series names
        """
        return pulumi.get(self, "positive")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartQueryResult(dict):
    def __init__(__self__, *,
                 downsamplings: Sequence['outputs.GetMonitoringDashboardWidgetChartQueryDownsamplingResult'],
                 targets: Sequence['outputs.GetMonitoringDashboardWidgetChartQueryTargetResult']):
        """
        :param Sequence['GetMonitoringDashboardWidgetChartQueryDownsamplingArgs'] downsamplings: Downsampling settings
        :param Sequence['GetMonitoringDashboardWidgetChartQueryTargetArgs'] targets: Downsampling settings
        """
        pulumi.set(__self__, "downsamplings", downsamplings)
        pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def downsamplings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartQueryDownsamplingResult']:
        """
        Downsampling settings
        """
        return pulumi.get(self, "downsamplings")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartQueryTargetResult']:
        """
        Downsampling settings
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartQueryDownsamplingResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 gap_filling: _builtins.str,
                 grid_aggregation: _builtins.str,
                 grid_interval: _builtins.int,
                 max_points: _builtins.int):
        """
        :param _builtins.bool disabled: Disable downsampling
        :param _builtins.str gap_filling: Parameters for filling gaps in data
        :param _builtins.str grid_aggregation: Function that is used for downsampling
        :param _builtins.int grid_interval: Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        :param _builtins.int max_points: Maximum number of points to be returned
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "gap_filling", gap_filling)
        pulumi.set(__self__, "grid_aggregation", grid_aggregation)
        pulumi.set(__self__, "grid_interval", grid_interval)
        pulumi.set(__self__, "max_points", max_points)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Disable downsampling
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="gapFilling")
    def gap_filling(self) -> _builtins.str:
        """
        Parameters for filling gaps in data
        """
        return pulumi.get(self, "gap_filling")

    @_builtins.property
    @pulumi.getter(name="gridAggregation")
    def grid_aggregation(self) -> _builtins.str:
        """
        Function that is used for downsampling
        """
        return pulumi.get(self, "grid_aggregation")

    @_builtins.property
    @pulumi.getter(name="gridInterval")
    def grid_interval(self) -> _builtins.int:
        """
        Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
        """
        return pulumi.get(self, "grid_interval")

    @_builtins.property
    @pulumi.getter(name="maxPoints")
    def max_points(self) -> _builtins.int:
        """
        Maximum number of points to be returned
        """
        return pulumi.get(self, "max_points")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartQueryTargetResult(dict):
    def __init__(__self__, *,
                 hidden: _builtins.bool,
                 query: _builtins.str,
                 text_mode: _builtins.bool):
        """
        :param _builtins.bool hidden: Checks that target is visible or invisible
        :param _builtins.str query: Required. Query
        :param _builtins.bool text_mode: Text mode
        """
        pulumi.set(__self__, "hidden", hidden)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "text_mode", text_mode)

    @_builtins.property
    @pulumi.getter
    def hidden(self) -> _builtins.bool:
        """
        Checks that target is visible or invisible
        """
        return pulumi.get(self, "hidden")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        """
        Required. Query
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter(name="textMode")
    def text_mode(self) -> _builtins.bool:
        """
        Text mode
        """
        return pulumi.get(self, "text_mode")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartSeriesOverrideResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 settings: Sequence['outputs.GetMonitoringDashboardWidgetChartSeriesOverrideSettingResult'],
                 target_index: _builtins.str):
        """
        :param _builtins.str name: Series name
        :param Sequence['GetMonitoringDashboardWidgetChartSeriesOverrideSettingArgs'] settings: Override settings
        :param _builtins.str target_index: Target index
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "target_index", target_index)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Series name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartSeriesOverrideSettingResult']:
        """
        Override settings
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter(name="targetIndex")
    def target_index(self) -> _builtins.str:
        """
        Target index
        """
        return pulumi.get(self, "target_index")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartSeriesOverrideSettingResult(dict):
    def __init__(__self__, *,
                 color: _builtins.str,
                 grow_down: _builtins.bool,
                 name: _builtins.str,
                 stack_name: _builtins.str,
                 type: _builtins.str,
                 yaxis_position: _builtins.str):
        """
        :param _builtins.str color: Series color or empty
        :param _builtins.bool grow_down: Stack grow down
        :param _builtins.str name: Series name or empty
        :param _builtins.str stack_name: Stack name or empty
        :param _builtins.str type: Type
        :param _builtins.str yaxis_position: Yaxis position
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "grow_down", grow_down)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stack_name", stack_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "yaxis_position", yaxis_position)

    @_builtins.property
    @pulumi.getter
    def color(self) -> _builtins.str:
        """
        Series color or empty
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter(name="growDown")
    def grow_down(self) -> _builtins.bool:
        """
        Stack grow down
        """
        return pulumi.get(self, "grow_down")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Series name or empty
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stackName")
    def stack_name(self) -> _builtins.str:
        """
        Stack name or empty
        """
        return pulumi.get(self, "stack_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="yaxisPosition")
    def yaxis_position(self) -> _builtins.str:
        """
        Yaxis position
        """
        return pulumi.get(self, "yaxis_position")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingResult(dict):
    def __init__(__self__, *,
                 aggregation: _builtins.str,
                 color_scheme_settings: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingResult'],
                 heatmap_settings: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingResult'],
                 interpolate: _builtins.str,
                 normalize: _builtins.bool,
                 show_labels: _builtins.bool,
                 title: _builtins.str,
                 type: _builtins.str,
                 yaxis_settings: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingResult']):
        """
        :param _builtins.str aggregation: Aggregation
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingArgs'] color_scheme_settings: Color scheme settings
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingArgs'] heatmap_settings: Heatmap settings
        :param _builtins.str interpolate: Interpolate
        :param _builtins.bool normalize: Normalize
        :param _builtins.bool show_labels: Show chart labels
        :param _builtins.str title: Inside chart title
        :param _builtins.str type: Visualization type
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingArgs'] yaxis_settings: Y axis settings
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "color_scheme_settings", color_scheme_settings)
        pulumi.set(__self__, "heatmap_settings", heatmap_settings)
        pulumi.set(__self__, "interpolate", interpolate)
        pulumi.set(__self__, "normalize", normalize)
        pulumi.set(__self__, "show_labels", show_labels)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "yaxis_settings", yaxis_settings)

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> _builtins.str:
        """
        Aggregation
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter(name="colorSchemeSettings")
    def color_scheme_settings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingResult']:
        """
        Color scheme settings
        """
        return pulumi.get(self, "color_scheme_settings")

    @_builtins.property
    @pulumi.getter(name="heatmapSettings")
    def heatmap_settings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingResult']:
        """
        Heatmap settings
        """
        return pulumi.get(self, "heatmap_settings")

    @_builtins.property
    @pulumi.getter
    def interpolate(self) -> _builtins.str:
        """
        Interpolate
        """
        return pulumi.get(self, "interpolate")

    @_builtins.property
    @pulumi.getter
    def normalize(self) -> _builtins.bool:
        """
        Normalize
        """
        return pulumi.get(self, "normalize")

    @_builtins.property
    @pulumi.getter(name="showLabels")
    def show_labels(self) -> _builtins.bool:
        """
        Show chart labels
        """
        return pulumi.get(self, "show_labels")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Inside chart title
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Visualization type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="yaxisSettings")
    def yaxis_settings(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingResult']:
        """
        Y axis settings
        """
        return pulumi.get(self, "yaxis_settings")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingResult(dict):
    def __init__(__self__, *,
                 automatics: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticResult'],
                 gradients: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientResult'],
                 standards: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardResult']):
        """
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticArgs'] automatics: Automatic color scheme
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientArgs'] gradients: Gradient color scheme
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardArgs'] standards: Standard color scheme
        """
        pulumi.set(__self__, "automatics", automatics)
        pulumi.set(__self__, "gradients", gradients)
        pulumi.set(__self__, "standards", standards)

    @_builtins.property
    @pulumi.getter
    def automatics(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticResult']:
        """
        Automatic color scheme
        """
        return pulumi.get(self, "automatics")

    @_builtins.property
    @pulumi.getter
    def gradients(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientResult']:
        """
        Gradient color scheme
        """
        return pulumi.get(self, "gradients")

    @_builtins.property
    @pulumi.getter
    def standards(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardResult']:
        """
        Standard color scheme
        """
        return pulumi.get(self, "standards")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomaticResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradientResult(dict):
    def __init__(__self__, *,
                 green_value: _builtins.str,
                 red_value: _builtins.str,
                 violet_value: _builtins.str,
                 yellow_value: _builtins.str):
        """
        :param _builtins.str green_value: Gradient green value
        :param _builtins.str red_value: Gradient red value
        :param _builtins.str violet_value: Gradient violet value
        :param _builtins.str yellow_value: Gradient yellow value
        """
        pulumi.set(__self__, "green_value", green_value)
        pulumi.set(__self__, "red_value", red_value)
        pulumi.set(__self__, "violet_value", violet_value)
        pulumi.set(__self__, "yellow_value", yellow_value)

    @_builtins.property
    @pulumi.getter(name="greenValue")
    def green_value(self) -> _builtins.str:
        """
        Gradient green value
        """
        return pulumi.get(self, "green_value")

    @_builtins.property
    @pulumi.getter(name="redValue")
    def red_value(self) -> _builtins.str:
        """
        Gradient red value
        """
        return pulumi.get(self, "red_value")

    @_builtins.property
    @pulumi.getter(name="violetValue")
    def violet_value(self) -> _builtins.str:
        """
        Gradient violet value
        """
        return pulumi.get(self, "violet_value")

    @_builtins.property
    @pulumi.getter(name="yellowValue")
    def yellow_value(self) -> _builtins.str:
        """
        Gradient yellow value
        """
        return pulumi.get(self, "yellow_value")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandardResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSettingResult(dict):
    def __init__(__self__, *,
                 green_value: _builtins.str,
                 red_value: _builtins.str,
                 violet_value: _builtins.str,
                 yellow_value: _builtins.str):
        """
        :param _builtins.str green_value: Heatmap green value
        :param _builtins.str red_value: Heatmap red value
        :param _builtins.str violet_value: Heatmap violet_value
        :param _builtins.str yellow_value: Heatmap yellow value
        """
        pulumi.set(__self__, "green_value", green_value)
        pulumi.set(__self__, "red_value", red_value)
        pulumi.set(__self__, "violet_value", violet_value)
        pulumi.set(__self__, "yellow_value", yellow_value)

    @_builtins.property
    @pulumi.getter(name="greenValue")
    def green_value(self) -> _builtins.str:
        """
        Heatmap green value
        """
        return pulumi.get(self, "green_value")

    @_builtins.property
    @pulumi.getter(name="redValue")
    def red_value(self) -> _builtins.str:
        """
        Heatmap red value
        """
        return pulumi.get(self, "red_value")

    @_builtins.property
    @pulumi.getter(name="violetValue")
    def violet_value(self) -> _builtins.str:
        """
        Heatmap violet_value
        """
        return pulumi.get(self, "violet_value")

    @_builtins.property
    @pulumi.getter(name="yellowValue")
    def yellow_value(self) -> _builtins.str:
        """
        Heatmap yellow value
        """
        return pulumi.get(self, "yellow_value")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingResult(dict):
    def __init__(__self__, *,
                 lefts: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftResult'],
                 rights: Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightResult']):
        """
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftArgs'] lefts: Left Y axis settings
        :param Sequence['GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightArgs'] rights: Right Y axis settings
        """
        pulumi.set(__self__, "lefts", lefts)
        pulumi.set(__self__, "rights", rights)

    @_builtins.property
    @pulumi.getter
    def lefts(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftResult']:
        """
        Left Y axis settings
        """
        return pulumi.get(self, "lefts")

    @_builtins.property
    @pulumi.getter
    def rights(self) -> Sequence['outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightResult']:
        """
        Right Y axis settings
        """
        return pulumi.get(self, "rights")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeftResult(dict):
    def __init__(__self__, *,
                 max: _builtins.str,
                 min: _builtins.str,
                 precision: _builtins.int,
                 title: _builtins.str,
                 type: _builtins.str,
                 unit_format: _builtins.str):
        """
        :param _builtins.str max: Max value in extended number format or empty
        :param _builtins.str min: Min value in extended number format or empty
        :param _builtins.int precision: Tick value precision (null as default, 0-7 in other cases)
        :param _builtins.str title: Title or empty
        :param _builtins.str type: Type
        :param _builtins.str unit_format: Unit format
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "precision", precision)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unit_format", unit_format)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.str:
        """
        Max value in extended number format or empty
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.str:
        """
        Min value in extended number format or empty
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.int:
        """
        Tick value precision (null as default, 0-7 in other cases)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Title or empty
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unitFormat")
    def unit_format(self) -> _builtins.str:
        """
        Unit format
        """
        return pulumi.get(self, "unit_format")


@pulumi.output_type
class GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRightResult(dict):
    def __init__(__self__, *,
                 max: _builtins.str,
                 min: _builtins.str,
                 precision: _builtins.int,
                 title: _builtins.str,
                 type: _builtins.str,
                 unit_format: _builtins.str):
        """
        :param _builtins.str max: Max value in extended number format or empty
        :param _builtins.str min: Min value in extended number format or empty
        :param _builtins.int precision: Tick value precision (null as default, 0-7 in other cases)
        :param _builtins.str title: Title or empty
        :param _builtins.str type: Type
        :param _builtins.str unit_format: Unit format
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "precision", precision)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unit_format", unit_format)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.str:
        """
        Max value in extended number format or empty
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.str:
        """
        Min value in extended number format or empty
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> _builtins.int:
        """
        Tick value precision (null as default, 0-7 in other cases)
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Title or empty
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unitFormat")
    def unit_format(self) -> _builtins.str:
        """
        Unit format
        """
        return pulumi.get(self, "unit_format")


@pulumi.output_type
class GetMonitoringDashboardWidgetPositionResult(dict):
    def __init__(__self__, *,
                 h: _builtins.int,
                 w: _builtins.int,
                 x: _builtins.int,
                 y: _builtins.int):
        """
        :param _builtins.int h: Height.
        :param _builtins.int w: Weight.
        :param _builtins.int x: X-axis top-left corner coordinate.
        :param _builtins.int y: Y-axis top-left corner coordinate.
        """
        pulumi.set(__self__, "h", h)
        pulumi.set(__self__, "w", w)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @_builtins.property
    @pulumi.getter
    def h(self) -> _builtins.int:
        """
        Height.
        """
        return pulumi.get(self, "h")

    @_builtins.property
    @pulumi.getter
    def w(self) -> _builtins.int:
        """
        Weight.
        """
        return pulumi.get(self, "w")

    @_builtins.property
    @pulumi.getter
    def x(self) -> _builtins.int:
        """
        X-axis top-left corner coordinate.
        """
        return pulumi.get(self, "x")

    @_builtins.property
    @pulumi.getter
    def y(self) -> _builtins.int:
        """
        Y-axis top-left corner coordinate.
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class GetMonitoringDashboardWidgetTextResult(dict):
    def __init__(__self__, *,
                 text: _builtins.str):
        """
        :param _builtins.str text: Widget text.
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Widget text.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class GetMonitoringDashboardWidgetTitleResult(dict):
    def __init__(__self__, *,
                 size: _builtins.str,
                 text: _builtins.str):
        """
        :param _builtins.str size: Title size.
        :param _builtins.str text: Title text.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Title size.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Title text.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class GetOrganizationmanagerGroupMemberResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The ID of the member.
        :param _builtins.str type: The type of the member.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the member.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the member.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOrganizationmanagerOsLoginSettingsSshCertificateSettingsResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables or disables usage of SSH certificates signed by trusted Certification Authority (CA).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables usage of SSH certificates signed by trusted Certification Authority (CA).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetOrganizationmanagerOsLoginSettingsUserSshKeySettingsResult(dict):
    def __init__(__self__, *,
                 allow_manage_own_keys: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool allow_manage_own_keys: If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        :param _builtins.bool enabled: Enables or disables usage of ssh keys assigned to a specific subject.
        """
        if allow_manage_own_keys is not None:
            pulumi.set(__self__, "allow_manage_own_keys", allow_manage_own_keys)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowManageOwnKeys")
    def allow_manage_own_keys(self) -> Optional[_builtins.bool]:
        """
        If set to true subject is allowed to manage own ssh keys without having to be assigned specific permissions.
        """
        return pulumi.get(self, "allow_manage_own_keys")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables or disables usage of ssh keys assigned to a specific subject.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetOrganizationmanagerSamlFederationSecuritySettingResult(dict):
    def __init__(__self__, *,
                 encrypted_assertions: _builtins.bool,
                 force_authn: _builtins.bool):
        """
        :param _builtins.bool encrypted_assertions: Enable encrypted assertions.
        :param _builtins.bool force_authn: Force authentication on session expiration
        """
        pulumi.set(__self__, "encrypted_assertions", encrypted_assertions)
        pulumi.set(__self__, "force_authn", force_authn)

    @_builtins.property
    @pulumi.getter(name="encryptedAssertions")
    def encrypted_assertions(self) -> _builtins.bool:
        """
        Enable encrypted assertions.
        """
        return pulumi.get(self, "encrypted_assertions")

    @_builtins.property
    @pulumi.getter(name="forceAuthn")
    def force_authn(self) -> _builtins.bool:
        """
        Force authentication on session expiration
        """
        return pulumi.get(self, "force_authn")


@pulumi.output_type
class GetServerlessContainerAsyncInvocationResult(dict):
    def __init__(__self__, *,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str service_account_id: Service account used for async invocation.
        """
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account used for async invocation.
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetServerlessContainerConnectivityResult(dict):
    def __init__(__self__, *,
                 network_id: _builtins.str):
        """
        :param _builtins.str network_id: Network the revision will have access to.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        Network the revision will have access to.
        """
        return pulumi.get(self, "network_id")


@pulumi.output_type
class GetServerlessContainerImageResult(dict):
    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 commands: Sequence[_builtins.str],
                 digest: _builtins.str,
                 environment: Mapping[str, _builtins.str],
                 url: _builtins.str,
                 work_dir: _builtins.str):
        """
        :param Sequence[_builtins.str] args: List of arguments for Yandex Cloud Serverless Container.
        :param Sequence[_builtins.str] commands: List of commands for Yandex Cloud Serverless Container.
        :param _builtins.str digest: Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if `image.0.url` stays the same. If field not specified then its value will be computed.
        :param Mapping[str, _builtins.str] environment: A set of key/value environment variable pairs for Yandex Cloud Serverless Container. Each key must begin with a letter (A-Z, a-z).
        :param _builtins.str url: URL of image that will be deployed as Yandex Cloud Serverless Container.
        :param _builtins.str work_dir: Working directory for Yandex Cloud Serverless Container.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "work_dir", work_dir)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        List of arguments for Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        """
        List of commands for Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> _builtins.str:
        """
        Digest of image that will be deployed as Yandex Cloud Serverless Container. If presented, should be equal to digest that will be resolved at server side by URL. Container will be updated on digest change even if `image.0.url` stays the same. If field not specified then its value will be computed.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Mapping[str, _builtins.str]:
        """
        A set of key/value environment variable pairs for Yandex Cloud Serverless Container. Each key must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of image that will be deployed as Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="workDir")
    def work_dir(self) -> _builtins.str:
        """
        Working directory for Yandex Cloud Serverless Container.
        """
        return pulumi.get(self, "work_dir")


@pulumi.output_type
class GetServerlessContainerLogOptionResult(dict):
    def __init__(__self__, *,
                 disabled: _builtins.bool,
                 folder_id: _builtins.str,
                 log_group_id: _builtins.str,
                 min_level: _builtins.str):
        """
        :param _builtins.bool disabled: Is logging from container disabled.
        :param _builtins.str folder_id: Log entries are written to default log group for specified folder.
        :param _builtins.str log_group_id: Log entries are written to specified log group.
        :param _builtins.str min_level: Minimum log entry level.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "min_level", min_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Is logging from container disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Log entries are written to default log group for specified folder.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Log entries are written to specified log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> _builtins.str:
        """
        Minimum log entry level.
        """
        return pulumi.get(self, "min_level")


@pulumi.output_type
class GetServerlessContainerMetadataOptionsResult(dict):
    def __init__(__self__, *,
                 aws_v1_http_endpoint: _builtins.int,
                 gce_http_endpoint: _builtins.int):
        """
        :param _builtins.int aws_v1_http_endpoint: Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        :param _builtins.int gce_http_endpoint: Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        pulumi.set(__self__, "aws_v1_http_endpoint", aws_v1_http_endpoint)
        pulumi.set(__self__, "gce_http_endpoint", gce_http_endpoint)

    @_builtins.property
    @pulumi.getter(name="awsV1HttpEndpoint")
    def aws_v1_http_endpoint(self) -> _builtins.int:
        """
        Enables access to AWS flavored metadata (IMDSv1). Values: `0` - default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "aws_v1_http_endpoint")

    @_builtins.property
    @pulumi.getter(name="gceHttpEndpoint")
    def gce_http_endpoint(self) -> _builtins.int:
        """
        Enables access to GCE flavored metadata. Values: `0`- default, `1` - enabled, `2` - disabled.
        """
        return pulumi.get(self, "gce_http_endpoint")


@pulumi.output_type
class GetServerlessContainerMountResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 mount_point_path: _builtins.str,
                 ephemeral_disk: Optional['outputs.GetServerlessContainerMountEphemeralDiskResult'] = None,
                 object_storage: Optional['outputs.GetServerlessContainerMountObjectStorageResult'] = None):
        """
        :param _builtins.str mode: Mounts accessibility mode. Valid values are `ro` and `rw`.
        :param _builtins.str mount_point_path: Path inside the container to access the directory in which the target is mounted.
        :param 'GetServerlessContainerMountEphemeralDiskArgs' ephemeral_disk: One of the available mount types. Disk available during the function execution time.
        :param 'GetServerlessContainerMountObjectStorageArgs' object_storage: Available mount types. Object storage as a mount.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if ephemeral_disk is not None:
            pulumi.set(__self__, "ephemeral_disk", ephemeral_disk)
        if object_storage is not None:
            pulumi.set(__self__, "object_storage", object_storage)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mounts accessibility mode. Valid values are `ro` and `rw`.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> _builtins.str:
        """
        Path inside the container to access the directory in which the target is mounted.
        """
        return pulumi.get(self, "mount_point_path")

    @_builtins.property
    @pulumi.getter(name="ephemeralDisk")
    def ephemeral_disk(self) -> Optional['outputs.GetServerlessContainerMountEphemeralDiskResult']:
        """
        One of the available mount types. Disk available during the function execution time.
        """
        return pulumi.get(self, "ephemeral_disk")

    @_builtins.property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> Optional['outputs.GetServerlessContainerMountObjectStorageResult']:
        """
        Available mount types. Object storage as a mount.
        """
        return pulumi.get(self, "object_storage")


@pulumi.output_type
class GetServerlessContainerMountEphemeralDiskResult(dict):
    def __init__(__self__, *,
                 block_size_kb: _builtins.int,
                 size_gb: _builtins.int):
        """
        :param _builtins.int block_size_kb: Block size of the ephemeral disk in KB.
        :param _builtins.int size_gb: Size of the ephemeral disk in GB.
        """
        pulumi.set(__self__, "block_size_kb", block_size_kb)
        pulumi.set(__self__, "size_gb", size_gb)

    @_builtins.property
    @pulumi.getter(name="blockSizeKb")
    def block_size_kb(self) -> _builtins.int:
        """
        Block size of the ephemeral disk in KB.
        """
        return pulumi.get(self, "block_size_kb")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        """
        Size of the ephemeral disk in GB.
        """
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class GetServerlessContainerMountObjectStorageResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetServerlessContainerRuntimeResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the runtime for Yandex Cloud Serverless Container. Valid values are `http` and `task`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServerlessContainerSecretResult(dict):
    def __init__(__self__, *,
                 environment_variable: _builtins.str,
                 id: _builtins.str,
                 key: _builtins.str,
                 version_id: _builtins.str):
        """
        :param _builtins.str environment_variable: Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        :param _builtins.str id: Secret's ID.
        :param _builtins.str key: Secret's entries key which value will be stored in environment variable.
        :param _builtins.str version_id: Secret's version ID.
        """
        pulumi.set(__self__, "environment_variable", environment_variable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter(name="environmentVariable")
    def environment_variable(self) -> _builtins.str:
        """
        Container's environment variable in which secret's value will be stored. Must begin with a letter (A-Z, a-z).
        """
        return pulumi.get(self, "environment_variable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Secret's ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Secret's entries key which value will be stored in environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> _builtins.str:
        """
        Secret's version ID.
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class GetServerlessContainerStorageMountResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 mount_point_path: _builtins.str,
                 prefix: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: Name of the mounting bucket.
        :param _builtins.str mount_point_path: Path inside the container to access the directory in which the bucket is mounted.
        :param _builtins.str prefix: Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        :param _builtins.bool read_only: Mount the bucket in read-only mode.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "mount_point_path", mount_point_path)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the mounting bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="mountPointPath")
    def mount_point_path(self) -> _builtins.str:
        """
        Path inside the container to access the directory in which the bucket is mounted.
        """
        return pulumi.get(self, "mount_point_path")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix within the bucket. If you leave this field empty, the entire bucket will be mounted.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Mount the bucket in read-only mode.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetServerlessEventrouterConnectorTimerResult(dict):
    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 payload: _builtins.str,
                 timezone: _builtins.str):
        """
        :param _builtins.str cron_expression: Cron expression. Cron expression with seconds. Example: 0 45 16 ? * *
        :param _builtins.str payload: Payload to be passed to bus
        :param _builtins.str timezone: Timezone in tz database format. Example: Europe/Moscow
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "payload", payload)
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        Cron expression. Cron expression with seconds. Example: 0 45 16 ? * *
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> _builtins.str:
        """
        Payload to be passed to bus
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        Timezone in tz database format. Example: Europe/Moscow
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetServerlessEventrouterConnectorYdResult(dict):
    def __init__(__self__, *,
                 consumer: _builtins.str,
                 database: _builtins.str,
                 service_account_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str consumer: Consumer name
        :param _builtins.str database: Stream database
        :param _builtins.str service_account_id: Service account which has read permission on the stream
        :param _builtins.str stream_name: Stream name, absolute or relative
        """
        pulumi.set(__self__, "consumer", consumer)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def consumer(self) -> _builtins.str:
        """
        Consumer name
        """
        return pulumi.get(self, "consumer")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Stream database
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has read permission on the stream
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Stream name, absolute or relative
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetServerlessEventrouterConnectorYmqResult(dict):
    def __init__(__self__, *,
                 batch_size: _builtins.int,
                 polling_timeout: _builtins.str,
                 queue_arn: _builtins.str,
                 service_account_id: _builtins.str,
                 visibility_timeout: _builtins.str):
        """
        :param _builtins.int batch_size: Batch size for polling
        :param _builtins.str polling_timeout: Queue polling timeout
        :param _builtins.str queue_arn: Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        :param _builtins.str service_account_id: Service account which has read access to the queue
        :param _builtins.str visibility_timeout: Queue visibility timeout override
        """
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "polling_timeout", polling_timeout)
        pulumi.set(__self__, "queue_arn", queue_arn)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.int:
        """
        Batch size for polling
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="pollingTimeout")
    def polling_timeout(self) -> _builtins.str:
        """
        Queue polling timeout
        """
        return pulumi.get(self, "polling_timeout")

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> _builtins.str:
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        return pulumi.get(self, "queue_arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has read access to the queue
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> _builtins.str:
        """
        Queue visibility timeout override
        """
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class GetServerlessEventrouterRuleContainerResult(dict):
    def __init__(__self__, *,
                 batch_settings: _builtins.str,
                 container_id: _builtins.str,
                 container_revision_id: _builtins.str,
                 path: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str batch_settings: Batch settings
        :param _builtins.str container_id: Container ID
        :param _builtins.str container_revision_id: Container revision ID
        :param _builtins.str path: Endpoint HTTP path to invoke
        :param _builtins.str service_account_id: Service account which should be used to call a container
        """
        pulumi.set(__self__, "batch_settings", batch_settings)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "container_revision_id", container_revision_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> _builtins.str:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> _builtins.str:
        """
        Container ID
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="containerRevisionId")
    def container_revision_id(self) -> _builtins.str:
        """
        Container revision ID
        """
        return pulumi.get(self, "container_revision_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Endpoint HTTP path to invoke
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which should be used to call a container
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetServerlessEventrouterRuleFunctionResult(dict):
    def __init__(__self__, *,
                 batch_settings: Sequence['outputs.GetServerlessEventrouterRuleFunctionBatchSettingResult'],
                 function_id: _builtins.str,
                 function_tag: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param Sequence['GetServerlessEventrouterRuleFunctionBatchSettingArgs'] batch_settings: Batch settings
        :param _builtins.str function_id: Function ID
        :param _builtins.str function_tag: Function tag
        :param _builtins.str service_account_id: Service account which has call permission on the function
        """
        pulumi.set(__self__, "batch_settings", batch_settings)
        pulumi.set(__self__, "function_id", function_id)
        pulumi.set(__self__, "function_tag", function_tag)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> Sequence['outputs.GetServerlessEventrouterRuleFunctionBatchSettingResult']:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> _builtins.str:
        """
        Function ID
        """
        return pulumi.get(self, "function_id")

    @_builtins.property
    @pulumi.getter(name="functionTag")
    def function_tag(self) -> _builtins.str:
        """
        Function tag
        """
        return pulumi.get(self, "function_tag")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has call permission on the function
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetServerlessEventrouterRuleFunctionBatchSettingResult(dict):
    def __init__(__self__, *,
                 cutoff: _builtins.str,
                 max_bytes: _builtins.int,
                 max_count: _builtins.int):
        """
        :param _builtins.str cutoff: Maximum batch size: rule will send a batch if its lifetime exceeds this value
        :param _builtins.int max_bytes: Maximum batch size: rule will send a batch if total size of events exceeds this value
        :param _builtins.int max_count: Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        pulumi.set(__self__, "cutoff", cutoff)
        pulumi.set(__self__, "max_bytes", max_bytes)
        pulumi.set(__self__, "max_count", max_count)

    @_builtins.property
    @pulumi.getter
    def cutoff(self) -> _builtins.str:
        """
        Maximum batch size: rule will send a batch if its lifetime exceeds this value
        """
        return pulumi.get(self, "cutoff")

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> _builtins.int:
        """
        Maximum batch size: rule will send a batch if total size of events exceeds this value
        """
        return pulumi.get(self, "max_bytes")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> _builtins.int:
        """
        Maximum batch size: rule will send a batch if number of events exceeds this value
        """
        return pulumi.get(self, "max_count")


@pulumi.output_type
class GetServerlessEventrouterRuleGatewayWebsocketBroadcastResult(dict):
    def __init__(__self__, *,
                 batch_settings: _builtins.str,
                 gateway_id: _builtins.str,
                 path: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str batch_settings: Batch settings
        :param _builtins.str gateway_id: Gateway ID
        :param _builtins.str path: Path
        :param _builtins.str service_account_id: Service account which has permission for writing to websockets
        """
        pulumi.set(__self__, "batch_settings", batch_settings)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> _builtins.str:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        Gateway ID
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has permission for writing to websockets
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetServerlessEventrouterRuleLoggingResult(dict):
    def __init__(__self__, *,
                 folder_id: _builtins.str,
                 log_group_id: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str folder_id: Folder ID
        :param _builtins.str log_group_id: Log group ID
        :param _builtins.str service_account_id: Service account which has permission for writing logs
        """
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Folder ID
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Log group ID
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has permission for writing logs
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetServerlessEventrouterRuleWorkflowResult(dict):
    def __init__(__self__, *,
                 batch_settings: _builtins.str,
                 service_account_id: _builtins.str,
                 workflow_id: _builtins.str):
        """
        :param _builtins.str batch_settings: Batch settings
        :param _builtins.str service_account_id: Service account which should be used to start workflow
        :param _builtins.str workflow_id: Workflow ID
        """
        pulumi.set(__self__, "batch_settings", batch_settings)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "workflow_id", workflow_id)

    @_builtins.property
    @pulumi.getter(name="batchSettings")
    def batch_settings(self) -> _builtins.str:
        """
        Batch settings
        """
        return pulumi.get(self, "batch_settings")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which should be used to start workflow
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> _builtins.str:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")


@pulumi.output_type
class GetServerlessEventrouterRuleYdResult(dict):
    def __init__(__self__, *,
                 database: _builtins.str,
                 service_account_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str database: Stream database
        :param _builtins.str service_account_id: Service account, which has write permission on the stream
        :param _builtins.str stream_name: Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Stream database
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account, which has write permission on the stream
        """
        return pulumi.get(self, "service_account_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Full stream name, like /ru-central1/aoegtvhtp8ob********/cc8004q4lbo6********/test
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetServerlessEventrouterRuleYmqResult(dict):
    def __init__(__self__, *,
                 queue_arn: _builtins.str,
                 service_account_id: _builtins.str):
        """
        :param _builtins.str queue_arn: Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        :param _builtins.str service_account_id: Service account which has write access to the queue
        """
        pulumi.set(__self__, "queue_arn", queue_arn)
        pulumi.set(__self__, "service_account_id", service_account_id)

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> _builtins.str:
        """
        Queue ARN. Example: yrn:yc:ymq:ru-central1:aoe***:test
        """
        return pulumi.get(self, "queue_arn")

    @_builtins.property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> _builtins.str:
        """
        Service account which has write access to the queue
        """
        return pulumi.get(self, "service_account_id")


@pulumi.output_type
class GetSmartcaptchaCaptchaOverrideVariantResult(dict):
    def __init__(__self__, *,
                 challenge_type: _builtins.str,
                 complexity: _builtins.str,
                 description: _builtins.str,
                 pre_check_type: _builtins.str,
                 uuid: _builtins.str):
        """
        :param _builtins.str challenge_type: Additional task type of the captcha.
        :param _builtins.str complexity: Complexity of the captcha.
        :param _builtins.str description: Optional description of the rule. 0-512 characters long.
        :param _builtins.str pre_check_type: Basic check type of the captcha.
        :param _builtins.str uuid: Unique identifier of the variant.
        """
        pulumi.set(__self__, "challenge_type", challenge_type)
        pulumi.set(__self__, "complexity", complexity)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "pre_check_type", pre_check_type)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="challengeType")
    def challenge_type(self) -> _builtins.str:
        """
        Additional task type of the captcha.
        """
        return pulumi.get(self, "challenge_type")

    @_builtins.property
    @pulumi.getter
    def complexity(self) -> _builtins.str:
        """
        Complexity of the captcha.
        """
        return pulumi.get(self, "complexity")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="preCheckType")
    def pre_check_type(self) -> _builtins.str:
        """
        Basic check type of the captcha.
        """
        return pulumi.get(self, "pre_check_type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        Unique identifier of the variant.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionResult'],
                 description: _builtins.str,
                 name: _builtins.str,
                 override_variant_uuid: _builtins.str,
                 priority: _builtins.int):
        """
        :param Sequence['GetSmartcaptchaCaptchaSecurityRuleConditionArgs'] conditions: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        :param _builtins.str description: Description of the rule. 0-512 characters long.
        :param _builtins.str name: Name of the rule. The name is unique within the captcha. 1-50 characters long.
        :param _builtins.str override_variant_uuid: Variant UUID to show in case of match the rule. Keep empty to use defaults.
        :param _builtins.int priority: Priority of the rule. Lower value means higher priority.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "override_variant_uuid", override_variant_uuid)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionResult']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartcaptcha/v1/captcha.proto).
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule. The name is unique within the captcha. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="overrideVariantUuid")
    def override_variant_uuid(self) -> _builtins.str:
        """
        Variant UUID to show in case of match the rule. Keep empty to use defaults.
        """
        return pulumi.get(self, "override_variant_uuid")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Priority of the rule. Lower value means higher priority.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionResult(dict):
    def __init__(__self__, *,
                 headers: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHeaderResult'],
                 hosts: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHostResult'],
                 source_ips: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpResult'],
                 uris: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriResult']):
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "source_ips", source_ips)
        pulumi.set(__self__, "uris", uris)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHostResult']:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpResult']:
        return pulumi.get(self, "source_ips")

    @_builtins.property
    @pulumi.getter
    def uris(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriResult']:
        return pulumi.get(self, "uris")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionHostResult(dict):
    def __init__(__self__, *,
                 hosts: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHostHostResult']):
        pulumi.set(__self__, "hosts", hosts)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHostHostResult']:
        return pulumi.get(self, "hosts")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionHostHostResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchResult']):
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchResult']:
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchResult']:
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchResult']:
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchResult']:
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriPathResult'],
                 queries: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 dry_run: _builtins.bool,
                 dynamic_quotas: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaResult'],
                 name: _builtins.str,
                 priority: _builtins.int,
                 static_quotas: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaResult']):
        """
        :param _builtins.str description: Description of the rule. 0-512 characters long.
        :param _builtins.bool dry_run: This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaArgs'] dynamic_quotas: Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
        :param _builtins.str name: Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        :param _builtins.int priority: Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaArgs'] static_quotas: Static quota. Counting each request individually.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "dynamic_quotas", dynamic_quotas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "static_quotas", static_quotas)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        This allows you to evaluate backend capabilities and find the optimum limit values. Requests will not be blocked in this mode.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter(name="dynamicQuotas")
    def dynamic_quotas(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaResult']:
        """
        Dynamic quota. Grouping requests by a certain attribute and limiting the number of groups.
        """
        return pulumi.get(self, "dynamic_quotas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule. The name is unique within the ARL profile. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Determines the priority in case there are several matched rules. Enter an integer within the range of 1 and 999999. The rule priority must be unique within the entire ARL profile. A lower numeric value means a higher priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="staticQuotas")
    def static_quotas(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaResult']:
        """
        Static quota. Counting each request individually.
        """
        return pulumi.get(self, "static_quotas")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 characteristics: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicResult'],
                 conditions: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionResult'],
                 limit: _builtins.int,
                 period: _builtins.int):
        """
        :param _builtins.str action: Action in case of exceeding this quota. Possible values: `DENY`.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicArgs'] characteristics: List of characteristics.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionArgs'] conditions: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.int limit: Desired maximum number of requests per period.
        :param _builtins.int period: Period of time in seconds.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "characteristics", characteristics)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def characteristics(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicResult']:
        """
        List of characteristics.
        """
        return pulumi.get(self, "characteristics")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionResult']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Desired maximum number of requests per period.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Period of time in seconds.
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicResult(dict):
    def __init__(__self__, *,
                 case_insensitive: _builtins.bool,
                 key_characteristics: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicResult'],
                 simple_characteristics: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicResult']):
        """
        :param _builtins.bool case_insensitive: Determines case-sensitive or case-insensitive keys matching.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicArgs'] key_characteristics: Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicArgs'] simple_characteristics: Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        """
        pulumi.set(__self__, "case_insensitive", case_insensitive)
        pulumi.set(__self__, "key_characteristics", key_characteristics)
        pulumi.set(__self__, "simple_characteristics", simple_characteristics)

    @_builtins.property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> _builtins.bool:
        """
        Determines case-sensitive or case-insensitive keys matching.
        """
        return pulumi.get(self, "case_insensitive")

    @_builtins.property
    @pulumi.getter(name="keyCharacteristics")
    def key_characteristics(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicResult']:
        """
        Characteristic based on key match in the Query params, HTTP header, and HTTP cookie attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        """
        return pulumi.get(self, "key_characteristics")

    @_builtins.property
    @pulumi.getter(name="simpleCharacteristics")
    def simple_characteristics(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicResult']:
        """
        Characteristic automatically based on the Request path, HTTP method, IP address, Region, and Host attributes. See [Rules](https://yandex.cloud/docs/smartwebsecurity/concepts/arl#requests-counting) for more details.
        """
        return pulumi.get(self, "simple_characteristics")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicKeyCharacteristicResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str type: Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        :param _builtins.str value: String value of the key.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of key characteristic. Possible values: `COOKIE_KEY`, `HEADER_KEY`, `QUERY_KEY`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        String value of the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaCharacteristicSimpleCharacteristicResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of simple characteristic. Possible values: `REQUEST_PATH`, `HTTP_METHOD`, `IP`, `GEO`, `HOST`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityResult'],
                 headers: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderResult'],
                 http_methods: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodResult'],
                 request_uris: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriResult'],
                 source_ips: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpResult']):
        pulumi.set(__self__, "authorities", authorities)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityResult']:
        return pulumi.get(self, "authorities")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodResult']:
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriResult']:
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpResult']:
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityResult']):
        pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityResult']:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionAuthorityAuthorityResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodResult']):
        pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodResult']:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionHttpMethodHttpMethodResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathResult'],
                 queries: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionRequestUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchResult']):
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchResult']:
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchResult']:
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchResult']:
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchResult']:
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleDynamicQuotaConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 conditions: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionResult'],
                 limit: _builtins.int,
                 period: _builtins.int):
        """
        :param _builtins.str action: Action in case of exceeding this quota. Possible values: `DENY`.
        :param Sequence['GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionArgs'] conditions: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.int limit: Desired maximum number of requests per period.
        :param _builtins.int period: Period of time in seconds.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action in case of exceeding this quota. Possible values: `DENY`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionResult']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        Desired maximum number of requests per period.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        """
        Period of time in seconds.
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityResult'],
                 headers: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderResult'],
                 http_methods: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodResult'],
                 request_uris: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriResult'],
                 source_ips: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpResult']):
        pulumi.set(__self__, "authorities", authorities)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityResult']:
        return pulumi.get(self, "authorities")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodResult']:
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriResult']:
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpResult']:
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityResult']):
        pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityResult']:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionAuthorityAuthorityResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodResult']):
        pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodResult']:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionHttpMethodHttpMethodResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathResult'],
                 queries: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionRequestUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchResult']):
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchResult']:
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchResult']:
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchResult']:
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchResult']:
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsAdvancedRateLimiterProfileAdvancedRateLimiterRuleStaticQuotaConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsSecurityProfileAnalyzeRequestBodyResult(dict):
    def __init__(__self__, *,
                 size_limit: _builtins.int,
                 size_limit_action: _builtins.str):
        pulumi.set(__self__, "size_limit", size_limit)
        pulumi.set(__self__, "size_limit_action", size_limit_action)

    @_builtins.property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> _builtins.int:
        return pulumi.get(self, "size_limit")

    @_builtins.property
    @pulumi.getter(name="sizeLimitAction")
    def size_limit_action(self) -> _builtins.str:
        return pulumi.get(self, "size_limit_action")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 dry_run: _builtins.bool,
                 name: _builtins.str,
                 priority: _builtins.int,
                 rule_conditions: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionResult'],
                 smart_protections: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionResult'],
                 wafs: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafResult']):
        """
        :param _builtins.str description: Optional description of the rule. 0-512 characters long.
        :param _builtins.bool dry_run: This mode allows you to test your security profile or a single rule.
        :param _builtins.str name: Name of the rule. The name is unique within the security profile. 1-50 characters long.
        :param _builtins.int priority: Determines the priority for checking the incoming traffic.
        :param Sequence['GetSwsSecurityProfileSecurityRuleRuleConditionArgs'] rule_conditions: Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action).
        :param Sequence['GetSwsSecurityProfileSecurityRuleSmartProtectionArgs'] smart_protections: Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules).
        :param Sequence['GetSwsSecurityProfileSecurityRuleWafArgs'] wafs: Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules).
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dry_run", dry_run)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rule_conditions", rule_conditions)
        pulumi.set(__self__, "smart_protections", smart_protections)
        pulumi.set(__self__, "wafs", wafs)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Optional description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="dryRun")
    def dry_run(self) -> _builtins.bool:
        """
        This mode allows you to test your security profile or a single rule.
        """
        return pulumi.get(self, "dry_run")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule. The name is unique within the security profile. 1-50 characters long.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Determines the priority for checking the incoming traffic.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="ruleConditions")
    def rule_conditions(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionResult']:
        """
        Rule actions, see [Rule actions](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#rule-action).
        """
        return pulumi.get(self, "rule_conditions")

    @_builtins.property
    @pulumi.getter(name="smartProtections")
    def smart_protections(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionResult']:
        """
        Smart Protection rule, see [Smart Protection rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#smart-protection-rules).
        """
        return pulumi.get(self, "smart_protections")

    @_builtins.property
    @pulumi.getter
    def wafs(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafResult']:
        """
        Web Application Firewall (WAF) rule, see [WAF rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/rules#waf-rules).
        """
        return pulumi.get(self, "wafs")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 conditions: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionResult']):
        """
        :param _builtins.str action: Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        :param Sequence['GetSwsSecurityProfileSecurityRuleRuleConditionConditionArgs'] conditions: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action to perform if this rule matched. Possible values: `ALLOW` or `DENY`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionResult']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityResult'],
                 headers: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderResult'],
                 http_methods: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodResult'],
                 request_uris: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriResult'],
                 source_ips: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpResult']):
        pulumi.set(__self__, "authorities", authorities)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityResult']:
        return pulumi.get(self, "authorities")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodResult']:
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriResult']:
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpResult']:
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityResult']):
        pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityResult']:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthorityResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodResult']):
        pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodResult']:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethodResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathResult'],
                 queries: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchResult']):
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchResult']:
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchResult']:
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchResult']:
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchResult']:
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionResult'],
                 mode: _builtins.str):
        """
        :param Sequence['GetSwsSecurityProfileSecurityRuleSmartProtectionConditionArgs'] conditions: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.str mode: Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionResult']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityResult'],
                 headers: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderResult'],
                 http_methods: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodResult'],
                 request_uris: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriResult'],
                 source_ips: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpResult']):
        pulumi.set(__self__, "authorities", authorities)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityResult']:
        return pulumi.get(self, "authorities")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodResult']:
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriResult']:
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpResult']:
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityResult']):
        pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityResult']:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthorityResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodResult']):
        pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodResult']:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethodResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathResult'],
                 queries: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchResult']):
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchResult']:
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchResult']:
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchResult']:
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchResult']:
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionResult'],
                 mode: _builtins.str,
                 waf_profile_id: _builtins.str):
        """
        :param Sequence['GetSwsSecurityProfileSecurityRuleWafConditionArgs'] conditions: The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        :param _builtins.str mode: Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        :param _builtins.str waf_profile_id: ID of WAF profile to use in this rule.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "waf_profile_id", waf_profile_id)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionResult']:
        """
        The condition for matching the rule. You can find all possibilities of condition in [gRPC specs](https://github.com/yandex-cloud/cloudapi/blob/master/yandex/cloud/smartwebsecurity/v1/security_profile.proto).
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of protection. Possible values: `FULL` (full protection means that the traffic will be checked based on ML models and behavioral analysis, with suspicious requests being sent to SmartCaptcha) or `API` (API protection means checking the traffic based on ML models and behavioral analysis without sending suspicious requests to SmartCaptcha. The suspicious requests will be blocked).
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="wafProfileId")
    def waf_profile_id(self) -> _builtins.str:
        """
        ID of WAF profile to use in this rule.
        """
        return pulumi.get(self, "waf_profile_id")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionAuthorityResult'],
                 headers: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHeaderResult'],
                 http_methods: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodResult'],
                 request_uris: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriResult'],
                 source_ips: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpResult']):
        pulumi.set(__self__, "authorities", authorities)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionAuthorityResult']:
        return pulumi.get(self, "authorities")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodResult']:
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriResult']:
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpResult']:
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionAuthorityResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityResult']):
        pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityResult']:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionAuthorityAuthorityResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodResult']):
        pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodResult']:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionHttpMethodHttpMethodResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionRequestUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriPathResult'],
                 queries: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionRequestUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionRequestUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchResult']):
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchResult']:
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchResult']:
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchResult']:
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchResult']:
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsSecurityProfileSecurityRuleWafConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsWafProfileAnalyzeRequestBodyResult(dict):
    def __init__(__self__, *,
                 is_enabled: _builtins.bool,
                 size_limit: _builtins.int,
                 size_limit_action: _builtins.str):
        """
        :param _builtins.bool is_enabled: Possible to turn analyzer on and turn if off.
        :param _builtins.int size_limit: Maximum size of body to pass to analyzer. In kilobytes.
        :param _builtins.str size_limit_action: Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "size_limit", size_limit)
        pulumi.set(__self__, "size_limit_action", size_limit_action)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Possible to turn analyzer on and turn if off.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> _builtins.int:
        """
        Maximum size of body to pass to analyzer. In kilobytes.
        """
        return pulumi.get(self, "size_limit")

    @_builtins.property
    @pulumi.getter(name="sizeLimitAction")
    def size_limit_action(self) -> _builtins.str:
        """
        Action to perform if maximum size of body exceeded. Possible values: `IGNORE` and `DENY`.
        """
        return pulumi.get(self, "size_limit_action")


@pulumi.output_type
class GetSwsWafProfileCoreRuleSetResult(dict):
    def __init__(__self__, *,
                 inbound_anomaly_score: _builtins.int,
                 paranoia_level: _builtins.int,
                 rule_sets: Sequence['outputs.GetSwsWafProfileCoreRuleSetRuleSetResult']):
        """
        :param _builtins.int inbound_anomaly_score: Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        :param _builtins.int paranoia_level: Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        :param Sequence['GetSwsWafProfileCoreRuleSetRuleSetArgs'] rule_sets: Rule set settings. See [Basic rule set](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#rules-set) for details.
        """
        pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        pulumi.set(__self__, "paranoia_level", paranoia_level)
        pulumi.set(__self__, "rule_sets", rule_sets)

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> _builtins.int:
        """
        Anomaly score. Enter an integer within the range of 2 and 10000. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#anomaly) for more details.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="paranoiaLevel")
    def paranoia_level(self) -> _builtins.int:
        """
        Paranoia level. Enter an integer within the range of 1 and 4. Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [Rules](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#paranoia) for more details. NOTE: this option has no effect on enabling or disabling rules, it is used only as recommendation for user to enable all rules with paranoia_level <= this value.
        """
        return pulumi.get(self, "paranoia_level")

    @_builtins.property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Sequence['outputs.GetSwsWafProfileCoreRuleSetRuleSetResult']:
        """
        Rule set settings. See [Basic rule set](https://yandex.cloud/en/docs/smartwebsecurity/concepts/waf#rules-set) for details.
        """
        return pulumi.get(self, "rule_sets")


@pulumi.output_type
class GetSwsWafProfileCoreRuleSetRuleSetResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 version: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        :param _builtins.str version: Version of the rule set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionResult'],
                 description: _builtins.str,
                 exclude_rules: Sequence['outputs.GetSwsWafProfileExclusionRuleExcludeRuleResult'],
                 log_excluded: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str description: Description of the rule. 0-512 characters long.
        :param Sequence['GetSwsWafProfileExclusionRuleExcludeRuleArgs'] exclude_rules: Exclude rules.
        :param _builtins.bool log_excluded: Records the fact that an exception rule is triggered.
        :param _builtins.str name: Name of exclusion rule.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "exclude_rules", exclude_rules)
        pulumi.set(__self__, "log_excluded", log_excluded)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionResult']:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the rule. 0-512 characters long.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="excludeRules")
    def exclude_rules(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleExcludeRuleResult']:
        """
        Exclude rules.
        """
        return pulumi.get(self, "exclude_rules")

    @_builtins.property
    @pulumi.getter(name="logExcluded")
    def log_excluded(self) -> _builtins.bool:
        """
        Records the fact that an exception rule is triggered.
        """
        return pulumi.get(self, "log_excluded")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of exclusion rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionAuthorityResult'],
                 headers: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHeaderResult'],
                 http_methods: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHttpMethodResult'],
                 request_uris: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriResult'],
                 source_ips: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpResult']):
        """
        :param Sequence['GetSwsWafProfileExclusionRuleConditionSourceIpArgs'] source_ips: Source IP.
        """
        pulumi.set(__self__, "authorities", authorities)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "request_uris", request_uris)
        pulumi.set(__self__, "source_ips", source_ips)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionAuthorityResult']:
        return pulumi.get(self, "authorities")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHeaderResult']:
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHttpMethodResult']:
        return pulumi.get(self, "http_methods")

    @_builtins.property
    @pulumi.getter(name="requestUris")
    def request_uris(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriResult']:
        return pulumi.get(self, "request_uris")

    @_builtins.property
    @pulumi.getter(name="sourceIps")
    def source_ips(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpResult']:
        """
        Source IP.
        """
        return pulumi.get(self, "source_ips")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionAuthorityResult(dict):
    def __init__(__self__, *,
                 authorities: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionAuthorityAuthorityResult']):
        pulumi.set(__self__, "authorities", authorities)

    @_builtins.property
    @pulumi.getter
    def authorities(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionAuthorityAuthorityResult']:
        return pulumi.get(self, "authorities")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionAuthorityAuthorityResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionHeaderResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHeaderValueResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHeaderValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionHeaderValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionHttpMethodResult(dict):
    def __init__(__self__, *,
                 http_methods: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHttpMethodHttpMethodResult']):
        pulumi.set(__self__, "http_methods", http_methods)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionHttpMethodHttpMethodResult']:
        return pulumi.get(self, "http_methods")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionHttpMethodHttpMethodResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionRequestUriResult(dict):
    def __init__(__self__, *,
                 paths: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriPathResult'],
                 queries: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriQueryResult']):
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "queries", queries)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriPathResult']:
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriQueryResult']:
        return pulumi.get(self, "queries")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionRequestUriPathResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionRequestUriQueryResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriQueryValueResult']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionRequestUriQueryValueResult']:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionRequestUriQueryValueResult(dict):
    def __init__(__self__, *,
                 exact_match: _builtins.str,
                 exact_not_match: _builtins.str,
                 pire_regex_match: _builtins.str,
                 pire_regex_not_match: _builtins.str,
                 prefix_match: _builtins.str,
                 prefix_not_match: _builtins.str):
        pulumi.set(__self__, "exact_match", exact_match)
        pulumi.set(__self__, "exact_not_match", exact_not_match)
        pulumi.set(__self__, "pire_regex_match", pire_regex_match)
        pulumi.set(__self__, "pire_regex_not_match", pire_regex_not_match)
        pulumi.set(__self__, "prefix_match", prefix_match)
        pulumi.set(__self__, "prefix_not_match", prefix_not_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter(name="exactNotMatch")
    def exact_not_match(self) -> _builtins.str:
        return pulumi.get(self, "exact_not_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexMatch")
    def pire_regex_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_match")

    @_builtins.property
    @pulumi.getter(name="pireRegexNotMatch")
    def pire_regex_not_match(self) -> _builtins.str:
        return pulumi.get(self, "pire_regex_not_match")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="prefixNotMatch")
    def prefix_not_match(self) -> _builtins.str:
        return pulumi.get(self, "prefix_not_match")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionSourceIpResult(dict):
    def __init__(__self__, *,
                 geo_ip_matches: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchResult'],
                 geo_ip_not_matches: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchResult'],
                 ip_ranges_matches: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchResult'],
                 ip_ranges_not_matches: Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchResult']):
        """
        :param Sequence['GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchArgs'] geo_ip_matches: Locations to include.
        :param Sequence['GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchArgs'] geo_ip_not_matches: Locations to exclude.
        :param Sequence['GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchArgs'] ip_ranges_matches: IP ranges to include.
        :param Sequence['GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchArgs'] ip_ranges_not_matches: IP ranges to exclude.
        """
        pulumi.set(__self__, "geo_ip_matches", geo_ip_matches)
        pulumi.set(__self__, "geo_ip_not_matches", geo_ip_not_matches)
        pulumi.set(__self__, "ip_ranges_matches", ip_ranges_matches)
        pulumi.set(__self__, "ip_ranges_not_matches", ip_ranges_not_matches)

    @_builtins.property
    @pulumi.getter(name="geoIpMatches")
    def geo_ip_matches(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchResult']:
        """
        Locations to include.
        """
        return pulumi.get(self, "geo_ip_matches")

    @_builtins.property
    @pulumi.getter(name="geoIpNotMatches")
    def geo_ip_not_matches(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchResult']:
        """
        Locations to exclude.
        """
        return pulumi.get(self, "geo_ip_not_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesMatches")
    def ip_ranges_matches(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchResult']:
        """
        IP ranges to include.
        """
        return pulumi.get(self, "ip_ranges_matches")

    @_builtins.property
    @pulumi.getter(name="ipRangesNotMatches")
    def ip_ranges_not_matches(self) -> Sequence['outputs.GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchResult']:
        """
        IP ranges to exclude.
        """
        return pulumi.get(self, "ip_ranges_not_matches")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] locations: Locations to include.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        """
        Locations to include.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionSourceIpGeoIpNotMatchResult(dict):
    def __init__(__self__, *,
                 locations: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] locations: Locations to exclude.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        """
        Locations to exclude.
        """
        return pulumi.get(self, "locations")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] ip_ranges: IP ranges to include.
        """
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        """
        IP ranges to include.
        """
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleConditionSourceIpIpRangesNotMatchResult(dict):
    def __init__(__self__, *,
                 ip_ranges: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] ip_ranges: IP ranges to exclude.
        """
        pulumi.set(__self__, "ip_ranges", ip_ranges)

    @_builtins.property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[_builtins.str]:
        """
        IP ranges to exclude.
        """
        return pulumi.get(self, "ip_ranges")


@pulumi.output_type
class GetSwsWafProfileExclusionRuleExcludeRuleResult(dict):
    def __init__(__self__, *,
                 exclude_all: _builtins.bool,
                 rule_ids: Sequence[_builtins.str]):
        """
        :param _builtins.bool exclude_all: Set this option true to exclude all rules.
        :param Sequence[_builtins.str] rule_ids: List of rules to exclude.
        """
        pulumi.set(__self__, "exclude_all", exclude_all)
        pulumi.set(__self__, "rule_ids", rule_ids)

    @_builtins.property
    @pulumi.getter(name="excludeAll")
    def exclude_all(self) -> _builtins.bool:
        """
        Set this option true to exclude all rules.
        """
        return pulumi.get(self, "exclude_all")

    @_builtins.property
    @pulumi.getter(name="ruleIds")
    def rule_ids(self) -> Sequence[_builtins.str]:
        """
        List of rules to exclude.
        """
        return pulumi.get(self, "rule_ids")


@pulumi.output_type
class GetSwsWafProfileRuleResult(dict):
    def __init__(__self__, *,
                 is_blocking: _builtins.bool,
                 is_enabled: _builtins.bool,
                 rule_id: _builtins.str):
        """
        :param _builtins.bool is_blocking: Determines is it rule blocking or not.
        :param _builtins.bool is_enabled: Determines is it rule enabled or not.
        :param _builtins.str rule_id: Rule ID.
        """
        pulumi.set(__self__, "is_blocking", is_blocking)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "rule_id", rule_id)

    @_builtins.property
    @pulumi.getter(name="isBlocking")
    def is_blocking(self) -> _builtins.bool:
        """
        Determines is it rule blocking or not.
        """
        return pulumi.get(self, "is_blocking")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Determines is it rule enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.str:
        """
        Rule ID.
        """
        return pulumi.get(self, "rule_id")


@pulumi.output_type
class GetSwsWafProfileRuleSetResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 core_rule_sets: Sequence['outputs.GetSwsWafProfileRuleSetCoreRuleSetResult'],
                 is_enabled: _builtins.bool,
                 ml_rule_sets: Sequence['outputs.GetSwsWafProfileRuleSetMlRuleSetResult'],
                 priority: _builtins.int,
                 ya_rule_sets: Sequence['outputs.GetSwsWafProfileRuleSetYaRuleSetResult']):
        """
        :param _builtins.str action: Action of the rule set.
        :param Sequence['GetSwsWafProfileRuleSetCoreRuleSetArgs'] core_rule_sets: Core rule set.
        :param _builtins.bool is_enabled: Determines is it rule set enabled or not.
        :param Sequence['GetSwsWafProfileRuleSetMlRuleSetArgs'] ml_rule_sets: List of ML rule sets.
        :param _builtins.int priority: Priority of the rule set.
        :param Sequence['GetSwsWafProfileRuleSetYaRuleSetArgs'] ya_rule_sets: Yandex rule set.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "core_rule_sets", core_rule_sets)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "ml_rule_sets", ml_rule_sets)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "ya_rule_sets", ya_rule_sets)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action of the rule set.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="coreRuleSets")
    def core_rule_sets(self) -> Sequence['outputs.GetSwsWafProfileRuleSetCoreRuleSetResult']:
        """
        Core rule set.
        """
        return pulumi.get(self, "core_rule_sets")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Determines is it rule set enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="mlRuleSets")
    def ml_rule_sets(self) -> Sequence['outputs.GetSwsWafProfileRuleSetMlRuleSetResult']:
        """
        List of ML rule sets.
        """
        return pulumi.get(self, "ml_rule_sets")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Priority of the rule set.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="yaRuleSets")
    def ya_rule_sets(self) -> Sequence['outputs.GetSwsWafProfileRuleSetYaRuleSetResult']:
        """
        Yandex rule set.
        """
        return pulumi.get(self, "ya_rule_sets")


@pulumi.output_type
class GetSwsWafProfileRuleSetCoreRuleSetResult(dict):
    def __init__(__self__, *,
                 inbound_anomaly_score: _builtins.int,
                 paranoia_level: _builtins.int,
                 rule_sets: Sequence['outputs.GetSwsWafProfileRuleSetCoreRuleSetRuleSetResult']):
        """
        :param _builtins.int inbound_anomaly_score: Inbound anomaly score of the rule set.
        :param _builtins.int paranoia_level: Paranoia level of the rule set.
        :param Sequence['GetSwsWafProfileRuleSetCoreRuleSetRuleSetArgs'] rule_sets: Rule set.
        """
        pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        pulumi.set(__self__, "paranoia_level", paranoia_level)
        pulumi.set(__self__, "rule_sets", rule_sets)

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> _builtins.int:
        """
        Inbound anomaly score of the rule set.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="paranoiaLevel")
    def paranoia_level(self) -> _builtins.int:
        """
        Paranoia level of the rule set.
        """
        return pulumi.get(self, "paranoia_level")

    @_builtins.property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Sequence['outputs.GetSwsWafProfileRuleSetCoreRuleSetRuleSetResult']:
        """
        Rule set.
        """
        return pulumi.get(self, "rule_sets")


@pulumi.output_type
class GetSwsWafProfileRuleSetCoreRuleSetRuleSetResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str id: Id of the rule set.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        :param _builtins.str version: Version of the rule set.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the rule set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSwsWafProfileRuleSetMlRuleSetResult(dict):
    def __init__(__self__, *,
                 rule_groups: Sequence['outputs.GetSwsWafProfileRuleSetMlRuleSetRuleGroupResult'],
                 rule_sets: Sequence['outputs.GetSwsWafProfileRuleSetMlRuleSetRuleSetResult']):
        """
        :param Sequence['GetSwsWafProfileRuleSetMlRuleSetRuleGroupArgs'] rule_groups: List of rule groups.
        :param Sequence['GetSwsWafProfileRuleSetMlRuleSetRuleSetArgs'] rule_sets: Rule set of the ML rule set.
        """
        pulumi.set(__self__, "rule_groups", rule_groups)
        pulumi.set(__self__, "rule_sets", rule_sets)

    @_builtins.property
    @pulumi.getter(name="ruleGroups")
    def rule_groups(self) -> Sequence['outputs.GetSwsWafProfileRuleSetMlRuleSetRuleGroupResult']:
        """
        List of rule groups.
        """
        return pulumi.get(self, "rule_groups")

    @_builtins.property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Sequence['outputs.GetSwsWafProfileRuleSetMlRuleSetRuleSetResult']:
        """
        Rule set of the ML rule set.
        """
        return pulumi.get(self, "rule_sets")


@pulumi.output_type
class GetSwsWafProfileRuleSetMlRuleSetRuleGroupResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 inbound_anomaly_score: _builtins.int,
                 is_enabled: _builtins.bool):
        """
        :param _builtins.str action: Action of the rule group.
        :param _builtins.str id: ID of the rule group.
        :param _builtins.int inbound_anomaly_score: Inbound anomaly score.
        :param _builtins.bool is_enabled: Is the rule group enabled.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action of the rule group.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the rule group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> _builtins.int:
        """
        Inbound anomaly score.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Is the rule group enabled.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class GetSwsWafProfileRuleSetMlRuleSetRuleSetResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str id: Id of the rule set.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        :param _builtins.str version: Version of the rule set.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the rule set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSwsWafProfileRuleSetYaRuleSetResult(dict):
    def __init__(__self__, *,
                 rule_groups: Sequence['outputs.GetSwsWafProfileRuleSetYaRuleSetRuleGroupResult'],
                 rule_sets: Sequence['outputs.GetSwsWafProfileRuleSetYaRuleSetRuleSetResult']):
        """
        :param Sequence['GetSwsWafProfileRuleSetYaRuleSetRuleGroupArgs'] rule_groups: List of rule groups.
        :param Sequence['GetSwsWafProfileRuleSetYaRuleSetRuleSetArgs'] rule_sets: Rule set of the Yandex rule set.
        """
        pulumi.set(__self__, "rule_groups", rule_groups)
        pulumi.set(__self__, "rule_sets", rule_sets)

    @_builtins.property
    @pulumi.getter(name="ruleGroups")
    def rule_groups(self) -> Sequence['outputs.GetSwsWafProfileRuleSetYaRuleSetRuleGroupResult']:
        """
        List of rule groups.
        """
        return pulumi.get(self, "rule_groups")

    @_builtins.property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Sequence['outputs.GetSwsWafProfileRuleSetYaRuleSetRuleSetResult']:
        """
        Rule set of the Yandex rule set.
        """
        return pulumi.get(self, "rule_sets")


@pulumi.output_type
class GetSwsWafProfileRuleSetYaRuleSetRuleGroupResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 id: _builtins.str,
                 inbound_anomaly_score: _builtins.int,
                 is_enabled: _builtins.bool):
        """
        :param _builtins.str action: Action of the rule group.
        :param _builtins.str id: ID of the rule group.
        :param _builtins.int inbound_anomaly_score: Inbound anomaly score.
        :param _builtins.bool is_enabled: Is the rule group enabled.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inbound_anomaly_score", inbound_anomaly_score)
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Action of the rule group.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the rule group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inboundAnomalyScore")
    def inbound_anomaly_score(self) -> _builtins.int:
        """
        Inbound anomaly score.
        """
        return pulumi.get(self, "inbound_anomaly_score")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Is the rule group enabled.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class GetSwsWafProfileRuleSetYaRuleSetRuleSetResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str id: Id of the rule set.
        :param _builtins.str name: Name of the rule set.
        :param _builtins.str type: Type of the rule set.
        :param _builtins.str version: Version of the rule set.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the rule set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the rule set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the rule set.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the rule set.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSwsWafRuleSetDescriptorRuleResult(dict):
    def __init__(__self__, *,
                 anomaly_score: _builtins.int,
                 id: _builtins.str,
                 paranoia_level: _builtins.int):
        """
        :param _builtins.int anomaly_score: Numeric anomaly value, i.e., a potential attack indicator. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [documentation](https://yandex.cloud/docs/smartwebsecurity/concepts/waf#anomaly).
        :param _builtins.str id: The rule ID.
        :param _builtins.int paranoia_level: Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [documentation](https://yandex.cloud/docs/smartwebsecurity/concepts/waf#paranoia).
        """
        pulumi.set(__self__, "anomaly_score", anomaly_score)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "paranoia_level", paranoia_level)

    @_builtins.property
    @pulumi.getter(name="anomalyScore")
    def anomaly_score(self) -> _builtins.int:
        """
        Numeric anomaly value, i.e., a potential attack indicator. The higher this value, the more likely it is that the request that satisfies the rule is an attack. See [documentation](https://yandex.cloud/docs/smartwebsecurity/concepts/waf#anomaly).
        """
        return pulumi.get(self, "anomaly_score")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The rule ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="paranoiaLevel")
    def paranoia_level(self) -> _builtins.int:
        """
        Paranoia level classifies rules according to their aggression. The higher the paranoia level, the better your protection, but also the higher the probability of WAF false positives. See [documentation](https://yandex.cloud/docs/smartwebsecurity/concepts/waf#paranoia).
        """
        return pulumi.get(self, "paranoia_level")


@pulumi.output_type
class GetVpcAddressDnsRecordResult(dict):
    def __init__(__self__, *,
                 dns_zone_id: _builtins.str,
                 fqdn: _builtins.str,
                 ptr: _builtins.bool,
                 ttl: _builtins.int):
        """
        :param _builtins.str dns_zone_id: DNS zone id to create record at.
        :param _builtins.str fqdn: FQDN for record to address.
        :param _builtins.bool ptr: If PTR record is needed.
        :param _builtins.int ttl: TTL of DNS record.
        """
        pulumi.set(__self__, "dns_zone_id", dns_zone_id)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "ptr", ptr)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="dnsZoneId")
    def dns_zone_id(self) -> _builtins.str:
        """
        DNS zone id to create record at.
        """
        return pulumi.get(self, "dns_zone_id")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        FQDN for record to address.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter
    def ptr(self) -> _builtins.bool:
        """
        If PTR record is needed.
        """
        return pulumi.get(self, "ptr")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        TTL of DNS record.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetVpcAddressExternalIpv4AddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 ddos_protection_provider: _builtins.str,
                 outgoing_smtp_capability: _builtins.str,
                 zone_id: _builtins.str):
        """
        :param _builtins.str address: Allocated IP address.
        :param _builtins.str ddos_protection_provider: Enable DDOS protection. Possible values are: `qrator`
        :param _builtins.str outgoing_smtp_capability: Wanted outgoing smtp capability.
        :param _builtins.str zone_id: The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ddos_protection_provider", ddos_protection_provider)
        pulumi.set(__self__, "outgoing_smtp_capability", outgoing_smtp_capability)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Allocated IP address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="ddosProtectionProvider")
    def ddos_protection_provider(self) -> _builtins.str:
        """
        Enable DDOS protection. Possible values are: `qrator`
        """
        return pulumi.get(self, "ddos_protection_provider")

    @_builtins.property
    @pulumi.getter(name="outgoingSmtpCapability")
    def outgoing_smtp_capability(self) -> _builtins.str:
        """
        Wanted outgoing smtp capability.
        """
        return pulumi.get(self, "outgoing_smtp_capability")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        The [availability zone](https://yandex.cloud/docs/overview/concepts/geo-scope) where resource is located. If it is not provided, the default provider zone will be used.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetVpcGatewaySharedEgressGatewayResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcPrivateEndpointDnsOptionResult(dict):
    def __init__(__self__, *,
                 private_dns_records_enabled: _builtins.bool):
        """
        :param _builtins.bool private_dns_records_enabled: If enabled - additional service DNS will be created.
        """
        pulumi.set(__self__, "private_dns_records_enabled", private_dns_records_enabled)

    @_builtins.property
    @pulumi.getter(name="privateDnsRecordsEnabled")
    def private_dns_records_enabled(self) -> _builtins.bool:
        """
        If enabled - additional service DNS will be created.
        """
        return pulumi.get(self, "private_dns_records_enabled")


@pulumi.output_type
class GetVpcPrivateEndpointEndpointAddressResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 address_id: _builtins.str,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str address: Specifies IP address within `subnet_id`.
        :param _builtins.str address_id: ID of the address.
        :param _builtins.str subnet_id: Subnet of the IP address.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "address_id", address_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Specifies IP address within `subnet_id`.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="addressId")
    def address_id(self) -> _builtins.str:
        """
        ID of the address.
        """
        return pulumi.get(self, "address_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Subnet of the IP address.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetVpcPrivateEndpointObjectStorageResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcRouteTableStaticRouteResult(dict):
    def __init__(__self__, *,
                 destination_prefix: _builtins.str,
                 gateway_id: _builtins.str,
                 next_hop_address: _builtins.str):
        """
        :param _builtins.str destination_prefix: Route prefix in CIDR notation.
        :param _builtins.str gateway_id: ID of the gateway used ad next hop.
        :param _builtins.str next_hop_address: Address of the next hop.
        """
        pulumi.set(__self__, "destination_prefix", destination_prefix)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "next_hop_address", next_hop_address)

    @_builtins.property
    @pulumi.getter(name="destinationPrefix")
    def destination_prefix(self) -> _builtins.str:
        """
        Route prefix in CIDR notation.
        """
        return pulumi.get(self, "destination_prefix")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        ID of the gateway used ad next hop.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="nextHopAddress")
    def next_hop_address(self) -> _builtins.str:
        """
        Address of the next hop.
        """
        return pulumi.get(self, "next_hop_address")


@pulumi.output_type
class GetVpcSecurityGroupEgressResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 from_port: _builtins.int,
                 id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 port: _builtins.int,
                 predefined_target: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str,
                 to_port: _builtins.int,
                 v4_cidr_blocks: Sequence[_builtins.str],
                 v6_cidr_blocks: Sequence[_builtins.str]):
        """
        :param _builtins.str description: Description of the rule.
        :param _builtins.int from_port: Minimum port number.
        :param _builtins.str id: The resource identifier.
        :param Mapping[str, _builtins.str] labels: Labels to assign to this rule.
        :param _builtins.int port: Port number (if applied to a single port).
        :param _builtins.str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        :param _builtins.str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param _builtins.str security_group_id: Target security group ID for this rule.
        :param _builtins.int to_port: Maximum port number.
        :param Sequence[_builtins.str] v4_cidr_blocks: The blocks of IPv4 addresses for this rule.
        :param Sequence[_builtins.str] v6_cidr_blocks: The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "predefined_target", predefined_target)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "to_port", to_port)
        pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The resource identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> _builtins.str:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Sequence[_builtins.str]:
        """
        The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Sequence[_builtins.str]:
        """
        The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class GetVpcSecurityGroupIngressResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 from_port: _builtins.int,
                 id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 port: _builtins.int,
                 predefined_target: _builtins.str,
                 protocol: _builtins.str,
                 security_group_id: _builtins.str,
                 to_port: _builtins.int,
                 v4_cidr_blocks: Sequence[_builtins.str],
                 v6_cidr_blocks: Sequence[_builtins.str]):
        """
        :param _builtins.str description: Description of the rule.
        :param _builtins.int from_port: Minimum port number.
        :param _builtins.str id: The resource identifier.
        :param Mapping[str, _builtins.str] labels: Labels to assign to this rule.
        :param _builtins.int port: Port number (if applied to a single port).
        :param _builtins.str predefined_target: Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        :param _builtins.str protocol: One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        :param _builtins.str security_group_id: Target security group ID for this rule.
        :param _builtins.int to_port: Maximum port number.
        :param Sequence[_builtins.str] v4_cidr_blocks: The blocks of IPv4 addresses for this rule.
        :param Sequence[_builtins.str] v6_cidr_blocks: The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "predefined_target", predefined_target)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "to_port", to_port)
        pulumi.set(__self__, "v4_cidr_blocks", v4_cidr_blocks)
        pulumi.set(__self__, "v6_cidr_blocks", v6_cidr_blocks)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        Minimum port number.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The resource identifier.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Labels to assign to this rule.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port number (if applied to a single port).
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="predefinedTarget")
    def predefined_target(self) -> _builtins.str:
        """
        Special-purpose targets. `self_security_group` refers to this particular security group. `loadbalancer_healthchecks` represents [loadbalancer health check nodes](https://yandex.cloud/docs/network-load-balancer/concepts/health-check).
        """
        return pulumi.get(self, "predefined_target")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        One of `ANY`, `TCP`, `UDP`, `ICMP`, `IPV6_ICMP`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Target security group ID for this rule.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        Maximum port number.
        """
        return pulumi.get(self, "to_port")

    @_builtins.property
    @pulumi.getter(name="v4CidrBlocks")
    def v4_cidr_blocks(self) -> Sequence[_builtins.str]:
        """
        The blocks of IPv4 addresses for this rule.
        """
        return pulumi.get(self, "v4_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="v6CidrBlocks")
    def v6_cidr_blocks(self) -> Sequence[_builtins.str]:
        """
        The blocks of IPv6 addresses for this rule. `v6_cidr_blocks` argument is currently not supported. It will be available in the future.
        """
        return pulumi.get(self, "v6_cidr_blocks")


@pulumi.output_type
class GetVpcSubnetDhcpOptionResult(dict):
    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 domain_name_servers: Sequence[_builtins.str],
                 ntp_servers: Sequence[_builtins.str]):
        """
        :param _builtins.str domain_name: Domain name.
        :param Sequence[_builtins.str] domain_name_servers: Domain name server IP addresses.
        :param Sequence[_builtins.str] ntp_servers: NTP server IP addresses.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        pulumi.set(__self__, "ntp_servers", ntp_servers)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Sequence[_builtins.str]:
        """
        Domain name server IP addresses.
        """
        return pulumi.get(self, "domain_name_servers")

    @_builtins.property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Sequence[_builtins.str]:
        """
        NTP server IP addresses.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class GetYdbDatabaseDedicatedLocationResult(dict):
    def __init__(__self__, *,
                 regions: Sequence['outputs.GetYdbDatabaseDedicatedLocationRegionResult']):
        """
        :param Sequence['GetYdbDatabaseDedicatedLocationRegionArgs'] regions: Region for the Yandex Database cluster.
        """
        pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Sequence['outputs.GetYdbDatabaseDedicatedLocationRegionResult']:
        """
        Region for the Yandex Database cluster.
        """
        return pulumi.get(self, "regions")


@pulumi.output_type
class GetYdbDatabaseDedicatedLocationRegionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: Region ID for the Yandex Database cluster.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Region ID for the Yandex Database cluster.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetYdbDatabaseDedicatedScalePolicyResult(dict):
    def __init__(__self__, *,
                 auto_scales: Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyAutoScaleResult'],
                 fixed_scales: Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyFixedScaleResult']):
        """
        :param Sequence['GetYdbDatabaseDedicatedScalePolicyAutoScaleArgs'] auto_scales: Auto scaling policy for the Yandex Database cluster. This is a preview feature, and you need to enable it using the label `enable_autoscaling=1`.
        :param Sequence['GetYdbDatabaseDedicatedScalePolicyFixedScaleArgs'] fixed_scales: Fixed scaling policy for the Yandex Database cluster.
        """
        pulumi.set(__self__, "auto_scales", auto_scales)
        pulumi.set(__self__, "fixed_scales", fixed_scales)

    @_builtins.property
    @pulumi.getter(name="autoScales")
    def auto_scales(self) -> Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyAutoScaleResult']:
        """
        Auto scaling policy for the Yandex Database cluster. This is a preview feature, and you need to enable it using the label `enable_autoscaling=1`.
        """
        return pulumi.get(self, "auto_scales")

    @_builtins.property
    @pulumi.getter(name="fixedScales")
    def fixed_scales(self) -> Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyFixedScaleResult']:
        """
        Fixed scaling policy for the Yandex Database cluster.
        """
        return pulumi.get(self, "fixed_scales")


@pulumi.output_type
class GetYdbDatabaseDedicatedScalePolicyAutoScaleResult(dict):
    def __init__(__self__, *,
                 max_size: _builtins.int,
                 min_size: _builtins.int,
                 target_trackings: Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyAutoScaleTargetTrackingResult']):
        """
        :param _builtins.int max_size: Maximum number of nodes to which autoscaling can scale the database.
        :param _builtins.int min_size: Minimum number of nodes to which autoscaling can scale the database.
        :param Sequence['GetYdbDatabaseDedicatedScalePolicyAutoScaleTargetTrackingArgs'] target_trackings: A target tracking scaling policy automatically scales the capacity of your Yandex Database cluster based on a target metric value.
        """
        pulumi.set(__self__, "max_size", max_size)
        pulumi.set(__self__, "min_size", min_size)
        pulumi.set(__self__, "target_trackings", target_trackings)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.int:
        """
        Maximum number of nodes to which autoscaling can scale the database.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> _builtins.int:
        """
        Minimum number of nodes to which autoscaling can scale the database.
        """
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter(name="targetTrackings")
    def target_trackings(self) -> Sequence['outputs.GetYdbDatabaseDedicatedScalePolicyAutoScaleTargetTrackingResult']:
        """
        A target tracking scaling policy automatically scales the capacity of your Yandex Database cluster based on a target metric value.
        """
        return pulumi.get(self, "target_trackings")


@pulumi.output_type
class GetYdbDatabaseDedicatedScalePolicyAutoScaleTargetTrackingResult(dict):
    def __init__(__self__, *,
                 cpu_utilization_percent: _builtins.int):
        """
        :param _builtins.int cpu_utilization_percent: A percentage of database nodes average CPU utilization.
        """
        pulumi.set(__self__, "cpu_utilization_percent", cpu_utilization_percent)

    @_builtins.property
    @pulumi.getter(name="cpuUtilizationPercent")
    def cpu_utilization_percent(self) -> _builtins.int:
        """
        A percentage of database nodes average CPU utilization.
        """
        return pulumi.get(self, "cpu_utilization_percent")


@pulumi.output_type
class GetYdbDatabaseDedicatedScalePolicyFixedScaleResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int):
        """
        :param _builtins.int size: Number of instances for the Yandex Database cluster.
        """
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Number of instances for the Yandex Database cluster.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetYdbDatabaseDedicatedStorageConfigResult(dict):
    def __init__(__self__, *,
                 group_count: _builtins.int,
                 storage_type_id: _builtins.str):
        """
        :param _builtins.int group_count: Amount of storage groups of selected type for the Yandex Database cluster.
        :param _builtins.str storage_type_id: Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
        pulumi.set(__self__, "group_count", group_count)
        pulumi.set(__self__, "storage_type_id", storage_type_id)

    @_builtins.property
    @pulumi.getter(name="groupCount")
    def group_count(self) -> _builtins.int:
        """
        Amount of storage groups of selected type for the Yandex Database cluster.
        """
        return pulumi.get(self, "group_count")

    @_builtins.property
    @pulumi.getter(name="storageTypeId")
    def storage_type_id(self) -> _builtins.str:
        """
        Storage type ID for the Yandex Database cluster. Available presets can be obtained via `yc ydb storage-type list` command.
        """
        return pulumi.get(self, "storage_type_id")


@pulumi.output_type
class GetYdbDatabaseServerlessServerlessDatabaseResult(dict):
    def __init__(__self__, *,
                 enable_throttling_rcu_limit: _builtins.bool,
                 provisioned_rcu_limit: _builtins.int,
                 storage_size_limit: _builtins.int,
                 throttling_rcu_limit: _builtins.int):
        pulumi.set(__self__, "enable_throttling_rcu_limit", enable_throttling_rcu_limit)
        pulumi.set(__self__, "provisioned_rcu_limit", provisioned_rcu_limit)
        pulumi.set(__self__, "storage_size_limit", storage_size_limit)
        pulumi.set(__self__, "throttling_rcu_limit", throttling_rcu_limit)

    @_builtins.property
    @pulumi.getter(name="enableThrottlingRcuLimit")
    def enable_throttling_rcu_limit(self) -> _builtins.bool:
        return pulumi.get(self, "enable_throttling_rcu_limit")

    @_builtins.property
    @pulumi.getter(name="provisionedRcuLimit")
    def provisioned_rcu_limit(self) -> _builtins.int:
        return pulumi.get(self, "provisioned_rcu_limit")

    @_builtins.property
    @pulumi.getter(name="storageSizeLimit")
    def storage_size_limit(self) -> _builtins.int:
        return pulumi.get(self, "storage_size_limit")

    @_builtins.property
    @pulumi.getter(name="throttlingRcuLimit")
    def throttling_rcu_limit(self) -> _builtins.int:
        return pulumi.get(self, "throttling_rcu_limit")


