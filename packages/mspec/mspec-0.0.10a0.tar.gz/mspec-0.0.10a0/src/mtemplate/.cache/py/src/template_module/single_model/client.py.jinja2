from core.exceptions import MSpecError, ConfigError, NotFoundError, AuthenticationError, ForbiddenError
from {{ module.name.snake_case }}.{{ model.name.snake_case }}.model import {{ model.name.pascal_case }}

import json

from urllib.request import Request, urlopen
from urllib.error import HTTPError


__all__ = [
    'client_create_{{ model.name.snake_case }}',
    'client_read_{{ model.name.snake_case }}',
    'client_update_{{ model.name.snake_case }}',
    'client_delete_{{ model.name.snake_case }}',
    'client_list_{{ model.name.snake_case }}'
]

def client_create_{{ model.name.snake_case }}(ctx:dict, obj:{{ model.name.pascal_case }}) -> {{ model.name.pascal_case }}:
    """
    create a {{ model.name.lower_case }} on the server, verifying the data first.
    
    args ::
        ctx :: dict containing the client context.
        obj :: the {{ model.name.pascal_case }} object to create.
    
    return :: {{ model.name.pascal_case }} object with the new id.

    raises :: ConfigError, MSpecError
    """

    try:
        url = f'{ctx["host"]}/api/{{ module.name.kebab_case }}/{{ model.name.kebab_case }}'
    except KeyError:
        raise ConfigError('invalid context, missing host')

    request_body = obj.validate().to_json().encode()

    try:
        request = Request(url, headers=ctx['headers'], method='POST', data=request_body)

        with urlopen(request) as response:
            response_body = response.read().decode('utf-8')
            return {{ model.name.pascal_case }}(**json.loads(response_body)).convert_types()
        
    except HTTPError as e:
        if e.code == 401:
            raise AuthenticationError('Error creating {{ model.name.lower_case }}: authentication error')
        elif e.code == 403:
            raise ForbiddenError('Error creating {{ model.name.lower_case }}: forbidden')

        raise MSpecError(f'error creating {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')

    except (json.JSONDecodeError, KeyError) as e:
        raise MSpecError(f'invalid response from server, {e.__class__.__name__}: {e}')
    except Exception as e:
        raise MSpecError(f'error creating {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')

def client_read_{{ model.name.snake_case }}(ctx:dict, id:str) -> {{ model.name.pascal_case }}:
    """
    read a {{ model.name.lower_case }} from the server, verifying it first.

    args ::
        ctx :: dict containing the client context.
        id :: str of the id of the item to read.
    
    return :: profile object if it exists.

    raises :: ConfigError, MSpecError, NotFoundError
    """

    try:
        url = ctx['host'] + '/api/{{ module.name.kebab_case }}/{{ model.name.kebab_case }}/' + id
    except KeyError:
        raise ConfigError('invalid context, missing host')

    try:

        request = Request(url, headers=ctx['headers'], method='GET')

        with urlopen(request) as response:
            response_body = response.read().decode('utf-8')

    except HTTPError as e:
        if e.code == 401:
            raise AuthenticationError('Error reading {{ model.name.lower_case }}: invalid username or password')
        elif e.code == 403:
            raise ForbiddenError('Error reading {{ model.name.lower_case }}: forbidden')
        elif e.code == 404:
            raise NotFoundError(f'{{ model.name.lower_case }} {id} not found')
        raise MSpecError(f'error reading {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')
    except (json.JSONDecodeError, KeyError) as e:
        raise MSpecError('invalid response from server, {e.__class__.__name__}: {e}')
    except Exception as e:
        raise MSpecError(f'error reading {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')

    return {{ model.name.pascal_case }}(**json.loads(response_body)).convert_types()

def client_update_{{ model.name.snake_case }}(ctx:dict, obj:{{ model.name.pascal_case }}) -> {{ model.name.pascal_case }}:
    """
    update a {{ model.name.lower_case }} on the server, verifying the data first.

    args ::
        ctx :: dict containing the client context.
        obj :: the {{ model.name.pascal_case }} object to update.
    
    return :: {{ model.name.pascal_case }} object.

    raises :: ConfigError, MSpecError, NotFoundError
    """
    try:
        _id = obj.id
    except KeyError:
        raise ValueError('invalid data, missing id')

    if _id is None:
        raise ValueError('invalid data, missing id')

    try:
        url = f'{ctx["host"]}/api/{{ module.name.kebab_case }}/{{ model.name.kebab_case }}/{_id}'
    except KeyError:
        raise ConfigError('invalid context, missing host')

    request_body = obj.validate().to_json().encode()

    try:
        request = Request(url, headers=ctx['headers'], method='PUT', data=request_body)

        with urlopen(request) as response:
            response_body = response.read().decode('utf-8')
    
    except HTTPError as e:
        if e.code == 401:
            raise AuthenticationError('Error updating {{ model.name.lower_case }}: authentication error')
        elif e.code == 403:
            raise ForbiddenError('Error updating {{ model.name.lower_case }}: forbidden')
        elif e.code == 404:
            raise NotFoundError(f'{{ model.name.lower_case }} {id} not found')
        raise MSpecError(f'error updating {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')
        
    except (json.JSONDecodeError, KeyError) as e:
        raise MSpecError('invalid response from server, {e.__class__.__name__}: {e}')
    
    except Exception as e:
        raise MSpecError(f'error updating {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')

    return {{ model.name.pascal_case }}(**json.loads(response_body)).convert_types()

def client_delete_{{ model.name.snake_case }}(ctx:dict, id:str) -> None:
    """
    delete a {{ model.name.lower_case }} from the server.

    args ::
        ctx :: dict containing the client context.
        id :: str of the id of the item to delete.
    
    return :: None

    raises :: ConfigError, MSpecError
    """

    try:
        url = f'{ctx["host"]}/api/{{ module.name.kebab_case }}/{{ model.name.kebab_case }}/{id}'
    except KeyError:
        raise ConfigError('invalid context, missing host')

    try:
        request = Request(url, headers=ctx['headers'], method='DELETE')

        with urlopen(request) as response:
            _ = response.read().decode('utf-8')

    except (json.JSONDecodeError, KeyError) as e:
        raise MSpecError('invalid response from server, {e.__class__.__name__}: {e}')
    
    except Exception as e:
        raise MSpecError(f'error deleting {{ model.name.lower_case }}: {e.__class__.__name__}: {e}')

def client_list_{{ model.name.snake_case }}(ctx:dict, offset:int=0, limit:int=50) -> list[{{ model.name.pascal_case }}]:
    """
    list {{ model.name.lower_case }}s from the server, verifying each.

    args ::
        ctx :: dict containing the client context.
        offset :: int of the offset to start listing from.
        limit :: int of the maximum number of items to list.
    
    return :: list of {{ model.name.pascal_case }} objects.

    raises :: ConfigError, MSpecError
    """

    try:
        url = f'{ctx["host"]}/api/{{ module.name.kebab_case }}/{{ model.name.kebab_case }}?offset={offset}&limit={limit}'
    except KeyError:
        raise ConfigError('invalid context, missing host')

    try:
        request = Request(url, headers=ctx['headers'], method='GET')
        
        with urlopen(request) as response:
            response_body = response.read().decode('utf-8')

        response_data = json.loads(response_body)

        return {
            'total': response_data['total'],
            'items': [{{ model.name.pascal_case }}(**item).convert_types() for item in response_data['items']]
        }

    except (json.JSONDecodeError, TypeError) as e:
        raise MSpecError(f'invalid response from server, {e.__class__.__name__}: {e}')

    except Exception as e:
        raise MSpecError(f'error listing {{ model.name.lower_case }}s: {e.__class__.__name__}: {e}')