import sqlite3
from datetime import datetime
from core.types import datetime_format_str
from core.exceptions import ForbiddenError, NotFoundError
from template_module.multi_model.model import MultiModel

__all__ = [
    'db_create_multi_model', 
    'db_read_multi_model',
    'db_update_multi_model', 
    'db_delete_multi_model', 
    'db_list_multi_model',
]

def db_create_multi_model(ctx:dict, obj:MultiModel) -> MultiModel:
    """
    create a multi model in the database, verifying the data first.

    args ::
        ctx :: dict containing the database client
        obj :: the MultiModel object to create.

    return :: and MultiModel object with the new id.
    """
    if obj.id is not None:
        raise ValueError('id must be null to create a new item')
    
    obj.validate()
    cursor:sqlite3.Cursor = ctx['db']['cursor']



    result = cursor.execute(
        "INSERT INTO multi_model('user_id') VALUES(?)",
        (user.id,)
    )
    assert result.rowcount == 1
    assert result.lastrowid is not None
    obj.id = str(result.lastrowid)


    ctx['db']['commit']()
    return obj

def db_read_multi_model(ctx:dict, id:str) -> MultiModel:
    """
    read a multi model from the database and verify it.

    args ::
        ctx :: dict containing the database client
        id :: the id of the item to read.

    return :: the MultiModel object.
    raises :: NotFoundError if the item is not found.
    """

    cursor:sqlite3.Cursor = ctx['db']['cursor']
    result = cursor.execute(f"SELECT * FROM multi_model WHERE id=?", (id,))
    entry = result.fetchone()
    if entry is None:
        raise NotFoundError(f'multi model {id} not found')

    return MultiModel(
        id=str(entry[0]),
        multi_float=multi_float,
        multi_int=multi_int,
        multi_string=multi_string,
        multi_enum=multi_enum,
        multi_datetime=multi_datetime
    ).validate()

def db_update_multi_model(ctx:dict, obj:MultiModel) -> MultiModel:
    """
    update a multi model in the database, and verify the data first.

    args ::
        ctx :: dict containing the database client
        obj :: the MultiModel object to update.

    return :: the MultiModel object.
    raises :: NotFoundError if the item is not found
    """
    if obj.id is None:
        raise ValueError('id must not be null to update an item')
    
    obj.validate()


    cursor:sqlite3.Cursor = ctx['db']['cursor']

    ctx['db']['commit']()
    return obj

def db_delete_multi_model(ctx:dict, id:str) -> None:
    """
    delete a multi model from the database.

    args ::
        ctx :: dict containing the database client
        id :: the id of the item to delete.
    
    return :: None
    """

    cursor:sqlite3.Cursor = ctx['db']['cursor']


    cursor.execute(f"DELETE FROM multi_model WHERE id=?", (id,))

    cursor.execute(f"DELETE FROM multi_model_multi_int WHERE multi_model_id=?", (id,))
    cursor.execute(f"DELETE FROM multi_model_multi_float WHERE multi_model_id=?", (id,))
    cursor.execute(f"DELETE FROM multi_model_multi_string WHERE multi_model_id=?", (id,))
    cursor.execute(f"DELETE FROM multi_model_multi_enum WHERE multi_model_id=?", (id,))
    cursor.execute(f"DELETE FROM multi_model_multi_datetime WHERE multi_model_id=?", (id,))

    ctx['db']['commit']()

def db_list_multi_model(ctx:dict, offset:int=0, limit:int=25) -> dict:
    """
    list multi models from the database, and verify each

    args ::
        ctx :: dict containing the database client
        offset :: the offset to start listing from.
        limit :: the maximum number of items to list.

    return :: dict with two keys:
        total :: int of the total number of items.
        items :: list of each item as a dict.
    """
    cursor:sqlite3.Cursor = ctx['db']['cursor']
    
    items = []
    query = cursor.execute("SELECT * FROM multi_model ORDER BY id LIMIT ? OFFSET ?", (limit, offset))

    for entry in query.fetchall():

        items.append(MultiModel(
            id=str(entry[0]),
            user_id=str(entry[1]),
			multi_bool=multi_bool,
			multi_float=multi_float,
			multi_int=multi_int,
			multi_string=multi_string,
            multi_enum=multi_enum,
            multi_datetime=multi_datetime,
        ).validate())

    return {
        'total': cursor.execute("SELECT COUNT(*) FROM multi_model").fetchone()[0],
        'items': items
    }