import sqlite3
from datetime import datetime
from core.types import datetime_format_str
from core.exceptions import NotFoundError
from {{ module.name.snake_case }}.{{ model.name.snake_case }}.model import {{ model.name.pascal_case }}


__all__ = [
    'db_create_{{ model.name.snake_case }}', 
    'db_read_{{ model.name.snake_case }}',
    'db_update_{{ model.name.snake_case }}', 
    'db_delete_{{ model.name.snake_case }}', 
    'db_list_{{ model.name.snake_case }}',
]

def db_create_{{ model.name.snake_case }}(ctx:dict, obj:{{ model.name.pascal_case }}) -> {{ model.name.pascal_case }}:
    """
    create a single model in the database, verifying the data first.

    args ::
        ctx :: dict containing the database client
        obj :: the {{ model.name.pascal_case }} object to create.

    return :: and {{ model.name.pascal_case }} object with the new id.
    """
    if obj.id is not None:
        raise ValueError('id must be null to create a new item')
    
    obj.validate()
    cursor:sqlite3.Cursor = ctx['db']['cursor']
    {% if model.auth.require_login is true %}
{{ macro.py_create_model_login_check(model=model) }}
    {% endif %}

    {% if model.auth.max_models_per_user is not none %}
{{ macro.py_create_model_max_created_check(model=model) }}
    {% endif %}

{{ macro.py_db_create(model) }}


    {% for field in model.list_fields %}
{{ macro_by_type('py_sql_create', field.type_id, model=model, field=field) }}
    {% endfor %}

    ctx['db']['commit']()
    return obj

def db_read_{{ model.name.snake_case }}(ctx:dict, id:str) -> {{ model.name.pascal_case }}:
    """
    read a single model from the database and verify it.

    args ::
        ctx :: dict containing the database client
        id :: the id of the item to read.
    
    return :: the {{ model.name.pascal_case }} object.
    raises :: NotFoundError if the item is not found.
    """

{{ macro.py_sql_read(model=model) }}

    {% for field in model.list_fields %}
{{ macro_by_type('py_sql_read', field.type_id, model=model, field=field) }}
    {% endfor %}
    
    return {{ model.name.pascal_case }}(
        id=str(entry[0]),
        {% for index, field in enumerate(model.non_list_fields, start=1) %}
            {% if field.name.snake_case == 'user_id' %}
{{ macro.py_sql_convert_user_id(field=field, index=index) }}
            {% else %}
{{ macro_by_type('py_sql_convert', field.type_id, field=field, index=index) }}
            {% endif %}
        {% endfor %}
        {% for field in model.list_fields %}
{{ macro.py_sql_convert_list(field=field) }}
        {% endfor %}
    ).validate()

def db_update_{{ model.name.snake_case }}(ctx:dict, obj:{{ model.name.pascal_case }}) -> {{ model.name.pascal_case }}:
    """
    update a single model in the database, and verify the data first.

    args ::
        ctx :: dict containing the database client
        obj :: the {{ model.name.pascal_case }} object to update.

    return :: the {{ model.name.pascal_case }} object.
    raises :: NotFoundError if the item is not found
    """
    if obj.id is None:
        raise ValueError('id must not be null to update an item')
    
    obj.validate()
    cursor:sqlite3.Cursor = ctx['db']['cursor']
    {% if model.auth.require_login is true %}
{{ macro.py_db_update_auth(model=model) }}
    {% endif %}

{{ macro.py_db_update(model=model) }}


    ctx['db']['commit']()
    return obj

def db_delete_{{ model.name.snake_case }}(ctx:dict, id:str) -> None:
    """
    delete a single model from the database.

    args ::
        ctx :: dict containing the database client
        id :: the id of the item to delete.
    
    return :: None
    """

    cursor:sqlite3.Cursor = ctx['db']['cursor']
    {% if model.auth.require_login is true %}
{{ macro.py_db_delete_auth(model=model) }}
    {% endif %}


{{ macro.py_sql_delete(model=model) }}

    {% for field in model.list_fields %}
{{ macro.py_sql_delete_list(model=model, field=field) }}
    {% endfor %}

    ctx['db']['commit']()

def db_list_{{ model.name.snake_case }}(ctx:dict, offset:int=0, limit:int=25) -> dict:
    """
    list single models from the database, and verify each

    args ::
        ctx :: dict containing the database client
        offset :: the offset to start listing from.
        limit :: the maximum number of items to list.
    
    return :: dict with two keys:
        total :: int of the total number of items.
        items :: list of each item as a dict.
    """
    cursor:sqlite3.Cursor = ctx['db']['cursor']
    
    items = []
    query = cursor.execute("SELECT * FROM {{ model.name.snake_case }} ORDER BY id LIMIT ? OFFSET ?", (limit, offset))

    for entry in query.fetchall():
        {% for field in model.list_fields %}
{{ macro_by_type('py_sql', field.type_id, model=model, field=field) }}
        {% endfor %}
        items.append({{ model.name.pascal_case }}(
            id=str(entry[0]),
            {% for index, field in enumerate(model.non_list_fields, start=1) %}
                {% if field.name.snake_case == 'user_id' %}
{{ macro.py_sql_convert_user_id(field=field, index=index) }}
                {% else %}
{{ macro_by_type('py_sql_convert', field.type_id, field=field, index=index) }}
                {% endif %}
            {% endfor %}
            {% for field in model.list_fields %}
{{ macro.py_sql_convert_list(field=field) }}
            {% endfor %}
        ).validate())

    return {
        'total': cursor.execute("SELECT COUNT(*) FROM {{ model.name.snake_case }}").fetchone()[0],
        'items': items
    }
