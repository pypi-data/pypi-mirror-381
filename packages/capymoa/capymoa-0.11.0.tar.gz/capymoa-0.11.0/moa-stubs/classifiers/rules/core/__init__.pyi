
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import moa
import moa.classifiers.core
import moa.classifiers.core.attributeclassobservers
import moa.classifiers.core.conditionaltests
import moa.classifiers.core.splitcriteria
import moa.classifiers.rules
import moa.classifiers.rules.core.anomalydetection
import moa.classifiers.rules.core.attributeclassobservers
import moa.classifiers.rules.core.changedetection
import moa.classifiers.rules.core.conditionaltests
import moa.classifiers.rules.core.splitcriteria
import moa.classifiers.rules.core.voting
import moa.classifiers.rules.functions
import moa.classifiers.rules.multilabel.attributeclassobservers
import moa.classifiers.trees
import moa.core
import typing



class Predicate:
    def evaluate(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...
    def getAttributeIndex(self) -> int: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int, instanceInformation: com.yahoo.labs.samoa.instances.InstanceInformation) -> None: ...
    def isEqualOrLess(self) -> bool: ...
    def negateCondition(self) -> None: ...

class Rule(moa.AbstractMOAObject):
    def __init__(self, builder: 'Rule.Builder'): ...
    def computeError(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    def getBuilder(self) -> 'Rule.Builder': ...
    def getCurrentError(self) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getInstancesSeen(self) -> int: ...
    def getLearningNode(self) -> 'RuleActiveLearningNode': ...
    def getNodeList(self) -> java.util.List['RuleSplitNode']: ...
    @typing.overload
    def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> typing.MutableSequence[float]: ...
    def getRuleNumberID(self) -> int: ...
    def isAnomaly(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float, double2: float, int: int) -> bool: ...
    def isCovering(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...
    def printRule(self) -> str: ...
    def setBuilder(self, builder: 'Rule.Builder') -> None: ...
    def setLearningNode(self, ruleActiveLearningNode: 'RuleActiveLearningNode') -> None: ...
    def setNodeList(self, list: java.util.List['RuleSplitNode']) -> None: ...
    def setRuleNumberID(self, int: int) -> None: ...
    def split(self) -> None: ...
    def statisticsOtherBranchSplit(self) -> typing.MutableSequence[float]: ...
    def tryToExpand(self, double: float, double2: float) -> bool: ...
    def updatePageHinckleyTest(self, double: float) -> bool: ...
    def updateStatistics(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class Builder(java.io.Serializable):
        constantLearningRatioDecayOption: com.github.javacliparser.FlagOption = ...
        learningRatioOption: com.github.javacliparser.FloatOption = ...
        id: int = ...
        amRules: moa.classifiers.rules.AbstractAMRules = ...
        def __init__(self): ...
        def alpha(self, double: float) -> 'Rule.Builder': ...
        def amRules(self, abstractAMRules: moa.classifiers.rules.AbstractAMRules) -> 'Rule.Builder': ...
        def build(self) -> 'Rule': ...
        def changeDetection(self, boolean: bool) -> 'Rule.Builder': ...
        def getAMRules(self) -> moa.classifiers.rules.AbstractAMRules: ...
        def getOwner(self) -> 'Rule': ...
        def id(self, int: int) -> 'Rule.Builder': ...
        def owner(self, rule: 'Rule') -> 'Rule.Builder': ...
        def predictionFunction(self, int: int) -> 'Rule.Builder': ...
        def setOwner(self, rule: 'Rule') -> None: ...
        def statistics(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'Rule.Builder': ...
        def threshold(self, double: float) -> 'Rule.Builder': ...

class RuleActiveLearningNode(moa.classifiers.trees.HoeffdingTree.ActiveLearningNode):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, builder: Rule.Builder): ...
    def computeError(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def computeProbability(self, double: float, double2: float, double3: float) -> float: ...
    def getAttributeObservers(self) -> moa.core.AutoExpandVector[moa.classifiers.core.attributeclassobservers.AttributeClassObserver]: ...
    def getBestSuggestion(self) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getCurrentError(self) -> float: ...
    def getInstancesSeen(self) -> int: ...
    def getLearnerToUse(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> int: ...
    def getNodeStatistics(self) -> moa.core.DoubleVector: ...
    @typing.overload
    def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def getSimplePrediction(self) -> typing.MutableSequence[float]: ...
    def getSplitIndex(self) -> int: ...
    def getStatisticsBranchSplit(self) -> typing.MutableSequence[float]: ...
    def getStatisticsNewRuleActiveLearningNode(self) -> typing.MutableSequence[float]: ...
    def getStatisticsOtherBranchSplit(self) -> typing.MutableSequence[float]: ...
    def initialize(self, ruleActiveLearningNode: 'RuleActiveLearningNode') -> None: ...
    def isAnomaly(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float, double2: float, int: int) -> bool: ...
    @typing.overload
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    @typing.overload
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: moa.classifiers.trees.HoeffdingTree) -> None: ...
    def setBestSuggestion(self, attributeSplitSuggestion: moa.classifiers.core.AttributeSplitSuggestion) -> None: ...
    def setSplitIndex(self, int: int) -> None: ...
    def setStatisticsBranchSplit(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setStatisticsNewRuleActiveLearningNode(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setStatisticsOtherBranchSplit(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def tryToExpand(self, double: float, double2: float) -> bool: ...
    def updateChangeDetection(self, double: float) -> bool: ...
    def updatePageHinckleyTest(self, double: float) -> bool: ...
    def updateStatistics(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class RuleSet(java.util.ArrayList[Rule]):
    def __init__(self): ...

class RuleSplitNode(moa.classifiers.trees.HoeffdingTree.SplitNode):
    def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    def evaluate(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...
    def getSplitTest(self) -> moa.classifiers.core.conditionaltests.InstanceConditionalTest: ...

class Utils:
    def __init__(self): ...
    @staticmethod
    def complementSet(intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def computeEntropy(double: float, double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def computeEntropy(doubleVector: moa.core.DoubleVector) -> float: ...
    @typing.overload
    @staticmethod
    def computeSD(double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    @staticmethod
    def computeSD(doubleVector: moa.core.DoubleVector) -> float: ...
    @typing.overload
    @staticmethod
    def computeVariance(double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    @staticmethod
    def computeVariance(doubleVector: moa.core.DoubleVector) -> float: ...
    @typing.overload
    @staticmethod
    def copy(singleVectorArray: typing.Union[typing.List[moa.classifiers.rules.multilabel.attributeclassobservers.SingleVector], jpype.JArray]) -> typing.MutableSequence[moa.classifiers.rules.multilabel.attributeclassobservers.SingleVector]: ...
    @typing.overload
    @staticmethod
    def copy(doubleVectorArray: typing.Union[typing.List[moa.core.DoubleVector], jpype.JArray]) -> typing.MutableSequence[moa.core.DoubleVector]: ...
    @typing.overload
    @staticmethod
    def copy(doubleVectorArray: typing.Union[typing.List[typing.MutableSequence[moa.core.DoubleVector]], jpype.JArray]) -> typing.MutableSequence[typing.MutableSequence[moa.core.DoubleVector]]: ...
    @staticmethod
    def copyAsFloatVector(doubleVectorArray: typing.Union[typing.List[moa.core.DoubleVector], jpype.JArray]) -> typing.MutableSequence[moa.classifiers.rules.multilabel.attributeclassobservers.SingleVector]: ...
    @staticmethod
    def floatToDoubleVector(singleVector: moa.classifiers.rules.multilabel.attributeclassobservers.SingleVector) -> moa.core.DoubleVector: ...
    @staticmethod
    def getIndexCorrespondence(intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> typing.MutableSequence[int]: ...

class NominalRulePredicate(moa.AbstractMOAObject, Predicate):
    def __init__(self, int: int, double: float, boolean: bool): ...
    @typing.overload
    def evaluate(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...
    @typing.overload
    def evaluate(self, multiLabelInstance: com.yahoo.labs.samoa.instances.MultiLabelInstance) -> bool: ...
    def getAttributeIndex(self) -> int: ...
    @typing.overload
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int, instanceInformation: com.yahoo.labs.samoa.instances.InstanceInformation) -> None: ...
    def isEqualOrLess(self) -> bool: ...
    def negateCondition(self) -> None: ...
    def toString(self) -> str: ...

class NumericRulePredicate(moa.AbstractMOAObject, Predicate):
    def __init__(self, int: int, double: float, boolean: bool): ...
    @typing.overload
    def evaluate(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...
    @typing.overload
    def evaluate(self, multiLabelInstance: com.yahoo.labs.samoa.instances.MultiLabelInstance) -> bool: ...
    def getAttributeIndex(self) -> int: ...
    @typing.overload
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int, instanceInformation: com.yahoo.labs.samoa.instances.InstanceInformation) -> None: ...
    def isEqualOrLess(self) -> bool: ...
    def negateCondition(self) -> None: ...
    def toString(self) -> str: ...

class RuleActiveRegressionNode(RuleActiveLearningNode):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, builder: Rule.Builder): ...
    def computeError(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    @typing.overload
    def computeSD(self, double: float, double2: float, double3: float) -> float: ...
    @typing.overload
    def computeSD(self, double: float, double2: float, long: int) -> float: ...
    @typing.overload
    def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion) -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
    @typing.overload
    def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, hoeffdingTree: moa.classifiers.trees.HoeffdingTree) -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
    def getCurrentError(self) -> float: ...
    def getLearnerToUse(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> int: ...
    def getNormalizedPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    def getPerceptron(self) -> moa.classifiers.rules.functions.Perceptron: ...
    @typing.overload
    def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> typing.MutableSequence[float]: ...
    def getSimplePrediction(self) -> typing.MutableSequence[float]: ...
    def getTargetMean(self) -> moa.classifiers.rules.functions.TargetMean: ...
    def getWeightSeen(self) -> float: ...
    def initialize(self, ruleActiveLearningNode: RuleActiveLearningNode) -> None: ...
    def isAnomaly(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float, double2: float, int: int) -> bool: ...
    @typing.overload
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: moa.classifiers.trees.HoeffdingTree) -> None: ...
    @typing.overload
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def setPerceptron(self, perceptron: moa.classifiers.rules.functions.Perceptron) -> None: ...
    def setTargetMean(self, targetMean: moa.classifiers.rules.functions.TargetMean) -> None: ...
    def tryToExpand(self, double: float, double2: float) -> bool: ...
    def updateStatistics(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.rules.core")``.

    NominalRulePredicate: typing.Type[NominalRulePredicate]
    NumericRulePredicate: typing.Type[NumericRulePredicate]
    Predicate: typing.Type[Predicate]
    Rule: typing.Type[Rule]
    RuleActiveLearningNode: typing.Type[RuleActiveLearningNode]
    RuleActiveRegressionNode: typing.Type[RuleActiveRegressionNode]
    RuleSet: typing.Type[RuleSet]
    RuleSplitNode: typing.Type[RuleSplitNode]
    Utils: typing.Type[Utils]
    anomalydetection: moa.classifiers.rules.core.anomalydetection.__module_protocol__
    attributeclassobservers: moa.classifiers.rules.core.attributeclassobservers.__module_protocol__
    changedetection: moa.classifiers.rules.core.changedetection.__module_protocol__
    conditionaltests: moa.classifiers.rules.core.conditionaltests.__module_protocol__
    splitcriteria: moa.classifiers.rules.core.splitcriteria.__module_protocol__
    voting: moa.classifiers.rules.core.voting.__module_protocol__
