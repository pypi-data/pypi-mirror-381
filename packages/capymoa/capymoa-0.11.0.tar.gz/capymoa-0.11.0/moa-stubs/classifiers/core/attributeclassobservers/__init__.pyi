
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import java.io
import java.lang
import jpype
import moa.classifiers.core
import moa.classifiers.core.splitcriteria
import moa.core
import moa.options
import typing



class AttributeClassObserver(moa.options.OptionHandler):
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...

class DiscreteAttributeClassObserver(AttributeClassObserver): ...

class NullAttributeClassObserver(moa.options.AbstractOptionHandler, AttributeClassObserver):
    def __init__(self): ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    def totalWeightOfClassObservations(self) -> float: ...
    def weightOfObservedMissingValues(self) -> float: ...

class NumericAttributeClassObserver(AttributeClassObserver): ...

class BinaryTreeNumericAttributeClassObserver(moa.options.AbstractOptionHandler, NumericAttributeClassObserver):
    root: 'BinaryTreeNumericAttributeClassObserver.Node' = ...
    def __init__(self): ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    class Node(java.io.Serializable):
        cut_point: float = ...
        classCountsLeft: moa.core.DoubleVector = ...
        classCountsRight: moa.core.DoubleVector = ...
        left: 'BinaryTreeNumericAttributeClassObserver.Node' = ...
        right: 'BinaryTreeNumericAttributeClassObserver.Node' = ...
        def __init__(self, binaryTreeNumericAttributeClassObserver: 'BinaryTreeNumericAttributeClassObserver', double: float, int: int, double2: float): ...
        def insertValue(self, double: float, int: int, double2: float) -> None: ...

class BinaryTreeNumericAttributeClassObserverRegression(moa.options.AbstractOptionHandler, NumericAttributeClassObserver):
    serialVersionUID: typing.ClassVar[int] = ...
    root1: 'BinaryTreeNumericAttributeClassObserverRegression.Node' = ...
    def __init__(self): ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    class Node(java.io.Serializable):
        cut_point: float = ...
        lessThan: typing.MutableSequence[float] = ...
        greaterThan: typing.MutableSequence[float] = ...
        left: 'BinaryTreeNumericAttributeClassObserverRegression.Node' = ...
        right: 'BinaryTreeNumericAttributeClassObserverRegression.Node' = ...
        def __init__(self, binaryTreeNumericAttributeClassObserverRegression: 'BinaryTreeNumericAttributeClassObserverRegression', double: float, double2: float): ...
        def insertValue(self, double: float, double2: float) -> None: ...

class GaussianNumericAttributeClassObserver(moa.options.AbstractOptionHandler, NumericAttributeClassObserver):
    numBinsOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def forceSplit(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, double2: float) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getClassDistsResultingFromBinarySplit(self, double: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getSplitPointSuggestions(self) -> typing.MutableSequence[float]: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...

class GreenwaldKhannaNumericAttributeClassObserver(moa.options.AbstractOptionHandler, NumericAttributeClassObserver):
    numTuplesOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getClassDistsResultingFromBinarySplit(self, double: float) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...

class NominalAttributeClassObserver(moa.options.AbstractOptionHandler, DiscreteAttributeClassObserver):
    attValDistPerClass: moa.core.AutoExpandVector = ...
    def __init__(self): ...
    def forceSplit(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool, double2: float) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getClassDistsResultingFromBinarySplit(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getClassDistsResultingFromMultiwaySplit(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMaxAttValsObserved(self) -> int: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    def totalWeightOfClassObservations(self) -> float: ...
    def weightOfObservedMissingValues(self) -> float: ...

class VFMLNumericAttributeClassObserver(moa.options.AbstractOptionHandler, NumericAttributeClassObserver):
    numBinsOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def observeAttributeTarget(self, double: float, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...

class FIMTDDNumericAttributeClassObserver(BinaryTreeNumericAttributeClassObserver, NumericAttributeClassObserver):
    def __init__(self): ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    @typing.overload
    def observeAttributeClass(self, double: float, double2: float, double3: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    def removeBadSplits(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, double: float, double2: float, double3: float) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.core.attributeclassobservers")``.

    AttributeClassObserver: typing.Type[AttributeClassObserver]
    BinaryTreeNumericAttributeClassObserver: typing.Type[BinaryTreeNumericAttributeClassObserver]
    BinaryTreeNumericAttributeClassObserverRegression: typing.Type[BinaryTreeNumericAttributeClassObserverRegression]
    DiscreteAttributeClassObserver: typing.Type[DiscreteAttributeClassObserver]
    FIMTDDNumericAttributeClassObserver: typing.Type[FIMTDDNumericAttributeClassObserver]
    GaussianNumericAttributeClassObserver: typing.Type[GaussianNumericAttributeClassObserver]
    GreenwaldKhannaNumericAttributeClassObserver: typing.Type[GreenwaldKhannaNumericAttributeClassObserver]
    NominalAttributeClassObserver: typing.Type[NominalAttributeClassObserver]
    NullAttributeClassObserver: typing.Type[NullAttributeClassObserver]
    NumericAttributeClassObserver: typing.Type[NumericAttributeClassObserver]
    VFMLNumericAttributeClassObserver: typing.Type[VFMLNumericAttributeClassObserver]
