
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import moa
import moa.cluster
import moa.clusterers
import typing



class BICO(moa.clusterers.AbstractClusterer):
    numClustersOption: com.github.javacliparser.IntOption = ...
    numDimensionsOption: com.github.javacliparser.IntOption = ...
    maxNumClusterFeaturesOption: com.github.javacliparser.IntOption = ...
    numProjectionsOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getClusteringResult(self) -> moa.cluster.Clustering: ...
    def getMicroClusteringResult(self) -> moa.cluster.Clustering: ...
    def getMicroClusteringSize(self) -> int: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def implementsMicroClusterer(self) -> bool: ...
    def isRandomizable(self) -> bool: ...
    def printMicroClusteringResult(self, writer: java.io.Writer) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class ClusteringFeature(moa.cluster.SphereCluster):
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, doubleArray2: typing.Union[typing.List[float], jpype.JArray], double3: float, double4: float): ...
    def add(self, int: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float) -> None: ...
    @typing.overload
    def calcKMeansCosts(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    def calcKMeansCosts(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    def calcKMeansCosts(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], clusteringFeature: 'ClusteringFeature') -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getNumPoints(self) -> int: ...
    def getSumPoints(self) -> typing.MutableSequence[float]: ...
    def getSumSquaredLength(self) -> float: ...
    def getThreshold(self) -> float: ...
    @typing.overload
    def merge(self, sphereCluster: moa.cluster.SphereCluster) -> None: ...
    @typing.overload
    def merge(self, clusteringFeature: 'ClusteringFeature') -> None: ...
    def printClusterCenter(self, writer: java.io.Writer) -> None: ...
    def setNumPoints(self, int: int) -> None: ...
    def setSumPoints(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setSumSquaredLength(self, double: float) -> None: ...
    def setThreshold(self, double: float) -> None: ...
    def toCluster(self) -> moa.cluster.Cluster: ...
    def toClusterCenter(self) -> typing.MutableSequence[float]: ...

class ClusteringTreeNode(moa.AbstractMOAObject):
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], clusteringFeature: ClusteringFeature): ...
    def addChild(self, clusteringTreeNode: 'ClusteringTreeNode') -> bool: ...
    def addToClustering(self, clustering: moa.cluster.Clustering) -> moa.cluster.Clustering: ...
    def addToClusteringCenters(self, list: java.util.List[typing.Union[typing.List[float], jpype.JArray]]) -> java.util.List[typing.MutableSequence[float]]: ...
    def clearChildren(self) -> None: ...
    def count(self) -> int: ...
    def getCenter(self) -> typing.MutableSequence[float]: ...
    def getChildren(self) -> java.util.List['ClusteringTreeNode']: ...
    def getClusteringFeature(self) -> ClusteringFeature: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getThreshold(self) -> float: ...
    def hasNoChildren(self) -> bool: ...
    def nearestChild(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'ClusteringTreeNode': ...
    def printClusteringCenters(self, writer: java.io.Writer) -> None: ...
    def setCenter(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setThreshold(self, double: float) -> None: ...

class CoresetKMeans:
    def __init__(self): ...
    @staticmethod
    def generatekMeansPlusPlusCentroids(int: int, list: java.util.List[typing.Union[typing.List[float], jpype.JArray]], random: java.util.Random) -> java.util.List[typing.MutableSequence[float]]: ...
    @staticmethod
    def kMeans(list: java.util.List[typing.Union[typing.List[float], jpype.JArray]], list2: java.util.List[typing.Union[typing.List[float], jpype.JArray]]) -> float: ...

_CuckooHashing__T = typing.TypeVar('_CuckooHashing__T')  # <T>
class CuckooHashing(typing.Generic[_CuckooHashing__T]):
    DEFAULT_STASH_SIZE: typing.ClassVar[int] = ...
    DEFAULT_NUM_TABLES: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, random: java.util.Random): ...
    @typing.overload
    def __init__(self, int: int, random: java.util.Random): ...
    def clear(self) -> None: ...
    def get(self, long: int) -> _CuckooHashing__T: ...
    def isEmpty(self) -> bool: ...
    def put(self, long: int, t: _CuckooHashing__T) -> None: ...
    def size(self) -> int: ...

class DietzfelbingerHash:
    def __init__(self, int: int, random: java.util.Random): ...
    def hash(self, long: int) -> int: ...
    def nextHashFunction(self) -> None: ...

class Metric:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def distance(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def distance(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def distance(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], int: int) -> float: ...
    @typing.overload
    @staticmethod
    def distanceSquared(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def distanceSquared(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def distanceSquared(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], int: int) -> float: ...
    @typing.overload
    @staticmethod
    def distanceWithDivision(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def distanceWithDivision(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float, doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def distanceWithDivision(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float, doubleArray2: typing.Union[typing.List[float], jpype.JArray], double4: float) -> float: ...
    @typing.overload
    @staticmethod
    def distanceWithDivisionSquared(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float) -> float: ...
    @typing.overload
    @staticmethod
    def distanceWithDivisionSquared(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float, doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def distanceWithDivisionSquared(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float, doubleArray2: typing.Union[typing.List[float], jpype.JArray], double4: float) -> float: ...
    @typing.overload
    @staticmethod
    def dotProduct(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def dotProduct(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def dotProductWithAddition(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def dotProductWithAddition(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> float: ...

class ClusteringTreeHeadNode(ClusteringTreeNode):
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], clusteringFeature: ClusteringFeature, int: int, int2: int, int3: int, random: java.util.Random): ...
    def addChild(self, clusteringTreeNode: ClusteringTreeNode) -> bool: ...
    def clearChildren(self) -> None: ...
    def nearestChild(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> ClusteringTreeNode: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.clusterers.kmeanspm")``.

    BICO: typing.Type[BICO]
    ClusteringFeature: typing.Type[ClusteringFeature]
    ClusteringTreeHeadNode: typing.Type[ClusteringTreeHeadNode]
    ClusteringTreeNode: typing.Type[ClusteringTreeNode]
    CoresetKMeans: typing.Type[CoresetKMeans]
    CuckooHashing: typing.Type[CuckooHashing]
    DietzfelbingerHash: typing.Type[DietzfelbingerHash]
    Metric: typing.Type[Metric]
