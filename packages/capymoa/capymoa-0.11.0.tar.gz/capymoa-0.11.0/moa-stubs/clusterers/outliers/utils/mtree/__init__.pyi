
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import moa.clusterers.outliers.utils.mtree.utils
import typing



_DistanceFunction__DATA = typing.TypeVar('_DistanceFunction__DATA')  # <DATA>
class DistanceFunction(typing.Generic[_DistanceFunction__DATA]):
    def calculate(self, dATA: _DistanceFunction__DATA, dATA2: _DistanceFunction__DATA) -> float: ...

class DistanceFunctions:
    EUCLIDEAN: typing.ClassVar[DistanceFunction] = ...
    EUCLIDEAN_INTEGER_LIST: typing.ClassVar[DistanceFunction] = ...
    EUCLIDEAN_DOUBLE_LIST: typing.ClassVar[DistanceFunction] = ...
    _cached__Data = typing.TypeVar('_cached__Data')  # <Data>
    @staticmethod
    def cached(distanceFunction: typing.Union[DistanceFunction[_cached__Data], typing.Callable[[_cached__Data, _cached__Data], float]]) -> DistanceFunction[_cached__Data]: ...
    @staticmethod
    def euclidean(euclideanCoordinate: 'DistanceFunctions.EuclideanCoordinate', euclideanCoordinate2: 'DistanceFunctions.EuclideanCoordinate') -> float: ...
    class EuclideanCoordinate:
        def dimensions(self) -> int: ...
        def get(self, int: int) -> float: ...

_MTree__DATA = typing.TypeVar('_MTree__DATA')  # <DATA>
class MTree(typing.Generic[_MTree__DATA]):
    DEFAULT_MIN_NODE_CAPACITY: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, int: int, int2: int, distanceFunction: typing.Union[DistanceFunction[_MTree__DATA], typing.Callable[[_MTree__DATA, _MTree__DATA], float]], splitFunction: typing.Union['SplitFunction'[_MTree__DATA], typing.Callable[[java.util.Set[typing.Any], DistanceFunction[typing.Any]], 'SplitFunction.SplitResult'[typing.Any]]]): ...
    @typing.overload
    def __init__(self, int: int, distanceFunction: typing.Union[DistanceFunction[_MTree__DATA], typing.Callable[[_MTree__DATA, _MTree__DATA], float]], splitFunction: typing.Union['SplitFunction'[_MTree__DATA], typing.Callable[[java.util.Set[typing.Any], DistanceFunction[typing.Any]], 'SplitFunction.SplitResult'[typing.Any]]]): ...
    @typing.overload
    def __init__(self, distanceFunction: typing.Union[DistanceFunction[_MTree__DATA], typing.Callable[[_MTree__DATA, _MTree__DATA], float]], splitFunction: typing.Union['SplitFunction'[_MTree__DATA], typing.Callable[[java.util.Set[typing.Any], DistanceFunction[typing.Any]], 'SplitFunction.SplitResult'[typing.Any]]]): ...
    def add(self, dATA: _MTree__DATA) -> None: ...
    @typing.overload
    def getNearest(self, dATA: _MTree__DATA) -> 'MTree.Query': ...
    @typing.overload
    def getNearest(self, dATA: _MTree__DATA, double: float, int: int) -> 'MTree.Query': ...
    def getNearestByLimit(self, dATA: _MTree__DATA, int: int) -> 'MTree.Query': ...
    def getNearestByRange(self, dATA: _MTree__DATA, double: float) -> 'MTree.Query': ...
    def remove(self, dATA: _MTree__DATA) -> bool: ...
    class Query(java.lang.Iterable['MTree.ResultItem']):
        def iterator(self) -> java.util.Iterator['MTree.ResultItem']: ...
    class ResultItem:
        data: typing.Any = ...
        distance: float = ...

_PartitionFunction__DATA = typing.TypeVar('_PartitionFunction__DATA')  # <DATA>
class PartitionFunction(typing.Generic[_PartitionFunction__DATA]):
    def process(self, pair: moa.clusterers.outliers.utils.mtree.utils.Pair[_PartitionFunction__DATA], set: java.util.Set[_PartitionFunction__DATA], distanceFunction: typing.Union[DistanceFunction[_PartitionFunction__DATA], typing.Callable[[_PartitionFunction__DATA, _PartitionFunction__DATA], float]]) -> moa.clusterers.outliers.utils.mtree.utils.Pair[java.util.Set[_PartitionFunction__DATA]]: ...

_PromotionFunction__DATA = typing.TypeVar('_PromotionFunction__DATA')  # <DATA>
class PromotionFunction(typing.Generic[_PromotionFunction__DATA]):
    def process(self, set: java.util.Set[_PromotionFunction__DATA], distanceFunction: typing.Union[DistanceFunction[_PromotionFunction__DATA], typing.Callable[[_PromotionFunction__DATA, _PromotionFunction__DATA], float]]) -> moa.clusterers.outliers.utils.mtree.utils.Pair[_PromotionFunction__DATA]: ...

_SplitFunction__SplitResult__DATA = typing.TypeVar('_SplitFunction__SplitResult__DATA')  # <DATA>
_SplitFunction__DATA = typing.TypeVar('_SplitFunction__DATA')  # <DATA>
class SplitFunction(typing.Generic[_SplitFunction__DATA]):
    def process(self, set: java.util.Set[_SplitFunction__DATA], distanceFunction: typing.Union[DistanceFunction[_SplitFunction__DATA], typing.Callable[[_SplitFunction__DATA, _SplitFunction__DATA], float]]) -> 'SplitFunction.SplitResult'[_SplitFunction__DATA]: ...
    class SplitResult(typing.Generic[_SplitFunction__SplitResult__DATA]):
        promoted: moa.clusterers.outliers.utils.mtree.utils.Pair = ...
        partitions: moa.clusterers.outliers.utils.mtree.utils.Pair = ...
        def __init__(self, pair: moa.clusterers.outliers.utils.mtree.utils.Pair[_SplitFunction__SplitResult__DATA], pair2: moa.clusterers.outliers.utils.mtree.utils.Pair[java.util.Set[_SplitFunction__SplitResult__DATA]]): ...

_ComposedSplitFunction__DATA = typing.TypeVar('_ComposedSplitFunction__DATA')  # <DATA>
class ComposedSplitFunction(SplitFunction[_ComposedSplitFunction__DATA], typing.Generic[_ComposedSplitFunction__DATA]):
    def __init__(self, promotionFunction: typing.Union[PromotionFunction[_ComposedSplitFunction__DATA], typing.Callable[[java.util.Set[typing.Any], DistanceFunction[typing.Any]], moa.clusterers.outliers.utils.mtree.utils.Pair[typing.Any]]], partitionFunction: typing.Union[PartitionFunction[_ComposedSplitFunction__DATA], typing.Callable[[moa.clusterers.outliers.utils.mtree.utils.Pair[typing.Any], java.util.Set[typing.Any], DistanceFunction[typing.Any]], moa.clusterers.outliers.utils.mtree.utils.Pair[java.util.Set[typing.Any]]]]): ...
    def process(self, set: java.util.Set[_ComposedSplitFunction__DATA], distanceFunction: typing.Union[DistanceFunction[_ComposedSplitFunction__DATA], typing.Callable[[_ComposedSplitFunction__DATA, _ComposedSplitFunction__DATA], float]]) -> SplitFunction.SplitResult[_ComposedSplitFunction__DATA]: ...

_PartitionFunctions__BalancedPartition__DATA = typing.TypeVar('_PartitionFunctions__BalancedPartition__DATA')  # <DATA>
class PartitionFunctions:
    class BalancedPartition(PartitionFunction[_PartitionFunctions__BalancedPartition__DATA], typing.Generic[_PartitionFunctions__BalancedPartition__DATA]):
        def __init__(self): ...
        def process(self, pair: moa.clusterers.outliers.utils.mtree.utils.Pair[_PartitionFunctions__BalancedPartition__DATA], set: java.util.Set[_PartitionFunctions__BalancedPartition__DATA], distanceFunction: typing.Union[DistanceFunction[_PartitionFunctions__BalancedPartition__DATA], typing.Callable[[_PartitionFunctions__BalancedPartition__DATA, _PartitionFunctions__BalancedPartition__DATA], float]]) -> moa.clusterers.outliers.utils.mtree.utils.Pair[java.util.Set[_PartitionFunctions__BalancedPartition__DATA]]: ...

_PromotionFunctions__RandomPromotion__DATA = typing.TypeVar('_PromotionFunctions__RandomPromotion__DATA')  # <DATA>
class PromotionFunctions:
    class RandomPromotion(PromotionFunction[_PromotionFunctions__RandomPromotion__DATA], typing.Generic[_PromotionFunctions__RandomPromotion__DATA]):
        def __init__(self): ...
        def process(self, set: java.util.Set[_PromotionFunctions__RandomPromotion__DATA], distanceFunction: typing.Union[DistanceFunction[_PromotionFunctions__RandomPromotion__DATA], typing.Callable[[_PromotionFunctions__RandomPromotion__DATA, _PromotionFunctions__RandomPromotion__DATA], float]]) -> moa.clusterers.outliers.utils.mtree.utils.Pair[_PromotionFunctions__RandomPromotion__DATA]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.clusterers.outliers.utils.mtree")``.

    ComposedSplitFunction: typing.Type[ComposedSplitFunction]
    DistanceFunction: typing.Type[DistanceFunction]
    DistanceFunctions: typing.Type[DistanceFunctions]
    MTree: typing.Type[MTree]
    PartitionFunction: typing.Type[PartitionFunction]
    PartitionFunctions: typing.Type[PartitionFunctions]
    PromotionFunction: typing.Type[PromotionFunction]
    PromotionFunctions: typing.Type[PromotionFunctions]
    SplitFunction: typing.Type[SplitFunction]
    utils: moa.clusterers.outliers.utils.mtree.utils.__module_protocol__
