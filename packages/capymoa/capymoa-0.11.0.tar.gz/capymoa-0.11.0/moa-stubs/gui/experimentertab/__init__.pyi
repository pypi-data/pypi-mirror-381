
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.awt
import java.awt.event
import java.awt.image
import java.io
import java.lang
import java.util
import javax.swing
import javax.swing.event
import javax.swing.table
import jpype
import jpype.protocol
import moa.core
import moa.evaluation
import moa.gui
import moa.gui.conceptdrift
import moa.gui.experimentertab.statisticaltests
import moa.gui.experimentertab.tasks
import moa.tasks
import org.jfree.chart
import typing



class Algorithm:
    name: str = ...
    path: str = ...
    measures: java.util.List = ...
    buffer: java.io.BufferedReader = ...
    measureStdSize: int = ...
    def __init__(self, string: str, list: java.util.List['Measure'], bufferedReader: java.io.BufferedReader, string2: str): ...
    def getMeasuresPerData(self, list: java.util.List['Stream']) -> typing.MutableSequence[java.util.List['Measure']]: ...

class AnalyzeTab(javax.swing.JPanel):
    def __init__(self): ...
    def cleanTables(self) -> None: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def readData(self, string: str) -> None: ...

class Buffer:
    def __init__(self, mainTaskArray: typing.Union[typing.List[moa.tasks.MainTask], jpype.JArray]): ...

class ExpPreviewPanel(javax.swing.JPanel, moa.tasks.ResultPreviewListener):
    autoFreqStrings: typing.ClassVar[typing.MutableSequence[str]] = ...
    autoFreqTimeSecs: typing.ClassVar[typing.MutableSequence[int]] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, typePanel: 'ExpPreviewPanel.TypePanel'): ...
    @typing.overload
    def __init__(self, typePanel: 'ExpPreviewPanel.TypePanel', cDTaskManagerPanel: moa.gui.conceptdrift.CDTaskManagerPanel): ...
    def disableRefresh(self) -> None: ...
    def enableRefresh(self) -> None: ...
    def latestPreviewChanged(self) -> None: ...
    def refresh(self) -> None: ...
    def setLatestPreview(self, object: typing.Any) -> None: ...
    def setTaskThreadToPreview(self, expTaskThread: 'ExpTaskThread') -> None: ...
    def updateAutoRefreshTimer(self) -> None: ...
    class TypePanel(java.lang.Enum['ExpPreviewPanel.TypePanel']):
        CLASSIFICATION: typing.ClassVar['ExpPreviewPanel.TypePanel'] = ...
        REGRESSION: typing.ClassVar['ExpPreviewPanel.TypePanel'] = ...
        CONCEPT_DRIFT: typing.ClassVar['ExpPreviewPanel.TypePanel'] = ...
        def getMeasureCollection(self) -> moa.evaluation.MeasureCollection: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ExpPreviewPanel.TypePanel': ...
        @staticmethod
        def values() -> typing.MutableSequence['ExpPreviewPanel.TypePanel']: ...

class ExpTaskThread(java.lang.Thread):
    isCompleted: bool = ...
    def __init__(self, buffer: Buffer): ...
    def addTaskCompletionListener(self, taskCompletionListener: typing.Union[moa.tasks.TaskCompletionListener, typing.Callable]) -> None: ...
    def cancelTask(self) -> None: ...
    def getCPUSecondsElapsed(self) -> float: ...
    def getCurrentActivityFracComplete(self) -> float: ...
    def getCurrentActivityString(self) -> str: ...
    def getCurrentStatusString(self) -> str: ...
    def getFinalResult(self) -> typing.Any: ...
    def getLatestPreviewGrabTimeSeconds(self) -> float: ...
    def getLatestResultPreview(self) -> typing.Any: ...
    def getPreview(self, resultPreviewListener: typing.Union[moa.tasks.ResultPreviewListener, typing.Callable]) -> None: ...
    def getTask(self) -> moa.tasks.Task: ...
    def isComplete(self) -> bool: ...
    def pauseTask(self) -> None: ...
    def removeTaskCompletionListener(self, taskCompletionListener: typing.Union[moa.tasks.TaskCompletionListener, typing.Callable]) -> None: ...
    def resumeTask(self) -> None: ...
    def run(self) -> None: ...
    class Status(java.lang.Enum['ExpTaskThread.Status']):
        NOT_STARTED: typing.ClassVar['ExpTaskThread.Status'] = ...
        RUNNING: typing.ClassVar['ExpTaskThread.Status'] = ...
        PAUSED: typing.ClassVar['ExpTaskThread.Status'] = ...
        CANCELLING: typing.ClassVar['ExpTaskThread.Status'] = ...
        CANCELLED: typing.ClassVar['ExpTaskThread.Status'] = ...
        COMPLETED: typing.ClassVar['ExpTaskThread.Status'] = ...
        FAILED: typing.ClassVar['ExpTaskThread.Status'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'ExpTaskThread.Status': ...
        @staticmethod
        def values() -> typing.MutableSequence['ExpTaskThread.Status']: ...

class ExperimenterTabPanel(moa.gui.AbstractTabPanel):
    def __init__(self): ...
    def getDescription(self) -> str: ...
    def getTabTitle(self) -> str: ...

class ExperimeterCLI:
    measures: typing.MutableSequence[int] = ...
    types: typing.MutableSequence[str] = ...
    def __init__(self, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    def getAlgorithms(self) -> typing.MutableSequence[str]: ...
    def getAlgorithmsID(self) -> typing.MutableSequence[str]: ...
    def getArgs(self) -> typing.MutableSequence[str]: ...
    def getResultsFolder(self) -> str: ...
    def getSaveExperimentsPath(self) -> str: ...
    def getStreams(self) -> typing.MutableSequence[str]: ...
    def getStreamsID(self) -> typing.MutableSequence[str]: ...
    def getTask(self) -> str: ...
    def getThreads(self) -> int: ...
    def proccesCMD(self) -> bool: ...
    def setAlgorithms(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def setAlgorithmsID(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def setArgs(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def setResultsFolder(self, string: str) -> None: ...
    def setSaveExperimentsPath(self, string: str) -> None: ...
    def setStreamIndex(self, int: int, string: str) -> None: ...
    def setStreams(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def setStreamsID(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def setTask(self, string: str) -> None: ...
    def setThreads(self, int: int) -> None: ...
    def summary1CMD(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> bool: ...

class ImageChart:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str, jFreeChart: org.jfree.chart.JFreeChart): ...
    @typing.overload
    def __init__(self, string: str, jFreeChart: org.jfree.chart.JFreeChart, int: int, int2: int): ...
    def exportIMG(self, string: str, string2: str) -> None: ...
    def getChart(self) -> org.jfree.chart.JFreeChart: ...
    def getHeight(self) -> int: ...
    def getName(self) -> str: ...
    def getWidth(self) -> int: ...
    def setChart(self, jFreeChart: org.jfree.chart.JFreeChart) -> None: ...
    def setHeight(self, int: int) -> None: ...
    def setName(self, string: str) -> None: ...
    def setWidth(self, int: int) -> None: ...
    def toString(self) -> str: ...

class ImagePanel(org.jfree.chart.ChartPanel):
    def __init__(self, jFreeChart: org.jfree.chart.JFreeChart): ...
    def doSaveAs(self) -> None: ...

class ImageTreePanel(javax.swing.JPanel, javax.swing.event.TreeSelectionListener):
    def __init__(self, imageChartArray: typing.Union[typing.List[ImageChart], jpype.JArray]): ...
    def getChart(self) -> typing.MutableSequence[ImageChart]: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def valueChanged(self, treeSelectionEvent: javax.swing.event.TreeSelectionEvent) -> None: ...

class ImageViewer(javax.swing.JFrame):
    def __init__(self, imageTreePanel: ImageTreePanel, string: str): ...

class Measure:
    def __init__(self, string: str, string2: str, boolean: bool, int: int): ...
    def computeValue(self, doubleVector: moa.core.DoubleVector) -> None: ...
    def getFileName(self) -> str: ...
    def getIndex(self) -> int: ...
    def getName(self) -> str: ...
    def getStd(self) -> float: ...
    def getValue(self) -> float: ...
    def getValues(self) -> moa.core.DoubleVector: ...
    def isType(self) -> bool: ...
    def setFileName(self, string: str) -> None: ...
    def setIndex(self, int: int) -> None: ...
    def setName(self, string: str) -> None: ...
    def setStd(self, double: float) -> None: ...
    def setType(self, boolean: bool) -> None: ...
    def setValue(self, double: float) -> None: ...
    def setValues(self, doubleVector: moa.core.DoubleVector) -> None: ...

class PlotTab(javax.swing.JPanel):
    def __init__(self): ...
    def cleanTables(self) -> None: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def readData(self, string: str) -> None: ...
    class LegendType(java.lang.Enum['PlotTab.LegendType']):
        NONE: typing.ClassVar['PlotTab.LegendType'] = ...
        BOX_VERTICAL: typing.ClassVar['PlotTab.LegendType'] = ...
        BOX_HORIZONTAL: typing.ClassVar['PlotTab.LegendType'] = ...
        NOBOX_VERTICAL: typing.ClassVar['PlotTab.LegendType'] = ...
        NOBOX_HORIZONTAL: typing.ClassVar['PlotTab.LegendType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'PlotTab.LegendType': ...
        @staticmethod
        def values() -> typing.MutableSequence['PlotTab.LegendType']: ...
    class PlotStyle(java.lang.Enum['PlotTab.PlotStyle']):
        LINES: typing.ClassVar['PlotTab.PlotStyle'] = ...
        POINTS: typing.ClassVar['PlotTab.PlotStyle'] = ...
        LINESPOINTS: typing.ClassVar['PlotTab.PlotStyle'] = ...
        IMPULSES: typing.ClassVar['PlotTab.PlotStyle'] = ...
        STEPS: typing.ClassVar['PlotTab.PlotStyle'] = ...
        FSTEPS: typing.ClassVar['PlotTab.PlotStyle'] = ...
        HISTEPS: typing.ClassVar['PlotTab.PlotStyle'] = ...
        DOTS: typing.ClassVar['PlotTab.PlotStyle'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'PlotTab.PlotStyle': ...
        @staticmethod
        def values() -> typing.MutableSequence['PlotTab.PlotStyle']: ...
    class Terminal(java.lang.Enum['PlotTab.Terminal']):
        CANVAS: typing.ClassVar['PlotTab.Terminal'] = ...
        EPSLATEX: typing.ClassVar['PlotTab.Terminal'] = ...
        GIF: typing.ClassVar['PlotTab.Terminal'] = ...
        JPEG: typing.ClassVar['PlotTab.Terminal'] = ...
        LATEX: typing.ClassVar['PlotTab.Terminal'] = ...
        PDFCAIRO: typing.ClassVar['PlotTab.Terminal'] = ...
        PNG: typing.ClassVar['PlotTab.Terminal'] = ...
        POSTSCRIPT: typing.ClassVar['PlotTab.Terminal'] = ...
        POSTSCRIPT_COLOR: typing.ClassVar['PlotTab.Terminal'] = ...
        PSLATEX: typing.ClassVar['PlotTab.Terminal'] = ...
        PSTEX: typing.ClassVar['PlotTab.Terminal'] = ...
        PSTRICKS: typing.ClassVar['PlotTab.Terminal'] = ...
        SVG: typing.ClassVar['PlotTab.Terminal'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'PlotTab.Terminal': ...
        @staticmethod
        def values() -> typing.MutableSequence['PlotTab.Terminal']: ...

class PreviewExperiments(javax.swing.JFrame):
    def __init__(self, expPreviewPanel: ExpPreviewPanel): ...
    def setVisible(self, boolean: bool) -> None: ...

class RankingGraph(javax.swing.JFrame):
    image: java.awt.image.BufferedImage = ...
    gb: java.awt.Graphics2D = ...
    imgPath: str = ...
    def __init__(self, arrayList: java.util.ArrayList[moa.gui.experimentertab.statisticaltests.RankPerAlgorithm], arrayList2: java.util.ArrayList[moa.gui.experimentertab.statisticaltests.PValuePerTwoAlgorithm], string: str, double: float): ...
    def fontSelection(self) -> None: ...
    class SliderPanel(javax.swing.JPanel):
        def __init__(self, rankingGraph: 'RankingGraph'): ...

class ReadFile:
    def __init__(self, string: str): ...
    @staticmethod
    def deleteDrectory(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> None: ...
    def getAlgNames(self) -> java.util.LinkedList[str]: ...
    def getAlgShortNames(self) -> java.util.ArrayList[str]: ...
    def getMeasures(self) -> java.util.LinkedList[str]: ...
    def getPath(self) -> str: ...
    def getStream(self) -> java.util.LinkedList[str]: ...
    def processFiles(self) -> str: ...
    @staticmethod
    def readCSV(string: str) -> java.util.ArrayList[typing.MutableSequence[str]]: ...
    def setPath(self, string: str) -> None: ...
    def updateMeasures(self, stringArray: typing.Union[typing.List[str], jpype.JArray], string2: str) -> str: ...

class Stream:
    name: str = ...
    algorithm: java.util.List = ...
    def __init__(self, string: str, list: java.util.List[str], list2: java.util.List[str], list3: java.util.List[Measure]): ...
    def getAlgorithm(self) -> java.util.List[Algorithm]: ...
    def getName(self) -> str: ...
    def readBuffer(self, list: java.util.List[str], list2: java.util.List[str], list3: java.util.List[Measure]) -> None: ...
    def setName(self, string: str) -> None: ...

class Summary:
    streams: java.util.List = ...
    path: str = ...
    summary: typing.MutableSequence['SummaryTable'] = ...
    def __init__(self, list: java.util.List[Stream], string: str): ...
    def computeWinsTiesLossesHTML(self, string: str) -> None: ...
    def computeWinsTiesLossesLatex(self, string: str) -> None: ...
    def generateCSV(self) -> None: ...
    def generateHTML(self, string: str) -> None: ...
    def generateLatex(self, string: str) -> None: ...
    def invertedSumariesPerMeasure(self, string: str) -> None: ...
    def showSummary(self) -> typing.MutableSequence['SummaryTable']: ...

class SummaryTab(javax.swing.JPanel):
    measures: java.util.LinkedList = ...
    def __init__(self): ...
    def cleanTables(self) -> None: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def readData(self, string: str) -> None: ...
    def summaryCMD(self, stringArray: typing.Union[typing.List[str], jpype.JArray], stringArray2: typing.Union[typing.List[str], jpype.JArray]) -> None: ...

class SummaryTable:
    algNames: typing.MutableSequence[str] = ...
    measureName: str = ...
    value: typing.MutableSequence[typing.MutableSequence[typing.Any]] = ...
    def __init__(self): ...

class SummaryViewer(javax.swing.JFrame):
    tableSummary: javax.swing.JTable = ...
    scroll: javax.swing.JScrollPane = ...
    jTablePanel: javax.swing.JPanel = ...
    summaryType: javax.swing.JComboBox = ...
    bntExport: javax.swing.JButton = ...
    summaryTable: typing.MutableSequence[SummaryTable] = ...
    summary: Summary = ...
    resultsPath: str = ...
    def __init__(self, summaryTableArray: typing.Union[typing.List[SummaryTable], jpype.JArray], summary2: Summary, string: str): ...

class TaskManagerForm(javax.swing.JPanel):
    def __init__(self): ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...

class TaskManagerTabPanel(javax.swing.JPanel):
    MILLISECS_BETWEEN_REFRESH: typing.ClassVar[int] = ...
    progressAnimSequence: typing.ClassVar[typing.MutableSequence[str]] = ...
    MAX_STATUS_STRING_LENGTH: typing.ClassVar[int] = ...
    summary: SummaryTab = ...
    plot: PlotTab = ...
    analizeTab: AnalyzeTab = ...
    def __init__(self): ...
    def cancelSelectedTasks(self) -> None: ...
    def cleanTables(self) -> None: ...
    def deleteSelectedTasks(self) -> None: ...
    def getSelectedTasks(self) -> typing.MutableSequence[ExpTaskThread]: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def openConfig(self, string: str) -> None: ...
    def pauseSelectedTasks(self) -> None: ...
    def resumeSelectedTasks(self) -> None: ...
    def runTask(self) -> None: ...
    def runTaskCLI(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def taskSelectionChanged(self) -> None: ...
    class ProgressCellRenderer(javax.swing.JProgressBar, javax.swing.table.TableCellRenderer):
        def __init__(self, taskManagerTabPanel: 'TaskManagerTabPanel'): ...
        @typing.overload
        def firePropertyChange(self, string: str, byte: int, byte2: int) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, double: float, double2: float) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, float: float, float2: float) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, long: int, long2: int) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, short: int, short2: int) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, char: str, char2: str) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, int: int, int2: int) -> None: ...
        @typing.overload
        def firePropertyChange(self, string: str, boolean: bool, boolean2: bool) -> None: ...
        def getTableCellRendererComponent(self, jTable: javax.swing.JTable, object: typing.Any, boolean: bool, boolean2: bool, int: int, int2: int) -> java.awt.Component: ...
        def revalidate(self) -> None: ...
        def validate(self) -> None: ...

class TaskTextViewerPanel(javax.swing.JPanel, java.awt.event.ActionListener):
    exportFileExtension: typing.ClassVar[str] = ...
    gridBagConstraints: java.awt.GridBagConstraints = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, typePanel: ExpPreviewPanel.TypePanel, cDTaskManagerPanel: moa.gui.conceptdrift.CDTaskManagerPanel): ...
    def actionPerformed(self, actionEvent: java.awt.event.ActionEvent) -> None: ...
    def initVisualEvalPanel(self) -> None: ...
    def setGraph(self, string: str) -> None: ...
    def setText(self, string: str) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.gui.experimentertab")``.

    Algorithm: typing.Type[Algorithm]
    AnalyzeTab: typing.Type[AnalyzeTab]
    Buffer: typing.Type[Buffer]
    ExpPreviewPanel: typing.Type[ExpPreviewPanel]
    ExpTaskThread: typing.Type[ExpTaskThread]
    ExperimenterTabPanel: typing.Type[ExperimenterTabPanel]
    ExperimeterCLI: typing.Type[ExperimeterCLI]
    ImageChart: typing.Type[ImageChart]
    ImagePanel: typing.Type[ImagePanel]
    ImageTreePanel: typing.Type[ImageTreePanel]
    ImageViewer: typing.Type[ImageViewer]
    Measure: typing.Type[Measure]
    PlotTab: typing.Type[PlotTab]
    PreviewExperiments: typing.Type[PreviewExperiments]
    RankingGraph: typing.Type[RankingGraph]
    ReadFile: typing.Type[ReadFile]
    Stream: typing.Type[Stream]
    Summary: typing.Type[Summary]
    SummaryTab: typing.Type[SummaryTab]
    SummaryTable: typing.Type[SummaryTable]
    SummaryViewer: typing.Type[SummaryViewer]
    TaskManagerForm: typing.Type[TaskManagerForm]
    TaskManagerTabPanel: typing.Type[TaskManagerTabPanel]
    TaskTextViewerPanel: typing.Type[TaskTextViewerPanel]
    statisticaltests: moa.gui.experimentertab.statisticaltests.__module_protocol__
    tasks: moa.gui.experimentertab.tasks.__module_protocol__
