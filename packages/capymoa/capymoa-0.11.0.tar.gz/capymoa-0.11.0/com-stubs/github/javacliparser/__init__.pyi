
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser.gui
import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import jpype
import jpype.protocol
import typing



class Configurable(java.io.Serializable): ...

class JavaCLIParser(java.io.Serializable):
    handler: typing.Any = ...
    def __init__(self, object: typing.Any, string: str): ...
    def discoverOptionsViaReflection(self) -> typing.MutableSequence['Option']: ...
    def getOptions(self) -> 'Options': ...
    def getPurposeString(self) -> str: ...
    def prepareClassOptions(self) -> None: ...

class Option(java.io.Serializable):
    def copy(self) -> 'Option': ...
    def getCLIChar(self) -> str: ...
    def getDefaultCLIString(self) -> str: ...
    def getName(self) -> str: ...
    def getPurpose(self) -> str: ...
    def getStateString(self) -> str: ...
    def getValueAsCLIString(self) -> str: ...
    def resetToDefault(self) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class Options(java.io.Serializable):
    def __init__(self): ...
    def addOption(self, option: Option) -> None: ...
    def getAsCLIString(self) -> str: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getHelp(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getHelpString(self) -> str: ...
    @typing.overload
    def getOption(self, char: str) -> Option: ...
    @typing.overload
    def getOption(self, string: str) -> Option: ...
    def getOptionArray(self) -> typing.MutableSequence[Option]: ...
    def numOptions(self) -> int: ...
    def removeAllOptions(self) -> None: ...
    @typing.overload
    def removeOption(self, option: Option) -> None: ...
    @typing.overload
    def removeOption(self, string: str) -> None: ...
    def resetToDefaults(self) -> None: ...
    def setViaCLIString(self, string: str) -> None: ...

class SerializeUtils:
    def __init__(self): ...
    @staticmethod
    def copyObject(serializable: java.io.Serializable) -> typing.Any: ...
    @staticmethod
    def measureObjectByteSize(serializable: java.io.Serializable) -> int: ...
    @staticmethod
    def readFromFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> typing.Any: ...
    @staticmethod
    def writeToFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], serializable: java.io.Serializable) -> None: ...
    class ByteCountingOutputStream(java.io.OutputStream):
        def __init__(self): ...
        def getNumBytesWritten(self) -> int: ...
        @typing.overload
        def write(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
        @typing.overload
        def write(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> None: ...
        @typing.overload
        def write(self, int: int) -> None: ...

class StringUtils:
    newline: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def appendIndent(stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @staticmethod
    def appendIndented(stringBuilder: java.lang.StringBuilder, int: int, string2: str) -> None: ...
    @staticmethod
    def appendNewline(stringBuilder: java.lang.StringBuilder) -> None: ...
    @staticmethod
    def appendNewlineIndented(stringBuilder: java.lang.StringBuilder, int: int, string2: str) -> None: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int) -> str: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int, int2: int) -> str: ...

class AbstractOption(Option):
    illegalNameCharacters: typing.ClassVar[typing.MutableSequence[str]] = ...
    def __init__(self, string: str, char: str, string2: str): ...
    def copy(self) -> Option: ...
    def getCLIChar(self) -> str: ...
    def getName(self) -> str: ...
    def getPurpose(self) -> str: ...
    def getStateString(self) -> str: ...
    @staticmethod
    def nameIsLegal(string: str) -> bool: ...
    def resetToDefault(self) -> None: ...

class AbstractClassOption(AbstractOption):
    FILE_PREFIX_STRING: typing.ClassVar[str] = ...
    INMEM_PREFIX_STRING: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str): ...
    @staticmethod
    def classToCLIString(class_: typing.Type[typing.Any], class2: typing.Type[typing.Any]) -> str: ...
    def getDefaultCLIString(self) -> str: ...
    def getNullString(self) -> str: ...
    def getRequiredType(self) -> typing.Type[typing.Any]: ...
    def getValue(self) -> typing.Any: ...
    def getValueAsCLIString(self) -> str: ...
    def materializeObject(self) -> typing.Any: ...
    def setCurrentObject(self, object: typing.Any) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...
    @staticmethod
    def stripPackagePrefix(string: str, class_: typing.Type[typing.Any]) -> str: ...

class FlagOption(AbstractOption):
    def __init__(self, string: str, char: str, string2: str): ...
    def getDefaultCLIString(self) -> str: ...
    def getStateString(self) -> str: ...
    def getValueAsCLIString(self) -> str: ...
    def isSet(self) -> bool: ...
    def set(self) -> None: ...
    def setValue(self, boolean: bool) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...
    def unset(self) -> None: ...

class FloatOption(AbstractOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, double: float): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, double: float, double2: float, double3: float): ...
    @staticmethod
    def cliStringToDouble(string: str) -> float: ...
    @staticmethod
    def doubleToCLIString(double: float) -> str: ...
    def getDefaultCLIString(self) -> str: ...
    def getMaxValue(self) -> float: ...
    def getMinValue(self) -> float: ...
    def getValue(self) -> float: ...
    def getValueAsCLIString(self) -> str: ...
    def setDefault(self, double: float) -> None: ...
    def setValue(self, double: float) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class IntOption(AbstractOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, int: int): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, int: int, int2: int, int3: int): ...
    @staticmethod
    def cliStringToInt(string: str) -> int: ...
    def getDefaultCLIString(self) -> str: ...
    def getMaxValue(self) -> int: ...
    def getMinValue(self) -> int: ...
    def getValue(self) -> int: ...
    def getValueAsCLIString(self) -> str: ...
    @staticmethod
    def intToCLIString(int: int) -> str: ...
    def setDefaultValue(self, int: int) -> None: ...
    def setValue(self, int: int) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class ListOption(AbstractOption):
    def __init__(self, string: str, char: str, string2: str, option: Option, optionArray: typing.Union[typing.List[Option], jpype.JArray], char2: str): ...
    @staticmethod
    def cliStringToOptionArray(string: str, char: str, option: Option) -> typing.MutableSequence[Option]: ...
    def getDefaultCLIString(self) -> str: ...
    def getList(self) -> typing.MutableSequence[Option]: ...
    def getValueAsCLIString(self) -> str: ...
    @staticmethod
    def optionArrayToCLIString(optionArray: typing.Union[typing.List[Option], jpype.JArray], char: str) -> str: ...
    def setList(self, optionArray: typing.Union[typing.List[Option], jpype.JArray]) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class MultiChoiceOption(AbstractOption):
    def __init__(self, string: str, char: str, string2: str, stringArray: typing.Union[typing.List[str], jpype.JArray], stringArray2: typing.Union[typing.List[str], jpype.JArray], int: int): ...
    def getChosenIndex(self) -> int: ...
    def getChosenLabel(self) -> str: ...
    def getDefaultCLIString(self) -> str: ...
    def getDefaultOptionIndex(self) -> int: ...
    def getOptionDescriptions(self) -> typing.MutableSequence[str]: ...
    def getOptionLabels(self) -> typing.MutableSequence[str]: ...
    def getValueAsCLIString(self) -> str: ...
    def setChosenIndex(self, int: int) -> None: ...
    def setChosenLabel(self, string: str) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class StringOption(AbstractOption):
    def __init__(self, string: str, char: str, string2: str, string3: str): ...
    def getDefaultCLIString(self) -> str: ...
    def getValue(self) -> str: ...
    def getValueAsCLIString(self) -> str: ...
    def setValue(self, string: str) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class ClassOption(AbstractClassOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str): ...
    @staticmethod
    def cliStringToObject(string: str, class_: typing.Type[typing.Any], optionArray: typing.Union[typing.List[Option], jpype.JArray]) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def createObject(string: str, class_: typing.Type[typing.Any]) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def createObject(stringArray: typing.Union[typing.List[str], jpype.JArray], class_: typing.Type[typing.Any]) -> typing.Any: ...
    def getValueAsCLIString(self) -> str: ...
    @staticmethod
    def objectToCLIString(object: typing.Any, class_: typing.Type[typing.Any]) -> str: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class FileOption(StringOption):
    def __init__(self, string: str, char: str, string2: str, string3: str, string4: str, boolean: bool): ...
    def getDefaultFileExtension(self) -> str: ...
    def getFile(self) -> java.io.File: ...
    def isOutputFile(self) -> bool: ...

class RangeOption(StringOption):
    def __init__(self, string: str, char: str, string2: str, string3: str): ...
    def getRange(self) -> com.yahoo.labs.samoa.instances.Range: ...
    def setRange(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("com.github.javacliparser")``.

    AbstractClassOption: typing.Type[AbstractClassOption]
    AbstractOption: typing.Type[AbstractOption]
    ClassOption: typing.Type[ClassOption]
    Configurable: typing.Type[Configurable]
    FileOption: typing.Type[FileOption]
    FlagOption: typing.Type[FlagOption]
    FloatOption: typing.Type[FloatOption]
    IntOption: typing.Type[IntOption]
    JavaCLIParser: typing.Type[JavaCLIParser]
    ListOption: typing.Type[ListOption]
    MultiChoiceOption: typing.Type[MultiChoiceOption]
    Option: typing.Type[Option]
    Options: typing.Type[Options]
    RangeOption: typing.Type[RangeOption]
    SerializeUtils: typing.Type[SerializeUtils]
    StringOption: typing.Type[StringOption]
    StringUtils: typing.Type[StringUtils]
    gui: com.github.javacliparser.gui.__module_protocol__
