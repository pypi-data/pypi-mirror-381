
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.util
import jpype
import typing
import weka.core



class ArffLoader:
    @typing.overload
    def __init__(self, reader: java.io.Reader): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, range: 'Range'): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, int: int, int2: int): ...
    def getStructure(self) -> 'InstanceInformation': ...
    def readInstance(self) -> 'Instance': ...
    def readInstanceDense(self) -> 'Instance': ...

class Attribute(java.io.Serializable):
    ARFF_ATTRIBUTE: typing.ClassVar[str] = ...
    ARFF_ATTRIBUTE_INTEGER: typing.ClassVar[str] = ...
    ARFF_ATTRIBUTE_REAL: typing.ClassVar[str] = ...
    ARFF_ATTRIBUTE_NUMERIC: typing.ClassVar[str] = ...
    ARFF_ATTRIBUTE_STRING: typing.ClassVar[str] = ...
    ARFF_ATTRIBUTE_DATE: typing.ClassVar[str] = ...
    ARFF_ATTRIBUTE_RELATIONAL: typing.ClassVar[str] = ...
    ARFF_END_SUBRELATION: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, list: java.util.List[str]): ...
    def enumerateValues(self) -> java.util.Enumeration: ...
    def getAttributeValues(self) -> java.util.List[str]: ...
    def indexOfValue(self, string: str) -> int: ...
    def isNominal(self) -> bool: ...
    def isNumeric(self) -> bool: ...
    def name(self) -> str: ...
    def numValues(self) -> int: ...
    def toString(self) -> str: ...
    def value(self, int: int) -> str: ...

class AttributesInformation(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray], int: int): ...
    @typing.overload
    def __init__(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray], int2: int): ...
    @typing.overload
    def __init__(self, attributesInformation: 'AttributesInformation'): ...
    @typing.overload
    def __init__(self, list: java.util.List[Attribute], int: int): ...
    def attribute(self, int: int) -> Attribute: ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def insertAttributeAt(self, attribute: Attribute, int: int) -> None: ...
    def locateIndex(self, int: int) -> int: ...
    @typing.overload
    def setAttributes(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray]) -> None: ...
    @typing.overload
    def setAttributes(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...

class Instance(java.io.Serializable):
    def addSparseValues(self, intArray: typing.Union[typing.List[int], jpype.JArray], doubleArray: typing.Union[typing.List[float], jpype.JArray], int2: int) -> None: ...
    def attribute(self, int: int) -> Attribute: ...
    def classAttribute(self) -> Attribute: ...
    def classIndex(self) -> int: ...
    def classIsMissing(self) -> bool: ...
    @typing.overload
    def classValue(self) -> float: ...
    @typing.overload
    def classValue(self, int: int) -> float: ...
    def copy(self) -> 'Instance': ...
    def dataset(self) -> 'Instances': ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def index(self, int: int) -> int: ...
    def indexOfAttribute(self, attribute: Attribute) -> int: ...
    def inputAttribute(self, int: int) -> Attribute: ...
    def insertAttributeAt(self, int: int) -> None: ...
    @typing.overload
    def isMissing(self, attribute: Attribute) -> bool: ...
    @typing.overload
    def isMissing(self, int: int) -> bool: ...
    def isMissingSparse(self, int: int) -> bool: ...
    def numAttributes(self) -> int: ...
    def numClasses(self) -> int: ...
    def numInputAttributes(self) -> int: ...
    def numOutputAttributes(self) -> int: ...
    def numValues(self) -> int: ...
    def numberOutputTargets(self) -> int: ...
    def outputAttribute(self, int: int) -> Attribute: ...
    @typing.overload
    def setClassValue(self, double: float) -> None: ...
    @typing.overload
    def setClassValue(self, int: int, double: float) -> None: ...
    def setDataset(self, instances: 'Instances') -> None: ...
    @typing.overload
    def setMissing(self, attribute: Attribute) -> None: ...
    @typing.overload
    def setMissing(self, int: int) -> None: ...
    @typing.overload
    def setValue(self, attribute: Attribute, double: float) -> None: ...
    @typing.overload
    def setValue(self, int: int, double: float) -> None: ...
    def setWeight(self, double: float) -> None: ...
    def stringValue(self, int: int) -> str: ...
    def toDoubleArray(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def value(self, attribute: Attribute) -> float: ...
    @typing.overload
    def value(self, int: int) -> float: ...
    def valueInputAttribute(self, int: int) -> float: ...
    def valueOutputAttribute(self, int: int) -> float: ...
    def valueSparse(self, int: int) -> float: ...
    def weight(self) -> float: ...

class InstanceData(java.io.Serializable):
    def copy(self) -> 'InstanceData': ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def index(self, int: int) -> int: ...
    def insertAttributeAt(self, int: int) -> None: ...
    def isMissing(self, int: int) -> bool: ...
    def isMissingSparse(self, int: int) -> bool: ...
    def numAttributes(self) -> int: ...
    def numValues(self) -> int: ...
    def setValue(self, int: int, double: float) -> None: ...
    def toDoubleArray(self) -> typing.MutableSequence[float]: ...
    def value(self, int: int) -> float: ...
    def valueSparse(self, int: int) -> float: ...

class InstanceInformation(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instanceInformation: 'InstanceInformation'): ...
    @typing.overload
    def __init__(self, string: str, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray]): ...
    @typing.overload
    def __init__(self, string: str, list: java.util.List[Attribute]): ...
    def attribute(self, int: int) -> Attribute: ...
    def classAttribute(self) -> Attribute: ...
    def classIndex(self) -> int: ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def getRelationName(self) -> str: ...
    def inputAttribute(self, int: int) -> Attribute: ...
    def inputAttributeIndex(self, int: int) -> int: ...
    def insertAttributeAt(self, attribute: Attribute, int: int) -> None: ...
    def numAttributes(self) -> int: ...
    def numClasses(self) -> int: ...
    def numInputAttributes(self) -> int: ...
    def numOutputAttributes(self) -> int: ...
    def outputAttribute(self, int: int) -> Attribute: ...
    def outputAttributeIndex(self, int: int) -> int: ...
    @typing.overload
    def setAttributes(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray]) -> None: ...
    @typing.overload
    def setAttributes(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def setClassIndex(self, int: int) -> None: ...
    def setRangeOutputIndices(self, range: 'Range') -> None: ...
    def setRelationName(self, string: str) -> None: ...

class Instances(java.io.Serializable):
    ARFF_RELATION: typing.ClassVar[str] = ...
    ARFF_DATA: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: 'Instances'): ...
    @typing.overload
    def __init__(self, instances: 'Instances', int: int): ...
    @typing.overload
    def __init__(self, instances: 'Instances', int: int, int2: int): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, range: 'Range'): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, int: int, int2: int): ...
    @typing.overload
    def __init__(self, stringReader: java.io.StringReader, int: int): ...
    @typing.overload
    def __init__(self, string: str, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray], int: int): ...
    @typing.overload
    def __init__(self, string: str, list: java.util.List[Attribute], int: int): ...
    def add(self, instance: Instance) -> None: ...
    @typing.overload
    def attribute(self, int: int) -> Attribute: ...
    @typing.overload
    def attribute(self, string: str) -> Attribute: ...
    def classAttribute(self) -> Attribute: ...
    def classIndex(self) -> int: ...
    @typing.overload
    def delete(self) -> None: ...
    @typing.overload
    def delete(self, int: int) -> None: ...
    def deleteAttributeAt(self, integer: int) -> None: ...
    def get(self, int: int) -> Instance: ...
    def getIndicesIrrelevants(self) -> typing.MutableSequence[int]: ...
    def getIndicesRelevants(self) -> typing.MutableSequence[int]: ...
    def getRelationName(self) -> str: ...
    def insertAttributeAt(self, attribute: Attribute, int: int) -> None: ...
    def instance(self, int: int) -> Instance: ...
    def meanOrMode(self, int: int) -> float: ...
    def numAttributes(self) -> int: ...
    def numClasses(self) -> int: ...
    def numInstances(self) -> int: ...
    def randomize(self, random: java.util.Random) -> None: ...
    def readInstance(self, reader: java.io.Reader) -> bool: ...
    def set(self, int: int, instance: Instance) -> None: ...
    @typing.overload
    def setAttributes(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray]) -> None: ...
    @typing.overload
    def setAttributes(self, attributeArray: typing.Union[typing.List[Attribute], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    @typing.overload
    def setAttributes(self, list: java.util.List[Attribute], list2: java.util.List[int]) -> None: ...
    def setClassIndex(self, int: int) -> None: ...
    def setIndicesRelevants(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def setRangeOutputIndices(self, range: 'Range') -> None: ...
    def setRelationName(self, string: str) -> None: ...
    def size(self) -> int: ...
    def stratify(self, int: int) -> None: ...
    def swap(self, int: int, int2: int) -> None: ...
    def testCV(self, int: int, int2: int) -> 'Instances': ...
    def toString(self) -> str: ...
    @typing.overload
    def trainCV(self, int: int, int2: int) -> 'Instances': ...
    @typing.overload
    def trainCV(self, int: int, int2: int, random: java.util.Random) -> 'Instances': ...

class Prediction:
    def getVote(self, int: int, int2: int) -> float: ...
    @typing.overload
    def getVotes(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotes(self, int: int) -> typing.MutableSequence[float]: ...
    def hasVotesForAttribute(self, int: int) -> bool: ...
    def numClasses(self, int: int) -> int: ...
    def numOutputAttributes(self) -> int: ...
    def setVote(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def setVotes(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    def setVotes(self, int: int, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...

class Range(java.io.Serializable):
    def __init__(self, string: str): ...
    def getEnd(self) -> int: ...
    def getStart(self) -> int: ...
    def setRange(self, string: str) -> None: ...
    def setUpper(self, int: int) -> None: ...

class SamoaToWekaInstanceConverter(java.io.Serializable):
    def __init__(self): ...
    def wekaInstance(self, instance: Instance) -> weka.core.Instance: ...
    def wekaInstances(self, instances: Instances) -> weka.core.Instances: ...
    def wekaInstancesInformation(self, instances: Instances) -> weka.core.Instances: ...

class WekaToSamoaInstanceConverter(java.io.Serializable):
    def __init__(self): ...
    def samoaInstance(self, instance: weka.core.Instance) -> Instance: ...
    def samoaInstances(self, instances: weka.core.Instances) -> Instances: ...
    def samoaInstancesInformation(self, instances: weka.core.Instances) -> Instances: ...

class DenseInstanceData(InstanceData):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, int: int): ...
    def copy(self) -> InstanceData: ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def index(self, int: int) -> int: ...
    def insertAttributeAt(self, int: int) -> None: ...
    def isMissing(self, int: int) -> bool: ...
    def isMissingSparse(self, int: int) -> bool: ...
    def numAttributes(self) -> int: ...
    def numValues(self) -> int: ...
    def setValue(self, int: int, double: float) -> None: ...
    def toDoubleArray(self) -> typing.MutableSequence[float]: ...
    def value(self, int: int) -> float: ...
    def valueSparse(self, int: int) -> float: ...

class InstancesHeader(Instances):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: Instances): ...
    @staticmethod
    def getAttributeNameString(instancesHeader: 'InstancesHeader', int: int) -> str: ...
    @staticmethod
    def getClassLabelString(instancesHeader: 'InstancesHeader', int: int) -> str: ...
    @staticmethod
    def getClassNameString(instancesHeader: 'InstancesHeader') -> str: ...
    @staticmethod
    def getInputAttributeNameString(instancesHeader: 'InstancesHeader', int: int) -> str: ...
    def getInstanceInformation(self) -> InstanceInformation: ...
    @staticmethod
    def getNominalValueString(instancesHeader: 'InstancesHeader', int: int, int2: int) -> str: ...
    @staticmethod
    def getNumericValueString(instancesHeader: 'InstancesHeader', int: int, double: float) -> str: ...
    def inputAttribute(self, int: int) -> Attribute: ...
    def numInputAttributes(self) -> int: ...
    def numOutputAttributes(self) -> int: ...
    def outputAttribute(self, int: int) -> Attribute: ...

class MultiLabelInstance(Instance): ...

class MultiLabelPrediction(Prediction, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def getVote(self, int: int, int2: int) -> float: ...
    @typing.overload
    def getVotes(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotes(self, int: int) -> typing.MutableSequence[float]: ...
    def hasVotesForAttribute(self, int: int) -> bool: ...
    def numClasses(self, int: int) -> int: ...
    def numOutputAttributes(self) -> int: ...
    def setVote(self, int: int, int2: int, double: float) -> None: ...
    @typing.overload
    def setVotes(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    def setVotes(self, int: int, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...

class MultiTargetArffLoader(ArffLoader):
    @typing.overload
    def __init__(self, reader: java.io.Reader): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, range: Range): ...

class SparseInstanceData(InstanceData):
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray], int2: int): ...
    @typing.overload
    def __init__(self, int: int): ...
    def copy(self) -> InstanceData: ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def getAttributeValues(self) -> typing.MutableSequence[float]: ...
    def getIndexValues(self) -> typing.MutableSequence[int]: ...
    def getNumberAttributes(self) -> int: ...
    def index(self, int: int) -> int: ...
    def insertAttributeAt(self, int: int) -> None: ...
    def isMissing(self, int: int) -> bool: ...
    def isMissingSparse(self, int: int) -> bool: ...
    def locateIndex(self, int: int) -> int: ...
    def numAttributes(self) -> int: ...
    def numValues(self) -> int: ...
    def setAttributeValues(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setIndexValues(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def setNumberAttributes(self, int: int) -> None: ...
    def setValue(self, int: int, double: float) -> None: ...
    def toDoubleArray(self) -> typing.MutableSequence[float]: ...
    def value(self, int: int) -> float: ...
    def valueSparse(self, int: int) -> float: ...

class FilteredSparseInstanceData(SparseInstanceData):
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray], int2: int): ...
    def value(self, int: int) -> float: ...

class InstanceImpl(MultiLabelInstance):
    @typing.overload
    def __init__(self, instanceImpl: 'InstanceImpl'): ...
    @typing.overload
    def __init__(self, double: float, instanceData: InstanceData): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray], int2: int): ...
    @typing.overload
    def __init__(self, int: int): ...
    def addSparseValues(self, intArray: typing.Union[typing.List[int], jpype.JArray], doubleArray: typing.Union[typing.List[float], jpype.JArray], int2: int) -> None: ...
    def attribute(self, int: int) -> Attribute: ...
    def classAttribute(self) -> Attribute: ...
    def classIndex(self) -> int: ...
    def classIsMissing(self) -> bool: ...
    @typing.overload
    def classValue(self) -> float: ...
    @typing.overload
    def classValue(self, int: int) -> float: ...
    def copy(self) -> Instance: ...
    def dataset(self) -> Instances: ...
    def deleteAttributeAt(self, int: int) -> None: ...
    def index(self, int: int) -> int: ...
    def indexOfAttribute(self, attribute: Attribute) -> int: ...
    def inputAttribute(self, int: int) -> Attribute: ...
    def insertAttributeAt(self, int: int) -> None: ...
    @typing.overload
    def isMissing(self, attribute: Attribute) -> bool: ...
    @typing.overload
    def isMissing(self, int: int) -> bool: ...
    def isMissingSparse(self, int: int) -> bool: ...
    def numAttributes(self) -> int: ...
    def numClasses(self) -> int: ...
    def numInputAttributes(self) -> int: ...
    def numOutputAttributes(self) -> int: ...
    def numValues(self) -> int: ...
    def numberOutputTargets(self) -> int: ...
    def outputAttribute(self, int: int) -> Attribute: ...
    @typing.overload
    def setClassValue(self, double: float) -> None: ...
    @typing.overload
    def setClassValue(self, int: int, double: float) -> None: ...
    def setDataset(self, instances: Instances) -> None: ...
    @typing.overload
    def setMissing(self, attribute: Attribute) -> None: ...
    @typing.overload
    def setMissing(self, int: int) -> None: ...
    @typing.overload
    def setValue(self, attribute: Attribute, double: float) -> None: ...
    @typing.overload
    def setValue(self, int: int, double: float) -> None: ...
    def setWeight(self, double: float) -> None: ...
    def stringValue(self, int: int) -> str: ...
    def toDoubleArray(self) -> typing.MutableSequence[float]: ...
    def toString(self) -> str: ...
    @typing.overload
    def value(self, attribute: Attribute) -> float: ...
    @typing.overload
    def value(self, int: int) -> float: ...
    def valueInputAttribute(self, int: int) -> float: ...
    def valueOutputAttribute(self, int: int) -> float: ...
    def valueSparse(self, int: int) -> float: ...
    def weight(self) -> float: ...

class DenseInstance(InstanceImpl):
    @typing.overload
    def __init__(self, instance: Instance): ...
    @typing.overload
    def __init__(self, instanceImpl: InstanceImpl): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...

class SparseInstance(InstanceImpl):
    @typing.overload
    def __init__(self, instanceImpl: InstanceImpl): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray], int2: int): ...

class FilteredSparseInstance(SparseInstance):
    @typing.overload
    def __init__(self, instanceImpl: InstanceImpl): ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray], int2: int): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("com.yahoo.labs.samoa.instances")``.

    ArffLoader: typing.Type[ArffLoader]
    Attribute: typing.Type[Attribute]
    AttributesInformation: typing.Type[AttributesInformation]
    DenseInstance: typing.Type[DenseInstance]
    DenseInstanceData: typing.Type[DenseInstanceData]
    FilteredSparseInstance: typing.Type[FilteredSparseInstance]
    FilteredSparseInstanceData: typing.Type[FilteredSparseInstanceData]
    Instance: typing.Type[Instance]
    InstanceData: typing.Type[InstanceData]
    InstanceImpl: typing.Type[InstanceImpl]
    InstanceInformation: typing.Type[InstanceInformation]
    Instances: typing.Type[Instances]
    InstancesHeader: typing.Type[InstancesHeader]
    MultiLabelInstance: typing.Type[MultiLabelInstance]
    MultiLabelPrediction: typing.Type[MultiLabelPrediction]
    MultiTargetArffLoader: typing.Type[MultiTargetArffLoader]
    Prediction: typing.Type[Prediction]
    Range: typing.Type[Range]
    SamoaToWekaInstanceConverter: typing.Type[SamoaToWekaInstanceConverter]
    SparseInstance: typing.Type[SparseInstance]
    SparseInstanceData: typing.Type[SparseInstanceData]
    WekaToSamoaInstanceConverter: typing.Type[WekaToSamoaInstanceConverter]
