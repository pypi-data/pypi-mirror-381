
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.lang
import java.util
import java.util.function
import typing



class Capabilities:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, *capability: 'Capability'): ...
    @typing.overload
    def addCapabilities(self, collection: typing.Union[java.util.Collection['Capability'], typing.Sequence['Capability'], typing.Set['Capability']]) -> None: ...
    @typing.overload
    def addCapabilities(self, capabilities: 'Capabilities') -> None: ...
    @typing.overload
    def addCapabilities(self, *capability: 'Capability') -> None: ...
    def addCapability(self, capability: 'Capability') -> None: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, capabilities: 'Capabilities') -> bool: ...
    @typing.overload
    def equals(self, capability: 'Capability') -> bool: ...
    def hasCapability(self, capability: 'Capability') -> bool: ...

class CapabilitiesHandler:
    def defineImmutableCapabilities(self) -> 'ImmutableCapabilities': ...
    def getCapabilities(self) -> Capabilities: ...

class Capability(java.lang.Enum['Capability']):
    VIEW_STANDARD: typing.ClassVar['Capability'] = ...
    VIEW_LITE: typing.ClassVar['Capability'] = ...
    VIEW_EXPERIMENTAL: typing.ClassVar['Capability'] = ...
    @staticmethod
    def forShortName(string: str) -> 'Capability': ...
    @staticmethod
    def stringValues() -> typing.MutableSequence[str]: ...
    def toString(self) -> str: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Capability': ...
    @staticmethod
    def values() -> typing.MutableSequence['Capability']: ...

class CapabilityRequirement:
    NON_HANDLER_CAPABILITIES: typing.ClassVar['ImmutableCapabilities'] = ...
    def __init__(self, predicate: typing.Union[java.util.function.Predicate[Capabilities], typing.Callable[[Capabilities], bool]]): ...
    @staticmethod
    def has(capability: Capability) -> 'CapabilityRequirement': ...
    @staticmethod
    def hasAll(*capability: Capability) -> 'CapabilityRequirement': ...
    @staticmethod
    def hasAny(*capability: Capability) -> 'CapabilityRequirement': ...
    @typing.overload
    def isMetBy(self, class_: typing.Type[typing.Any]) -> bool: ...
    @typing.overload
    def isMetBy(self, capabilities: Capabilities) -> bool: ...
    @typing.overload
    def isMetBy(self, capabilitiesHandler: CapabilitiesHandler) -> bool: ...
    def or_(self, capabilityRequirement: 'CapabilityRequirement') -> 'CapabilityRequirement': ...

class ImmutableCapabilities(Capabilities):
    def __init__(self, *capability: Capability): ...
    @typing.overload
    def addCapabilities(self, collection: typing.Union[java.util.Collection[Capability], typing.Sequence[Capability], typing.Set[Capability]]) -> None: ...
    @typing.overload
    def addCapabilities(self, *capability: Capability) -> None: ...
    @typing.overload
    def addCapabilities(self, capabilities: Capabilities) -> None: ...
    def addCapability(self, capability: Capability) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.capabilities")``.

    Capabilities: typing.Type[Capabilities]
    CapabilitiesHandler: typing.Type[CapabilitiesHandler]
    Capability: typing.Type[Capability]
    CapabilityRequirement: typing.Type[CapabilityRequirement]
    ImmutableCapabilities: typing.Type[ImmutableCapabilities]
