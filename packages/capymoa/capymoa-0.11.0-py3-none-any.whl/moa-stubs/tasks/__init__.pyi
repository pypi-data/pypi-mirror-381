
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.lang
import java.util
import javax.swing
import jpype
import moa
import moa.capabilities
import moa.classifiers
import moa.core
import moa.evaluation
import moa.options
import moa.streams
import moa.streams.clustering
import moa.tasks.ipynb
import moa.tasks.meta
import typing



class FailedTaskReport(moa.AbstractMOAObject):
    def __init__(self, throwable: java.lang.Throwable): ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getFailureReason(self) -> java.lang.Throwable: ...

class ResultPreviewListener:
    def latestPreviewChanged(self) -> None: ...

class Task(moa.MOAObject):
    @typing.overload
    def doTask(self) -> typing.Any: ...
    @typing.overload
    def doTask(self, taskMonitor: 'TaskMonitor', objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class TaskCompletionListener:
    def taskCompleted(self, taskThread: 'TaskThread') -> None: ...

class TaskMonitor:
    def getCurrentActivityDescription(self) -> str: ...
    def getCurrentActivityFractionComplete(self) -> float: ...
    def getLatestResultPreview(self) -> typing.Any: ...
    def isCancelled(self) -> bool: ...
    def isPaused(self) -> bool: ...
    def requestCancel(self) -> None: ...
    def requestPause(self) -> None: ...
    @typing.overload
    def requestResultPreview(self) -> None: ...
    @typing.overload
    def requestResultPreview(self, resultPreviewListener: typing.Union[ResultPreviewListener, typing.Callable]) -> None: ...
    def requestResume(self) -> None: ...
    def resultPreviewRequested(self) -> bool: ...
    def setCurrentActivity(self, string: str, double: float) -> None: ...
    def setCurrentActivityDescription(self, string: str) -> None: ...
    def setCurrentActivityFractionComplete(self, double: float) -> None: ...
    def setLatestResultPreview(self, object: typing.Any) -> None: ...
    def taskShouldAbort(self) -> bool: ...

class TaskThread(java.lang.Thread):
    @typing.overload
    def __init__(self, task: Task): ...
    @typing.overload
    def __init__(self, task: Task, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]): ...
    def addTaskCompletionListener(self, taskCompletionListener: typing.Union[TaskCompletionListener, typing.Callable]) -> None: ...
    def cancelTask(self) -> None: ...
    def getCPUSecondsElapsed(self) -> float: ...
    def getCurrentActivityFracComplete(self) -> float: ...
    def getCurrentActivityString(self) -> str: ...
    def getCurrentStatusString(self) -> str: ...
    def getFinalResult(self) -> typing.Any: ...
    def getLatestPreviewGrabTimeSeconds(self) -> float: ...
    def getLatestResultPreview(self) -> typing.Any: ...
    def getPreview(self, resultPreviewListener: typing.Union[ResultPreviewListener, typing.Callable]) -> None: ...
    def getTask(self) -> Task: ...
    def isCancelled(self) -> bool: ...
    def isComplete(self) -> bool: ...
    def isFailed(self) -> bool: ...
    def pauseTask(self) -> None: ...
    def removeTaskCompletionListener(self, taskCompletionListener: typing.Union[TaskCompletionListener, typing.Callable]) -> None: ...
    def resumeTask(self) -> None: ...
    def run(self) -> None: ...
    class Status(java.lang.Enum['TaskThread.Status']):
        NOT_STARTED: typing.ClassVar['TaskThread.Status'] = ...
        RUNNING: typing.ClassVar['TaskThread.Status'] = ...
        PAUSED: typing.ClassVar['TaskThread.Status'] = ...
        CANCELLING: typing.ClassVar['TaskThread.Status'] = ...
        CANCELLED: typing.ClassVar['TaskThread.Status'] = ...
        COMPLETED: typing.ClassVar['TaskThread.Status'] = ...
        FAILED: typing.ClassVar['TaskThread.Status'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'TaskThread.Status': ...
        @staticmethod
        def values() -> typing.MutableSequence['TaskThread.Status']: ...

class AbstractTask(moa.options.AbstractOptionHandler, Task):
    def __init__(self): ...
    @typing.overload
    def doTask(self) -> typing.Any: ...
    @typing.overload
    def doTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getTaskName(self) -> str: ...

class NullMonitor(TaskMonitor):
    def __init__(self): ...
    def getCurrentActivityDescription(self) -> str: ...
    def getCurrentActivityFractionComplete(self) -> float: ...
    def getLatestResultPreview(self) -> typing.Any: ...
    def isCancelled(self) -> bool: ...
    def isPaused(self) -> bool: ...
    def requestCancel(self) -> None: ...
    def requestPause(self) -> None: ...
    @typing.overload
    def requestResultPreview(self) -> None: ...
    @typing.overload
    def requestResultPreview(self, resultPreviewListener: typing.Union[ResultPreviewListener, typing.Callable]) -> None: ...
    def requestResume(self) -> None: ...
    def resultPreviewRequested(self) -> bool: ...
    def setCurrentActivity(self, string: str, double: float) -> None: ...
    def setCurrentActivityDescription(self, string: str) -> None: ...
    def setCurrentActivityFractionComplete(self, double: float) -> None: ...
    def setLatestResultPreview(self, object: typing.Any) -> None: ...
    def taskShouldAbort(self) -> bool: ...

class StandardTaskMonitor(TaskMonitor):
    def __init__(self): ...
    def getCurrentActivityDescription(self) -> str: ...
    def getCurrentActivityFractionComplete(self) -> float: ...
    def getLatestResultPreview(self) -> typing.Any: ...
    def isCancelled(self) -> bool: ...
    def isPaused(self) -> bool: ...
    def requestCancel(self) -> None: ...
    def requestPause(self) -> None: ...
    @typing.overload
    def requestResultPreview(self) -> None: ...
    @typing.overload
    def requestResultPreview(self, resultPreviewListener: typing.Union[ResultPreviewListener, typing.Callable]) -> None: ...
    def requestResume(self) -> None: ...
    def resultPreviewRequested(self) -> bool: ...
    def setCurrentActivity(self, string: str, double: float) -> None: ...
    def setCurrentActivityDescription(self, string: str) -> None: ...
    def setCurrentActivityFractionComplete(self, double: float) -> None: ...
    def setLatestResultPreview(self, object: typing.Any) -> None: ...
    def taskShouldAbort(self) -> bool: ...

class CacheShuffledStream(AbstractTask):
    streamOption: moa.options.ClassOption = ...
    maximumCacheSizeOption: com.github.javacliparser.IntOption = ...
    shuffleRandomSeedOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class MainTask(AbstractTask):
    outputFileOption: com.github.javacliparser.FileOption = ...
    def __init__(self): ...

class AuxiliarMainTask(MainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class ClassificationMainTask(MainTask, moa.capabilities.CapabilitiesHandler):
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class ConceptDriftMainTask(MainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class MultiLabelMainTask(MainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class MultiTargetMainTask(MainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class Plot(MainTask):
    gnuplotPathOption: com.github.javacliparser.StringOption = ...
    plotOutputOption: com.github.javacliparser.FileOption = ...
    inputFilesOption: com.github.javacliparser.ListOption = ...
    fileAliasesOption: com.github.javacliparser.ListOption = ...
    outputTypeOption: com.github.javacliparser.MultiChoiceOption = ...
    plotStyleOption: com.github.javacliparser.MultiChoiceOption = ...
    xColumnOption: com.github.javacliparser.IntOption = ...
    xTitleOption: com.github.javacliparser.StringOption = ...
    xUnitOption: com.github.javacliparser.StringOption = ...
    yColumnOption: com.github.javacliparser.IntOption = ...
    yTitleOption: com.github.javacliparser.StringOption = ...
    yUnitOption: com.github.javacliparser.StringOption = ...
    lineWidthOption: com.github.javacliparser.IntOption = ...
    pointIntervalOption: com.github.javacliparser.IntOption = ...
    smoothOption: com.github.javacliparser.FlagOption = ...
    deleteScriptsOption: com.github.javacliparser.FlagOption = ...
    legendLocationOption: com.github.javacliparser.MultiChoiceOption = ...
    legendTypeOption: com.github.javacliparser.MultiChoiceOption = ...
    additionalSetOption: com.github.javacliparser.StringOption = ...
    additionalPlotOption: com.github.javacliparser.StringOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...
    class LegendLocation(java.lang.Enum['Plot.LegendLocation']):
        TOP_LEFT_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        TOP_CENTER_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        TOP_RIGHT_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        LEFT_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        CENTER_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        RIGHT_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        BOTTOM_LEFT_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        BOTTOM_CENTER_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        BOTTOM_RIGHT_INSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        TOP_LEFT_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        TOP_CENTER_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        TOP_RIGHT_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        LEFT_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        CENTER_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        RIGHT_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        BOTTOM_LEFT_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        BOTTOM_CENTER_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        BOTTOM_RIGHT_OUTSIDE: typing.ClassVar['Plot.LegendLocation'] = ...
        @staticmethod
        def getDescriptions() -> typing.MutableSequence[str]: ...
        @staticmethod
        def getStringValues() -> typing.MutableSequence[str]: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Plot.LegendLocation': ...
        @staticmethod
        def values() -> typing.MutableSequence['Plot.LegendLocation']: ...
    class LegendType(java.lang.Enum['Plot.LegendType']):
        NONE: typing.ClassVar['Plot.LegendType'] = ...
        BOX_VERTICAL: typing.ClassVar['Plot.LegendType'] = ...
        BOX_HORIZONTAL: typing.ClassVar['Plot.LegendType'] = ...
        NOBOX_VERTICAL: typing.ClassVar['Plot.LegendType'] = ...
        NOBOX_HORIZONTAL: typing.ClassVar['Plot.LegendType'] = ...
        @staticmethod
        def getDescriptions() -> typing.MutableSequence[str]: ...
        @staticmethod
        def getStringValues() -> typing.MutableSequence[str]: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Plot.LegendType': ...
        @staticmethod
        def values() -> typing.MutableSequence['Plot.LegendType']: ...
    class PlotStyle(java.lang.Enum['Plot.PlotStyle']):
        LINES: typing.ClassVar['Plot.PlotStyle'] = ...
        POINTS: typing.ClassVar['Plot.PlotStyle'] = ...
        LINESPOINTS: typing.ClassVar['Plot.PlotStyle'] = ...
        IMPULSES: typing.ClassVar['Plot.PlotStyle'] = ...
        STEPS: typing.ClassVar['Plot.PlotStyle'] = ...
        FSTEPS: typing.ClassVar['Plot.PlotStyle'] = ...
        HISTEPS: typing.ClassVar['Plot.PlotStyle'] = ...
        DOTS: typing.ClassVar['Plot.PlotStyle'] = ...
        @staticmethod
        def getDescriptions() -> typing.MutableSequence[str]: ...
        @staticmethod
        def getStringValues() -> typing.MutableSequence[str]: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Plot.PlotStyle': ...
        @staticmethod
        def values() -> typing.MutableSequence['Plot.PlotStyle']: ...
    class Terminal(java.lang.Enum['Plot.Terminal']):
        CANVAS: typing.ClassVar['Plot.Terminal'] = ...
        EPSLATEX: typing.ClassVar['Plot.Terminal'] = ...
        GIF: typing.ClassVar['Plot.Terminal'] = ...
        JPEG: typing.ClassVar['Plot.Terminal'] = ...
        LATEX: typing.ClassVar['Plot.Terminal'] = ...
        PDFCAIRO: typing.ClassVar['Plot.Terminal'] = ...
        PNG: typing.ClassVar['Plot.Terminal'] = ...
        POSTSCRIPT: typing.ClassVar['Plot.Terminal'] = ...
        POSTSCRIPT_COLOR: typing.ClassVar['Plot.Terminal'] = ...
        PSLATEX: typing.ClassVar['Plot.Terminal'] = ...
        PSTEX: typing.ClassVar['Plot.Terminal'] = ...
        PSTRICKS: typing.ClassVar['Plot.Terminal'] = ...
        SVG: typing.ClassVar['Plot.Terminal'] = ...
        @staticmethod
        def getDescriptions() -> typing.MutableSequence[str]: ...
        @staticmethod
        def getStringValues() -> typing.MutableSequence[str]: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Plot.Terminal': ...
        @staticmethod
        def values() -> typing.MutableSequence['Plot.Terminal']: ...

class RegressionMainTask(MainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class SemiSupervisedMainTask(MainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class EvaluateClustering(AuxiliarMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    generalEvalOption: com.github.javacliparser.FlagOption = ...
    f1Option: com.github.javacliparser.FlagOption = ...
    entropyOption: com.github.javacliparser.FlagOption = ...
    cmmOption: com.github.javacliparser.FlagOption = ...
    ssqOption: com.github.javacliparser.FlagOption = ...
    separationOption: com.github.javacliparser.FlagOption = ...
    silhouetteOption: com.github.javacliparser.FlagOption = ...
    statisticalOption: com.github.javacliparser.FlagOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateConceptDrift(ConceptDriftMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateInterleavedChunks(ClassificationMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    chunkSizeOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    maxMemoryOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateInterleavedTestThenTrain(ClassificationMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    randomSeedOption: com.github.javacliparser.IntOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateInterleavedTestThenTrainSSLDelayed(SemiSupervisedMainTask):
    randomSeedOption: com.github.javacliparser.IntOption = ...
    onlyLabeledDataOption: com.github.javacliparser.FlagOption = ...
    standardLearnerOption: moa.options.ClassOption = ...
    sslLearnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    labelProbabilityOption: com.github.javacliparser.FloatOption = ...
    delayLengthOption: com.github.javacliparser.IntOption = ...
    initialWindowSizeOption: com.github.javacliparser.IntOption = ...
    debugPseudoLabelsOption: com.github.javacliparser.FlagOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    debugOutputUnlabeledClassInformation: com.github.javacliparser.FileOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateModel(ClassificationMainTask, moa.capabilities.CapabilitiesHandler):
    modelOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, learningPerformanceEvaluator: moa.evaluation.LearningPerformanceEvaluator, int: int): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateModelMultiLabel(MultiLabelMainTask):
    modelOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, learningPerformanceEvaluator: moa.evaluation.LearningPerformanceEvaluator, int: int): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateModelMultiTarget(MultiTargetMainTask):
    modelOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, learningPerformanceEvaluator: moa.evaluation.LearningPerformanceEvaluator, int: int): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateModelRegression(RegressionMainTask):
    modelOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, learningPerformanceEvaluator: moa.evaluation.LearningPerformanceEvaluator, int: int): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateMultipleClusterings(AuxiliarMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    numStreamsOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    mergeResultsOption: com.github.javacliparser.FlagOption = ...
    generalEvalOption: com.github.javacliparser.FlagOption = ...
    f1Option: com.github.javacliparser.FlagOption = ...
    entropyOption: com.github.javacliparser.FlagOption = ...
    cmmOption: com.github.javacliparser.FlagOption = ...
    ssqOption: com.github.javacliparser.FlagOption = ...
    separationOption: com.github.javacliparser.FlagOption = ...
    silhouetteOption: com.github.javacliparser.FlagOption = ...
    statisticalOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluateOnlineRecommender(AuxiliarMainTask):
    datasetOption: moa.options.ClassOption = ...
    ratingPredictorOption: moa.options.ClassOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePeriodicHeldOutTest(ClassificationMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    testSizeOption: com.github.javacliparser.IntOption = ...
    trainSizeOption: com.github.javacliparser.IntOption = ...
    trainTimeOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    cacheTestOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequential(ClassificationMainTask, moa.capabilities.CapabilitiesHandler):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialCV(ClassificationMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    numFoldsOption: com.github.javacliparser.IntOption = ...
    validationMethodologyOption: com.github.javacliparser.MultiChoiceOption = ...
    randomSeedOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getEvaluationMeasurements(self, measurementArray: typing.Union[typing.List[moa.core.Measurement], jpype.JArray], learningPerformanceEvaluatorArray: typing.Union[typing.List[moa.evaluation.LearningPerformanceEvaluator], jpype.JArray]) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialDelayed(ClassificationMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    delayLengthOption: com.github.javacliparser.IntOption = ...
    initialWindowSizeOption: com.github.javacliparser.IntOption = ...
    trainOnInitialWindowOption: com.github.javacliparser.FlagOption = ...
    trainInBatches: com.github.javacliparser.FlagOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialDelayedCV(ClassificationMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    delayLengthOption: com.github.javacliparser.IntOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    numFoldsOption: com.github.javacliparser.IntOption = ...
    validationMethodologyOption: com.github.javacliparser.MultiChoiceOption = ...
    randomSeedOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getEvaluationMeasurements(self, measurementArray: typing.Union[typing.List[moa.core.Measurement], jpype.JArray], learningPerformanceEvaluatorArray: typing.Union[typing.List[moa.evaluation.LearningPerformanceEvaluator], jpype.JArray]) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialMultiLabel(MultiLabelMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialMultiTarget(MultiTargetMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialMultiTargetSemiSuper(MultiTargetMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    unlabeledPercentage: com.github.javacliparser.FloatOption = ...
    dbInitialModelPercentage: com.github.javacliparser.FloatOption = ...
    runSeed: com.github.javacliparser.IntOption = ...
    slidingWindowSize: com.github.javacliparser.IntOption = ...
    slidingWindowStep: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialPredictionIntervals(RegressionMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class EvaluatePrequentialRegression(RegressionMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    evaluatorOption: moa.options.ClassOption = ...
    instanceLimitOption: com.github.javacliparser.IntOption = ...
    timeLimitOption: com.github.javacliparser.IntOption = ...
    sampleFrequencyOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    outputPredictionFileOption: com.github.javacliparser.FileOption = ...
    widthOption: com.github.javacliparser.IntOption = ...
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class FeatureImportanceConfig(ClassificationMainTask, moa.capabilities.CapabilitiesHandler):
    learnerOption: moa.options.ClassOption = ...
    nanSubstitute: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def doNotNormalizeFeatureScore(self) -> bool: ...
    def getNaNSubstitute(self) -> float: ...
    def getProgressBar(self) -> javax.swing.JProgressBar: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...
    def getWindowSize(self) -> int: ...
    def setDoNotNormalizeFeatureScore(self, boolean: bool) -> None: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def setNaNSubstitute(self, double: float) -> None: ...
    def setWindowSize(self, int: int) -> None: ...

class LearnModel(ClassificationMainTask, moa.capabilities.CapabilitiesHandler):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    numPassesOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, int: int, int2: int): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class LearnModelMultiLabel(MultiLabelMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    numPassesOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, int: int, int2: int): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class LearnModelMultiTarget(MultiTargetMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    numPassesOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, int: int, int2: int): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class LearnModelRegression(RegressionMainTask):
    learnerOption: moa.options.ClassOption = ...
    streamOption: moa.options.ClassOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    numPassesOption: com.github.javacliparser.IntOption = ...
    memCheckFrequencyOption: com.github.javacliparser.IntOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classifier: moa.classifiers.Classifier, instanceStream: moa.streams.InstanceStream, int: int, int2: int): ...
    def doMainTask(self, taskMonitor: TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class MeasureStreamSpeed(AuxiliarMainTask):
    streamOption: moa.options.ClassOption = ...
    generateSizeOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class PredictionIntervalMainTask(RegressionMainTask):
    def __init__(self): ...
    def getEventsList(self) -> java.util.ArrayList[moa.streams.clustering.ClusterEvent]: ...

class RunStreamTasks(ConceptDriftMainTask):
    taskOption: moa.options.ClassOption = ...
    streamParameterOption: com.github.javacliparser.StringOption = ...
    firstValueOption: com.github.javacliparser.FloatOption = ...
    lastValueOption: com.github.javacliparser.FloatOption = ...
    incrementValueOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class RunTasks(AuxiliarMainTask):
    taskOption: moa.options.ClassOption = ...
    classifierParameterOption: com.github.javacliparser.StringOption = ...
    firstValueOption: com.github.javacliparser.FloatOption = ...
    lastValueOption: com.github.javacliparser.FloatOption = ...
    incrementValueOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class WriteConfigurationToJupyterNotebook(AuxiliarMainTask):
    taskOption: moa.options.ClassOption = ...
    notebookOutputFile: com.github.javacliparser.FileOption = ...
    runConfig: com.github.javacliparser.FlagOption = ...
    exportAdvancedNotebook: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class WriteMultipleStreamsToARFF(AuxiliarMainTask):
    streamOption: moa.options.ClassOption = ...
    arffFileOption: com.github.javacliparser.FileOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    suppressHeaderOption: com.github.javacliparser.FlagOption = ...
    numStreamsOption: com.github.javacliparser.IntOption = ...
    randomFlagOne: com.github.javacliparser.FlagOption = ...
    randomOneOption: com.github.javacliparser.StringOption = ...
    randomFlagTwo: com.github.javacliparser.FlagOption = ...
    randomTwoOption: com.github.javacliparser.StringOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...

class WriteStreamToARFFFile(AuxiliarMainTask):
    streamOption: moa.options.ClassOption = ...
    arffFileOption: com.github.javacliparser.FileOption = ...
    maxInstancesOption: com.github.javacliparser.IntOption = ...
    suppressHeaderOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def getTaskResultType(self) -> typing.Type[typing.Any]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.tasks")``.

    AbstractTask: typing.Type[AbstractTask]
    AuxiliarMainTask: typing.Type[AuxiliarMainTask]
    CacheShuffledStream: typing.Type[CacheShuffledStream]
    ClassificationMainTask: typing.Type[ClassificationMainTask]
    ConceptDriftMainTask: typing.Type[ConceptDriftMainTask]
    EvaluateClustering: typing.Type[EvaluateClustering]
    EvaluateConceptDrift: typing.Type[EvaluateConceptDrift]
    EvaluateInterleavedChunks: typing.Type[EvaluateInterleavedChunks]
    EvaluateInterleavedTestThenTrain: typing.Type[EvaluateInterleavedTestThenTrain]
    EvaluateInterleavedTestThenTrainSSLDelayed: typing.Type[EvaluateInterleavedTestThenTrainSSLDelayed]
    EvaluateModel: typing.Type[EvaluateModel]
    EvaluateModelMultiLabel: typing.Type[EvaluateModelMultiLabel]
    EvaluateModelMultiTarget: typing.Type[EvaluateModelMultiTarget]
    EvaluateModelRegression: typing.Type[EvaluateModelRegression]
    EvaluateMultipleClusterings: typing.Type[EvaluateMultipleClusterings]
    EvaluateOnlineRecommender: typing.Type[EvaluateOnlineRecommender]
    EvaluatePeriodicHeldOutTest: typing.Type[EvaluatePeriodicHeldOutTest]
    EvaluatePrequential: typing.Type[EvaluatePrequential]
    EvaluatePrequentialCV: typing.Type[EvaluatePrequentialCV]
    EvaluatePrequentialDelayed: typing.Type[EvaluatePrequentialDelayed]
    EvaluatePrequentialDelayedCV: typing.Type[EvaluatePrequentialDelayedCV]
    EvaluatePrequentialMultiLabel: typing.Type[EvaluatePrequentialMultiLabel]
    EvaluatePrequentialMultiTarget: typing.Type[EvaluatePrequentialMultiTarget]
    EvaluatePrequentialMultiTargetSemiSuper: typing.Type[EvaluatePrequentialMultiTargetSemiSuper]
    EvaluatePrequentialPredictionIntervals: typing.Type[EvaluatePrequentialPredictionIntervals]
    EvaluatePrequentialRegression: typing.Type[EvaluatePrequentialRegression]
    FailedTaskReport: typing.Type[FailedTaskReport]
    FeatureImportanceConfig: typing.Type[FeatureImportanceConfig]
    LearnModel: typing.Type[LearnModel]
    LearnModelMultiLabel: typing.Type[LearnModelMultiLabel]
    LearnModelMultiTarget: typing.Type[LearnModelMultiTarget]
    LearnModelRegression: typing.Type[LearnModelRegression]
    MainTask: typing.Type[MainTask]
    MeasureStreamSpeed: typing.Type[MeasureStreamSpeed]
    MultiLabelMainTask: typing.Type[MultiLabelMainTask]
    MultiTargetMainTask: typing.Type[MultiTargetMainTask]
    NullMonitor: typing.Type[NullMonitor]
    Plot: typing.Type[Plot]
    PredictionIntervalMainTask: typing.Type[PredictionIntervalMainTask]
    RegressionMainTask: typing.Type[RegressionMainTask]
    ResultPreviewListener: typing.Type[ResultPreviewListener]
    RunStreamTasks: typing.Type[RunStreamTasks]
    RunTasks: typing.Type[RunTasks]
    SemiSupervisedMainTask: typing.Type[SemiSupervisedMainTask]
    StandardTaskMonitor: typing.Type[StandardTaskMonitor]
    Task: typing.Type[Task]
    TaskCompletionListener: typing.Type[TaskCompletionListener]
    TaskMonitor: typing.Type[TaskMonitor]
    TaskThread: typing.Type[TaskThread]
    WriteConfigurationToJupyterNotebook: typing.Type[WriteConfigurationToJupyterNotebook]
    WriteMultipleStreamsToARFF: typing.Type[WriteMultipleStreamsToARFF]
    WriteStreamToARFFFile: typing.Type[WriteStreamToARFFFile]
    ipynb: moa.tasks.ipynb.__module_protocol__
    meta: moa.tasks.meta.__module_protocol__
