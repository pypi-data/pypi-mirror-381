
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import jpype.protocol
import moa
import moa.core.utils
import typing



class AutoClassDiscovery:
    CLASS_LIST: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def findClassNames(string: str) -> typing.MutableSequence[str]: ...
    @staticmethod
    def findClassesOfType(string: str, class_: typing.Type[typing.Any]) -> typing.MutableSequence[typing.Type]: ...
    @staticmethod
    def getAllClassNames() -> java.util.List[str]: ...
    @staticmethod
    def hasEmptyConstructor(class_: typing.Type[typing.Any]) -> bool: ...
    @staticmethod
    def isPublicConcreteClassOfType(string: str, class_: typing.Type[typing.Any]) -> bool: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...

_AutoExpandVector__T = typing.TypeVar('_AutoExpandVector__T')  # <T>
class AutoExpandVector(java.util.ArrayList[_AutoExpandVector__T], moa.MOAObject, typing.Generic[_AutoExpandVector__T]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def add(self, t: _AutoExpandVector__T) -> bool: ...
    @typing.overload
    def add(self, int: int, t: _AutoExpandVector__T) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[java.util.Collection[_AutoExpandVector__T], typing.Sequence[_AutoExpandVector__T], typing.Set[_AutoExpandVector__T]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[_AutoExpandVector__T], typing.Sequence[_AutoExpandVector__T], typing.Set[_AutoExpandVector__T]]) -> bool: ...
    def clear(self) -> None: ...
    def copy(self) -> moa.MOAObject: ...
    def get(self, int: int) -> _AutoExpandVector__T: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def measureByteSize(self) -> int: ...
    def set(self, int: int, t: _AutoExpandVector__T) -> _AutoExpandVector__T: ...

class DoubleVector(moa.AbstractMOAObject):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, doubleVector: 'DoubleVector'): ...
    def addToValue(self, int: int, double: float) -> None: ...
    def addToValues(self, double: float) -> None: ...
    @typing.overload
    def addValues(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    def addValues(self, doubleVector: 'DoubleVector') -> None: ...
    def getArrayCopy(self) -> typing.MutableSequence[float]: ...
    def getArrayRef(self) -> typing.MutableSequence[float]: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def getSingleLineDescription(self, stringBuilder: java.lang.StringBuilder) -> None: ...
    @typing.overload
    def getSingleLineDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getValue(self, int: int) -> float: ...
    def maxIndex(self) -> int: ...
    def minWeight(self) -> float: ...
    def normalize(self) -> None: ...
    def numNonZeroEntries(self) -> int: ...
    def numValues(self) -> int: ...
    def scaleValues(self, double: float) -> None: ...
    def setValue(self, int: int, double: float) -> None: ...
    @typing.overload
    def subtractValues(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    def subtractValues(self, doubleVector: 'DoubleVector') -> None: ...
    def sumOfAbsoluteValues(self) -> float: ...
    def sumOfValues(self) -> float: ...

_Example__T = typing.TypeVar('_Example__T')  # <T>
class Example(typing.Generic[_Example__T]):
    def copy(self) -> 'Example': ...
    def getData(self) -> _Example__T: ...
    def setWeight(self, double: float) -> None: ...
    def weight(self) -> float: ...

_FastVector__E = typing.TypeVar('_FastVector__E')  # <E>
class FastVector(java.util.ArrayList[_FastVector__E], typing.Generic[_FastVector__E]):
    def __init__(self): ...
    def addElement(self, e: _FastVector__E) -> None: ...
    def elementAt(self, int: int) -> _FastVector__E: ...
    def removeElementAt(self, int: int) -> None: ...

_FixedLengthList__E = typing.TypeVar('_FixedLengthList__E')  # <E>
class FixedLengthList(java.util.ArrayList[_FixedLengthList__E], typing.Generic[_FixedLengthList__E]):
    def __init__(self, int: int): ...
    @typing.overload
    def add(self, e: _FixedLengthList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _FixedLengthList__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[java.util.Collection[_FixedLengthList__E], typing.Sequence[_FixedLengthList__E], typing.Set[_FixedLengthList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[java.util.Collection[_FixedLengthList__E], typing.Sequence[_FixedLengthList__E], typing.Set[_FixedLengthList__E]]) -> bool: ...
    def getMaxSize(self) -> int: ...
    def getOldestEntry(self) -> _FixedLengthList__E: ...
    def getYoungestEntry(self) -> _FixedLengthList__E: ...

class GaussianEstimator(moa.AbstractMOAObject):
    NORMAL_CONSTANT: typing.ClassVar[float] = ...
    def __init__(self): ...
    def addObservation(self, double: float, double2: float) -> None: ...
    def addObservations(self, gaussianEstimator: 'GaussianEstimator') -> None: ...
    def estimatedWeight_LessThan_EqualTo_GreaterThan_Value(self, double: float) -> typing.MutableSequence[float]: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMean(self) -> float: ...
    def getStdDev(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def getVariance(self) -> float: ...
    def probabilityDensity(self, double: float) -> float: ...

class Globals:
    workbenchTitle: typing.ClassVar[str] = ...
    versionString: typing.ClassVar[str] = ...
    copyrightNotice: typing.ClassVar[str] = ...
    webAddress: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def getWorkbenchInfoString() -> str: ...

class GreenwaldKhannaQuantileSummary(moa.AbstractMOAObject):
    def __init__(self, int: int): ...
    def compress(self, long: int) -> None: ...
    @staticmethod
    def computeBandBoundaries(long: int) -> typing.MutableSequence[int]: ...
    def findMaxDelta(self) -> int: ...
    def getCountBelow(self, double: float) -> int: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPropotionBelow(self, double: float) -> float: ...
    def getQuantile(self, double: float) -> float: ...
    def getSuggestedCutpoints(self) -> typing.MutableSequence[float]: ...
    def getTotalCount(self) -> int: ...
    def getWorstError(self) -> int: ...
    def insert(self, double: float) -> None: ...

class InputStreamProgressMonitor(java.io.FilterInputStream):
    def __init__(self, inputStream: java.io.InputStream): ...
    def getBytesRead(self) -> int: ...
    def getBytesRemaining(self) -> int: ...
    def getProgressFraction(self) -> float: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> int: ...
    @typing.overload
    def read(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> int: ...
    def reset(self) -> None: ...
    def skip(self, long: int) -> int: ...

class Measurement(moa.AbstractMOAObject):
    def __init__(self, string: str, double: float): ...
    @staticmethod
    def averageMeasurements(measurementArray: typing.Union[typing.List[typing.MutableSequence['Measurement']], jpype.JArray]) -> typing.MutableSequence['Measurement']: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @staticmethod
    def getMeasurementNamed(string: str, measurementArray: typing.Union[typing.List['Measurement'], jpype.JArray]) -> 'Measurement': ...
    @staticmethod
    def getMeasurementsDescription(measurementArray: typing.Union[typing.List['Measurement'], jpype.JArray], stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getName(self) -> str: ...
    def getValue(self) -> float: ...

class MiscUtils:
    def __init__(self): ...
    @staticmethod
    def chooseRandomIndexBasedOnWeights(doubleArray: typing.Union[typing.List[float], jpype.JArray], random: java.util.Random) -> int: ...
    @staticmethod
    def getStackTraceString(exception: java.lang.Exception) -> str: ...
    @staticmethod
    def maxIndex(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> int: ...
    @staticmethod
    def poisson(double: float, random: java.util.Random) -> int: ...

class MultilabelInstance(com.yahoo.labs.samoa.instances.InstanceImpl):
    @typing.overload
    def __init__(self, instanceImpl: com.yahoo.labs.samoa.instances.InstanceImpl): ...
    @typing.overload
    def __init__(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    def getNumLabels(self) -> int: ...
    def setNumLabels(self, int: int) -> None: ...

class MultilabelInstancesHeader(com.yahoo.labs.samoa.instances.InstancesHeader):
    def __init__(self, instances: com.yahoo.labs.samoa.instances.Instances, int: int): ...
    def getNumClassLabels(self) -> int: ...

class ObjectRepository:
    def getObjectNamed(self, string: str) -> typing.Any: ...

class PropertiesReader:
    def __init__(self): ...
    @staticmethod
    def readProperties(string: str) -> java.util.Properties: ...

class SerializeUtils:
    def __init__(self): ...
    @staticmethod
    def copyObject(serializable: java.io.Serializable) -> typing.Any: ...
    @staticmethod
    def measureObjectByteSize(serializable: java.io.Serializable) -> int: ...
    @staticmethod
    def readFromFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> typing.Any: ...
    @staticmethod
    def writeToFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], serializable: java.io.Serializable) -> None: ...
    class ByteCountingOutputStream(java.io.OutputStream):
        def __init__(self): ...
        def getNumBytesWritten(self) -> int: ...
        @typing.overload
        def write(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
        @typing.overload
        def write(self, byteArray: typing.Union[typing.List[int], jpype.JArray, bytes], int: int, int2: int) -> None: ...
        @typing.overload
        def write(self, int: int) -> None: ...

class SizeOf:
    def __init__(self): ...
    @staticmethod
    def fullSizeOf(object: typing.Any) -> int: ...
    @staticmethod
    def sizeOf(object: typing.Any) -> int: ...

class Statistics:
    def __init__(self): ...
    @staticmethod
    def FProbability(double: float, int: int, int2: int) -> float: ...
    @staticmethod
    def binomialStandardError(double: float, int: int) -> float: ...
    @staticmethod
    def chiSquaredProbability(double: float, double2: float) -> float: ...
    @staticmethod
    def errorFunction(double: float) -> float: ...
    @staticmethod
    def errorFunctionComplemented(double: float) -> float: ...
    @staticmethod
    def gamma(double: float) -> float: ...
    @staticmethod
    def incompleteBeta(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def incompleteBetaFraction1(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def incompleteBetaFraction2(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def incompleteGamma(double: float, double2: float) -> float: ...
    @staticmethod
    def incompleteGammaComplement(double: float, double2: float) -> float: ...
    @staticmethod
    def lnGamma(double: float) -> float: ...
    @staticmethod
    def normalInverse(double: float) -> float: ...
    @staticmethod
    def normalProbability(double: float) -> float: ...
    @staticmethod
    def p1evl(double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int) -> float: ...
    @staticmethod
    def polevl(double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int) -> float: ...
    @staticmethod
    def powerSeries(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def stirlingFormula(double: float) -> float: ...

class StringUtils:
    newline: typing.ClassVar[str] = ...
    def __init__(self): ...
    @staticmethod
    def appendIndent(stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @staticmethod
    def appendIndented(stringBuilder: java.lang.StringBuilder, int: int, string2: str) -> None: ...
    @staticmethod
    def appendNewline(stringBuilder: java.lang.StringBuilder) -> None: ...
    @staticmethod
    def appendNewlineIndented(stringBuilder: java.lang.StringBuilder, int: int, string2: str) -> None: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int) -> str: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int, int2: int) -> str: ...
    @staticmethod
    def secondsToDHMSString(double: float) -> str: ...

class TimingUtils:
    def __init__(self): ...
    @staticmethod
    def enablePreciseTiming() -> bool: ...
    @staticmethod
    def getNanoCPUTimeOfCurrentThread() -> int: ...
    @staticmethod
    def getNanoCPUTimeOfThread(long: int) -> int: ...
    @staticmethod
    def nanoTimeToSeconds(long: int) -> float: ...

class Utils:
    log2: typing.ClassVar[float] = ...
    SMALL: typing.ClassVar[float] = ...
    def __init__(self): ...
    @staticmethod
    def arrayToString(object: typing.Any) -> str: ...
    @staticmethod
    def backQuoteChars(string: str) -> str: ...
    @staticmethod
    def breakUp(string: str, int: int) -> typing.MutableSequence[str]: ...
    _cast__T = typing.TypeVar('_cast__T')  # <T>
    @staticmethod
    def cast(object: typing.Any) -> _cast__T: ...
    @staticmethod
    def checkForRemainingOptions(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    @staticmethod
    def convertNewLines(string: str) -> str: ...
    @staticmethod
    def convertToRelativePath(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> java.io.File: ...
    @staticmethod
    def correlation(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], int: int) -> float: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int) -> str: ...
    @typing.overload
    @staticmethod
    def doubleToString(double: float, int: int, int2: int) -> str: ...
    @staticmethod
    def eq(double: float, double2: float) -> bool: ...
    @staticmethod
    def forName(class_: typing.Type[typing.Any], string: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> typing.Any: ...
    @staticmethod
    def getArrayClass(class_: typing.Type) -> typing.Type: ...
    @typing.overload
    @staticmethod
    def getArrayDimensions(class_: typing.Type) -> int: ...
    @typing.overload
    @staticmethod
    def getArrayDimensions(object: typing.Any) -> int: ...
    @typing.overload
    @staticmethod
    def getFlag(char: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def getFlag(string: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> bool: ...
    @typing.overload
    @staticmethod
    def getOption(char: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> str: ...
    @typing.overload
    @staticmethod
    def getOption(string: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> str: ...
    @typing.overload
    @staticmethod
    def getOptionPos(char: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> int: ...
    @typing.overload
    @staticmethod
    def getOptionPos(string: str, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> int: ...
    @staticmethod
    def gr(double: float, double2: float) -> bool: ...
    @staticmethod
    def grOrEq(double: float, double2: float) -> bool: ...
    @staticmethod
    def info(intArray: typing.Union[typing.List[int], jpype.JArray]) -> float: ...
    @staticmethod
    def isMissingValue(double: float) -> bool: ...
    @staticmethod
    def joinOptions(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> str: ...
    @typing.overload
    @staticmethod
    def kthSmallestValue(doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int) -> float: ...
    @typing.overload
    @staticmethod
    def kthSmallestValue(intArray: typing.Union[typing.List[int], jpype.JArray], int2: int) -> float: ...
    @staticmethod
    def log2(double: float) -> float: ...
    @staticmethod
    def logs2probs(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    @typing.overload
    @staticmethod
    def maxIndex(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> int: ...
    @typing.overload
    @staticmethod
    def maxIndex(intArray: typing.Union[typing.List[int], jpype.JArray]) -> int: ...
    @staticmethod
    def mean(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def minIndex(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> int: ...
    @typing.overload
    @staticmethod
    def minIndex(intArray: typing.Union[typing.List[int], jpype.JArray]) -> int: ...
    @staticmethod
    def missingValue() -> float: ...
    @typing.overload
    @staticmethod
    def normalize(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    @typing.overload
    @staticmethod
    def normalize(doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float) -> None: ...
    @staticmethod
    def padLeft(string: str, int: int) -> str: ...
    @staticmethod
    def padRight(string: str, int: int) -> str: ...
    @staticmethod
    def partitionOptions(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> typing.MutableSequence[str]: ...
    @staticmethod
    def probRound(double: float, random: java.util.Random) -> int: ...
    @staticmethod
    def probToLogOdds(double: float) -> float: ...
    @staticmethod
    def quote(string: str) -> str: ...
    @staticmethod
    def removeSubstring(string: str, string2: str) -> str: ...
    @staticmethod
    def replaceSubstring(string: str, string2: str, string3: str) -> str: ...
    @staticmethod
    def revertNewLines(string: str) -> str: ...
    @staticmethod
    def round(double: float) -> int: ...
    @staticmethod
    def roundDouble(double: float, int: int) -> float: ...
    @staticmethod
    def sm(double: float, double2: float) -> bool: ...
    @staticmethod
    def smOrEq(double: float, double2: float) -> bool: ...
    @typing.overload
    @staticmethod
    def sort(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def sort(intArray: typing.Union[typing.List[int], jpype.JArray]) -> typing.MutableSequence[int]: ...
    @staticmethod
    def splitOptions(string: str) -> typing.MutableSequence[str]: ...
    @staticmethod
    def stableSort(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[int]: ...
    @typing.overload
    @staticmethod
    def sum(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    @staticmethod
    def sum(intArray: typing.Union[typing.List[int], jpype.JArray]) -> int: ...
    @staticmethod
    def unbackQuoteChars(string: str) -> str: ...
    @staticmethod
    def unquote(string: str) -> str: ...
    @staticmethod
    def variance(doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @staticmethod
    def xlogx(int: int) -> float: ...

class WekaUtils:
    def __init__(self): ...
    @staticmethod
    def isWekaVersionOK() -> bool: ...

class InstanceExample(Example[com.yahoo.labs.samoa.instances.Instance]):
    instance: com.yahoo.labs.samoa.instances.Instance = ...
    def __init__(self, instance: com.yahoo.labs.samoa.instances.Instance): ...
    def copy(self) -> Example: ...
    def getData(self) -> com.yahoo.labs.samoa.instances.Instance: ...
    def setWeight(self, double: float) -> None: ...
    def toString(self) -> str: ...
    def weight(self) -> float: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.core")``.

    AutoClassDiscovery: typing.Type[AutoClassDiscovery]
    AutoExpandVector: typing.Type[AutoExpandVector]
    DoubleVector: typing.Type[DoubleVector]
    Example: typing.Type[Example]
    FastVector: typing.Type[FastVector]
    FixedLengthList: typing.Type[FixedLengthList]
    GaussianEstimator: typing.Type[GaussianEstimator]
    Globals: typing.Type[Globals]
    GreenwaldKhannaQuantileSummary: typing.Type[GreenwaldKhannaQuantileSummary]
    InputStreamProgressMonitor: typing.Type[InputStreamProgressMonitor]
    InstanceExample: typing.Type[InstanceExample]
    Measurement: typing.Type[Measurement]
    MiscUtils: typing.Type[MiscUtils]
    MultilabelInstance: typing.Type[MultilabelInstance]
    MultilabelInstancesHeader: typing.Type[MultilabelInstancesHeader]
    ObjectRepository: typing.Type[ObjectRepository]
    PropertiesReader: typing.Type[PropertiesReader]
    SerializeUtils: typing.Type[SerializeUtils]
    SizeOf: typing.Type[SizeOf]
    Statistics: typing.Type[Statistics]
    StringUtils: typing.Type[StringUtils]
    TimingUtils: typing.Type[TimingUtils]
    Utils: typing.Type[Utils]
    WekaUtils: typing.Type[WekaUtils]
    utils: moa.core.utils.__module_protocol__
