
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import moa
import moa.capabilities
import moa.cluster
import moa.core
import moa.evaluation.preview
import moa.gui.visualization
import moa.learners
import moa.options
import moa.streams
import moa.tasks
import typing



class CMM_GTAnalysis:
    def __init__(self, clustering: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint], boolean: bool): ...
    def getClassSeparability(self) -> float: ...
    def getModelQuality(self) -> float: ...
    def getNoiseSeparability(self) -> float: ...
    def getParameterString(self) -> str: ...

class ClassificationMeasureCollection: ...

class EfficientEvaluationLoops:
    def __init__(self): ...
    @staticmethod
    def PrequentialEvaluation(exampleStream: moa.streams.ExampleStream, learner: moa.learners.Learner, learningPerformanceEvaluator: 'LearningPerformanceEvaluator'[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]], learningPerformanceEvaluator2: 'LearningPerformanceEvaluator'[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]], long: int, long2: int, boolean: bool, boolean2: bool) -> 'EfficientEvaluationLoops.PrequentialResult': ...
    @staticmethod
    def PrequentialSSLEvaluation(exampleStream: moa.streams.ExampleStream[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]], learner: moa.learners.Learner, learningPerformanceEvaluator: 'LearningPerformanceEvaluator', learningPerformanceEvaluator2: 'LearningPerformanceEvaluator', long: int, long2: int, long3: int, long4: int, double: float, int: int, boolean: bool, boolean2: bool, boolean3: bool) -> 'EfficientEvaluationLoops.PrequentialResult': ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    class PrequentialResult:
        windowedResults: java.util.ArrayList = ...
        cumulativeResults: typing.MutableSequence[float] = ...
        targets: java.util.ArrayList = ...
        predictions: java.util.ArrayList = ...
        otherMeasurements: java.util.HashMap = ...
        @typing.overload
        def __init__(self, arrayList: java.util.ArrayList[typing.Union[typing.List[float], jpype.JArray]], doubleArray: typing.Union[typing.List[float], jpype.JArray], arrayList2: java.util.ArrayList[int], arrayList3: java.util.ArrayList[int]): ...
        @typing.overload
        def __init__(self, arrayList: java.util.ArrayList[typing.Union[typing.List[float], jpype.JArray]], doubleArray: typing.Union[typing.List[float], jpype.JArray], arrayList2: java.util.ArrayList[int], arrayList3: java.util.ArrayList[int], hashMap: java.util.HashMap[str, float]): ...
        @typing.overload
        def __init__(self, arrayList: java.util.ArrayList[typing.Union[typing.List[float], jpype.JArray]], doubleArray: typing.Union[typing.List[float], jpype.JArray], hashMap: java.util.HashMap[str, float]): ...

class LearningEvaluation(moa.AbstractMOAObject):
    @typing.overload
    def __init__(self, measurementArray: typing.Union[typing.List[moa.core.Measurement], jpype.JArray]): ...
    @typing.overload
    def __init__(self, measurementArray: typing.Union[typing.List[moa.core.Measurement], jpype.JArray], learningPerformanceEvaluator: 'LearningPerformanceEvaluator', learner: moa.learners.Learner): ...
    @typing.overload
    def __init__(self, learningPerformanceEvaluator: 'LearningPerformanceEvaluator', learner: moa.learners.Learner): ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...

_LearningPerformanceEvaluator__E = typing.TypeVar('_LearningPerformanceEvaluator__E', bound=moa.core.Example)  # <E>
class LearningPerformanceEvaluator(moa.MOAObject, moa.capabilities.CapabilitiesHandler, java.lang.AutoCloseable, typing.Generic[_LearningPerformanceEvaluator__E]):
    @typing.overload
    def addResult(self, e: _LearningPerformanceEvaluator__E, prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, e: _LearningPerformanceEvaluator__E, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def close(self) -> None: ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def reset(self) -> None: ...

class MeasureCollection(moa.AbstractMOAObject):
    def __init__(self): ...
    def addEmptyValue(self, int: int) -> None: ...
    def addEventType(self, string: str) -> None: ...
    def addValue(self, int: int, double: float) -> None: ...
    def clean(self, int: int) -> None: ...
    def evaluateClusteringPerformance(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> float: ...
    def getAllValues(self, int: int) -> java.util.ArrayList[float]: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getEventType(self, int: int) -> str: ...
    def getLastValue(self, int: int) -> float: ...
    def getLowerQuartile(self, int: int) -> float: ...
    def getMaxValue(self, int: int) -> float: ...
    def getMean(self, int: int) -> float: ...
    def getMeanRunningTime(self) -> float: ...
    def getMedian(self, int: int) -> float: ...
    def getMinValue(self, int: int) -> float: ...
    def getName(self, int: int) -> str: ...
    def getNumMeasures(self) -> int: ...
    def getNumberOfValues(self, int: int) -> int: ...
    def getUpperQuartile(self, int: int) -> float: ...
    def getValue(self, int: int, int2: int) -> float: ...
    def isEnabled(self, int: int) -> bool: ...
    def setEnabled(self, int: int, boolean: bool) -> None: ...

class MembershipMatrix:
    def __init__(self, clustering: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]): ...
    def getClassDistribution(self, int: int) -> int: ...
    def getClassDistributionByLabel(self, int: int) -> int: ...
    def getClassSum(self, int: int) -> int: ...
    def getClassSumByLabel(self, int: int) -> int: ...
    def getClusterClassWeight(self, int: int, int2: int) -> int: ...
    def getClusterClassWeightByLabel(self, int: int, int2: int) -> int: ...
    def getClusterSum(self, int: int) -> int: ...
    def getInitalBuildTimestamp(self) -> int: ...
    def getNumClasses(self) -> int: ...
    def getTotalEntries(self) -> int: ...
    def hasNoiseClass(self) -> bool: ...
    def toString(self) -> str: ...

class ALMeasureCollection(MeasureCollection, ClassificationMeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...

class Accuracy(MeasureCollection, ClassificationMeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...
    def getNames(self) -> typing.MutableSequence[str]: ...

class BasicConceptDriftPerformanceEvaluator(moa.AbstractMOAObject, LearningPerformanceEvaluator[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]]):
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getInputValues(self) -> float: ...
    def getNumberChanges(self) -> float: ...
    def getNumberChangesOccurred(self) -> float: ...
    def getNumberDetections(self) -> float: ...
    def getNumberWarnings(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getPredictionError(self) -> float: ...
    def getTotalDelay(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def reset(self) -> None: ...

class CMM(MeasureCollection):
    debug: bool = ...
    enableClassMerge: bool = ...
    enableModelError: bool = ...
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...
    def getParameterString(self) -> str: ...

class ChangeDetectionMeasures(MeasureCollection, ClassificationMeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...
    def getNames(self) -> typing.MutableSequence[str]: ...

class ClassificationPerformanceEvaluator(LearningPerformanceEvaluator[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]]): ...

class EntropyCollection(MeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...

class F1(MeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...

class General(MeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...

class MultiLabelPerformanceEvaluator(LearningPerformanceEvaluator[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]]): ...

class MultiTargetPerformanceEvaluator(LearningPerformanceEvaluator[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]]): ...

class OutlierPerformance(MeasureCollection):
    def __init__(self): ...
    def addTimePerObject(self, double: float) -> None: ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...

class PredictionIntervalPerformanceEvaluator(LearningPerformanceEvaluator[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]]): ...

class RegressionPerformanceEvaluator(LearningPerformanceEvaluator[moa.core.Example[com.yahoo.labs.samoa.instances.Instance]]): ...

class SSQ(MeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...
    def getNames(self) -> typing.MutableSequence[str]: ...

class Separation(MeasureCollection):
    def __init__(self): ...

class SilhouetteCoefficient(MeasureCollection):
    def __init__(self): ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...
    def getNames(self) -> typing.MutableSequence[str]: ...

class StatisticalCollection(MeasureCollection):
    def __init__(self): ...
    def cindex(self, clustering: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> float: ...
    def evaluateClustering(self, clustering: moa.cluster.Clustering, clustering2: moa.cluster.Clustering, arrayList: java.util.ArrayList[moa.gui.visualization.DataPoint]) -> None: ...

class ALClassificationPerformanceEvaluator(ClassificationPerformanceEvaluator):
    def doLabelAcqReport(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], int: int) -> None: ...

class BasicAUCImbalancedPerformanceEvaluator(moa.options.AbstractOptionHandler, ClassificationPerformanceEvaluator):
    calculateAUC: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getAucEstimator(self) -> 'BasicAUCImbalancedPerformanceEvaluator.Estimator': ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class Estimator:
        def __init__(self, basicAUCImbalancedPerformanceEvaluator: 'BasicAUCImbalancedPerformanceEvaluator', boolean: bool): ...
        def add(self, double: float, boolean: bool, boolean2: bool) -> None: ...
        def getAUC(self) -> float: ...
        def getAccuracy(self) -> float: ...
        def getGMean(self) -> float: ...
        def getKappa(self) -> float: ...
        def getRatio(self) -> float: ...
        def getRecall(self) -> float: ...
        def getScoredAUC(self) -> float: ...
        class Score(java.lang.Comparable['BasicAUCImbalancedPerformanceEvaluator.Estimator.Score']):
            def __init__(self, estimator: 'BasicAUCImbalancedPerformanceEvaluator.Estimator', double: float, int: int, boolean: bool): ...
            def compareTo(self, score: 'BasicAUCImbalancedPerformanceEvaluator.Estimator.Score') -> int: ...
            def equals(self, object: typing.Any) -> bool: ...
    class SimpleEstimator:
        def __init__(self, basicAUCImbalancedPerformanceEvaluator: 'BasicAUCImbalancedPerformanceEvaluator'): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...

class BasicMultiLabelPerformanceEvaluator(moa.AbstractMOAObject, MultiTargetPerformanceEvaluator):
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def reset(self) -> None: ...

class BasicMultiTargetPerformanceEvaluator(moa.AbstractMOAObject, MultiTargetPerformanceEvaluator, RegressionPerformanceEvaluator):
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def reset(self) -> None: ...

class BasicMultiTargetPerformanceRelativeMeasuresEvaluator(moa.AbstractMOAObject, MultiTargetPerformanceEvaluator, RegressionPerformanceEvaluator):
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def reset(self) -> None: ...

class BasicPredictionIntervalEvaluator(moa.AbstractMOAObject, PredictionIntervalPerformanceEvaluator):
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getCapabilities(self) -> moa.capabilities.Capabilities: ...
    def getCoverage(self) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getTargetMeanError(self) -> float: ...
    def getTargetSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def reset(self) -> None: ...

class BasicRegressionPerformanceEvaluator(moa.AbstractMOAObject, RegressionPerformanceEvaluator):
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getAdjustedCoefficientOfDetermination(self) -> float: ...
    def getCoefficientOfDetermination(self) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTargetMeanError(self) -> float: ...
    def getTargetSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def reset(self) -> None: ...

class MultiTargetWindowRegressionPerformanceEvaluator(moa.options.AbstractOptionHandler, MultiTargetPerformanceEvaluator, RegressionPerformanceEvaluator):
    widthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class Estimator:
        def __init__(self, multiTargetWindowRegressionPerformanceEvaluator: 'MultiTargetWindowRegressionPerformanceEvaluator', int: int): ...
        def add(self, double: float) -> None: ...
        def total(self) -> float: ...

class MultiTargetWindowRegressionPerformanceRelativeMeasuresEvaluator(moa.options.AbstractOptionHandler, MultiTargetPerformanceEvaluator, RegressionPerformanceEvaluator):
    widthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class Estimator:
        def __init__(self, multiTargetWindowRegressionPerformanceRelativeMeasuresEvaluator: 'MultiTargetWindowRegressionPerformanceRelativeMeasuresEvaluator', int: int): ...
        def add(self, double: float) -> None: ...
        def total(self) -> float: ...

class RegressionAccuracy(Accuracy):
    def __init__(self): ...
    def getNames(self) -> typing.MutableSequence[str]: ...

class WindowAUCImbalancedPerformanceEvaluator(moa.options.AbstractOptionHandler, ClassificationPerformanceEvaluator):
    widthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getAucEstimator(self) -> 'WindowAUCImbalancedPerformanceEvaluator.Estimator': ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class Estimator:
        def __init__(self, windowAUCImbalancedPerformanceEvaluator: 'WindowAUCImbalancedPerformanceEvaluator', int: int): ...
        def add(self, double: float, boolean: bool, boolean2: bool) -> None: ...
        def getAUC(self) -> float: ...
        def getAccuracy(self) -> float: ...
        def getGMean(self) -> float: ...
        def getHoldoutAUC(self) -> float: ...
        def getKappa(self) -> float: ...
        def getRatio(self) -> float: ...
        def getRecall(self) -> float: ...
        def getScoredAUC(self) -> float: ...
        class Score(java.lang.Comparable['WindowAUCImbalancedPerformanceEvaluator.Estimator.Score']):
            def __init__(self, estimator: 'WindowAUCImbalancedPerformanceEvaluator.Estimator', double: float, int: int, boolean: bool): ...
            def compareTo(self, score: 'WindowAUCImbalancedPerformanceEvaluator.Estimator.Score') -> int: ...
            def equals(self, object: typing.Any) -> bool: ...
    class SimpleEstimator:
        def __init__(self, windowAUCImbalancedPerformanceEvaluator: 'WindowAUCImbalancedPerformanceEvaluator'): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...

class WindowPredictionIntervalEvaluator(moa.options.AbstractOptionHandler, PredictionIntervalPerformanceEvaluator):
    widthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getAverageLength(self) -> float: ...
    def getCoverage(self) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getNMPIW(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class Estimator:
        def __init__(self, windowPredictionIntervalEvaluator: 'WindowPredictionIntervalEvaluator', int: int): ...
        def add(self, double: float) -> None: ...
        def max(self) -> float: ...
        def min(self) -> float: ...
        def total(self) -> float: ...

class WindowRegressionPerformanceEvaluator(moa.options.AbstractOptionHandler, RegressionPerformanceEvaluator):
    widthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def getAdjustedCoefficientOfDetermination(self) -> float: ...
    def getCoefficientOfDetermination(self) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getMeanError(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getSquareError(self) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    def prepareForUseImpl(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class Estimator:
        def __init__(self, windowRegressionPerformanceEvaluator: 'WindowRegressionPerformanceEvaluator', int: int): ...
        def add(self, double: float) -> None: ...
        def total(self) -> float: ...

class PredictionIntervalAccuracy(RegressionAccuracy):
    def __init__(self): ...
    def getNames(self) -> typing.MutableSequence[str]: ...

class ALWindowClassificationPerformanceEvaluator(moa.evaluation.WindowClassificationPerformanceEvaluator, ALClassificationPerformanceEvaluator):
    def __init__(self): ...
    def doLabelAcqReport(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], int: int) -> None: ...
    def getAbsNumOfAcqInst(self) -> int: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    def getRelNumOfAcqInst(self) -> float: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    @typing.overload
    def reset(self) -> None: ...

class AdwinClassificationPerformanceEvaluator(moa.evaluation.BasicClassificationPerformanceEvaluator):
    def __init__(self): ...
    class AdwinEstimator(moa.evaluation.BasicClassificationPerformanceEvaluator.Estimator):
        def __init__(self, adwinClassificationPerformanceEvaluator: 'AdwinClassificationPerformanceEvaluator'): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...

class BasicClassificationPerformanceEvaluator(moa.options.AbstractOptionHandler, ClassificationPerformanceEvaluator):
    precisionRecallOutputOption: com.github.javacliparser.FlagOption = ...
    precisionPerClassOption: com.github.javacliparser.FlagOption = ...
    recallPerClassOption: com.github.javacliparser.FlagOption = ...
    f1PerClassOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], prediction: com.yahoo.labs.samoa.instances.Prediction) -> None: ...
    @typing.overload
    def addResult(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def getF1Statistic(self) -> float: ...
    @typing.overload
    def getF1Statistic(self, int: int) -> float: ...
    def getFractionCorrectlyClassified(self) -> float: ...
    def getFractionIncorrectlyClassified(self) -> float: ...
    def getKappaStatistic(self) -> float: ...
    def getKappaTemporalStatistic(self) -> float: ...
    def getPerformanceMeasurements(self) -> typing.MutableSequence[moa.core.Measurement]: ...
    @typing.overload
    def getPrecisionStatistic(self) -> float: ...
    @typing.overload
    def getPrecisionStatistic(self, int: int) -> float: ...
    @typing.overload
    def getRecallStatistic(self) -> float: ...
    @typing.overload
    def getRecallStatistic(self, int: int) -> float: ...
    def getTotalWeightObserved(self) -> float: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, int: int) -> None: ...
    class BasicEstimator(moa.evaluation.BasicClassificationPerformanceEvaluator.Estimator):
        def __init__(self, basicClassificationPerformanceEvaluator: 'BasicClassificationPerformanceEvaluator'): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...
    class Estimator(java.io.Serializable):
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...

class EWMAClassificationPerformanceEvaluator(BasicClassificationPerformanceEvaluator):
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    class EWMAEstimator(BasicClassificationPerformanceEvaluator.Estimator):
        def __init__(self, eWMAClassificationPerformanceEvaluator: 'EWMAClassificationPerformanceEvaluator', double: float): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...

class FadingFactorClassificationPerformanceEvaluator(BasicClassificationPerformanceEvaluator):
    alphaOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    class FadingFactorEstimator(BasicClassificationPerformanceEvaluator.Estimator):
        def __init__(self, fadingFactorClassificationPerformanceEvaluator: 'FadingFactorClassificationPerformanceEvaluator', double: float): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...

class WindowClassificationPerformanceEvaluator(BasicClassificationPerformanceEvaluator):
    widthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    class WindowEstimator(BasicClassificationPerformanceEvaluator.Estimator):
        def __init__(self, windowClassificationPerformanceEvaluator: 'WindowClassificationPerformanceEvaluator', int: int): ...
        def add(self, double: float) -> None: ...
        def estimation(self) -> float: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.evaluation")``.

    ALClassificationPerformanceEvaluator: typing.Type[ALClassificationPerformanceEvaluator]
    ALMeasureCollection: typing.Type[ALMeasureCollection]
    ALWindowClassificationPerformanceEvaluator: typing.Type[ALWindowClassificationPerformanceEvaluator]
    Accuracy: typing.Type[Accuracy]
    AdwinClassificationPerformanceEvaluator: typing.Type[AdwinClassificationPerformanceEvaluator]
    BasicAUCImbalancedPerformanceEvaluator: typing.Type[BasicAUCImbalancedPerformanceEvaluator]
    BasicClassificationPerformanceEvaluator: typing.Type[BasicClassificationPerformanceEvaluator]
    BasicConceptDriftPerformanceEvaluator: typing.Type[BasicConceptDriftPerformanceEvaluator]
    BasicMultiLabelPerformanceEvaluator: typing.Type[BasicMultiLabelPerformanceEvaluator]
    BasicMultiTargetPerformanceEvaluator: typing.Type[BasicMultiTargetPerformanceEvaluator]
    BasicMultiTargetPerformanceRelativeMeasuresEvaluator: typing.Type[BasicMultiTargetPerformanceRelativeMeasuresEvaluator]
    BasicPredictionIntervalEvaluator: typing.Type[BasicPredictionIntervalEvaluator]
    BasicRegressionPerformanceEvaluator: typing.Type[BasicRegressionPerformanceEvaluator]
    CMM: typing.Type[CMM]
    CMM_GTAnalysis: typing.Type[CMM_GTAnalysis]
    ChangeDetectionMeasures: typing.Type[ChangeDetectionMeasures]
    ClassificationMeasureCollection: typing.Type[ClassificationMeasureCollection]
    ClassificationPerformanceEvaluator: typing.Type[ClassificationPerformanceEvaluator]
    EWMAClassificationPerformanceEvaluator: typing.Type[EWMAClassificationPerformanceEvaluator]
    EfficientEvaluationLoops: typing.Type[EfficientEvaluationLoops]
    EntropyCollection: typing.Type[EntropyCollection]
    F1: typing.Type[F1]
    FadingFactorClassificationPerformanceEvaluator: typing.Type[FadingFactorClassificationPerformanceEvaluator]
    General: typing.Type[General]
    LearningEvaluation: typing.Type[LearningEvaluation]
    LearningPerformanceEvaluator: typing.Type[LearningPerformanceEvaluator]
    MeasureCollection: typing.Type[MeasureCollection]
    MembershipMatrix: typing.Type[MembershipMatrix]
    MultiLabelPerformanceEvaluator: typing.Type[MultiLabelPerformanceEvaluator]
    MultiTargetPerformanceEvaluator: typing.Type[MultiTargetPerformanceEvaluator]
    MultiTargetWindowRegressionPerformanceEvaluator: typing.Type[MultiTargetWindowRegressionPerformanceEvaluator]
    MultiTargetWindowRegressionPerformanceRelativeMeasuresEvaluator: typing.Type[MultiTargetWindowRegressionPerformanceRelativeMeasuresEvaluator]
    OutlierPerformance: typing.Type[OutlierPerformance]
    PredictionIntervalAccuracy: typing.Type[PredictionIntervalAccuracy]
    PredictionIntervalPerformanceEvaluator: typing.Type[PredictionIntervalPerformanceEvaluator]
    RegressionAccuracy: typing.Type[RegressionAccuracy]
    RegressionPerformanceEvaluator: typing.Type[RegressionPerformanceEvaluator]
    SSQ: typing.Type[SSQ]
    Separation: typing.Type[Separation]
    SilhouetteCoefficient: typing.Type[SilhouetteCoefficient]
    StatisticalCollection: typing.Type[StatisticalCollection]
    WindowAUCImbalancedPerformanceEvaluator: typing.Type[WindowAUCImbalancedPerformanceEvaluator]
    WindowClassificationPerformanceEvaluator: typing.Type[WindowClassificationPerformanceEvaluator]
    WindowPredictionIntervalEvaluator: typing.Type[WindowPredictionIntervalEvaluator]
    WindowRegressionPerformanceEvaluator: typing.Type[WindowRegressionPerformanceEvaluator]
    preview: moa.evaluation.preview.__module_protocol__
