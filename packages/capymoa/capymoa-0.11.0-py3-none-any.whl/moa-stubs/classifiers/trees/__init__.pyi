
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import moa
import moa.capabilities
import moa.classifiers
import moa.classifiers.core
import moa.classifiers.core.conditionaltests
import moa.classifiers.core.splitcriteria
import moa.classifiers.trees.iadem
import moa.classifiers.trees.plastic_util
import moa.core
import moa.options
import typing



class DecisionStump(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier):
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    binarySplitsOption: com.github.javacliparser.FlagOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    def __init__(self): ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class PLASTIC(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier, moa.classifiers.trees.plastic_util.PerformsTreeRevision, moa.classifiers.trees.plastic_util.MeasuresNumberOfLeaves):
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    reEvalPeriodOption: com.github.javacliparser.IntOption = ...
    nominalEstimatorOption: moa.options.ClassOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    tieThresholdReevalOption: com.github.javacliparser.FloatOption = ...
    relMinDeltaG: com.github.javacliparser.FloatOption = ...
    binarySplitsOption: com.github.javacliparser.FlagOption = ...
    leafpredictionOption: com.github.javacliparser.MultiChoiceOption = ...
    maxDepthOption: com.github.javacliparser.IntOption = ...
    maxBranchLengthOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def didPerformTreeRevision(self) -> bool: ...
    def getLeafNumber(self) -> int: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class PLASTICA(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier, moa.capabilities.CapabilitiesHandler):
    baseLearnerOption: moa.options.ClassOption = ...
    confidenceOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class ARFFIMTDD(moa.classifiers.AbstractClassifier, moa.classifiers.Regressor):
    maxID: int = ...
    subspaceSizeOption: com.github.javacliparser.IntOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    PageHinckleyAlphaOption: com.github.javacliparser.FloatOption = ...
    PageHinckleyThresholdOption: com.github.javacliparser.IntOption = ...
    alternateTreeFadingFactorOption: com.github.javacliparser.FloatOption = ...
    alternateTreeTMinOption: com.github.javacliparser.IntOption = ...
    alternateTreeTimeOption: com.github.javacliparser.IntOption = ...
    learningRatioOption: com.github.javacliparser.FloatOption = ...
    learningRateDecayFactorOption: com.github.javacliparser.FloatOption = ...
    learningRatioConstOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def calcByteSize(self) -> int: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def computeSD(self, double: float, double2: float, double3: float) -> float: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getNormalizedError(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float) -> float: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def normalizeTargetValue(self, double: float) -> float: ...
    def processInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, node: 'ARFFIMTDD.Node', double: float, double2: float, boolean: bool, boolean2: bool) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def scalarProduct(self, doubleVector: moa.core.DoubleVector, doubleVector2: moa.core.DoubleVector) -> float: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class FIMTDDPerceptron(java.io.Serializable):
        @typing.overload
        def __init__(self, aRFFIMTDD: 'ARFFIMTDD', fIMTDDPerceptron: 'ARFFIMTDD.FIMTDDPerceptron'): ...
        @typing.overload
        def __init__(self, aRFFIMTDD: 'ARFFIMTDD', aRFFIMTDD2: 'ARFFIMTDD'): ...
        def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getPurposeString(self) -> str: ...
        def getWeights(self) -> moa.core.DoubleVector: ...
        def normalizedInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> moa.core.DoubleVector: ...
        def prediction(self, doubleVector: moa.core.DoubleVector) -> float: ...
        def updatePerceptron(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def updateWeights(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float) -> None: ...
    class InnerNode(moa.classifiers.trees.ARFFIMTDD.Node):
        def __init__(self, aRFFIMTDD: 'ARFFIMTDD'): ...
        def PageHinckleyTest(self, double: float, double2: float) -> bool: ...
        def disableChangeDetection(self) -> None: ...
        def getChild(self, int: int) -> 'ARFFIMTDD.Node': ...
        def getChildIndex(self, node: 'ARFFIMTDD.Node') -> int: ...
        def initializeAlternateTree(self) -> None: ...
        def numChildren(self) -> int: ...
        def restartChangeDetection(self) -> None: ...
        def setChild(self, int: int, node: 'ARFFIMTDD.Node') -> None: ...
    class LeafNode(moa.classifiers.trees.ARFFIMTDD.Node):
        learningModel: 'ARFFIMTDD.FIMTDDPerceptron' = ...
        def __init__(self, aRFFIMTDD: 'ARFFIMTDD', int: int): ...
        def checkForSplit(self, aRFFIMTDD: 'ARFFIMTDD') -> None: ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion) -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getChildIndex(self, node: 'ARFFIMTDD.Node') -> int: ...
        def getNumSubtrees(self) -> int: ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getPredictionModel(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getPredictionTargetMean(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, boolean: bool, aRFFIMTDD: 'ARFFIMTDD') -> None: ...
        def setChild(self, int: int, node: 'ARFFIMTDD.Node') -> None: ...
    class Node(moa.AbstractMOAObject):
        ID: int = ...
        def __init__(self, aRFFIMTDD: 'ARFFIMTDD'): ...
        def calcByteSize(self) -> int: ...
        def copyStatistics(self, node: 'ARFFIMTDD.Node') -> None: ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def disableChangeDetection(self) -> None: ...
        def getChildIndex(self, node: 'ARFFIMTDD.Node') -> int: ...
        def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getLevel(self) -> int: ...
        def getNumSubtrees(self) -> int: ...
        def getParent(self) -> 'ARFFIMTDD.Node': ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def restartChangeDetection(self) -> None: ...
        def setChild(self, int: int, node: 'ARFFIMTDD.Node') -> None: ...
        def setParent(self, node: 'ARFFIMTDD.Node') -> None: ...
    class SplitNode(moa.classifiers.trees.ARFFIMTDD.InnerNode):
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, aRFFIMTDD: 'ARFFIMTDD'): ...
        def descendOneStep(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'ARFFIMTDD.Node': ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...

class ARFHoeffdingTree(moa.classifiers.trees.HoeffdingTree):
    subspaceSizeOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def isRandomizable(self) -> bool: ...
    class LearningNodeNB(moa.classifiers.trees.ARFHoeffdingTree.RandomLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
    class LearningNodeNBAdaptive(moa.classifiers.trees.ARFHoeffdingTree.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...
    class RandomLearningNode(moa.classifiers.trees.HoeffdingTree.ActiveLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...

class ASHoeffdingTree(moa.classifiers.trees.HoeffdingTree):
    def __init__(self): ...
    def deleteNode(self, node: 'HoeffdingTree.Node', int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    def resetLearningImpl(self) -> None: ...
    def resizeTree(self, node: 'HoeffdingTree.Node', int: int) -> None: ...
    def setMaxSize(self, int: int) -> None: ...
    def setResetTree(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class AdaHoeffdingOptionTree(moa.classifiers.trees.HoeffdingOptionTree):
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    class AdaLearningNode(moa.classifiers.trees.HoeffdingOptionTree.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...

class EFDT(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier):
    reEvalPeriodOption: com.github.javacliparser.IntOption = ...
    maxByteSizeOption: com.github.javacliparser.IntOption = ...
    numericEstimatorOption: moa.options.ClassOption = ...
    nominalEstimatorOption: moa.options.ClassOption = ...
    memoryEstimatePeriodOption: com.github.javacliparser.IntOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    binarySplitsOption: com.github.javacliparser.FlagOption = ...
    stopMemManagementOption: com.github.javacliparser.FlagOption = ...
    removePoorAttsOption: com.github.javacliparser.FlagOption = ...
    noPrePruneOption: com.github.javacliparser.FlagOption = ...
    leafpredictionOption: com.github.javacliparser.MultiChoiceOption = ...
    nbThresholdOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def calcByteSize(self) -> int: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def deactivateAllLeaves(self) -> None: ...
    def enforceTrackerLimit(self) -> None: ...
    def estimateModelByteSizes(self) -> None: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    @typing.overload
    def measureByteSize(self) -> int: ...
    @typing.overload
    @staticmethod
    def measureByteSize(mOAObject: moa.MOAObject) -> int: ...
    def measureTreeDepth(self) -> int: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class ActiveLearningNode(moa.classifiers.trees.EFDT.LearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def disableAttribute(self, int: int) -> None: ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, eFDT: 'EFDT') -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getWeightSeen(self) -> float: ...
        def getWeightSeenAtLastSplitEvaluation(self) -> float: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> None: ...
        def setWeightSeenAtLastSplitEvaluation(self, double: float) -> None: ...
    class EFDTLearningNode(moa.classifiers.trees.EFDT.LearningNodeNBAdaptive, moa.classifiers.trees.EFDT.EFDTNode):
        def __init__(self, eFDT: 'EFDT', doubleArray: typing.Union[typing.List[float], jpype.JArray], string: str): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> typing.MutableSequence[float]: ...
        def getParent(self) -> 'EFDT.EFDTSplitNode': ...
        def isRoot(self) -> bool: ...
        @typing.overload
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> None: ...
        @typing.overload
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT', eFDTSplitNode: 'EFDT.EFDTSplitNode', int: int) -> None: ...
        def setParent(self, eFDTSplitNode: 'EFDT.EFDTSplitNode') -> None: ...
        def setRoot(self, boolean: bool) -> None: ...
    class EFDTNode:
        def getParent(self) -> 'EFDT.EFDTSplitNode': ...
        def isRoot(self) -> bool: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT', eFDTSplitNode: 'EFDT.EFDTSplitNode', int: int) -> None: ...
        def setParent(self, eFDTSplitNode: 'EFDT.EFDTSplitNode') -> None: ...
        def setRoot(self, boolean: bool) -> None: ...
    class EFDTSplitNode(moa.classifiers.trees.EFDT.SplitNode, moa.classifiers.trees.EFDT.EFDTNode):
        @typing.overload
        def __init__(self, eFDT: 'EFDT', instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        @typing.overload
        def __init__(self, eFDT: 'EFDT', instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, eFDT: 'EFDT') -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getParent(self) -> 'EFDT.EFDTSplitNode': ...
        def isRoot(self) -> bool: ...
        def killSubtree(self, eFDT: 'EFDT') -> None: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT', eFDTSplitNode: 'EFDT.EFDTSplitNode', int: int) -> None: ...
        def setParent(self, eFDTSplitNode: 'EFDT.EFDTSplitNode') -> None: ...
        def setRoot(self, boolean: bool) -> None: ...
    class FoundNode:
        node: 'EFDT.Node' = ...
        parent: 'EFDT.SplitNode' = ...
        parentBranch: int = ...
        def __init__(self, node: 'EFDT.Node', splitNode: 'EFDT.SplitNode', int: int): ...
    class InactiveLearningNode(moa.classifiers.trees.EFDT.LearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> None: ...
    class LearningNode(moa.classifiers.trees.EFDT.Node):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> None: ...
    class LearningNodeNB(moa.classifiers.trees.EFDT.ActiveLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> typing.MutableSequence[float]: ...
    class LearningNodeNBAdaptive(moa.classifiers.trees.EFDT.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> None: ...
    class Node(moa.AbstractMOAObject):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def addToSplitAttempts(self, int: int) -> None: ...
        def calcByteSize(self) -> int: ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def calculatePromise(self) -> float: ...
        def describeSubtree(self, eFDT: 'EFDT', stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def filterInstanceToLeaf(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'EFDT.SplitNode', int: int) -> 'EFDT.FoundNode': ...
        def getClassDistributionAtTimeOfCreation(self) -> typing.MutableSequence[float]: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, eFDT: 'EFDT') -> typing.MutableSequence[float]: ...
        def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getInfogainSum(self) -> java.util.HashMap[int, float]: ...
        def getNumSplitAttempts(self) -> int: ...
        def getObservedClassDistribution(self) -> typing.MutableSequence[float]: ...
        def isLeaf(self) -> bool: ...
        def observedClassDistributionIsPure(self) -> bool: ...
        def setInfogainSum(self, hashMap: java.util.HashMap[int, float]) -> None: ...
        def subtreeDepth(self) -> int: ...
    class SplitNode(moa.classifiers.trees.EFDT.Node):
        @typing.overload
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        @typing.overload
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def calcByteSize(self) -> int: ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def describeSubtree(self, eFDT: 'EFDT', stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def filterInstanceToLeaf(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'EFDT.SplitNode', int: int) -> 'EFDT.FoundNode': ...
        def getChild(self, int: int) -> 'EFDT.Node': ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
        def isLeaf(self) -> bool: ...
        def numChildren(self) -> int: ...
        def setChild(self, int: int, node: 'EFDT.Node') -> None: ...
        def subtreeDepth(self) -> int: ...

class FIMTDD(moa.classifiers.AbstractClassifier, moa.classifiers.Regressor):
    maxID: int = ...
    splitCriterionOption: moa.options.ClassOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    PageHinckleyAlphaOption: com.github.javacliparser.FloatOption = ...
    PageHinckleyThresholdOption: com.github.javacliparser.IntOption = ...
    alternateTreeFadingFactorOption: com.github.javacliparser.FloatOption = ...
    alternateTreeTMinOption: com.github.javacliparser.IntOption = ...
    alternateTreeTimeOption: com.github.javacliparser.IntOption = ...
    regressionTreeOption: com.github.javacliparser.FlagOption = ...
    learningRatioOption: com.github.javacliparser.FloatOption = ...
    learningRateDecayFactorOption: com.github.javacliparser.FloatOption = ...
    learningRatioConstOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def buildingModelTree(self) -> bool: ...
    def calcByteSize(self) -> int: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def computeSD(self, double: float, double2: float, double3: float) -> float: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getNormalizedError(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float) -> float: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def normalizeTargetValue(self, double: float) -> float: ...
    def processInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, node: 'FIMTDD.Node', double: float, double2: float, boolean: bool, boolean2: bool) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def scalarProduct(self, doubleVector: moa.core.DoubleVector, doubleVector2: moa.core.DoubleVector) -> float: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class FIMTDDPerceptron(java.io.Serializable):
        @typing.overload
        def __init__(self, fIMTDD: 'FIMTDD', fIMTDDPerceptron: 'FIMTDD.FIMTDDPerceptron'): ...
        @typing.overload
        def __init__(self, fIMTDD: 'FIMTDD', fIMTDD2: 'FIMTDD'): ...
        def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getPurposeString(self) -> str: ...
        def getWeights(self) -> moa.core.DoubleVector: ...
        def normalizedInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> moa.core.DoubleVector: ...
        def prediction(self, doubleVector: moa.core.DoubleVector) -> float: ...
        def updatePerceptron(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def updateWeights(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float) -> None: ...
    class InnerNode(moa.classifiers.trees.FIMTDD.Node):
        def __init__(self, fIMTDD: 'FIMTDD'): ...
        def PageHinckleyTest(self, double: float, double2: float) -> bool: ...
        def disableChangeDetection(self) -> None: ...
        def getChild(self, int: int) -> 'FIMTDD.Node': ...
        def getChildIndex(self, node: 'FIMTDD.Node') -> int: ...
        def initializeAlternateTree(self) -> None: ...
        def numChildren(self) -> int: ...
        def restartChangeDetection(self) -> None: ...
        def setChild(self, int: int, node: 'FIMTDD.Node') -> None: ...
    class LeafNode(moa.classifiers.trees.FIMTDD.Node):
        learningModel: 'FIMTDD.FIMTDDPerceptron' = ...
        def __init__(self, fIMTDD: 'FIMTDD'): ...
        def checkForSplit(self, fIMTDD: 'FIMTDD') -> None: ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion) -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getChildIndex(self, node: 'FIMTDD.Node') -> int: ...
        def getNumSubtrees(self) -> int: ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getPredictionModel(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getPredictionTargetMean(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, boolean: bool) -> None: ...
        def setChild(self, int: int, node: 'FIMTDD.Node') -> None: ...
    class Node(moa.AbstractMOAObject):
        ID: int = ...
        def __init__(self, fIMTDD: 'FIMTDD'): ...
        def calcByteSize(self) -> int: ...
        def copyStatistics(self, node: 'FIMTDD.Node') -> None: ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def disableChangeDetection(self) -> None: ...
        def getChildIndex(self, node: 'FIMTDD.Node') -> int: ...
        def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getLevel(self) -> int: ...
        def getNumSubtrees(self) -> int: ...
        def getParent(self) -> 'FIMTDD.Node': ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def restartChangeDetection(self) -> None: ...
        def setChild(self, int: int, node: 'FIMTDD.Node') -> None: ...
        def setParent(self, node: 'FIMTDD.Node') -> None: ...
    class SplitNode(moa.classifiers.trees.FIMTDD.InnerNode):
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, fIMTDD: 'FIMTDD'): ...
        def descendOneStep(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'FIMTDD.Node': ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...

class HoeffdingAdaptiveTree(moa.classifiers.trees.HoeffdingTree):
    def __init__(self): ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingTree.SplitNode', int: int, boolean: bool) -> typing.MutableSequence['HoeffdingTree.FoundNode']: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class AdaLearningNode(moa.classifiers.trees.HoeffdingTree.LearningNodeNBAdaptive, moa.classifiers.trees.HoeffdingAdaptiveTree.NewNode):
        ErrorChange: bool = ...
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingTree.SplitNode', int: int, list: java.util.List['HoeffdingTree.FoundNode'], boolean: bool) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
        def getErrorEstimation(self) -> float: ...
        def getErrorWidth(self) -> float: ...
        def isNullError(self) -> bool: ...
        def killTreeChilds(self, hoeffdingAdaptiveTree: 'HoeffdingAdaptiveTree') -> None: ...
        @typing.overload
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingAdaptiveTree: 'HoeffdingAdaptiveTree', splitNode: 'HoeffdingTree.SplitNode', int: int) -> None: ...
        @typing.overload
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...
        def numberLeaves(self) -> int: ...
    class AdaSplitNode(moa.classifiers.trees.HoeffdingTree.SplitNode, moa.classifiers.trees.HoeffdingAdaptiveTree.NewNode):
        ErrorChange: bool = ...
        @typing.overload
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        @typing.overload
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingTree.SplitNode', int: int, list: java.util.List['HoeffdingTree.FoundNode'], boolean: bool) -> None: ...
        def getErrorEstimation(self) -> float: ...
        def getErrorWidth(self) -> float: ...
        def isNullError(self) -> bool: ...
        def killTreeChilds(self, hoeffdingAdaptiveTree: 'HoeffdingAdaptiveTree') -> None: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingAdaptiveTree: 'HoeffdingAdaptiveTree', splitNode: 'HoeffdingTree.SplitNode', int: int) -> None: ...
        def numberLeaves(self) -> int: ...
    class NewNode:
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingTree.SplitNode', int: int, list: java.util.List['HoeffdingTree.FoundNode'], boolean: bool) -> None: ...
        def getErrorEstimation(self) -> float: ...
        def getErrorWidth(self) -> float: ...
        def isNullError(self) -> bool: ...
        def killTreeChilds(self, hoeffdingAdaptiveTree: 'HoeffdingAdaptiveTree') -> None: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingAdaptiveTree: 'HoeffdingAdaptiveTree', splitNode: 'HoeffdingTree.SplitNode', int: int) -> None: ...
        def numberLeaves(self) -> int: ...

class HoeffdingAdaptiveTreeClassifLeaves(HoeffdingAdaptiveTree):
    leaveLearnerOption: moa.options.ClassOption = ...
    def __init__(self): ...
    class LearningNodeHATClassifier(HoeffdingAdaptiveTree.AdaLearningNode):
        @typing.overload
        def __init__(self, hoeffdingAdaptiveTreeClassifLeaves: 'HoeffdingAdaptiveTreeClassifLeaves', doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        @typing.overload
        def __init__(self, hoeffdingAdaptiveTreeClassifLeaves: 'HoeffdingAdaptiveTreeClassifLeaves', doubleArray: typing.Union[typing.List[float], jpype.JArray], classifier: moa.classifiers.Classifier, hoeffdingAdaptiveTreeClassifLeaves2: 'HoeffdingAdaptiveTreeClassifLeaves'): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
        def getClassifier(self) -> moa.classifiers.Classifier: ...
        @typing.overload
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingAdaptiveTree: HoeffdingAdaptiveTree, splitNode: 'HoeffdingTree.SplitNode', int: int) -> None: ...
        @typing.overload
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...

class HoeffdingOptionTree(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier, moa.capabilities.CapabilitiesHandler):
    maxOptionPathsOption: com.github.javacliparser.IntOption = ...
    maxByteSizeOption: com.github.javacliparser.IntOption = ...
    numericEstimatorOption: moa.options.ClassOption = ...
    nominalEstimatorOption: moa.options.ClassOption = ...
    memoryEstimatePeriodOption: com.github.javacliparser.IntOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    secondarySplitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    binarySplitsOption: com.github.javacliparser.FlagOption = ...
    removePoorAttsOption: com.github.javacliparser.FlagOption = ...
    noPrePruneOption: com.github.javacliparser.FlagOption = ...
    dumpFileOption: com.github.javacliparser.FileOption = ...
    memoryStrategyOption: com.github.javacliparser.IntOption = ...
    leafpredictionOption: com.github.javacliparser.MultiChoiceOption = ...
    nbThresholdOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def calcByteSize(self) -> int: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def deactivateAllLeaves(self) -> None: ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def enforceTrackerLimit(self) -> None: ...
    def estimateModelByteSizes(self) -> None: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    @typing.overload
    def measureByteSize(self) -> int: ...
    @typing.overload
    @staticmethod
    def measureByteSize(mOAObject: moa.MOAObject) -> int: ...
    def measureTreeDepth(self) -> int: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class ActiveLearningNode(moa.classifiers.trees.HoeffdingOptionTree.LearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def disableAttribute(self, int: int) -> None: ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, hoeffdingOptionTree: 'HoeffdingOptionTree') -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getWeightSeen(self) -> float: ...
        def getWeightSeenAtLastSplitEvaluation(self) -> float: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...
        def setWeightSeenAtLastSplitEvaluation(self, double: float) -> None: ...
    class FoundNode:
        node: 'HoeffdingOptionTree.Node' = ...
        parent: 'HoeffdingOptionTree.SplitNode' = ...
        parentBranch: int = ...
        def __init__(self, node: 'HoeffdingOptionTree.Node', splitNode: 'HoeffdingOptionTree.SplitNode', int: int): ...
    class InactiveLearningNode(moa.classifiers.trees.HoeffdingOptionTree.LearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...
    class LearningNode(moa.classifiers.trees.HoeffdingOptionTree.Node):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...
    class LearningNodeNB(moa.classifiers.trees.HoeffdingOptionTree.ActiveLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> typing.MutableSequence[float]: ...
    class LearningNodeNBAdaptive(moa.classifiers.trees.HoeffdingOptionTree.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...
    class Node(moa.AbstractMOAObject):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def calculatePromise(self) -> float: ...
        def describeSubtree(self, hoeffdingOptionTree: 'HoeffdingOptionTree', stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        @typing.overload
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingOptionTree.SplitNode', int: int, boolean: bool) -> typing.MutableSequence['HoeffdingOptionTree.FoundNode']: ...
        @typing.overload
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingOptionTree.SplitNode', int: int, list: java.util.List['HoeffdingOptionTree.FoundNode'], boolean: bool) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingOptionTree: 'HoeffdingOptionTree') -> typing.MutableSequence[float]: ...
        def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getObservedClassDistribution(self) -> typing.MutableSequence[float]: ...
        def isLeaf(self) -> bool: ...
        def observedClassDistributionIsPure(self) -> bool: ...
        def subtreeDepth(self) -> int: ...
    class SplitNode(moa.classifiers.trees.HoeffdingOptionTree.Node):
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def computeMeritOfExistingSplit(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
        def describeSubtree(self, hoeffdingOptionTree: 'HoeffdingOptionTree', stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        @typing.overload
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingOptionTree.SplitNode', int: int, boolean: bool) -> typing.MutableSequence['HoeffdingOptionTree.FoundNode']: ...
        @typing.overload
        def filterInstanceToLeaves(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingOptionTree.SplitNode', int: int, list: java.util.List['HoeffdingOptionTree.FoundNode'], boolean: bool) -> None: ...
        def getChild(self, int: int) -> 'HoeffdingOptionTree.Node': ...
        def getHeadOptionCount(self) -> int: ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
        def isLeaf(self) -> bool: ...
        def numChildren(self) -> int: ...
        def setChild(self, int: int, node: 'HoeffdingOptionTree.Node') -> None: ...
        def subtreeDepth(self) -> int: ...
        def updateOptionCount(self, splitNode: 'HoeffdingOptionTree.SplitNode', hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...
        def updateOptionCountBelow(self, int: int, hoeffdingOptionTree: 'HoeffdingOptionTree') -> None: ...

class HoeffdingTree(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier, moa.capabilities.CapabilitiesHandler):
    maxByteSizeOption: com.github.javacliparser.IntOption = ...
    numericEstimatorOption: moa.options.ClassOption = ...
    nominalEstimatorOption: moa.options.ClassOption = ...
    memoryEstimatePeriodOption: com.github.javacliparser.IntOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    binarySplitsOption: com.github.javacliparser.FlagOption = ...
    stopMemManagementOption: com.github.javacliparser.FlagOption = ...
    removePoorAttsOption: com.github.javacliparser.FlagOption = ...
    noPrePruneOption: com.github.javacliparser.FlagOption = ...
    leafpredictionOption: com.github.javacliparser.MultiChoiceOption = ...
    nbThresholdOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    def calcByteSize(self) -> int: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def deactivateAllLeaves(self) -> None: ...
    def defineImmutableCapabilities(self) -> moa.capabilities.ImmutableCapabilities: ...
    def enforceTrackerLimit(self) -> None: ...
    def estimateModelByteSizes(self) -> None: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getNodeCount(self) -> int: ...
    def getPurposeString(self) -> str: ...
    def getTreeRoot(self) -> 'HoeffdingTree.Node': ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    @typing.overload
    def measureByteSize(self) -> int: ...
    @typing.overload
    @staticmethod
    def measureByteSize(mOAObject: moa.MOAObject) -> int: ...
    def measureTreeDepth(self) -> int: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class ActiveLearningNode(moa.classifiers.trees.HoeffdingTree.LearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def disableAttribute(self, int: int) -> None: ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getWeightSeen(self) -> float: ...
        def getWeightSeenAtLastSplitEvaluation(self) -> float: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...
        def setWeightSeenAtLastSplitEvaluation(self, double: float) -> None: ...
    class FoundNode:
        node: 'HoeffdingTree.Node' = ...
        parent: 'HoeffdingTree.SplitNode' = ...
        parentBranch: int = ...
        def __init__(self, node: 'HoeffdingTree.Node', splitNode: 'HoeffdingTree.SplitNode', int: int): ...
    class InactiveLearningNode(moa.classifiers.trees.HoeffdingTree.LearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...
    class LearningNode(moa.classifiers.trees.HoeffdingTree.Node):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...
    class LearningNodeNB(moa.classifiers.trees.HoeffdingTree.ActiveLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
    class LearningNodeNBAdaptive(moa.classifiers.trees.HoeffdingTree.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> None: ...
    class Node(moa.AbstractMOAObject):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def calcByteSize(self) -> int: ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def calculatePromise(self) -> float: ...
        def describeSubtree(self, hoeffdingTree: 'HoeffdingTree', stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def filterInstanceToLeaf(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingTree.SplitNode', int: int) -> 'HoeffdingTree.FoundNode': ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: 'HoeffdingTree') -> typing.MutableSequence[float]: ...
        def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getObservedClassDistribution(self) -> typing.MutableSequence[float]: ...
        def getObservedClassDistributionAtLeavesReachableThroughThisNode(self) -> typing.MutableSequence[float]: ...
        def isLeaf(self) -> bool: ...
        def observedClassDistributionIsPure(self) -> bool: ...
        def subtreeDepth(self) -> int: ...
    class SplitNode(moa.classifiers.trees.HoeffdingTree.Node):
        @typing.overload
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        @typing.overload
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int): ...
        def calcByteSize(self) -> int: ...
        def calcByteSizeIncludingSubtree(self) -> int: ...
        def describeSubtree(self, hoeffdingTree: 'HoeffdingTree', stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def filterInstanceToLeaf(self, instance: com.yahoo.labs.samoa.instances.Instance, splitNode: 'HoeffdingTree.SplitNode', int: int) -> 'HoeffdingTree.FoundNode': ...
        def getChild(self, int: int) -> 'HoeffdingTree.Node': ...
        def getChildren(self) -> moa.core.AutoExpandVector['HoeffdingTree.Node']: ...
        def getObservedClassDistributionAtLeavesReachableThroughThisNode(self) -> typing.MutableSequence[float]: ...
        def getSplitTest(self) -> moa.classifiers.core.conditionaltests.InstanceConditionalTest: ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
        def isLeaf(self) -> bool: ...
        def numChildren(self) -> int: ...
        def setChild(self, int: int, node: 'HoeffdingTree.Node') -> None: ...
        def subtreeDepth(self) -> int: ...

class HoeffdingTreeClassifLeaves(HoeffdingTree):
    learnerOption: moa.options.ClassOption = ...
    def __init__(self): ...
    class LearningNodeClassifier(HoeffdingTree.ActiveLearningNode):
        @typing.overload
        def __init__(self, hoeffdingTreeClassifLeaves: 'HoeffdingTreeClassifLeaves', doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        @typing.overload
        def __init__(self, hoeffdingTreeClassifLeaves: 'HoeffdingTreeClassifLeaves', doubleArray: typing.Union[typing.List[float], jpype.JArray], classifier: moa.classifiers.Classifier, hoeffdingTreeClassifLeaves2: 'HoeffdingTreeClassifLeaves'): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> typing.MutableSequence[float]: ...
        def getClassifier(self) -> moa.classifiers.Classifier: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> None: ...

class LimAttHoeffdingTree(HoeffdingTree):
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def isRandomizable(self) -> bool: ...
    def setlistAttributes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    class LearningNodeNB(moa.classifiers.trees.LimAttHoeffdingTree.LimAttLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> typing.MutableSequence[float]: ...
    class LearningNodeNBAdaptive(moa.classifiers.trees.LimAttHoeffdingTree.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> None: ...
    class LimAttLearningNode(HoeffdingTree.ActiveLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> None: ...
        def setlistAttributes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...

class ORTO(FIMTDD, moa.classifiers.Regressor):
    maxTreesOption: com.github.javacliparser.IntOption = ...
    maxOptionLevelOption: com.github.javacliparser.IntOption = ...
    optionDecayFactorOption: com.github.javacliparser.FloatOption = ...
    optionNodeAggregationOption: com.github.javacliparser.MultiChoiceOption = ...
    optionFadingFactorOption: com.github.javacliparser.FloatOption = ...
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def processInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, node: FIMTDD.Node, double: float, double2: float, boolean: bool, boolean2: bool) -> None: ...
    def processInstanceOptionNode(self, instance: com.yahoo.labs.samoa.instances.Instance, optionNode: 'ORTO.OptionNode', double: float, double2: float, boolean: bool, boolean2: bool) -> None: ...
    def resetLearningImpl(self) -> None: ...
    class OptionNode(FIMTDD.InnerNode):
        def __init__(self, fIMTDD: FIMTDD): ...
        def directionForBestTree(self) -> int: ...
        def getFFRatio(self, int: int) -> float: ...
        def getNumSubtrees(self) -> int: ...
        @typing.overload
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        @typing.overload
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance, oRTO: 'ORTO') -> float: ...
        def resetFF(self) -> None: ...

class RandomHoeffdingTree(HoeffdingTree):
    def __init__(self): ...
    def getPurposeString(self) -> str: ...
    def isRandomizable(self) -> bool: ...
    class LearningNodeNB(moa.classifiers.trees.RandomHoeffdingTree.RandomLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def disableAttribute(self, int: int) -> None: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> typing.MutableSequence[float]: ...
    class LearningNodeNBAdaptive(moa.classifiers.trees.RandomHoeffdingTree.LearningNodeNB):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> None: ...
    class RandomLearningNode(HoeffdingTree.ActiveLearningNode):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, hoeffdingTree: HoeffdingTree) -> None: ...

class SelfOptimisingBaseTree(moa.classifiers.AbstractClassifier, moa.classifiers.Regressor):
    maxID: int = ...
    leafNodes: java.util.ArrayList = ...
    subspaceSizeOption: com.github.javacliparser.IntOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    PageHinckleyAlphaOption: com.github.javacliparser.FloatOption = ...
    PageHinckleyThresholdOption: com.github.javacliparser.IntOption = ...
    alternateTreeFadingFactorOption: com.github.javacliparser.FloatOption = ...
    alternateTreeTMinOption: com.github.javacliparser.IntOption = ...
    alternateTreeTimeOption: com.github.javacliparser.IntOption = ...
    learningRatioOption: com.github.javacliparser.FloatOption = ...
    learningRateDecayFactorOption: com.github.javacliparser.FloatOption = ...
    learningRatioConstOption: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def calcByteSize(self) -> int: ...
    @staticmethod
    def computeHoeffdingBound(double: float, double2: float, double3: float) -> float: ...
    def computeSD(self, double: float, double2: float, double3: float) -> float: ...
    def getLeafForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, node: 'SelfOptimisingBaseTree.Node') -> 'SelfOptimisingBaseTree.Node': ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getNormalizedError(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float) -> float: ...
    def getPurposeString(self) -> str: ...
    def getTreeRoot(self) -> 'SelfOptimisingBaseTree.Node': ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def normalizeTargetValue(self, double: float) -> float: ...
    def processInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, node: 'SelfOptimisingBaseTree.Node', double: float, double2: float, boolean: bool, boolean2: bool) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def scalarProduct(self, doubleVector: moa.core.DoubleVector, doubleVector2: moa.core.DoubleVector) -> float: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class FIMTDDPerceptron(java.io.Serializable):
        @typing.overload
        def __init__(self, selfOptimisingBaseTree: 'SelfOptimisingBaseTree', fIMTDDPerceptron: 'SelfOptimisingBaseTree.FIMTDDPerceptron'): ...
        @typing.overload
        def __init__(self, selfOptimisingBaseTree: 'SelfOptimisingBaseTree', selfOptimisingBaseTree2: 'SelfOptimisingBaseTree'): ...
        def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getPurposeString(self) -> str: ...
        def getWeights(self) -> moa.core.DoubleVector: ...
        def normalizedInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> moa.core.DoubleVector: ...
        def prediction(self, doubleVector: moa.core.DoubleVector) -> float: ...
        def updatePerceptron(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def updateWeights(self, instance: com.yahoo.labs.samoa.instances.Instance, double: float) -> None: ...
    class InnerNode(moa.classifiers.trees.SelfOptimisingBaseTree.Node):
        def __init__(self, selfOptimisingBaseTree: 'SelfOptimisingBaseTree'): ...
        def PageHinckleyTest(self, double: float, double2: float) -> bool: ...
        def disableChangeDetection(self) -> None: ...
        def getChild(self, int: int) -> 'SelfOptimisingBaseTree.Node': ...
        def getChildIndex(self, node: 'SelfOptimisingBaseTree.Node') -> int: ...
        def initializeAlternateTree(self) -> None: ...
        def numChildren(self) -> int: ...
        def restartChangeDetection(self) -> None: ...
        def setChild(self, int: int, node: 'SelfOptimisingBaseTree.Node') -> None: ...
    class LeafNode(moa.classifiers.trees.SelfOptimisingBaseTree.Node):
        learningModel: 'SelfOptimisingBaseTree.FIMTDDPerceptron' = ...
        sumsForAllAttrs: typing.MutableSequence[float] = ...
        learntInstances: float = ...
        def __init__(self, selfOptimisingBaseTree: 'SelfOptimisingBaseTree', int: int): ...
        def checkForSplit(self, selfOptimisingBaseTree: 'SelfOptimisingBaseTree') -> None: ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getBestSplitSuggestions(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion) -> typing.MutableSequence[moa.classifiers.core.AttributeSplitSuggestion]: ...
        def getChildIndex(self, node: 'SelfOptimisingBaseTree.Node') -> int: ...
        def getNumSubtrees(self) -> int: ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getPredictionModel(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getPredictionTargetMean(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance, boolean: bool, selfOptimisingBaseTree: 'SelfOptimisingBaseTree', leafNode: 'SelfOptimisingBaseTree.LeafNode') -> None: ...
        def setChild(self, int: int, node: 'SelfOptimisingBaseTree.Node') -> None: ...
    class Node(moa.AbstractMOAObject):
        ID: int = ...
        def __init__(self, selfOptimisingBaseTree: 'SelfOptimisingBaseTree'): ...
        def calcByteSize(self) -> int: ...
        def copyStatistics(self, node: 'SelfOptimisingBaseTree.Node') -> None: ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def disableChangeDetection(self) -> None: ...
        def getChildIndex(self, node: 'SelfOptimisingBaseTree.Node') -> int: ...
        def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getLevel(self) -> int: ...
        def getNumSubtrees(self) -> int: ...
        def getParent(self) -> 'SelfOptimisingBaseTree.Node': ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def restartChangeDetection(self) -> None: ...
        def setChild(self, int: int, node: 'SelfOptimisingBaseTree.Node') -> None: ...
        def setParent(self, node: 'SelfOptimisingBaseTree.Node') -> None: ...
    class SplitNode(moa.classifiers.trees.SelfOptimisingBaseTree.InnerNode):
        def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, selfOptimisingBaseTree: 'SelfOptimisingBaseTree'): ...
        def descendOneStep(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'SelfOptimisingBaseTree.Node': ...
        def describeSubtree(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
        def getPrediction(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.trees")``.

    ARFFIMTDD: typing.Type[ARFFIMTDD]
    ARFHoeffdingTree: typing.Type[ARFHoeffdingTree]
    ASHoeffdingTree: typing.Type[ASHoeffdingTree]
    AdaHoeffdingOptionTree: typing.Type[AdaHoeffdingOptionTree]
    DecisionStump: typing.Type[DecisionStump]
    EFDT: typing.Type[EFDT]
    FIMTDD: typing.Type[FIMTDD]
    HoeffdingAdaptiveTree: typing.Type[HoeffdingAdaptiveTree]
    HoeffdingAdaptiveTreeClassifLeaves: typing.Type[HoeffdingAdaptiveTreeClassifLeaves]
    HoeffdingOptionTree: typing.Type[HoeffdingOptionTree]
    HoeffdingTree: typing.Type[HoeffdingTree]
    HoeffdingTreeClassifLeaves: typing.Type[HoeffdingTreeClassifLeaves]
    LimAttHoeffdingTree: typing.Type[LimAttHoeffdingTree]
    ORTO: typing.Type[ORTO]
    PLASTIC: typing.Type[PLASTIC]
    PLASTICA: typing.Type[PLASTICA]
    RandomHoeffdingTree: typing.Type[RandomHoeffdingTree]
    SelfOptimisingBaseTree: typing.Type[SelfOptimisingBaseTree]
    iadem: moa.classifiers.trees.iadem.__module_protocol__
    plastic_util: moa.classifiers.trees.plastic_util.__module_protocol__
