
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import moa
import moa.classifiers
import moa.classifiers.core
import moa.classifiers.core.attributeclassobservers
import moa.classifiers.core.conditionaltests
import moa.classifiers.core.driftdetection
import moa.classifiers.core.splitcriteria
import moa.core
import moa.options
import typing



class IademAttributeSplitSuggestion(moa.classifiers.core.AttributeSplitSuggestion):
    def __init__(self, instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], double2: float, double3: float): ...
    def getMeritLowerBound(self) -> float: ...

class IademCommonProcedures(java.io.Serializable):
    def __init__(self, double: float): ...
    @staticmethod
    def AverageComparitionByHoeffdingCorollary(double: float, double2: float, double3: float) -> float: ...
    @staticmethod
    def computeBound(double: float, double2: float) -> float: ...
    @staticmethod
    def computeLevel(arrayList: java.util.ArrayList[float], arrayList2: java.util.ArrayList[int], double: float) -> float: ...
    @staticmethod
    def getConfidence() -> float: ...
    @staticmethod
    def getIADEM_HoeffdingBound(double: float, double2: float) -> float: ...
    @staticmethod
    def insertLotsHoles(arrayList: java.util.ArrayList[float], arrayList2: java.util.ArrayList[int], double: float, double2: float) -> None: ...
    @staticmethod
    def log(double: float, double2: float) -> float: ...
    @staticmethod
    def setConfidence(double: float) -> None: ...

class IademException(java.lang.Exception, java.io.Serializable):
    def __init__(self, string: str, string2: str, string3: str): ...
    def getMessage(self) -> str: ...

class IademGreenwaldKhannaQuantileSummary(moa.core.GreenwaldKhannaQuantileSummary):
    def __init__(self, int: int): ...
    def findIndexOfTupleGreaterThan(self, double: float) -> int: ...
    def maxNumberOfObservation(self, int: int) -> int: ...

class IademNominalAttributeBinaryTest(moa.classifiers.core.conditionaltests.NominalAttributeBinaryTest):
    def __init__(self, int: int, int2: int): ...
    def getAttValue(self) -> int: ...

class IademNominalAttributeMultiwayTest(moa.classifiers.core.conditionaltests.NominalAttributeMultiwayTest):
    def __init__(self, int: int, int2: int): ...
    def maxBranches(self) -> int: ...

class IademNumericAttributeBinaryTest(moa.classifiers.core.conditionaltests.NumericAttributeBinaryTest):
    def __init__(self, int: int, double: float, boolean: bool): ...
    def isEqualsPassesTest(self) -> bool: ...

class IademNumericAttributeObserver(moa.classifiers.core.attributeclassobservers.AttributeClassObserver):
    def addValue(self, double: float, int: int, double2: float) -> None: ...
    def computeClassDist(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray]) -> None: ...
    def computeClassDistProbabilities(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], boolean: bool) -> None: ...
    def computeConditionalProb(self, arrayList: java.util.ArrayList[float], double: float) -> typing.MutableSequence[float]: ...
    def computeConditionalProbPerBin(self, arrayList: java.util.ArrayList[float]) -> java.util.ArrayList[typing.MutableSequence[float]]: ...
    def cutPointSuggestion(self, int: int) -> java.util.ArrayList[float]: ...
    def getClassDist(self) -> typing.MutableSequence[int]: ...
    def getCopy(self) -> 'IademNumericAttributeObserver': ...
    def getCut(self, int: int) -> float: ...
    def getLeftClassDist(self, double: float) -> typing.MutableSequence[int]: ...
    def getMaxOfValues(self) -> int: ...
    def getNumberOfCutPoints(self) -> int: ...
    def getValueCount(self) -> int: ...
    def reset(self) -> None: ...
    def setMaxBins(self, int: int) -> None: ...

class IademSplitCriterion(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    def doMeasure(self, arrayList: java.util.ArrayList[float]) -> float: ...
    @staticmethod
    def getDefaultSplitMeasure() -> str: ...
    @staticmethod
    def getSplitMeasureOptions() -> java.util.ArrayList[str]: ...
    def getSplitMeasureText(self) -> str: ...
    def setSplitMeasure(self, string: str) -> None: ...

class IademGaussianNumericAttributeClassObserver(moa.classifiers.core.attributeclassobservers.GaussianNumericAttributeClassObserver, IademNumericAttributeObserver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def addValue(self, double: float, int: int, double2: float) -> None: ...
    def computeClassDist(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray]) -> None: ...
    def computeClassDistProbabilities(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], boolean: bool) -> None: ...
    def computeConditionalProb(self, arrayList: java.util.ArrayList[float], double: float) -> typing.MutableSequence[float]: ...
    def computeConditionalProbPerBin(self, arrayList: java.util.ArrayList[float]) -> java.util.ArrayList[typing.MutableSequence[float]]: ...
    def cutPointSuggestion(self, int: int) -> java.util.ArrayList[float]: ...
    def getClassDist(self) -> typing.MutableSequence[int]: ...
    def getCopy(self) -> IademNumericAttributeObserver: ...
    def getCut(self, int: int) -> float: ...
    def getLeftClassDist(self, double: float) -> typing.MutableSequence[int]: ...
    def getMaxOfValues(self) -> int: ...
    def getNumberOfCutPoints(self) -> int: ...
    def getValueCount(self) -> int: ...
    def reset(self) -> None: ...
    def setMaxBins(self, int: int) -> None: ...

class IademGreenwaldKhannaNumericAttributeClassObserver(moa.classifiers.core.attributeclassobservers.GreenwaldKhannaNumericAttributeClassObserver, IademNumericAttributeObserver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def addValue(self, double: float, int: int, double2: float) -> None: ...
    def computeClassDist(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray]) -> None: ...
    def computeClassDistProbabilities(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], boolean: bool) -> None: ...
    def computeConditionalProb(self, arrayList: java.util.ArrayList[float], double: float) -> typing.MutableSequence[float]: ...
    def computeConditionalProbPerBin(self, arrayList: java.util.ArrayList[float]) -> java.util.ArrayList[typing.MutableSequence[float]]: ...
    def cutPointSuggestion(self, int: int) -> java.util.ArrayList[float]: ...
    def getClassDist(self) -> typing.MutableSequence[int]: ...
    def getCopy(self) -> IademNumericAttributeObserver: ...
    def getCut(self, int: int) -> float: ...
    def getLeftClassDist(self, double: float) -> typing.MutableSequence[int]: ...
    def getMaxOfValues(self) -> int: ...
    def getNumberOfCutPoints(self) -> int: ...
    def getValueCount(self) -> int: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    def reset(self) -> None: ...
    def setMaxBins(self, int: int) -> None: ...

class IademVFMLNumericAttributeClassObserver(moa.classifiers.core.attributeclassobservers.VFMLNumericAttributeClassObserver, IademNumericAttributeObserver, moa.classifiers.core.attributeclassobservers.AttributeClassObserver):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def addValue(self, double: float, int: int, double2: float) -> None: ...
    def computeClassDist(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray]) -> None: ...
    def computeClassDistProbabilities(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], boolean: bool) -> None: ...
    def computeConditionalProb(self, arrayList: java.util.ArrayList[float], double: float) -> typing.MutableSequence[float]: ...
    def computeConditionalProbPerBin(self, arrayList: java.util.ArrayList[float]) -> java.util.ArrayList[typing.MutableSequence[float]]: ...
    def cutPointSuggestion(self, int: int) -> java.util.ArrayList[float]: ...
    def forgetAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def getBestEvaluatedSplitSuggestion(self, splitCriterion: moa.classifiers.core.splitcriteria.SplitCriterion, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int, boolean: bool) -> moa.classifiers.core.AttributeSplitSuggestion: ...
    def getClassDist(self) -> typing.MutableSequence[int]: ...
    def getCopy(self) -> IademNumericAttributeObserver: ...
    def getCut(self, int: int) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getLeftClassDist(self, double: float) -> typing.MutableSequence[int]: ...
    def getMaxOfValues(self) -> int: ...
    def getNumberOfCutPoints(self) -> int: ...
    def getValueCount(self) -> int: ...
    def observeAttributeClass(self, double: float, int: int, double2: float) -> None: ...
    def probabilityOfAttributeValueGivenClass(self, double: float, int: int) -> float: ...
    def reset(self) -> None: ...
    def setMaxBins(self, int: int) -> None: ...

class Iadem2(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier):
    numericEstimatorOption: moa.options.ClassOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    splitCriterionOption: com.github.javacliparser.MultiChoiceOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    splitTestsOption: com.github.javacliparser.MultiChoiceOption = ...
    leafPredictionOption: com.github.javacliparser.MultiChoiceOption = ...
    driftDetectionMethodOption: moa.options.ClassOption = ...
    attributeDiferentiation: com.github.javacliparser.FloatOption = ...
    naiveBayesLimit: int = ...
    percentInCommon: float = ...
    ERROR_MARGIN: typing.ClassVar[float] = ...
    numberOfNodes: int = ...
    numberOfLeaves: int = ...
    def __init__(self): ...
    def createRoot(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def getAttributeDifferentiation(self) -> float: ...
    def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def getMaxNumberOfBins(self) -> int: ...
    def getMeasure(self) -> IademSplitCriterion: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getNaiveBayesLimit(self) -> int: ...
    def getNumberOfInstancesProcessed(self) -> int: ...
    def getNumberOfLeaves(self) -> int: ...
    @typing.overload
    def getNumberOfNodes(self) -> int: ...
    @typing.overload
    def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def getNumericAttObserver(self) -> IademNumericAttributeObserver: ...
    def getPercentInCommon(self) -> float: ...
    def getTreeRoot(self) -> 'Iadem2.Node': ...
    def getValuesOfNominalAttributes(self, int: int, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def incrNumberOfInstancesProcessed(self) -> None: ...
    def isOnlyBinaryTest(self) -> bool: ...
    def isOnlyMultiwayTest(self) -> bool: ...
    def isRandomizable(self) -> bool: ...
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def newEstimator(self) -> moa.classifiers.core.driftdetection.AbstractChangeDetector: ...
    def newLeafNode(self, node: 'Iadem2.Node', long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.LeafNode': ...
    def newSplit(self, int: int) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def setNumberOfLeaves(self, int: int) -> None: ...
    def setNumberOfNodes(self, int: int) -> None: ...
    def setTreeRoot(self, node: 'Iadem2.Node') -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class LeafNode(moa.classifiers.trees.iadem.Iadem2.Node):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, boolean: bool, boolean2: bool, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def attemptToSplit(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def doSplit(self, iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence['Iadem2.LeafNode']: ...
        def getBestSplitSuggestion(self, instance: com.yahoo.labs.samoa.instances.Instance) -> IademAttributeSplitSuggestion: ...
        def getBestSplitSuggestionIADEM(self, instance: com.yahoo.labs.samoa.instances.Instance) -> IademAttributeSplitSuggestion: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def getInstNodeCountSinceVirtual(self) -> int: ...
        def getInstSeenSinceLastSplitAttempt(self) -> float: ...
        def getLeaves(self) -> java.util.ArrayList['Iadem2.LeafNode']: ...
        def getMajorityClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
        def getSubtreeNodeCount(self) -> int: ...
        def getTree(self) -> 'Iadem2': ...
        def getVirtualChildren(self) -> moa.core.AutoExpandVector['Iadem2.VirtualNode']: ...
        def hasInformationToSplit(self) -> bool: ...
        def isAllAttUsed(self) -> bool: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
        def setInstSeenSinceLastSplitAttempt(self, double: float) -> None: ...
        def setSplit(self, boolean: bool) -> None: ...
        def setVirtualChildren(self, autoExpandVector: moa.core.AutoExpandVector['Iadem2.VirtualNode']) -> None: ...
    class LeafNodeNB(moa.classifiers.trees.iadem.Iadem2.LeafNode):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, boolean: bool, boolean2: bool, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    class LeafNodeNBKirkby(moa.classifiers.trees.iadem.Iadem2.LeafNodeNB):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, boolean: bool, boolean2: bool, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
    class LeafNodeWeightedVote(moa.classifiers.trees.iadem.Iadem2.LeafNodeNB):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, boolean: bool, boolean2: bool, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
    class Node(java.io.Serializable):
        parent: 'Iadem2.Node' = ...
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getChildCount(self) -> int: ...
        def getClassValueDist(self) -> moa.core.DoubleVector: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def getLeaves(self) -> java.util.ArrayList['Iadem2.LeafNode']: ...
        def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
        def getParent(self) -> 'Iadem2.Node': ...
        def getSubtreeNodeCount(self) -> int: ...
        def getTree(self) -> 'Iadem2': ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
        def setClassValueDist(self, doubleVector: moa.core.DoubleVector) -> None: ...
        def setParent(self, node: 'Iadem2.Node') -> None: ...
        def setTree(self, iadem2: 'Iadem2') -> None: ...
    class NominalVirtualNode(moa.classifiers.trees.iadem.Iadem2.VirtualNode):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', int: int, boolean: bool, boolean2: bool): ...
        def computeConditionalProbability(self, double: float) -> moa.core.DoubleVector: ...
        def getNewSplitNode(self, long: int, node: 'Iadem2.Node', iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.SplitNode': ...
        def getNominalAttClassObserver(self) -> moa.core.AutoExpandVector[moa.core.DoubleVector]: ...
        def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
        def getPercent(self) -> float: ...
        def hasInformation(self) -> bool: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
        def updateHeuristicMeasure(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def updateHeuristicMeasureBinaryTest(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def updateHeuristicMeasureMultiwayTest(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class NumericVirtualNode(moa.classifiers.trees.iadem.Iadem2.VirtualNode):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', int: int, iademNumericAttributeObserver: IademNumericAttributeObserver): ...
        def computeConditionalProbability(self, double: float) -> moa.core.DoubleVector: ...
        def getNewSplitNode(self, long: int, node: 'Iadem2.Node', iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.SplitNode': ...
        def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
        def getNumericAttClassObserver(self) -> IademNumericAttributeObserver: ...
        def getPercent(self) -> float: ...
        def hasInformation(self) -> bool: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
        def updateHeuristicMeasure(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    class SplitNode(moa.classifiers.trees.iadem.Iadem2.Node):
        splitTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest = ...
        children: moa.core.AutoExpandVector = ...
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', nodeArray: typing.Union[typing.List['Iadem2.Node'], jpype.JArray], doubleArray: typing.Union[typing.List[float], jpype.JArray], instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest): ...
        def addChild(self, node: 'Iadem2.Node') -> None: ...
        def changeChildren(self, node: 'Iadem2.Node', node2: 'Iadem2.Node') -> None: ...
        def getChild(self, int: int) -> 'Iadem2.Node': ...
        def getChildCount(self) -> int: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def getLeaves(self) -> java.util.ArrayList['Iadem2.LeafNode']: ...
        def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
        def getSplitTest(self) -> moa.classifiers.core.conditionaltests.InstanceConditionalTest: ...
        def getSubtreeNodeCount(self) -> int: ...
        def instanceChildIndex(self, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.Node': ...
        def removeChild(self, node: 'Iadem2.Node') -> None: ...
        @typing.overload
        def setChild(self, node: 'Iadem2.Node', int: int) -> None: ...
        @typing.overload
        def setChild(self, autoExpandVector: moa.core.AutoExpandVector['Iadem2.Node']) -> None: ...
        def setChildren(self, nodeArray: typing.Union[typing.List['Iadem2.Node'], jpype.JArray]) -> None: ...
    class VirtualNode(moa.classifiers.trees.iadem.Iadem2.Node):
        def __init__(self, iadem2: 'Iadem2', iadem22: 'Iadem2', node: 'Iadem2.Node', int: int): ...
        def computeConditionalProbability(self, double: float) -> moa.core.DoubleVector: ...
        def getAttIndex(self) -> int: ...
        def getBestSplitSuggestion(self) -> IademAttributeSplitSuggestion: ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def getHeuristicMeasureLower(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getHeuristicMeasureUpper(self, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
        def getLeaves(self) -> java.util.ArrayList['Iadem2.LeafNode']: ...
        def getNewSplitNode(self, long: int, node: 'Iadem2.Node', iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> 'Iadem2.SplitNode': ...
        def getPercent(self) -> float: ...
        def getSubtreeNodeCount(self) -> int: ...
        def hasInformation(self) -> bool: ...
        def updateHeuristicMeasure(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class Iadem3(Iadem2, moa.classifiers.MultiClassClassifier):
    maxNestingLevelOption: com.github.javacliparser.IntOption = ...
    maxSubtreesPerNodeOption: com.github.javacliparser.IntOption = ...
    numSplitsByBreakingTies: int = ...
    def __init__(self): ...
    def addSubtree(self, iadem3Subtree: 'Iadem3Subtree') -> None: ...
    def canCreateSubtree(self) -> bool: ...
    def copyTree(self, iadem3Subtree: 'Iadem3Subtree') -> None: ...
    def createRoot(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def getChangedTrees(self) -> int: ...
    def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def getEstimatorCopy(self) -> moa.classifiers.core.driftdetection.AbstractChangeDetector: ...
    def getMaxAltSubtreesPerNode(self) -> int: ...
    def getMaxNestingLevels(self) -> int: ...
    def getNumberOfSubtrees(self) -> int: ...
    def getTreeLevel(self) -> int: ...
    def isRestaurarVectoresPrediccion(self) -> bool: ...
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def newDeletedTree(self) -> None: ...
    def newLeafNode(self, node: Iadem2.Node, long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.LeafNode: ...
    def newTreeChange(self) -> None: ...
    def numDeletedTrees(self) -> int: ...
    def numSubtrees(self) -> int: ...
    def numTrees(self) -> int: ...
    def removeSubtree(self, iadem3Subtree: 'Iadem3Subtree') -> None: ...
    def updateNumberOfLeaves(self, int: int) -> None: ...
    def updateNumberOfNodes(self, int: int) -> None: ...
    def updateNumberOfNodesSplitByTieBreaking(self, int: int) -> None: ...
    class AdaptiveLeafNode(Iadem2.LeafNode, java.io.Serializable):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, boolean: bool, boolean2: bool, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def attemptToSplit(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
        def doSplit(self, iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence['Iadem3.AdaptiveLeafNode']: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.Node: ...
    class AdaptiveLeafNodeNB(moa.classifiers.trees.iadem.Iadem3.AdaptiveLeafNode):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, boolean: bool, boolean2: bool, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    class AdaptiveLeafNodeNBAdaptive(moa.classifiers.trees.iadem.Iadem3.AdaptiveLeafNodeNB):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, boolean: bool, boolean2: bool, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.Node: ...
    class AdaptiveLeafNodeNBKirkby(moa.classifiers.trees.iadem.Iadem3.AdaptiveLeafNodeNB):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, boolean: bool, boolean2: bool, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.Node: ...
    class AdaptiveLeafNodeWeightedVote(moa.classifiers.trees.iadem.Iadem3.AdaptiveLeafNodeNBAdaptive):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, long: int, long2: int, doubleArray: typing.Union[typing.List[float], jpype.JArray], iademNumericAttributeObserver: IademNumericAttributeObserver, int: int, boolean: bool, boolean2: bool, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, instance: com.yahoo.labs.samoa.instances.Instance): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    class AdaptiveNominalVirtualNode(Iadem2.NominalVirtualNode, java.io.Serializable, moa.classifiers.trees.iadem.Iadem3.restartsVariablesAtDrift):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, int: int, boolean: bool, boolean2: bool): ...
        def getNewSplitNode(self, long: int, node: Iadem2.Node, iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.SplitNode: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.Node: ...
        def resetVariablesAtDrift(self) -> None: ...
    class AdaptiveNumericVirtualNode(Iadem2.NumericVirtualNode, java.io.Serializable, moa.classifiers.trees.iadem.Iadem3.restartsVariablesAtDrift):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, int: int, iademNumericAttributeObserver: IademNumericAttributeObserver): ...
        def getNewSplitNode(self, long: int, node: Iadem2.Node, iademAttributeSplitSuggestion: IademAttributeSplitSuggestion, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.SplitNode: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.Node: ...
        def resetVariablesAtDrift(self) -> None: ...
    class AdaptiveSplitNode(Iadem2.SplitNode, java.io.Serializable):
        def __init__(self, iadem3: 'Iadem3', iadem32: 'Iadem3', node: Iadem2.Node, nodeArray: typing.Union[typing.List[Iadem2.Node], jpype.JArray], doubleArray: typing.Union[typing.List[float], jpype.JArray], instanceConditionalTest: moa.classifiers.core.conditionaltests.InstanceConditionalTest, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector, adaptiveLeafNode: 'Iadem3.AdaptiveLeafNode', int: int): ...
        def getClassVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
        def getErrorEstimation(self) -> float: ...
        def getNumTrees(self) -> int: ...
        def getNumberOfNodes(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
        def getNumberOfSubtrees(self) -> int: ...
        def getSubtreeNodeCount(self) -> int: ...
        def isUseless(self, int: int) -> bool: ...
        def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> Iadem2.Node: ...
    class restartsVariablesAtDrift:
        def resetVariablesAtDrift(self) -> None: ...

class Iadem3Subtree(Iadem3):
    def __init__(self, node: Iadem2.Node, int: int, iadem3: Iadem3, instance: com.yahoo.labs.samoa.instances.Instance): ...
    def addSubtree(self, iadem3Subtree: 'Iadem3Subtree') -> None: ...
    def canCreateSubtree(self) -> bool: ...
    def estimacionValorMedio(self) -> float: ...
    def getEstimador(self) -> moa.classifiers.core.driftdetection.AbstractChangeDetector: ...
    def getEstimatorCopy(self) -> moa.classifiers.core.driftdetection.AbstractChangeDetector: ...
    def learnFromInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def newDeletedTree(self) -> None: ...
    def newSplit(self, int: int) -> None: ...
    def newTreeChange(self) -> None: ...
    def removeSubtree(self, iadem3Subtree: 'Iadem3Subtree') -> None: ...
    def setEstimador(self, abstractChangeDetector: moa.classifiers.core.driftdetection.AbstractChangeDetector) -> None: ...
    def setNewTree(self) -> None: ...
    def updateNumberOfLeaves(self, int: int) -> None: ...
    def updateNumberOfNodes(self, int: int) -> None: ...
    def updateNumberOfNodesSplitByTieBreaking(self, int: int) -> None: ...
    def windowWidth(self) -> int: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.trees.iadem")``.

    Iadem2: typing.Type[Iadem2]
    Iadem3: typing.Type[Iadem3]
    Iadem3Subtree: typing.Type[Iadem3Subtree]
    IademAttributeSplitSuggestion: typing.Type[IademAttributeSplitSuggestion]
    IademCommonProcedures: typing.Type[IademCommonProcedures]
    IademException: typing.Type[IademException]
    IademGaussianNumericAttributeClassObserver: typing.Type[IademGaussianNumericAttributeClassObserver]
    IademGreenwaldKhannaNumericAttributeClassObserver: typing.Type[IademGreenwaldKhannaNumericAttributeClassObserver]
    IademGreenwaldKhannaQuantileSummary: typing.Type[IademGreenwaldKhannaQuantileSummary]
    IademNominalAttributeBinaryTest: typing.Type[IademNominalAttributeBinaryTest]
    IademNominalAttributeMultiwayTest: typing.Type[IademNominalAttributeMultiwayTest]
    IademNumericAttributeBinaryTest: typing.Type[IademNumericAttributeBinaryTest]
    IademNumericAttributeObserver: typing.Type[IademNumericAttributeObserver]
    IademSplitCriterion: typing.Type[IademSplitCriterion]
    IademVFMLNumericAttributeClassObserver: typing.Type[IademVFMLNumericAttributeClassObserver]
