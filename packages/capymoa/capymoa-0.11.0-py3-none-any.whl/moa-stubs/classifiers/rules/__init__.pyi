
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import com.yahoo.labs.samoa.instances
import java.lang
import java.util
import jpype
import moa
import moa.classifiers
import moa.classifiers.core.attributeclassobservers
import moa.classifiers.rules.core
import moa.classifiers.rules.core.voting
import moa.classifiers.rules.driftdetection
import moa.classifiers.rules.errormeasurers
import moa.classifiers.rules.featureranking
import moa.classifiers.rules.functions
import moa.classifiers.rules.meta
import moa.classifiers.rules.multilabel
import moa.core
import moa.options
import typing



class AMRulesRegressor(moa.classifiers.rules.multilabel.AMRulesMultiTargetRegressor, moa.classifiers.Regressor):
    def __init__(self): ...

class AbstractAMRules(moa.classifiers.AbstractClassifier):
    NORMAL_CONSTANT: typing.ClassVar[float] = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    DriftDetectionOption: com.github.javacliparser.FlagOption = ...
    pageHinckleyAlphaOption: com.github.javacliparser.FloatOption = ...
    pageHinckleyThresholdOption: com.github.javacliparser.IntOption = ...
    noAnomalyDetectionOption: com.github.javacliparser.FlagOption = ...
    multivariateAnomalyProbabilityThresholdOption: com.github.javacliparser.FloatOption = ...
    univariateAnomalyprobabilityThresholdOption: com.github.javacliparser.FloatOption = ...
    anomalyNumInstThresholdOption: com.github.javacliparser.IntOption = ...
    unorderedRulesOption: com.github.javacliparser.FlagOption = ...
    VerbosityOption: com.github.javacliparser.IntOption = ...
    numericObserverOption: moa.options.ClassOption = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float): ...
    def PrintRuleSet(self) -> None: ...
    def getAttributesPercentage(self) -> float: ...
    def getModelAttIndexToInstanceAttIndex(self, int: int, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getVotes(self, instance: com.yahoo.labs.samoa.instances.Instance) -> moa.classifiers.rules.core.voting.Vote: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    @staticmethod
    def modelAttIndexToInstanceAttIndex(int: int, instance: com.yahoo.labs.samoa.instances.Instance) -> int: ...
    def newErrorWeightedVote(self) -> moa.classifiers.rules.core.voting.ErrorWeightedVote: ...
    @typing.overload
    def newRuleActiveLearningNode(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> moa.classifiers.rules.core.RuleActiveLearningNode: ...
    @typing.overload
    def newRuleActiveLearningNode(self, builder: moa.classifiers.rules.core.Rule.Builder) -> moa.classifiers.rules.core.RuleActiveLearningNode: ...
    def resetLearningImpl(self) -> None: ...
    def setAttributesPercentage(self, double: float) -> None: ...
    def setRandomSeed(self, int: int) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class BinaryClassifierFromRegressor(moa.classifiers.AbstractClassifier):
    baseLearnerOption: moa.options.ClassOption = ...
    def __init__(self): ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def isRandomizable(self) -> bool: ...
    def resetLearningImpl(self) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class Predicates(moa.AbstractMOAObject):
    def __init__(self, double: float, double2: float, double3: float): ...
    def evaluate(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...
    def getAttributeValue(self) -> float: ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getSymbol(self) -> float: ...
    def getValue(self) -> float: ...
    def setAttributeValue(self, double: float) -> None: ...
    def setSymbol(self, double: float) -> None: ...
    def setValue(self, double: float) -> None: ...

class RuleClassification(moa.AbstractMOAObject):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, ruleClassification: 'RuleClassification'): ...
    def getDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def ruleEvaluate(self, instance: com.yahoo.labs.samoa.instances.Instance) -> bool: ...

class RuleClassifier(moa.classifiers.AbstractClassifier, moa.classifiers.MultiClassClassifier):
    PminOption: com.github.javacliparser.FloatOption = ...
    splitConfidenceOption: com.github.javacliparser.FloatOption = ...
    tieThresholdOption: com.github.javacliparser.FloatOption = ...
    anomalyProbabilityThresholdOption: com.github.javacliparser.FloatOption = ...
    probabilityThresholdOption: com.github.javacliparser.FloatOption = ...
    anomalyNumInstThresholdOption: com.github.javacliparser.IntOption = ...
    gracePeriodOption: com.github.javacliparser.IntOption = ...
    predictionFunctionOption: com.github.javacliparser.MultiChoiceOption = ...
    orderedRulesOption: com.github.javacliparser.FlagOption = ...
    anomalyDetectionOption: com.github.javacliparser.FlagOption = ...
    Supervised: com.github.javacliparser.FlagOption = ...
    Unsupervised: com.github.javacliparser.FlagOption = ...
    def __init__(self): ...
    def ComputeHoeffdingBound(self, double: float, double2: float, double3: float) -> float: ...
    def checkBestAttrib(self, double: float, autoExpandVector: moa.core.AutoExpandVector[moa.classifiers.core.attributeclassobservers.AttributeClassObserver], doubleVector: moa.core.DoubleVector) -> bool: ...
    def computeAnomalySupervised(self, ruleClassification: RuleClassification, int: int, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    def computeAnomalyUnsupervised(self, ruleClassification: RuleClassification, int: int, instance: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    def computeMean(self, double: float, int: int) -> float: ...
    def computeProbability(self, double: float, double2: float, double3: float) -> float: ...
    def computeSD(self, double: float, double2: float, int: int) -> float: ...
    def createRule(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def entropy(self, doubleVector: moa.core.DoubleVector) -> float: ...
    def expandeRule(self, ruleClassification: RuleClassification, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> None: ...
    def findBestValEntropy(self, node: moa.classifiers.core.attributeclassobservers.BinaryTreeNumericAttributeClassObserver.Node, doubleVector: moa.core.DoubleVector, doubleVector2: moa.core.DoubleVector, boolean: bool, double3: float, doubleVector3: moa.core.DoubleVector) -> None: ...
    def findBestValEntropyNominalAtt(self, autoExpandVector: moa.core.AutoExpandVector[moa.core.DoubleVector], int: int) -> None: ...
    def getCountNominalAttrib(self, arrayList: java.util.ArrayList[Predicates]) -> int: ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getModelDescriptionNoAnomalyDetection(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...
    def getWeightSeen(self) -> float: ...
    def initializeRuleStatistics(self, ruleClassification: RuleClassification, predicates: Predicates, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def isRandomizable(self) -> bool: ...
    def mainFindBestValEntropy(self, node: moa.classifiers.core.attributeclassobservers.BinaryTreeNumericAttributeClassObserver.Node) -> None: ...
    def manageMemory(self, int: int, int2: int) -> None: ...
    def printAnomaliesSupervised(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def printAnomaliesUnsupervised(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def resetLearningImpl(self) -> None: ...
    def theBestAttributes(self, instance: com.yahoo.labs.samoa.instances.Instance, autoExpandVector: moa.core.AutoExpandVector[moa.classifiers.core.attributeclassobservers.AttributeClassObserver]) -> None: ...
    def trainOnInstanceImpl(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def updateRuleAttribStatistics(self, instance: com.yahoo.labs.samoa.instances.Instance, ruleClassification: RuleClassification, int: int) -> None: ...

class AMRulesRegressorOld(AbstractAMRules, moa.classifiers.Regressor):
    constantLearningRatioDecayOption: com.github.javacliparser.FlagOption = ...
    learningRatioOption: com.github.javacliparser.FloatOption = ...
    predictionFunctionOption: com.github.javacliparser.MultiChoiceOption = ...
    votingTypeOption: moa.options.ClassOption = ...
    splitCriterionOption: moa.options.ClassOption = ...
    def __init__(self): ...
    def getModelDescription(self, stringBuilder: java.lang.StringBuilder, int: int) -> None: ...
    def isRandomizable(self) -> bool: ...
    def newErrorWeightedVote(self) -> moa.classifiers.rules.core.voting.ErrorWeightedVote: ...
    @typing.overload
    def newRuleActiveLearningNode(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> moa.classifiers.rules.core.RuleActiveLearningNode: ...
    @typing.overload
    def newRuleActiveLearningNode(self, builder: moa.classifiers.rules.core.Rule.Builder) -> moa.classifiers.rules.core.RuleActiveLearningNode: ...
    def resetLearningImpl(self) -> None: ...

class RuleClassifierNBayes(RuleClassifier):
    nbThresholdOption: com.github.javacliparser.IntOption = ...
    def __init__(self): ...
    @typing.overload
    def getVotesForInstance(self, example: moa.core.Example[com.yahoo.labs.samoa.instances.Instance]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def getVotesForInstance(self, instance: com.yahoo.labs.samoa.instances.Instance) -> typing.MutableSequence[float]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.rules")``.

    AMRulesRegressor: typing.Type[AMRulesRegressor]
    AMRulesRegressorOld: typing.Type[AMRulesRegressorOld]
    AbstractAMRules: typing.Type[AbstractAMRules]
    BinaryClassifierFromRegressor: typing.Type[BinaryClassifierFromRegressor]
    Predicates: typing.Type[Predicates]
    RuleClassification: typing.Type[RuleClassification]
    RuleClassifier: typing.Type[RuleClassifier]
    RuleClassifierNBayes: typing.Type[RuleClassifierNBayes]
    core: moa.classifiers.rules.core.__module_protocol__
    driftdetection: moa.classifiers.rules.driftdetection.__module_protocol__
    errormeasurers: moa.classifiers.rules.errormeasurers.__module_protocol__
    featureranking: moa.classifiers.rules.featureranking.__module_protocol__
    functions: moa.classifiers.rules.functions.__module_protocol__
    meta: moa.classifiers.rules.meta.__module_protocol__
    multilabel: moa.classifiers.rules.multilabel.__module_protocol__
