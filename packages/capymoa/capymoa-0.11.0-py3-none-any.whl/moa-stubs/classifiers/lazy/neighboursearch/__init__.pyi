
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.yahoo.labs.samoa.instances
import java.io
import java.lang
import java.util
import jpype
import moa.classifiers.lazy.neighboursearch.kdtrees
import typing



class DistanceFunction:
    @typing.overload
    def distance(self, instance: com.yahoo.labs.samoa.instances.Instance, instance2: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    @typing.overload
    def distance(self, instance: com.yahoo.labs.samoa.instances.Instance, instance2: com.yahoo.labs.samoa.instances.Instance, double: float) -> float: ...
    def getAttributeIndices(self) -> str: ...
    def getInstances(self) -> com.yahoo.labs.samoa.instances.Instances: ...
    def getInvertSelection(self) -> bool: ...
    def postProcessDistances(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setAttributeIndices(self, string: str) -> None: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def setInvertSelection(self, boolean: bool) -> None: ...
    def update(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class NearestNeighbourSearch(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: com.yahoo.labs.samoa.instances.Instances): ...
    def addInstanceInfo(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    @staticmethod
    def combSort11(doubleArray: typing.Union[typing.List[float], jpype.JArray], intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def distanceFunctionTipText(self) -> str: ...
    def getDistanceFunction(self) -> DistanceFunction: ...
    def getDistances(self) -> typing.MutableSequence[float]: ...
    def getInstances(self) -> com.yahoo.labs.samoa.instances.Instances: ...
    def getMeasurePerformance(self) -> bool: ...
    def globalInfo(self) -> str: ...
    def kNearestNeighbours(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> com.yahoo.labs.samoa.instances.Instances: ...
    def measurePerformanceTipText(self) -> str: ...
    def nearestNeighbour(self, instance: com.yahoo.labs.samoa.instances.Instance) -> com.yahoo.labs.samoa.instances.Instance: ...
    @staticmethod
    def quickSort(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], int: int, int2: int) -> None: ...
    def setDistanceFunction(self, distanceFunction: DistanceFunction) -> None: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def update(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class KDTree(NearestNeighbourSearch):
    MIN: typing.ClassVar[int] = ...
    MAX: typing.ClassVar[int] = ...
    WIDTH: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: com.yahoo.labs.samoa.instances.Instances): ...
    def addInstanceInfo(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def assignSubToCenters(self, kDTreeNode: moa.classifiers.lazy.neighboursearch.kdtrees.KDTreeNode, instances: com.yahoo.labs.samoa.instances.Instances, intArray: typing.Union[typing.List[int], jpype.JArray], intArray2: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def centerInstances(self, instances: com.yahoo.labs.samoa.instances.Instances, intArray: typing.Union[typing.List[int], jpype.JArray], double: float) -> None: ...
    def enumerateMeasures(self) -> java.util.Enumeration: ...
    def getDistanceFunction(self) -> DistanceFunction: ...
    def getDistances(self) -> typing.MutableSequence[float]: ...
    def getMaxInstInLeaf(self) -> int: ...
    def getMeasure(self, string: str) -> float: ...
    def getMinBoxRelWidth(self) -> float: ...
    def getNodeSplitter(self) -> moa.classifiers.lazy.neighboursearch.kdtrees.KDTreeNodeSplitter: ...
    def getNormalizeNodeWidth(self) -> bool: ...
    def globalInfo(self) -> str: ...
    def kNearestNeighbours(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> com.yahoo.labs.samoa.instances.Instances: ...
    def maxInstInLeafTipText(self) -> str: ...
    def measureMaxDepth(self) -> float: ...
    def measureNumLeaves(self) -> float: ...
    def measureTreeSize(self) -> float: ...
    def minBoxRelWidthTipText(self) -> str: ...
    def nearestNeighbour(self, instance: com.yahoo.labs.samoa.instances.Instance) -> com.yahoo.labs.samoa.instances.Instance: ...
    def nodeSplitterTipText(self) -> str: ...
    def normalizeNodeWidthTipText(self) -> str: ...
    def setDistanceFunction(self, distanceFunction: DistanceFunction) -> None: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def setMaxInstInLeaf(self, int: int) -> None: ...
    def setMeasurePerformance(self, boolean: bool) -> None: ...
    def setMinBoxRelWidth(self, double: float) -> None: ...
    def setNodeSplitter(self, kDTreeNodeSplitter: moa.classifiers.lazy.neighboursearch.kdtrees.KDTreeNodeSplitter) -> None: ...
    def setNormalizeNodeWidth(self, boolean: bool) -> None: ...
    def update(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class LinearNNSearch(NearestNeighbourSearch):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: com.yahoo.labs.samoa.instances.Instances): ...
    def addInstanceInfo(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    def getDistances(self) -> typing.MutableSequence[float]: ...
    def getSkipIdentical(self) -> bool: ...
    def globalInfo(self) -> str: ...
    def kNearestNeighbours(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int) -> com.yahoo.labs.samoa.instances.Instances: ...
    def nearestNeighbour(self, instance: com.yahoo.labs.samoa.instances.Instance) -> com.yahoo.labs.samoa.instances.Instance: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def setSkipIdentical(self, boolean: bool) -> None: ...
    def skipIdenticalTipText(self) -> str: ...
    def update(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...

class NormalizableDistance(DistanceFunction):
    R_MIN: typing.ClassVar[int] = ...
    R_MAX: typing.ClassVar[int] = ...
    R_WIDTH: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: com.yahoo.labs.samoa.instances.Instances): ...
    def attributeIndicesTipText(self) -> str: ...
    @typing.overload
    def distance(self, instance: com.yahoo.labs.samoa.instances.Instance, instance2: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    @typing.overload
    def distance(self, instance: com.yahoo.labs.samoa.instances.Instance, instance2: com.yahoo.labs.samoa.instances.Instance, double: float) -> float: ...
    def dontNormalizeTipText(self) -> str: ...
    def getAttributeIndices(self) -> str: ...
    def getDontNormalize(self) -> bool: ...
    def getInstances(self) -> com.yahoo.labs.samoa.instances.Instances: ...
    def getInvertSelection(self) -> bool: ...
    def getRanges(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def globalInfo(self) -> str: ...
    def inRanges(self, instance: com.yahoo.labs.samoa.instances.Instance, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> bool: ...
    @typing.overload
    def initializeRanges(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    @typing.overload
    def initializeRanges(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    @typing.overload
    def initializeRanges(self, intArray: typing.Union[typing.List[int], jpype.JArray], int2: int, int3: int) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def initializeRangesEmpty(self, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...
    def invertSelectionTipText(self) -> str: ...
    @staticmethod
    def isMissingValue(double: float) -> bool: ...
    def postProcessDistances(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def rangesSet(self) -> bool: ...
    def setAttributeIndices(self, string: str) -> None: ...
    def setDontNormalize(self, boolean: bool) -> None: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def setInvertSelection(self, boolean: bool) -> None: ...
    def toString(self) -> str: ...
    def update(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    @typing.overload
    def updateRanges(self, instance: com.yahoo.labs.samoa.instances.Instance, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    @typing.overload
    def updateRanges(self, instance: com.yahoo.labs.samoa.instances.Instance) -> None: ...
    @typing.overload
    def updateRanges(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...
    def updateRangesFirst(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...

class EuclideanDistance(NormalizableDistance, java.lang.Cloneable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, instances: com.yahoo.labs.samoa.instances.Instances): ...
    def closestPoint(self, instance: com.yahoo.labs.samoa.instances.Instance, instances: com.yahoo.labs.samoa.instances.Instances, intArray: typing.Union[typing.List[int], jpype.JArray]) -> int: ...
    @typing.overload
    def distance(self, instance: com.yahoo.labs.samoa.instances.Instance, instance2: com.yahoo.labs.samoa.instances.Instance) -> float: ...
    @typing.overload
    def distance(self, instance: com.yahoo.labs.samoa.instances.Instance, instance2: com.yahoo.labs.samoa.instances.Instance, double: float) -> float: ...
    def getMiddle(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    def globalInfo(self) -> str: ...
    def postProcessDistances(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def sqDifference(self, int: int, double: float, double2: float) -> float: ...
    def valueIsSmallerEqual(self, instance: com.yahoo.labs.samoa.instances.Instance, int: int, double: float) -> bool: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.lazy.neighboursearch")``.

    DistanceFunction: typing.Type[DistanceFunction]
    EuclideanDistance: typing.Type[EuclideanDistance]
    KDTree: typing.Type[KDTree]
    LinearNNSearch: typing.Type[LinearNNSearch]
    NearestNeighbourSearch: typing.Type[NearestNeighbourSearch]
    NormalizableDistance: typing.Type[NormalizableDistance]
    kdtrees: moa.classifiers.lazy.neighboursearch.kdtrees.__module_protocol__
