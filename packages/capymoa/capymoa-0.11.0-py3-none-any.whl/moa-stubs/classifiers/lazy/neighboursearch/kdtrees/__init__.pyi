
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.yahoo.labs.samoa.instances
import java.io
import java.util
import jpype
import moa.classifiers.lazy.neighboursearch
import typing



class KDTreeNode(java.io.Serializable):
    m_NodeNumber: int = ...
    m_Left: 'KDTreeNode' = ...
    m_Right: 'KDTreeNode' = ...
    m_SplitValue: float = ...
    m_SplitDim: int = ...
    m_NodeRanges: typing.MutableSequence[typing.MutableSequence[float]] = ...
    m_NodesRectBounds: typing.MutableSequence[typing.MutableSequence[float]] = ...
    m_Start: int = ...
    m_End: int = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    def getSplitDim(self) -> int: ...
    def getSplitValue(self) -> float: ...
    def isALeaf(self) -> bool: ...
    def numInstances(self) -> int: ...

class KDTreeNodeSplitter(java.io.Serializable):
    MIN: typing.ClassVar[int] = ...
    MAX: typing.ClassVar[int] = ...
    WIDTH: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, intArray: typing.Union[typing.List[int], jpype.JArray], instances: com.yahoo.labs.samoa.instances.Instances, euclideanDistance: moa.classifiers.lazy.neighboursearch.EuclideanDistance): ...
    def getOptions(self) -> typing.MutableSequence[str]: ...
    def listOptions(self) -> java.util.Enumeration: ...
    def setEuclideanDistanceFunction(self, euclideanDistance: moa.classifiers.lazy.neighboursearch.EuclideanDistance) -> None: ...
    def setInstanceList(self, intArray: typing.Union[typing.List[int], jpype.JArray]) -> None: ...
    def setInstances(self, instances: com.yahoo.labs.samoa.instances.Instances) -> None: ...
    def setNodeWidthNormalization(self, boolean: bool) -> None: ...
    def setOptions(self, stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...
    def splitNode(self, kDTreeNode: KDTreeNode, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...

class KMeansInpiredMethod(KDTreeNodeSplitter):
    def __init__(self): ...
    def globalInfo(self) -> str: ...
    def splitNode(self, kDTreeNode: KDTreeNode, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...

class MedianOfWidestDimension(KDTreeNodeSplitter):
    def __init__(self): ...
    def globalInfo(self) -> str: ...
    def select(self, int: int, intArray: typing.Union[typing.List[int], jpype.JArray], int3: int, int4: int, int5: int) -> int: ...
    def splitNode(self, kDTreeNode: KDTreeNode, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...

class MidPointOfWidestDimension(KDTreeNodeSplitter):
    def __init__(self): ...
    def globalInfo(self) -> str: ...
    def splitNode(self, kDTreeNode: KDTreeNode, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...

class SlidingMidPointOfWidestSide(KDTreeNodeSplitter):
    def __init__(self): ...
    def globalInfo(self) -> str: ...
    def splitNode(self, kDTreeNode: KDTreeNode, int: int, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.classifiers.lazy.neighboursearch.kdtrees")``.

    KDTreeNode: typing.Type[KDTreeNode]
    KDTreeNodeSplitter: typing.Type[KDTreeNodeSplitter]
    KMeansInpiredMethod: typing.Type[KMeansInpiredMethod]
    MedianOfWidestDimension: typing.Type[MedianOfWidestDimension]
    MidPointOfWidestDimension: typing.Type[MidPointOfWidestDimension]
    SlidingMidPointOfWidestSide: typing.Type[SlidingMidPointOfWidestSide]
