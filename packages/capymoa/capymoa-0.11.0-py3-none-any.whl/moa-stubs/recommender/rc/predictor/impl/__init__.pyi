
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.util
import jpype
import moa.recommender.rc.data
import moa.recommender.rc.predictor
import moa.recommender.rc.utils
import typing



class BRISMFPredictor(moa.recommender.rc.utils.Updatable):
    @typing.overload
    def __init__(self, int: int, recommenderData: moa.recommender.rc.data.RecommenderData, boolean: bool): ...
    @typing.overload
    def __init__(self, int: int, recommenderData: moa.recommender.rc.data.RecommenderData, double: float, double2: float, boolean: bool): ...
    def getData(self) -> moa.recommender.rc.data.RecommenderData: ...
    def getItemFeatures(self, int: int) -> typing.MutableSequence[float]: ...
    def getNumFeatures(self) -> int: ...
    def getUserFeatures(self, int: int) -> typing.MutableSequence[float]: ...
    @typing.overload
    def predictRating(self, floatArray: typing.Union[typing.List[float], jpype.JArray], floatArray2: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    @typing.overload
    def predictRating(self, int: int, int2: int) -> float: ...
    def predictRatings(self, int: int, list: java.util.List[int]) -> java.util.List[float]: ...
    def setLRate(self, double: float) -> None: ...
    def setNIterations(self, int: int) -> None: ...
    def setRFactor(self, double: float) -> None: ...
    def train(self) -> None: ...
    @typing.overload
    def trainItem(self, int: int) -> None: ...
    @typing.overload
    def trainItem(self, int: int, int2: int) -> None: ...
    @typing.overload
    def trainItem(self, int: int, list: java.util.List[int], list2: java.util.List[float]) -> None: ...
    @typing.overload
    def trainItem(self, int: int, list: java.util.List[int], list2: java.util.List[float], int2: int) -> None: ...
    def trainItemFeats(self, int: int, list: java.util.List[int], list2: java.util.List[float], int2: int) -> typing.MutableSequence[float]: ...
    @typing.overload
    def trainUser(self, int: int) -> None: ...
    @typing.overload
    def trainUser(self, int: int, int2: int) -> None: ...
    @typing.overload
    def trainUser(self, int: int, list: java.util.List[int], list2: java.util.List[float]) -> None: ...
    @typing.overload
    def trainUser(self, int: int, list: java.util.List[int], list2: java.util.List[float], int2: int) -> None: ...
    def trainUserFeats(self, list: java.util.List[int], list2: java.util.List[float], int: int) -> typing.MutableSequence[float]: ...
    def updateNewItem(self, int: int, list: java.util.List[int], list2: java.util.List[float]) -> None: ...
    def updateNewUser(self, int: int, list: java.util.List[int], list2: java.util.List[float]) -> None: ...
    def updateRemoveItem(self, int: int) -> None: ...
    def updateRemoveRating(self, int: int, int2: int) -> None: ...
    def updateRemoveUser(self, int: int) -> None: ...
    def updateSetRating(self, int: int, int2: int, double: float) -> None: ...

class BaselinePredictor(moa.recommender.rc.predictor.RatingPredictor):
    def __init__(self, recommenderData: moa.recommender.rc.data.RecommenderData): ...
    def getData(self) -> moa.recommender.rc.data.RecommenderData: ...
    def predictRating(self, int: int, int2: int) -> float: ...
    def predictRatings(self, int: int, list: java.util.List[int]) -> java.util.List[float]: ...
    def train(self) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.recommender.rc.predictor.impl")``.

    BRISMFPredictor: typing.Type[BRISMFPredictor]
    BaselinePredictor: typing.Type[BaselinePredictor]
