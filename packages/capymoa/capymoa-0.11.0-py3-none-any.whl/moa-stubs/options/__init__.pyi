
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import com.github.javacliparser
import java.io
import java.lang
import javax.swing.event
import jpype
import moa
import moa.core
import moa.gui
import moa.tasks
import typing



class AbstractClassOption(com.github.javacliparser.AbstractOption):
    FILE_PREFIX_STRING: typing.ClassVar[str] = ...
    INMEM_PREFIX_STRING: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str): ...
    @staticmethod
    def classToCLIString(class_: typing.Type[typing.Any], class2: typing.Type[typing.Any]) -> str: ...
    def getDefaultCLIString(self) -> str: ...
    def getNullString(self) -> str: ...
    def getPreMaterializedObject(self) -> typing.Any: ...
    def getRequiredType(self) -> typing.Type[typing.Any]: ...
    def getValueAsCLIString(self) -> str: ...
    def materializeObject(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> typing.Any: ...
    def setCurrentObject(self, object: typing.Any) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...
    @staticmethod
    def stripPackagePrefix(string: str, class_: typing.Type[typing.Any]) -> str: ...

class DependentOptionsUpdater(javax.swing.event.ChangeListener, java.io.Serializable):
    def __init__(self, classOptionWithListenerOption: 'ClassOptionWithListenerOption', editableMultiChoiceOption: 'EditableMultiChoiceOption'): ...
    @staticmethod
    def getVariedOption(optionHandler: 'OptionHandler', string: str) -> com.github.javacliparser.Option: ...
    def refreshVariedParamNameOption(self) -> None: ...
    def stateChanged(self, changeEvent: javax.swing.event.ChangeEvent) -> None: ...

class EditableMultiChoiceOption(com.github.javacliparser.MultiChoiceOption):
    def __init__(self, string: str, char: str, string2: str, stringArray: typing.Union[typing.List[str], jpype.JArray], stringArray2: typing.Union[typing.List[str], jpype.JArray], int: int): ...
    def registerEditComponent(self, editableMultiChoiceOptionEditComponent: moa.gui.EditableMultiChoiceOptionEditComponent) -> None: ...
    def setOptions(self, stringArray: typing.Union[typing.List[str], jpype.JArray], stringArray2: typing.Union[typing.List[str], jpype.JArray], int: int) -> None: ...

class OptionHandler(moa.MOAObject, com.github.javacliparser.Configurable):
    def copy(self) -> 'OptionHandler': ...
    def getCLICreationString(self, class_: typing.Type[typing.Any]) -> str: ...
    def getOptions(self) -> com.github.javacliparser.Options: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def prepareForUse(self) -> None: ...
    @typing.overload
    def prepareForUse(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...

class OptionsHandler(com.github.javacliparser.JavaCLIParser):
    def __init__(self, object: typing.Any, string: str): ...
    def getPreparedClassOption(self, classOption: 'ClassOption') -> typing.Any: ...
    @typing.overload
    def prepareClassOptions(self) -> None: ...
    @typing.overload
    def prepareClassOptions(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...
    @typing.overload
    def prepareForUse(self) -> None: ...
    @typing.overload
    def prepareForUse(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...

class RequiredOptionNotSpecifiedException(java.lang.Exception):
    def __init__(self): ...

class AbstractOptionHandler(moa.AbstractMOAObject, OptionHandler):
    def __init__(self): ...
    @typing.overload
    def copy(self) -> OptionHandler: ...
    @typing.overload
    @staticmethod
    def copy(mOAObject: moa.MOAObject) -> moa.MOAObject: ...
    def getCLICreationString(self, class_: typing.Type[typing.Any]) -> str: ...
    def getOptions(self) -> com.github.javacliparser.Options: ...
    def getPurposeString(self) -> str: ...
    @typing.overload
    def prepareForUse(self) -> None: ...
    @typing.overload
    def prepareForUse(self, taskMonitor: moa.tasks.TaskMonitor, objectRepository: typing.Union[moa.core.ObjectRepository, typing.Callable]) -> None: ...

class ClassOption(AbstractClassOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str): ...
    @staticmethod
    def cliStringToObject(string: str, class_: typing.Type[typing.Any], optionArray: typing.Union[typing.List[com.github.javacliparser.Option], jpype.JArray]) -> typing.Any: ...
    def getValueAsCLIString(self) -> str: ...
    @staticmethod
    def objectToCLIString(object: typing.Any, class_: typing.Type[typing.Any]) -> str: ...
    def setDefaultCLIString(self, string: str) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class ClassOptionWithNames(AbstractClassOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, stringArray: typing.Union[typing.List[str], jpype.JArray]): ...
    @staticmethod
    def cliStringToObject(string: str, class_: typing.Type[typing.Any], optionArray: typing.Union[typing.List[com.github.javacliparser.Option], jpype.JArray]) -> typing.Any: ...
    def getClassNames(self) -> typing.MutableSequence[str]: ...
    def getValueAsCLIString(self) -> str: ...
    @staticmethod
    def objectToCLIString(object: typing.Any, class_: typing.Type[typing.Any]) -> str: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class WEKAClassOption(AbstractClassOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str): ...
    @staticmethod
    def cliStringToObject(string: str, class_: typing.Type[typing.Any], optionArray: typing.Union[typing.List[com.github.javacliparser.Option], jpype.JArray]) -> typing.Any: ...
    def getValueAsCLIString(self) -> str: ...
    @staticmethod
    def objectToCLIString(object: typing.Any, class_: typing.Type[typing.Any]) -> str: ...
    def setValueViaCLIString(self, string: str) -> None: ...

class ClassOptionWithListenerOption(ClassOption):
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, string4: str, changeListener: typing.Union[javax.swing.event.ChangeListener, typing.Callable]): ...
    @typing.overload
    def __init__(self, string: str, char: str, string2: str, class_: typing.Type[typing.Any], string3: str, changeListener: typing.Union[javax.swing.event.ChangeListener, typing.Callable]): ...
    def getChangeListener(self) -> javax.swing.event.ChangeListener: ...
    def setChangeListener(self, changeListener: typing.Union[javax.swing.event.ChangeListener, typing.Callable]) -> None: ...
    def setValueViaCLIString(self, string: str) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("moa.options")``.

    AbstractClassOption: typing.Type[AbstractClassOption]
    AbstractOptionHandler: typing.Type[AbstractOptionHandler]
    ClassOption: typing.Type[ClassOption]
    ClassOptionWithListenerOption: typing.Type[ClassOptionWithListenerOption]
    ClassOptionWithNames: typing.Type[ClassOptionWithNames]
    DependentOptionsUpdater: typing.Type[DependentOptionsUpdater]
    EditableMultiChoiceOption: typing.Type[EditableMultiChoiceOption]
    OptionHandler: typing.Type[OptionHandler]
    OptionsHandler: typing.Type[OptionsHandler]
    RequiredOptionNotSpecifiedException: typing.Type[RequiredOptionNotSpecifiedException]
    WEKAClassOption: typing.Type[WEKAClassOption]
