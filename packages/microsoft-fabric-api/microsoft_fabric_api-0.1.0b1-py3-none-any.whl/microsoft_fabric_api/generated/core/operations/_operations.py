# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/python@6.15.0)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Iterator, Optional, Type, TypeVar, Union, cast, overload

from azure.core import MatchConditions
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceModifiedError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._serialization import Serializer
from .._vendor import prep_if_match, prep_if_none_match

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_workspaces_create_workspace_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_list_workspaces_request(
    *,
    roles: Optional[str] = None,
    continuation_token_parameter: Optional[str] = None,
    prefer_workspace_specific_endpoints: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces"

    # Construct parameters
    if roles is not None:
        _params["roles"] = _SERIALIZER.query("roles", roles, "str")
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )
    if prefer_workspace_specific_endpoints is not None:
        _params["preferWorkspaceSpecificEndpoints"] = _SERIALIZER.query(
            "prefer_workspace_specific_endpoints", prefer_workspace_specific_endpoints, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_workspaces_get_workspace_request(
    workspace_id: str, *, prefer_workspace_specific_endpoints: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if prefer_workspace_specific_endpoints is not None:
        _params["preferWorkspaceSpecificEndpoints"] = _SERIALIZER.query(
            "prefer_workspace_specific_endpoints", prefer_workspace_specific_endpoints, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_workspaces_update_workspace_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_workspaces_delete_workspace_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_workspaces_add_workspace_role_assignment_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/roleAssignments"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_list_workspace_role_assignments_request(  # pylint: disable=name-too-long
    workspace_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/roleAssignments"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_workspaces_delete_workspace_role_assignment_request(  # pylint: disable=name-too-long
    workspace_id: str, workspace_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/roleAssignments/{workspaceRoleAssignmentId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "workspaceRoleAssignmentId": _SERIALIZER.url(
            "workspace_role_assignment_id", workspace_role_assignment_id, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_workspaces_update_workspace_role_assignment_request(  # pylint: disable=name-too-long
    workspace_id: str, workspace_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/roleAssignments/{workspaceRoleAssignmentId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "workspaceRoleAssignmentId": _SERIALIZER.url(
            "workspace_role_assignment_id", workspace_role_assignment_id, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_workspaces_get_workspace_role_assignment_request(  # pylint: disable=name-too-long
    workspace_id: str, workspace_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/roleAssignments/{workspaceRoleAssignmentId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "workspaceRoleAssignmentId": _SERIALIZER.url(
            "workspace_role_assignment_id", workspace_role_assignment_id, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_workspaces_assign_to_capacity_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/assignToCapacity"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_unassign_from_capacity_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/unassignFromCapacity"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_assign_to_domain_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/assignToDomain"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_unassign_from_domain_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/unassignFromDomain"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_provision_identity_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/provisionIdentity"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_deprovision_identity_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/deprovisionIdentity"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_workspaces_get_network_communication_policy_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/networking/communicationPolicy"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_workspaces_set_network_communication_policy_request(  # pylint: disable=name-too-long
    workspace_id: str, *, etag: Optional[str] = None, match_condition: Optional[MatchConditions] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/networking/communicationPolicy"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_items_list_items_request(
    workspace_id: str,
    *,
    type: Optional[str] = None,
    recursive: Optional[bool] = None,
    root_folder_id: Optional[str] = None,
    continuation_token_parameter: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if type is not None:
        _params["type"] = _SERIALIZER.query("type", type, "str")
    if recursive is not None:
        _params["recursive"] = _SERIALIZER.query("recursive", recursive, "bool")
    if root_folder_id is not None:
        _params["rootFolderId"] = _SERIALIZER.query("root_folder_id", root_folder_id, "str")
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_create_item_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_items_get_item_request(workspace_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_items_update_item_request(workspace_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_items_delete_item_request(workspace_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_items_get_item_definition_request(
    workspace_id: str, item_id: str, *, format: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/getDefinition"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_update_item_definition_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, *, update_metadata: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/updateDefinition"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if update_metadata is not None:
        _params["updateMetadata"] = _SERIALIZER.query("update_metadata", update_metadata, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_list_item_connections_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/connections"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_items_bulk_move_items_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/bulkMove"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_items_move_item_request(workspace_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/move"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_job_scheduler_list_item_schedules_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_type: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/{jobType}/schedules"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobType": _SERIALIZER.url("job_type", job_type, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_job_scheduler_create_item_schedule_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_type: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/{jobType}/schedules"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobType": _SERIALIZER.url("job_type", job_type, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_job_scheduler_get_item_schedule_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_type: str, schedule_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/{jobType}/schedules/{scheduleId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobType": _SERIALIZER.url("job_type", job_type, "str"),
        "scheduleId": _SERIALIZER.url("schedule_id", schedule_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_job_scheduler_update_item_schedule_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_type: str, schedule_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/{jobType}/schedules/{scheduleId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobType": _SERIALIZER.url("job_type", job_type, "str"),
        "scheduleId": _SERIALIZER.url("schedule_id", schedule_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_job_scheduler_delete_item_schedule_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_type: str, schedule_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/{jobType}/schedules/{scheduleId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobType": _SERIALIZER.url("job_type", job_type, "str"),
        "scheduleId": _SERIALIZER.url("schedule_id", schedule_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_job_scheduler_get_item_job_instance_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_instance_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/instances/{jobInstanceId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobInstanceId": _SERIALIZER.url("job_instance_id", job_instance_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_job_scheduler_list_item_job_instances_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/instances"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_job_scheduler_run_on_demand_item_job_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, *, job_type: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/instances"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["jobType"] = _SERIALIZER.query("job_type", job_type, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_job_scheduler_cancel_item_job_instance_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, job_instance_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/jobs/instances/{jobInstanceId}/cancel"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "jobInstanceId": _SERIALIZER.url("job_instance_id", job_instance_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_git_get_connection_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/connection"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_git_connect_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/connect"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_git_disconnect_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/disconnect"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_git_initialize_connection_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/initializeConnection"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_git_update_from_git_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/updateFromGit"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_git_get_status_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/status"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_git_commit_to_git_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/commitToGit"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_git_get_my_git_credentials_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/myGitCredentials"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_git_update_my_git_credentials_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/git/myGitCredentials"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_capacities_list_capacities_request(
    *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/capacities"

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_long_running_operations_get_operation_state_request(  # pylint: disable=name-too-long
    operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/operations/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_long_running_operations_get_operation_result_request(  # pylint: disable=name-too-long
    operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json, application/octet-stream")

    # Construct URL
    _url = "/operations/{operationId}/result"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_one_lake_shortcuts_creates_shortcuts_in_bulk_request(  # pylint: disable=name-too-long
    workspace_id: str,
    item_id: str,
    *,
    shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/shortcuts/bulkCreate"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if shortcut_conflict_policy is not None:
        _params["shortcutConflictPolicy"] = _SERIALIZER.query(
            "shortcut_conflict_policy", shortcut_conflict_policy, "str"
        )

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_one_lake_shortcuts_list_shortcuts_request(  # pylint: disable=name-too-long
    workspace_id: str,
    item_id: str,
    *,
    parent_path: Optional[str] = None,
    continuation_token_parameter: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/shortcuts"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if parent_path is not None:
        _params["parentPath"] = _SERIALIZER.query("parent_path", parent_path, "str")
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_one_lake_shortcuts_create_shortcut_request(  # pylint: disable=name-too-long
    workspace_id: str,
    item_id: str,
    *,
    shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/shortcuts"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if shortcut_conflict_policy is not None:
        _params["shortcutConflictPolicy"] = _SERIALIZER.query(
            "shortcut_conflict_policy", shortcut_conflict_policy, "str"
        )

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_one_lake_shortcuts_get_shortcut_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, shortcut_path: str, shortcut_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/shortcuts/{shortcutPath}/{shortcutName}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "shortcutPath": _SERIALIZER.url("shortcut_path", shortcut_path, "str"),
        "shortcutName": _SERIALIZER.url("shortcut_name", shortcut_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_one_lake_shortcuts_delete_shortcut_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, shortcut_path: str, shortcut_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/shortcuts/{shortcutPath}/{shortcutName}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "shortcutPath": _SERIALIZER.url("shortcut_path", shortcut_path, "str"),
        "shortcutName": _SERIALIZER.url("shortcut_name", shortcut_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_one_lake_shortcuts_reset_shortcut_cache_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/onelake/resetShortcutCache"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_tags_list_tags_request(*, continuation_token_parameter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/tags"

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_apply_tags_request(workspace_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/applyTags"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_tags_unapply_tags_request(workspace_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/unapplyTags"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_domains_list_domains_request(
    *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/domains"

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_domains_get_domain_request(domain_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/domains/{domainId}"
    path_format_arguments = {
        "domainId": _SERIALIZER.url("domain_id", domain_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_list_deployment_pipelines_request(  # pylint: disable=name-too-long
    *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines"

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_pipelines_create_deployment_pipeline_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_get_deployment_pipeline_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_update_deployment_pipeline_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_delete_deployment_pipeline_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_list_deployment_pipeline_role_assignments_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/roleAssignments"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_pipelines_add_deployment_pipeline_role_assignment_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/roleAssignments"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_delete_deployment_pipeline_role_assignment_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, principal_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/roleAssignments/{principalId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "principalId": _SERIALIZER.url("principal_id", principal_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_list_deployment_pipeline_operations_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/operations"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_pipelines_get_deployment_pipeline_operation_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/operations/{operationId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_list_deployment_pipeline_stages_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/stages"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_pipelines_get_deployment_pipeline_stage_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, stage_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/stages/{stageId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "stageId": _SERIALIZER.url("stage_id", stage_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_update_deployment_pipeline_stage_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, stage_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/stages/{stageId}"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "stageId": _SERIALIZER.url("stage_id", stage_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_list_deployment_pipeline_stage_items_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, stage_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/stages/{stageId}/items"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "stageId": _SERIALIZER.url("stage_id", stage_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_pipelines_deploy_stage_content_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/deploy"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_assign_workspace_to_stage_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, stage_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/stages/{stageId}/assignWorkspace"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "stageId": _SERIALIZER.url("stage_id", stage_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_deployment_pipelines_unassign_workspace_from_stage_request(  # pylint: disable=name-too-long
    deployment_pipeline_id: str, stage_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deploymentPipelines/{deploymentPipelineId}/stages/{stageId}/unassignWorkspace"
    path_format_arguments = {
        "deploymentPipelineId": _SERIALIZER.url("deployment_pipeline_id", deployment_pipeline_id, "str"),
        "stageId": _SERIALIZER.url("stage_id", stage_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_one_lake_data_access_security_list_data_access_roles_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/dataAccessRoles"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_one_lake_data_access_security_create_or_update_data_access_roles_request(  # pylint: disable=name-too-long
    workspace_id: str,
    item_id: str,
    *,
    dry_run: Optional[bool] = None,
    etag: Optional[str] = None,
    match_condition: Optional[MatchConditions] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/dataAccessRoles"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if dry_run is not None:
        _params["dryRun"] = _SERIALIZER.query("dry_run", dry_run, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if_match = prep_if_match(etag, match_condition)
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if_none_match = prep_if_none_match(etag, match_condition)
    if if_none_match is not None:
        _headers["If-None-Match"] = _SERIALIZER.header("if_none_match", if_none_match, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_external_data_shares_provider_create_external_data_share_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/externalDataShares"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_external_data_shares_provider_list_external_data_shares_in_item_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/externalDataShares"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_external_data_shares_provider_get_external_data_share_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, external_data_share_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/externalDataShares/{externalDataShareId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "externalDataShareId": _SERIALIZER.url("external_data_share_id", external_data_share_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_external_data_shares_provider_delete_external_data_share_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, external_data_share_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/externalDataShares/{externalDataShareId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "externalDataShareId": _SERIALIZER.url("external_data_share_id", external_data_share_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_external_data_shares_provider_revoke_external_data_share_request(  # pylint: disable=name-too-long
    workspace_id: str, item_id: str, external_data_share_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/items/{itemId}/externalDataShares/{externalDataShareId}/revoke"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "externalDataShareId": _SERIALIZER.url("external_data_share_id", external_data_share_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_external_data_shares_recipient_get_external_data_share_invitation_details_request(  # pylint: disable=name-too-long
    invitation_id: str, *, provider_tenant_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/externalDataShares/invitations/{invitationId}"
    path_format_arguments = {
        "invitationId": _SERIALIZER.url("invitation_id", invitation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["providerTenantId"] = _SERIALIZER.query("provider_tenant_id", provider_tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_external_data_shares_recipient_accept_external_data_share_invitation_request(  # pylint: disable=name-too-long
    invitation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/externalDataShares/invitations/{invitationId}/accept"
    path_format_arguments = {
        "invitationId": _SERIALIZER.url("invitation_id", invitation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_folders_list_folders_request(
    workspace_id: str,
    *,
    root_folder_id: Optional[str] = None,
    recursive: Optional[bool] = None,
    continuation_token_parameter: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/folders"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if root_folder_id is not None:
        _params["rootFolderId"] = _SERIALIZER.query("root_folder_id", root_folder_id, "str")
    if recursive is not None:
        _params["recursive"] = _SERIALIZER.query("recursive", recursive, "bool")
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_folders_create_folder_request(workspace_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/folders"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_folders_get_folder_request(workspace_id: str, folder_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/folders/{folderId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "folderId": _SERIALIZER.url("folder_id", folder_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_folders_update_folder_request(workspace_id: str, folder_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/folders/{folderId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "folderId": _SERIALIZER.url("folder_id", folder_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_folders_delete_folder_request(workspace_id: str, folder_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/folders/{folderId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "folderId": _SERIALIZER.url("folder_id", folder_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_folders_move_folder_request(workspace_id: str, folder_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/folders/{folderId}/move"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "folderId": _SERIALIZER.url("folder_id", folder_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_managed_private_endpoints_list_workspace_managed_private_endpoints_request(  # pylint: disable=name-too-long
    workspace_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/managedPrivateEndpoints"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_managed_private_endpoints_create_workspace_managed_private_endpoint_request(  # pylint: disable=name-too-long
    workspace_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/managedPrivateEndpoints"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_managed_private_endpoints_delete_workspace_managed_private_endpoint_request(  # pylint: disable=name-too-long
    workspace_id: str, managed_private_endpoint_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/managedPrivateEndpoints/{managedPrivateEndpointId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "managedPrivateEndpointId": _SERIALIZER.url("managed_private_endpoint_id", managed_private_endpoint_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_managed_private_endpoints_get_workspace_managed_private_endpoint_request(  # pylint: disable=name-too-long
    workspace_id: str, managed_private_endpoint_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/workspaces/{workspaceId}/managedPrivateEndpoints/{managedPrivateEndpointId}"
    path_format_arguments = {
        "workspaceId": _SERIALIZER.url("workspace_id", workspace_id, "str"),
        "managedPrivateEndpointId": _SERIALIZER.url("managed_private_endpoint_id", managed_private_endpoint_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_connections_list_connections_request(  # pylint: disable=name-too-long
    *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections"

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_connections_create_connection_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_connections_get_connection_request(connection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_connections_update_connection_request(  # pylint: disable=name-too-long
    connection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_connections_delete_connection_request(  # pylint: disable=name-too-long
    connection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_connections_list_supported_connection_types_request(  # pylint: disable=name-too-long
    *,
    gateway_id: Optional[str] = None,
    show_all_creation_methods: Optional[bool] = None,
    continuation_token_parameter: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/supportedConnectionTypes"

    # Construct parameters
    if gateway_id is not None:
        _params["gatewayId"] = _SERIALIZER.query("gateway_id", gateway_id, "str")
    if show_all_creation_methods is not None:
        _params["showAllCreationMethods"] = _SERIALIZER.query(
            "show_all_creation_methods", show_all_creation_methods, "bool"
        )
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_connections_list_connection_role_assignments_request(  # pylint: disable=name-too-long
    connection_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}/roleAssignments"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_connections_add_connection_role_assignment_request(  # pylint: disable=name-too-long
    connection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}/roleAssignments"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_connections_get_connection_role_assignment_request(  # pylint: disable=name-too-long
    connection_id: str, connection_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}/roleAssignments/{connectionRoleAssignmentId}"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
        "connectionRoleAssignmentId": _SERIALIZER.url(
            "connection_role_assignment_id", connection_role_assignment_id, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_connections_update_connection_role_assignment_request(  # pylint: disable=name-too-long
    connection_id: str, connection_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}/roleAssignments/{connectionRoleAssignmentId}"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
        "connectionRoleAssignmentId": _SERIALIZER.url(
            "connection_role_assignment_id", connection_role_assignment_id, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_connections_delete_connection_role_assignment_request(  # pylint: disable=name-too-long
    connection_id: str, connection_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/connections/{connectionId}/roleAssignments/{connectionRoleAssignmentId}"
    path_format_arguments = {
        "connectionId": _SERIALIZER.url("connection_id", connection_id, "str"),
        "connectionRoleAssignmentId": _SERIALIZER.url(
            "connection_role_assignment_id", connection_role_assignment_id, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_gateways_list_gateways_request(
    *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways"

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_gateways_create_gateway_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_gateways_get_gateway_request(gateway_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_gateways_update_gateway_request(gateway_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_gateways_delete_gateway_request(gateway_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_gateways_list_gateway_members_request(  # pylint: disable=name-too-long
    gateway_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/members"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_gateways_update_gateway_member_request(  # pylint: disable=name-too-long
    gateway_id: str, gateway_member_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/members/{gatewayMemberId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
        "gatewayMemberId": _SERIALIZER.url("gateway_member_id", gateway_member_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_gateways_delete_gateway_member_request(  # pylint: disable=name-too-long
    gateway_id: str, gateway_member_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/members/{gatewayMemberId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
        "gatewayMemberId": _SERIALIZER.url("gateway_member_id", gateway_member_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_gateways_list_gateway_role_assignments_request(  # pylint: disable=name-too-long
    gateway_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/roleAssignments"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if continuation_token_parameter is not None:
        _params["continuationToken"] = _SERIALIZER.query(
            "continuation_token_parameter", continuation_token_parameter, "str"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_gateways_add_gateway_role_assignment_request(  # pylint: disable=name-too-long
    gateway_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/roleAssignments"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_gateways_get_gateway_role_assignment_request(  # pylint: disable=name-too-long
    gateway_id: str, gateway_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/roleAssignments/{gatewayRoleAssignmentId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
        "gatewayRoleAssignmentId": _SERIALIZER.url("gateway_role_assignment_id", gateway_role_assignment_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_gateways_update_gateway_role_assignment_request(  # pylint: disable=name-too-long
    gateway_id: str, gateway_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/roleAssignments/{gatewayRoleAssignmentId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
        "gatewayRoleAssignmentId": _SERIALIZER.url("gateway_role_assignment_id", gateway_role_assignment_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_gateways_delete_gateway_role_assignment_request(  # pylint: disable=name-too-long
    gateway_id: str, gateway_role_assignment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/gateways/{gatewayId}/roleAssignments/{gatewayRoleAssignmentId}"
    path_format_arguments = {
        "gatewayId": _SERIALIZER.url("gateway_id", gateway_id, "str"),
        "gatewayRoleAssignmentId": _SERIALIZER.url("gateway_role_assignment_id", gateway_role_assignment_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


class WorkspacesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`workspaces` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create_workspace(
        self,
        create_workspace_request: _models.CreateWorkspaceRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Workspace:
        """Creates a new workspace.

        Permissions
        -----------


        * The caller must have permission to create workspaces granted by Fabric administrator. For
        more information see: `create workspaces
        </fabric/admin/portal-workspace#create-workspaces-new-workspace-experience>`_.
        * The caller must have *contributor* permissions or be an Admin on the capacity. For more
        information, see: `capacity user permissions
        </power-bi/enterprise/service-admin-premium-manage#manage-user-permissions>`_.
        * Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_workspace_request: Create workspace request payload. Required.
        :type create_workspace_request: ~microsoft.fabric.api.core.models.CreateWorkspaceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Workspace
        :rtype: ~microsoft.fabric.api.core.models.Workspace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_workspace(
        self, create_workspace_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Workspace:
        """Creates a new workspace.

        Permissions
        -----------


        * The caller must have permission to create workspaces granted by Fabric administrator. For
        more information see: `create workspaces
        </fabric/admin/portal-workspace#create-workspaces-new-workspace-experience>`_.
        * The caller must have *contributor* permissions or be an Admin on the capacity. For more
        information, see: `capacity user permissions
        </power-bi/enterprise/service-admin-premium-manage#manage-user-permissions>`_.
        * Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_workspace_request: Create workspace request payload. Required.
        :type create_workspace_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Workspace
        :rtype: ~microsoft.fabric.api.core.models.Workspace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_workspace(
        self, create_workspace_request: Union[_models.CreateWorkspaceRequest, IO[bytes]], **kwargs: Any
    ) -> _models.Workspace:
        """Creates a new workspace.

        Permissions
        -----------


        * The caller must have permission to create workspaces granted by Fabric administrator. For
        more information see: `create workspaces
        </fabric/admin/portal-workspace#create-workspaces-new-workspace-experience>`_.
        * The caller must have *contributor* permissions or be an Admin on the capacity. For more
        information, see: `capacity user permissions
        </power-bi/enterprise/service-admin-premium-manage#manage-user-permissions>`_.
        * Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_workspace_request: Create workspace request payload. Is either a
         CreateWorkspaceRequest type or a IO[bytes] type. Required.
        :type create_workspace_request: ~microsoft.fabric.api.core.models.CreateWorkspaceRequest or
         IO[bytes]
        :return: Workspace
        :rtype: ~microsoft.fabric.api.core.models.Workspace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Workspace] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_workspace_request, (IOBase, bytes)):
            _content = create_workspace_request
        else:
            _json = self._serialize.body(create_workspace_request, "CreateWorkspaceRequest")

        _request = build_workspaces_create_workspace_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("Workspace", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_workspaces(
        self,
        *,
        roles: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        prefer_workspace_specific_endpoints: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterable["_models.Workspace"]:
        """Returns a list of workspaces the principal can access. Use the roles query parameter to filter
        results by the principal workspace role.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword roles: A list of `roles
         </power-bi/collaborate-share/service-roles-new-workspaces#workspace-roles>`_. Separate values
         using a comma. If not provided, all workspaces are returned. Default value is None.
        :paramtype roles: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :keyword prefer_workspace_specific_endpoints: A setting that controls whether to include the
         workspace-specific API endpoint per workspace. True - Include the workspace-specific API
         endpoint, False - Do not include the workspace-specific API endpoint. Default value is None.
        :paramtype prefer_workspace_specific_endpoints: bool
        :return: An iterator like instance of Workspace
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Workspace]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Workspaces] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workspaces_list_workspaces_request(
                    roles=roles,
                    continuation_token_parameter=continuation_token_parameter,
                    prefer_workspace_specific_endpoints=prefer_workspace_specific_endpoints,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Workspaces, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_workspace(
        self, workspace_id: str, *, prefer_workspace_specific_endpoints: Optional[bool] = None, **kwargs: Any
    ) -> _models.WorkspaceInfo:
        """Returns specified workspace information.

        Permissions
        -----------

         The caller must have *viewer* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :keyword prefer_workspace_specific_endpoints: A setting that controls whether to include
         workspace-specific or general public endpoints for API and OneLake access. True - Include
         workspace-specific endpoints for API and OneLake access, False - Include general public
         endpoints for OneLake access. Default value is None.
        :paramtype prefer_workspace_specific_endpoints: bool
        :return: WorkspaceInfo
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceInfo] = kwargs.pop("cls", None)

        _request = build_workspaces_get_workspace_request(
            workspace_id=workspace_id,
            prefer_workspace_specific_endpoints=prefer_workspace_specific_endpoints,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("WorkspaceInfo", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_workspace(
        self,
        workspace_id: str,
        update_workspace_request: _models.UpdateWorkspaceRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Workspace:
        """Updates the specified workspace properties.

        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_workspace_request: Update workspace request payload. Required.
        :type update_workspace_request: ~microsoft.fabric.api.core.models.UpdateWorkspaceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Workspace
        :rtype: ~microsoft.fabric.api.core.models.Workspace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_workspace(
        self,
        workspace_id: str,
        update_workspace_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Workspace:
        """Updates the specified workspace properties.

        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_workspace_request: Update workspace request payload. Required.
        :type update_workspace_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Workspace
        :rtype: ~microsoft.fabric.api.core.models.Workspace
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_workspace(
        self,
        workspace_id: str,
        update_workspace_request: Union[_models.UpdateWorkspaceRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.Workspace:
        """Updates the specified workspace properties.

        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_workspace_request: Update workspace request payload. Is either a
         UpdateWorkspaceRequest type or a IO[bytes] type. Required.
        :type update_workspace_request: ~microsoft.fabric.api.core.models.UpdateWorkspaceRequest or
         IO[bytes]
        :return: Workspace
        :rtype: ~microsoft.fabric.api.core.models.Workspace
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Workspace] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_workspace_request, (IOBase, bytes)):
            _content = update_workspace_request
        else:
            _json = self._serialize.body(update_workspace_request, "UpdateWorkspaceRequest")

        _request = build_workspaces_update_workspace_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Workspace", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_workspace(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified workspace and the items under it.

        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workspaces_delete_workspace_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def add_workspace_role_assignment(
        self,
        workspace_id: str,
        workspace_role_assignment_request: _models.AddWorkspaceRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.WorkspaceRoleAssignment:
        """Adds a workspace role assignment.

        To get the principal user object ID required for request body, see `Find the user object ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *member* or higher workspace role.
        * Members can add members or others with lower permissions. For more information see:
        `workspace roles </power-bi/collaborate-share/service-roles-new-workspaces#workspace-roles>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------


        * Each workspace is limited to a maximum of 1,000 users or groups in workspace roles (Admin,
        Member, Contributor, Viewer). The number of users within a group is not limited. The limitation
        also covers external guests.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_request: Add workspace role assignment request payload.
         Required.
        :type workspace_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddWorkspaceRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_workspace_role_assignment(
        self,
        workspace_id: str,
        workspace_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.WorkspaceRoleAssignment:
        """Adds a workspace role assignment.

        To get the principal user object ID required for request body, see `Find the user object ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *member* or higher workspace role.
        * Members can add members or others with lower permissions. For more information see:
        `workspace roles </power-bi/collaborate-share/service-roles-new-workspaces#workspace-roles>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------


        * Each workspace is limited to a maximum of 1,000 users or groups in workspace roles (Admin,
        Member, Contributor, Viewer). The number of users within a group is not limited. The limitation
        also covers external guests.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_request: Add workspace role assignment request payload.
         Required.
        :type workspace_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_workspace_role_assignment(
        self,
        workspace_id: str,
        workspace_role_assignment_request: Union[_models.AddWorkspaceRoleAssignmentRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.WorkspaceRoleAssignment:
        """Adds a workspace role assignment.

        To get the principal user object ID required for request body, see `Find the user object ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *member* or higher workspace role.
        * Members can add members or others with lower permissions. For more information see:
        `workspace roles </power-bi/collaborate-share/service-roles-new-workspaces#workspace-roles>`_.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------


        * Each workspace is limited to a maximum of 1,000 users or groups in workspace roles (Admin,
        Member, Contributor, Viewer). The number of users within a group is not limited. The limitation
        also covers external guests.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_request: Add workspace role assignment request payload. Is
         either a AddWorkspaceRoleAssignmentRequest type or a IO[bytes] type. Required.
        :type workspace_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddWorkspaceRoleAssignmentRequest or IO[bytes]
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(workspace_role_assignment_request, (IOBase, bytes)):
            _content = workspace_role_assignment_request
        else:
            _json = self._serialize.body(workspace_role_assignment_request, "AddWorkspaceRoleAssignmentRequest")

        _request = build_workspaces_add_workspace_role_assignment_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("WorkspaceRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_workspace_role_assignments(
        self, workspace_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.WorkspaceRoleAssignment"]:
        """Returns a list of workspace role assignments.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------

         The caller must have *member* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of WorkspaceRoleAssignment
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.WorkspaceRoleAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.WorkspaceRoleAssignments] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_workspaces_list_workspace_role_assignments_request(
                    workspace_id=workspace_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.WorkspaceRoleAssignments, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def delete_workspace_role_assignment(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, workspace_role_assignment_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified workspace role assignment.

        The role assignment of the last admin can't be deleted.

        Permissions
        -----------

         The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

         Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_id: The workspace role assignment ID. Required.
        :type workspace_role_assignment_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workspaces_delete_workspace_role_assignment_request(
            workspace_id=workspace_id,
            workspace_role_assignment_id=workspace_role_assignment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def update_workspace_role_assignment(
        self,
        workspace_id: str,
        workspace_role_assignment_id: str,
        update_workspace_role_assignment_request: _models.UpdateWorkspaceRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.WorkspaceRoleAssignment:
        """Updates a workspace role assignment.

        The role assignment of the last admin can't be changed.

        Permissions
        -----------

        The caller must have *admin* role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_id: The workspace role assignment ID. Required.
        :type workspace_role_assignment_id: str
        :param update_workspace_role_assignment_request: Update workspace role assignment request
         payload. Required.
        :type update_workspace_role_assignment_request:
         ~microsoft.fabric.api.core.models.UpdateWorkspaceRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_workspace_role_assignment(
        self,
        workspace_id: str,
        workspace_role_assignment_id: str,
        update_workspace_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.WorkspaceRoleAssignment:
        """Updates a workspace role assignment.

        The role assignment of the last admin can't be changed.

        Permissions
        -----------

        The caller must have *admin* role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_id: The workspace role assignment ID. Required.
        :type workspace_role_assignment_id: str
        :param update_workspace_role_assignment_request: Update workspace role assignment request
         payload. Required.
        :type update_workspace_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_workspace_role_assignment(
        self,
        workspace_id: str,
        workspace_role_assignment_id: str,
        update_workspace_role_assignment_request: Union[_models.UpdateWorkspaceRoleAssignmentRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.WorkspaceRoleAssignment:
        """Updates a workspace role assignment.

        The role assignment of the last admin can't be changed.

        Permissions
        -----------

        The caller must have *admin* role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_id: The workspace role assignment ID. Required.
        :type workspace_role_assignment_id: str
        :param update_workspace_role_assignment_request: Update workspace role assignment request
         payload. Is either a UpdateWorkspaceRoleAssignmentRequest type or a IO[bytes] type. Required.
        :type update_workspace_role_assignment_request:
         ~microsoft.fabric.api.core.models.UpdateWorkspaceRoleAssignmentRequest or IO[bytes]
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.WorkspaceRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_workspace_role_assignment_request, (IOBase, bytes)):
            _content = update_workspace_role_assignment_request
        else:
            _json = self._serialize.body(
                update_workspace_role_assignment_request, "UpdateWorkspaceRoleAssignmentRequest"
            )

        _request = build_workspaces_update_workspace_role_assignment_request(
            workspace_id=workspace_id,
            workspace_role_assignment_id=workspace_role_assignment_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("WorkspaceRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_workspace_role_assignment(
        self, workspace_id: str, workspace_role_assignment_id: str, **kwargs: Any
    ) -> _models.WorkspaceRoleAssignment:
        """Returns information of a workspace role assignment.

        Permissions
        -----------

         The caller must have *member* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param workspace_role_assignment_id: The workspace role assignment ID. Required.
        :type workspace_role_assignment_id: str
        :return: WorkspaceRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceRoleAssignment] = kwargs.pop("cls", None)

        _request = build_workspaces_get_workspace_role_assignment_request(
            workspace_id=workspace_id,
            workspace_role_assignment_id=workspace_role_assignment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("WorkspaceRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def assign_to_capacity(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        assign_workspace_to_capacity_request: _models.AssignWorkspaceToCapacityRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified capacity.

        Permissions
        -----------


        * The caller must have *contributor* permissions or be an capacity Admin.
        * The caller must have *admin* workspace role.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * Fabric items (non-PowerBI) don't support migration across region. For more information see
        `moving data around </fabric/admin/portal-workspaces#moving-data-around>`_.
        * Workspaces with Fabric items (non-PowerBI) can only be assigned to Fabric, Fabric trial or
        Power BI Premium capacity. For more information see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param assign_workspace_to_capacity_request: Assign to capacity parameters. Required.
        :type assign_workspace_to_capacity_request:
         ~microsoft.fabric.api.core.models.AssignWorkspaceToCapacityRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def assign_to_capacity(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        assign_workspace_to_capacity_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified capacity.

        Permissions
        -----------


        * The caller must have *contributor* permissions or be an capacity Admin.
        * The caller must have *admin* workspace role.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * Fabric items (non-PowerBI) don't support migration across region. For more information see
        `moving data around </fabric/admin/portal-workspaces#moving-data-around>`_.
        * Workspaces with Fabric items (non-PowerBI) can only be assigned to Fabric, Fabric trial or
        Power BI Premium capacity. For more information see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param assign_workspace_to_capacity_request: Assign to capacity parameters. Required.
        :type assign_workspace_to_capacity_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def assign_to_capacity(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        assign_workspace_to_capacity_request: Union[_models.AssignWorkspaceToCapacityRequest, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified capacity.

        Permissions
        -----------


        * The caller must have *contributor* permissions or be an capacity Admin.
        * The caller must have *admin* workspace role.

        Required Scope
        --------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * Fabric items (non-PowerBI) don't support migration across region. For more information see
        `moving data around </fabric/admin/portal-workspaces#moving-data-around>`_.
        * Workspaces with Fabric items (non-PowerBI) can only be assigned to Fabric, Fabric trial or
        Power BI Premium capacity. For more information see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param assign_workspace_to_capacity_request: Assign to capacity parameters. Is either a
         AssignWorkspaceToCapacityRequest type or a IO[bytes] type. Required.
        :type assign_workspace_to_capacity_request:
         ~microsoft.fabric.api.core.models.AssignWorkspaceToCapacityRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(assign_workspace_to_capacity_request, (IOBase, bytes)):
            _content = assign_workspace_to_capacity_request
        else:
            _json = self._serialize.body(assign_workspace_to_capacity_request, "AssignWorkspaceToCapacityRequest")

        _request = build_workspaces_assign_to_capacity_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def unassign_from_capacity(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, **kwargs: Any
    ) -> None:
        """Unassigns the specified workspace from capacity.

        Permissions
        -----------

         The caller must have *admin* role on the workspace.

        Required Delegated Scopes
        -------------------------

        Capacity.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------

         Workspaces with Fabric items (non-PowerBI) cannot be unassigned from capacity of supported
        type. For more information see: `moving data around
        </fabric/admin/portal-workspaces#moving-data-around>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workspaces_unassign_from_capacity_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def assign_to_domain(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        assign_workspace_to_domain_request: _models.AssignWorkspaceToDomainRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified domain.

        Permissions
        -----------


        * The caller must have contributor permissions or be a domain Admin.
        * The caller must have workspace admin role.

        Required Scope
        --------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param assign_workspace_to_domain_request: Assign to domain parameters. Required.
        :type assign_workspace_to_domain_request:
         ~microsoft.fabric.api.core.models.AssignWorkspaceToDomainRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def assign_to_domain(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        assign_workspace_to_domain_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified domain.

        Permissions
        -----------


        * The caller must have contributor permissions or be a domain Admin.
        * The caller must have workspace admin role.

        Required Scope
        --------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param assign_workspace_to_domain_request: Assign to domain parameters. Required.
        :type assign_workspace_to_domain_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def assign_to_domain(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        assign_workspace_to_domain_request: Union[_models.AssignWorkspaceToDomainRequest, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified domain.

        Permissions
        -----------


        * The caller must have contributor permissions or be a domain Admin.
        * The caller must have workspace admin role.

        Required Scope
        --------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param assign_workspace_to_domain_request: Assign to domain parameters. Is either a
         AssignWorkspaceToDomainRequest type or a IO[bytes] type. Required.
        :type assign_workspace_to_domain_request:
         ~microsoft.fabric.api.core.models.AssignWorkspaceToDomainRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(assign_workspace_to_domain_request, (IOBase, bytes)):
            _content = assign_workspace_to_domain_request
        else:
            _json = self._serialize.body(assign_workspace_to_domain_request, "AssignWorkspaceToDomainRequest")

        _request = build_workspaces_assign_to_domain_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def unassign_from_domain(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, **kwargs: Any
    ) -> None:
        """Unassigns the specified workspace from domain.

        Permissions
        -----------

         The caller must have workspace admin role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_workspaces_unassign_from_domain_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    def _provision_identity_initial(self, workspace_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_workspaces_provision_identity_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_provision_identity(self, workspace_id: str, **kwargs: Any) -> LROPoller[_models.WorkspaceIdentity]:
        """Provision a workspace identity for a workspace.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have an *admin* role in the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :return: An instance of LROPoller that returns WorkspaceIdentity
        :rtype: ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.WorkspaceIdentity]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceIdentity] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._provision_identity_initial(
                workspace_id=workspace_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("WorkspaceIdentity", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.WorkspaceIdentity].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.WorkspaceIdentity](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _deprovision_identity_initial(self, workspace_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_workspaces_deprovision_identity_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_deprovision_identity(self, workspace_id: str, **kwargs: Any) -> LROPoller[None]:
        """Deprovision a workspace identity.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have an *admin* role in the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._deprovision_identity_initial(
                workspace_id=workspace_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_network_communication_policy(
        self, workspace_id: str, **kwargs: Any
    ) -> _models.WorkspaceNetworkingCommunicationPolicy:
        """Returns networking communication policy for the specified workspace. This feature is currently
        in preview.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *viewer* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: WorkspaceNetworkingCommunicationPolicy
        :rtype: ~microsoft.fabric.api.core.models.WorkspaceNetworkingCommunicationPolicy
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.WorkspaceNetworkingCommunicationPolicy] = kwargs.pop("cls", None)

        _request = build_workspaces_get_network_communication_policy_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        deserialized = self._deserialize("WorkspaceNetworkingCommunicationPolicy", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def set_network_communication_policy(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        set_workspace_networking_communication_policy: _models.WorkspaceNetworkingCommunicationPolicy,
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any,
    ) -> None:
        """Sets networking communication policy for the specified workspace. This API uses the PUT method
        and will overwrite all settings. Remaining policy will be set to default value if only partial
        policy is provided in the request body. Always run Get Network Communication Policy first and
        provide full policy in the request body. This feature is currently in preview.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param set_workspace_networking_communication_policy: Set workspace networking communication
         policy request payload. Required.
        :type set_workspace_networking_communication_policy:
         ~microsoft.fabric.api.core.models.WorkspaceNetworkingCommunicationPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def set_network_communication_policy(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        set_workspace_networking_communication_policy: IO[bytes],
        *,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any,
    ) -> None:
        """Sets networking communication policy for the specified workspace. This API uses the PUT method
        and will overwrite all settings. Remaining policy will be set to default value if only partial
        policy is provided in the request body. Always run Get Network Communication Policy first and
        provide full policy in the request body. This feature is currently in preview.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param set_workspace_networking_communication_policy: Set workspace networking communication
         policy request payload. Required.
        :type set_workspace_networking_communication_policy: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def set_network_communication_policy(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        set_workspace_networking_communication_policy: Union[_models.WorkspaceNetworkingCommunicationPolicy, IO[bytes]],
        *,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any,
    ) -> None:
        """Sets networking communication policy for the specified workspace. This API uses the PUT method
        and will overwrite all settings. Remaining policy will be set to default value if only partial
        policy is provided in the request body. Always run Get Network Communication Policy first and
        provide full policy in the request body. This feature is currently in preview.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param set_workspace_networking_communication_policy: Set workspace networking communication
         policy request payload. Is either a WorkspaceNetworkingCommunicationPolicy type or a IO[bytes]
         type. Required.
        :type set_workspace_networking_communication_policy:
         ~microsoft.fabric.api.core.models.WorkspaceNetworkingCommunicationPolicy or IO[bytes]
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(set_workspace_networking_communication_policy, (IOBase, bytes)):
            _content = set_workspace_networking_communication_policy
        else:
            _json = self._serialize.body(
                set_workspace_networking_communication_policy, "WorkspaceNetworkingCommunicationPolicy"
            )

        _request = build_workspaces_set_network_communication_policy_request(
            workspace_id=workspace_id,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class ItemsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`items` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_items(
        self,
        workspace_id: str,
        *,
        type: Optional[str] = None,
        recursive: Optional[bool] = None,
        root_folder_id: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.Item"]:
        """Returns a list of items from the specified workspace.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------

         The caller must have a *viewer* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :keyword type: The item's type. Default value is None.
        :paramtype type: str
        :keyword recursive: Lists items in a folder and its nested folders, or just a folder only. True
         - All items in the folder and its nested folders are listed, False - Only items in the folder
         are listed. The default value is true. Default value is None.
        :paramtype recursive: bool
        :keyword root_folder_id: This parameter allows users to filter items based on a specific root
         folder. If not provided, the workspace is used as the root folder. Default value is None.
        :paramtype root_folder_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Item
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Item]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Items] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_items_list_items_request(
                    workspace_id=workspace_id,
                    type=type,
                    recursive=recursive,
                    root_folder_id=root_folder_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Items, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_item_initial(
        self, workspace_id: str, create_item_request: Union[_models.CreateItemRequest, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_item_request, (IOBase, bytes)):
            _content = create_item_request
        else:
            _json = self._serialize.body(create_item_request, "CreateItemRequest")

        _request = build_items_create_item_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 201:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_item(
        self,
        workspace_id: str,
        create_item_request: _models.CreateItemRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.Item]:
        """Creates an item in the specified workspace.

        This API is supported for a number of item types, find the supported item types in `Item
        management overview </rest/api/fabric/articles/item-management/item-management-overview>`_. You
        can use `Get item definition API </rest/api/fabric/core/items/get-item-definition>`_ to get an
        item definition.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have a *contributor* workspace role.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------


        * To create a non-PowerBI Fabric item the workspace must be on a supported Fabric capacity. For
        more information see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.
        * To create a PowerBI item, the user must have the appropriate license. For more information
        see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.
        * When creating an item, use either ``creationPayload`` or ``definition``\\ , but do not use
        both at the same time.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_item_request: Create item request payload. Required.
        :type create_item_request: ~microsoft.fabric.api.core.models.CreateItemRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Item
        :rtype: ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.Item]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_item(
        self,
        workspace_id: str,
        create_item_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.Item]:
        """Creates an item in the specified workspace.

        This API is supported for a number of item types, find the supported item types in `Item
        management overview </rest/api/fabric/articles/item-management/item-management-overview>`_. You
        can use `Get item definition API </rest/api/fabric/core/items/get-item-definition>`_ to get an
        item definition.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have a *contributor* workspace role.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------


        * To create a non-PowerBI Fabric item the workspace must be on a supported Fabric capacity. For
        more information see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.
        * To create a PowerBI item, the user must have the appropriate license. For more information
        see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.
        * When creating an item, use either ``creationPayload`` or ``definition``\\ , but do not use
        both at the same time.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_item_request: Create item request payload. Required.
        :type create_item_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns Item
        :rtype: ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.Item]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_item(
        self, workspace_id: str, create_item_request: Union[_models.CreateItemRequest, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.Item]:
        """Creates an item in the specified workspace.

        This API is supported for a number of item types, find the supported item types in `Item
        management overview </rest/api/fabric/articles/item-management/item-management-overview>`_. You
        can use `Get item definition API </rest/api/fabric/core/items/get-item-definition>`_ to get an
        item definition.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have a *contributor* workspace role.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------


        * To create a non-PowerBI Fabric item the workspace must be on a supported Fabric capacity. For
        more information see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.
        * To create a PowerBI item, the user must have the appropriate license. For more information
        see `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.
        * When creating an item, use either ``creationPayload`` or ``definition``\\ , but do not use
        both at the same time.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_item_request: Create item request payload. Is either a CreateItemRequest type or
         a IO[bytes] type. Required.
        :type create_item_request: ~microsoft.fabric.api.core.models.CreateItemRequest or IO[bytes]
        :return: An instance of LROPoller that returns Item
        :rtype: ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.Item]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Item] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_item_initial(
                workspace_id=workspace_id,
                create_item_request=create_item_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("Item", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.Item].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.Item](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_item(self, workspace_id: str, item_id: str, **kwargs: Any) -> _models.Item:
        """Returns properties of the specified item.

        This API is supported for a number of item types, find the supported item types in `Item
        management overview </rest/api/fabric/articles/item-management/item-management-overview>`_.

        For retrieving additional type specific properties, refer to the get API reference page of the
        specific item type.

        Permissions
        -----------

         The caller must have *read* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.Read.All or Item.ReadWrite.All
        *
          Specific scope: *itemType*.Read.All or *itemType*.ReadWrite.All (for example:
        Notebook.ReadWrite.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :return: Item
        :rtype: ~microsoft.fabric.api.core.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Item] = kwargs.pop("cls", None)

        _request = build_items_get_item_request(
            workspace_id=workspace_id,
            item_id=item_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Item", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_item(
        self,
        workspace_id: str,
        item_id: str,
        update_item_request: _models.UpdateItemRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Item:
        """Updates the properties of the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item management overview
        </rest/api/fabric/articles/item-management/item-management-overview>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param update_item_request: Update item request payload. Required.
        :type update_item_request: ~microsoft.fabric.api.core.models.UpdateItemRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Item
        :rtype: ~microsoft.fabric.api.core.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_item(
        self,
        workspace_id: str,
        item_id: str,
        update_item_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Item:
        """Updates the properties of the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item management overview
        </rest/api/fabric/articles/item-management/item-management-overview>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param update_item_request: Update item request payload. Required.
        :type update_item_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Item
        :rtype: ~microsoft.fabric.api.core.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_item(
        self,
        workspace_id: str,
        item_id: str,
        update_item_request: Union[_models.UpdateItemRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.Item:
        """Updates the properties of the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item management overview
        </rest/api/fabric/articles/item-management/item-management-overview>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param update_item_request: Update item request payload. Is either a UpdateItemRequest type or
         a IO[bytes] type. Required.
        :type update_item_request: ~microsoft.fabric.api.core.models.UpdateItemRequest or IO[bytes]
        :return: Item
        :rtype: ~microsoft.fabric.api.core.models.Item
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Item] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_item_request, (IOBase, bytes)):
            _content = update_item_request
        else:
            _json = self._serialize.body(update_item_request, "UpdateItemRequest")

        _request = build_items_update_item_request(
            workspace_id=workspace_id,
            item_id=item_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Item", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_item(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, item_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item management overview
        </rest/api/fabric/articles/item-management/item-management-overview>`_.

        Permissions
        -----------

         The caller must have *write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_items_delete_item_request(
            workspace_id=workspace_id,
            item_id=item_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    def _get_item_definition_initial(
        self, workspace_id: str, item_id: str, *, format: Optional[str] = None, **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_items_get_item_definition_request(
            workspace_id=workspace_id,
            item_id=item_id,
            format=format,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_get_item_definition(
        self, workspace_id: str, item_id: str, *, format: Optional[str] = None, **kwargs: Any
    ) -> LROPoller[_models.ItemDefinitionResponse]:
        """Returns the specified item definition.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item definition overview
        </rest/api/fabric/articles/item-management/definitions/item-definition-overview>`_.
        When you get an item's definition, the sensitivity label is not a part of the definition.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

         This API is blocked for an item with a protected sensitivity label, unless the caller has the
        usage rights to delete the sensitivity label.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :keyword format: The format of the item definition. Default value is None.
        :paramtype format: str
        :return: An instance of LROPoller that returns ItemDefinitionResponse
        :rtype: ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.ItemDefinitionResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ItemDefinitionResponse] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._get_item_definition_initial(
                workspace_id=workspace_id,
                item_id=item_id,
                format=format,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("ItemDefinitionResponse", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ItemDefinitionResponse].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ItemDefinitionResponse](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_item_definition_initial(
        self,
        workspace_id: str,
        item_id: str,
        update_item_definition_request: Union[_models.UpdateItemDefinitionRequest, IO[bytes]],
        *,
        update_metadata: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_item_definition_request, (IOBase, bytes)):
            _content = update_item_definition_request
        else:
            _json = self._serialize.body(update_item_definition_request, "UpdateItemDefinitionRequest")

        _request = build_items_update_item_definition_request(
            workspace_id=workspace_id,
            item_id=item_id,
            update_metadata=update_metadata,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update_item_definition(
        self,
        workspace_id: str,
        item_id: str,
        update_item_definition_request: _models.UpdateItemDefinitionRequest,
        *,
        update_metadata: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Overrides the definition for the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item definition overview
        </rest/api/fabric/articles/item-management/definitions/item-definition-overview>`_.
        Updating the item's definition, does not affect its sensitivity label.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param update_item_definition_request: Update item definition request payload. Required.
        :type update_item_definition_request:
         ~microsoft.fabric.api.core.models.UpdateItemDefinitionRequest
        :keyword update_metadata: When set to true and the .platform file is provided as part of the
         definition, the item's metadata is updated using the metadata in the .platform file. Default
         value is None.
        :paramtype update_metadata: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_update_item_definition(
        self,
        workspace_id: str,
        item_id: str,
        update_item_definition_request: IO[bytes],
        *,
        update_metadata: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Overrides the definition for the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item definition overview
        </rest/api/fabric/articles/item-management/definitions/item-definition-overview>`_.
        Updating the item's definition, does not affect its sensitivity label.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param update_item_definition_request: Update item definition request payload. Required.
        :type update_item_definition_request: IO[bytes]
        :keyword update_metadata: When set to true and the .platform file is provided as part of the
         definition, the item's metadata is updated using the metadata in the .platform file. Default
         value is None.
        :paramtype update_metadata: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_update_item_definition(
        self,
        workspace_id: str,
        item_id: str,
        update_item_definition_request: Union[_models.UpdateItemDefinitionRequest, IO[bytes]],
        *,
        update_metadata: Optional[bool] = None,
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Overrides the definition for the specified item.

        This API is supported for a number of item types, find the supported item types and information
        about their definition structure in `Item definition overview
        </rest/api/fabric/articles/item-management/definitions/item-definition-overview>`_.
        Updating the item's definition, does not affect its sensitivity label.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - When the item type in the call is supported. Check the corresponding API for the item
        type you're calling, to see if your call is supported. For example, semantic models are
        supported.


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param update_item_definition_request: Update item definition request payload. Is either a
         UpdateItemDefinitionRequest type or a IO[bytes] type. Required.
        :type update_item_definition_request:
         ~microsoft.fabric.api.core.models.UpdateItemDefinitionRequest or IO[bytes]
        :keyword update_metadata: When set to true and the .platform file is provided as part of the
         definition, the item's metadata is updated using the metadata in the .platform file. Default
         value is None.
        :paramtype update_metadata: bool
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_item_definition_initial(
                workspace_id=workspace_id,
                item_id=item_id,
                update_item_definition_request=update_item_definition_request,
                update_metadata=update_metadata,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list_item_connections(
        self, workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.ItemConnection"]:
        """Returns the list of connections that the specified item is connected to.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------

         The caller must have *read and write* permissions for the item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

         This API is blocked for an item with a protected sensitivity label, unless the caller has the
        usage rights to delete the sensitivity label.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ItemConnection
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ItemConnection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ItemConnections] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_items_list_item_connections_request(
                    workspace_id=workspace_id,
                    item_id=item_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ItemConnections, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def bulk_move_items(
        self,
        workspace_id: str,
        bulk_move_items_request: _models.BulkMoveItemsRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MovedItems:
        """Move multiple items to a folder. Children items are moved with their parent items. You can't
        move children items without their parent items.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         A single request can't contain more than 50 items.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param bulk_move_items_request: Bulk move items request payload. Required.
        :type bulk_move_items_request: ~microsoft.fabric.api.core.models.BulkMoveItemsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MovedItems
        :rtype: ~microsoft.fabric.api.core.models.MovedItems
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def bulk_move_items(
        self,
        workspace_id: str,
        bulk_move_items_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MovedItems:
        """Move multiple items to a folder. Children items are moved with their parent items. You can't
        move children items without their parent items.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         A single request can't contain more than 50 items.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param bulk_move_items_request: Bulk move items request payload. Required.
        :type bulk_move_items_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MovedItems
        :rtype: ~microsoft.fabric.api.core.models.MovedItems
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def bulk_move_items(
        self, workspace_id: str, bulk_move_items_request: Union[_models.BulkMoveItemsRequest, IO[bytes]], **kwargs: Any
    ) -> _models.MovedItems:
        """Move multiple items to a folder. Children items are moved with their parent items. You can't
        move children items without their parent items.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         A single request can't contain more than 50 items.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param bulk_move_items_request: Bulk move items request payload. Is either a
         BulkMoveItemsRequest type or a IO[bytes] type. Required.
        :type bulk_move_items_request: ~microsoft.fabric.api.core.models.BulkMoveItemsRequest or
         IO[bytes]
        :return: MovedItems
        :rtype: ~microsoft.fabric.api.core.models.MovedItems
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MovedItems] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(bulk_move_items_request, (IOBase, bytes)):
            _content = bulk_move_items_request
        else:
            _json = self._serialize.body(bulk_move_items_request, "BulkMoveItemsRequest")

        _request = build_items_bulk_move_items_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("MovedItems", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def move_item(
        self,
        workspace_id: str,
        item_id: str,
        move_item_request: _models.MoveItemRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MovedItems:
        """Move the specified item to a folder within the same workspace. Child items are moved with their
        parent item. You can't move a child item without its parent item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param move_item_request: Move item request payload. Required.
        :type move_item_request: ~microsoft.fabric.api.core.models.MoveItemRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MovedItems
        :rtype: ~microsoft.fabric.api.core.models.MovedItems
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def move_item(
        self,
        workspace_id: str,
        item_id: str,
        move_item_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.MovedItems:
        """Move the specified item to a folder within the same workspace. Child items are moved with their
        parent item. You can't move a child item without its parent item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param move_item_request: Move item request payload. Required.
        :type move_item_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MovedItems
        :rtype: ~microsoft.fabric.api.core.models.MovedItems
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def move_item(
        self,
        workspace_id: str,
        item_id: str,
        move_item_request: Union[_models.MoveItemRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.MovedItems:
        """Move the specified item to a folder within the same workspace. Child items are moved with their
        parent item. You can't move a child item without its parent item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param move_item_request: Move item request payload. Is either a MoveItemRequest type or a
         IO[bytes] type. Required.
        :type move_item_request: ~microsoft.fabric.api.core.models.MoveItemRequest or IO[bytes]
        :return: MovedItems
        :rtype: ~microsoft.fabric.api.core.models.MovedItems
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.MovedItems] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(move_item_request, (IOBase, bytes)):
            _content = move_item_request
        else:
            _json = self._serialize.body(move_item_request, "MoveItemRequest")

        _request = build_items_move_item_request(
            workspace_id=workspace_id,
            item_id=item_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("MovedItems", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class JobSchedulerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`job_scheduler` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_item_schedules(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.ItemSchedule"]:
        """Get scheduling settings for one specific item.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All or Item.Read.All
        *
          Specific scope: *itemType*.ReadWrite.All or *itemType*.Read.All (for example:
        Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ItemSchedule
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ItemSchedule]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ItemSchedules] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_scheduler_list_item_schedules_request(
                    workspace_id=workspace_id,
                    item_id=item_id,
                    job_type=job_type,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ItemSchedules, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_item_schedule(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        create_schedule_request: _models.CreateScheduleRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ItemSchedule:
        """Create a new schedule for an item. An item can create maximum 20 schedulers.

        Required Delegated Scopes:
        --------------------------

        Item.Execute.All and Item.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param create_schedule_request: A item schedule create request. Required.
        :type create_schedule_request: ~microsoft.fabric.api.core.models.CreateScheduleRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_item_schedule(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        create_schedule_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ItemSchedule:
        """Create a new schedule for an item. An item can create maximum 20 schedulers.

        Required Delegated Scopes:
        --------------------------

        Item.Execute.All and Item.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param create_schedule_request: A item schedule create request. Required.
        :type create_schedule_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_item_schedule(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        create_schedule_request: Union[_models.CreateScheduleRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.ItemSchedule:
        """Create a new schedule for an item. An item can create maximum 20 schedulers.

        Required Delegated Scopes:
        --------------------------

        Item.Execute.All and Item.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param create_schedule_request: A item schedule create request. Is either a
         CreateScheduleRequest type or a IO[bytes] type. Required.
        :type create_schedule_request: ~microsoft.fabric.api.core.models.CreateScheduleRequest or
         IO[bytes]
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ItemSchedule] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_schedule_request, (IOBase, bytes)):
            _content = create_schedule_request
        else:
            _json = self._serialize.body(create_schedule_request, "CreateScheduleRequest")

        _request = build_job_scheduler_create_item_schedule_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_type=job_type,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("ItemSchedule", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_item_schedule(
        self, workspace_id: str, item_id: str, job_type: str, schedule_id: str, **kwargs: Any
    ) -> _models.ItemSchedule:
        """Get an existing schedule for an item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.Read.All or Item.ReadWrite.All
        *
          Specific scope: *itemType*.Read.All or *itemType*.ReadWrite.All (for example:
        Notebook.Read.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param schedule_id: The item schedule ID. Required.
        :type schedule_id: str
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ItemSchedule] = kwargs.pop("cls", None)

        _request = build_job_scheduler_get_item_schedule_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_type=job_type,
            schedule_id=schedule_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ItemSchedule", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_item_schedule(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        schedule_id: str,
        update_schedule_request: _models.UpdateScheduleRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ItemSchedule:
        """Update an existing schedule for an item.

        Required Delegated Scopes:
        --------------------------

        Item.Execute.All and Item.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param schedule_id: The item schedule ID. Required.
        :type schedule_id: str
        :param update_schedule_request: A item schedule update request. Required.
        :type update_schedule_request: ~microsoft.fabric.api.core.models.UpdateScheduleRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_item_schedule(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        schedule_id: str,
        update_schedule_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ItemSchedule:
        """Update an existing schedule for an item.

        Required Delegated Scopes:
        --------------------------

        Item.Execute.All and Item.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param schedule_id: The item schedule ID. Required.
        :type schedule_id: str
        :param update_schedule_request: A item schedule update request. Required.
        :type update_schedule_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_item_schedule(
        self,
        workspace_id: str,
        item_id: str,
        job_type: str,
        schedule_id: str,
        update_schedule_request: Union[_models.UpdateScheduleRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.ItemSchedule:
        """Update an existing schedule for an item.

        Required Delegated Scopes:
        --------------------------

        Item.Execute.All and Item.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param schedule_id: The item schedule ID. Required.
        :type schedule_id: str
        :param update_schedule_request: A item schedule update request. Is either a
         UpdateScheduleRequest type or a IO[bytes] type. Required.
        :type update_schedule_request: ~microsoft.fabric.api.core.models.UpdateScheduleRequest or
         IO[bytes]
        :return: ItemSchedule
        :rtype: ~microsoft.fabric.api.core.models.ItemSchedule
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ItemSchedule] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_schedule_request, (IOBase, bytes)):
            _content = update_schedule_request
        else:
            _json = self._serialize.body(update_schedule_request, "UpdateScheduleRequest")

        _request = build_job_scheduler_update_item_schedule_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_type=job_type,
            schedule_id=schedule_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ItemSchedule", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_item_schedule(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, item_id: str, job_type: str, schedule_id: str, **kwargs: Any
    ) -> None:
        """Delete an existing schedule for an item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_type: The job type. Required.
        :type job_type: str
        :param schedule_id: The item schedule ID. Required.
        :type schedule_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_scheduler_delete_item_schedule_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_type=job_type,
            schedule_id=schedule_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_item_job_instance(
        self, workspace_id: str, item_id: str, job_instance_id: str, **kwargs: Any
    ) -> _models.ItemJobInstance:
        """Get one item's job instance.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All or Item.Read.All
        *
          Specific scope: *itemType*.ReadWrite.All or *itemType*.Read.All (for example:
        Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_instance_id: The job instance ID. Required.
        :type job_instance_id: str
        :return: ItemJobInstance
        :rtype: ~microsoft.fabric.api.core.models.ItemJobInstance
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ItemJobInstance] = kwargs.pop("cls", None)

        _request = build_job_scheduler_get_item_job_instance_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_instance_id=job_instance_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ItemJobInstance", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_item_job_instances(
        self, workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.ItemJobInstance"]:
        """Returns a list of job instances for the specified item.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.ReadWrite.All or Item.Read.All
        *
          Specific scope: *itemType*.ReadWrite.All or *itemType*.Read.All (for example:
        Notebook.ReadWrite.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------


        * Most items have a limit of 100 recently completed entities, and there is not limit for active
        entities.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ItemJobInstance
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ItemJobInstance]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ItemJobInstances] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_job_scheduler_list_item_job_instances_request(
                    workspace_id=workspace_id,
                    item_id=item_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ItemJobInstances, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def run_on_demand_item_job(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        run_on_demand_item_job_request: Optional[_models.RunOnDemandItemJobRequest] = None,
        *,
        job_type: str,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Run on-demand item job instance.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.Execute.All
        *
          Specific scope: *itemType*.Execute.All (for example: Notebook.Execute.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param run_on_demand_item_job_request: Run on-demand item job request payload. Default value is
         None.
        :type run_on_demand_item_job_request:
         ~microsoft.fabric.api.core.models.RunOnDemandItemJobRequest
        :keyword job_type: Job type. Required.
        :paramtype job_type: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def run_on_demand_item_job(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        run_on_demand_item_job_request: Optional[IO[bytes]] = None,
        *,
        job_type: str,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Run on-demand item job instance.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.Execute.All
        *
          Specific scope: *itemType*.Execute.All (for example: Notebook.Execute.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param run_on_demand_item_job_request: Run on-demand item job request payload. Default value is
         None.
        :type run_on_demand_item_job_request: IO[bytes]
        :keyword job_type: Job type. Required.
        :paramtype job_type: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def run_on_demand_item_job(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        run_on_demand_item_job_request: Optional[Union[_models.RunOnDemandItemJobRequest, IO[bytes]]] = None,
        *,
        job_type: str,
        **kwargs: Any,
    ) -> None:
        """Run on-demand item job instance.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.Execute.All
        *
          Specific scope: *itemType*.Execute.All (for example: Notebook.Execute.All)

          for more information about scopes, see: `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param run_on_demand_item_job_request: Run on-demand item job request payload. Is either a
         RunOnDemandItemJobRequest type or a IO[bytes] type. Default value is None.
        :type run_on_demand_item_job_request:
         ~microsoft.fabric.api.core.models.RunOnDemandItemJobRequest or IO[bytes]
        :keyword job_type: Job type. Required.
        :paramtype job_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(run_on_demand_item_job_request, (IOBase, bytes)):
            _content = run_on_demand_item_job_request
        else:
            if run_on_demand_item_job_request is not None:
                _json = self._serialize.body(run_on_demand_item_job_request, "RunOnDemandItemJobRequest")
            else:
                _json = None

        _request = build_job_scheduler_run_on_demand_item_job_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_type=job_type,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def cancel_item_job_instance(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, item_id: str, job_instance_id: str, **kwargs: Any
    ) -> None:
        """Cancel an item's job instance.

        Required Delegated Scopes
        -------------------------

         For item APIs use these scope types:


        * Generic scope: Item.Execute.All
        *
          Specific scope: *itemType*.Execute.All (for example: Notebook.Execute.All)

          for more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param job_instance_id: The job instance ID. Required.
        :type job_instance_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_job_scheduler_cancel_item_job_instance_request(
            workspace_id=workspace_id,
            item_id=item_id,
            job_instance_id=job_instance_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class GitOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`git` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_connection(self, workspace_id: str, **kwargs: Any) -> _models.GitConnection:
        """Returns git connection details for the specified workspace.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: GitConnection
        :rtype: ~microsoft.fabric.api.core.models.GitConnection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GitConnection] = kwargs.pop("cls", None)

        _request = build_git_get_connection_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("GitConnection", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def connect(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        git_connect_request: _models.GitConnectRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Connect a specific workspace to a git repository and branch.

        This operation does not sync between the workspace and the connected branch. To complete the
        sync, use the `Initialize Connection </rest/api/fabric/core/git/initialize-connection>`_
        operation and follow with either the `Commit To Git </rest/api/fabric/core/git/commit-to-git>`_
        or the `Update From Git </rest/api/fabric/core/git/update-from-git>`_ operation.

        To get started with GitHub, see: `Get started with Git integration
        </fabric/cicd/git-integration/git-get-started?tabs=github>`_.

        To get the connection ID, see `Automate Git integration
        </fabric/cicd/git-integration/git-automation#get-or-create-git-provider-credentials-connection>`_.

        Permissions
        -----------

        The caller must have an *admin* role for the workspace.

        For configured connection Git credentials, the caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         When using Automatic credentials source, this API is blocked for GitHub provider and for
        Service Principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Supported only when myGitCredentials.source is ConfiguredConnection


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param git_connect_request: Connect to the Git request payload. Required.
        :type git_connect_request: ~microsoft.fabric.api.core.models.GitConnectRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def connect(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        git_connect_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Connect a specific workspace to a git repository and branch.

        This operation does not sync between the workspace and the connected branch. To complete the
        sync, use the `Initialize Connection </rest/api/fabric/core/git/initialize-connection>`_
        operation and follow with either the `Commit To Git </rest/api/fabric/core/git/commit-to-git>`_
        or the `Update From Git </rest/api/fabric/core/git/update-from-git>`_ operation.

        To get started with GitHub, see: `Get started with Git integration
        </fabric/cicd/git-integration/git-get-started?tabs=github>`_.

        To get the connection ID, see `Automate Git integration
        </fabric/cicd/git-integration/git-automation#get-or-create-git-provider-credentials-connection>`_.

        Permissions
        -----------

        The caller must have an *admin* role for the workspace.

        For configured connection Git credentials, the caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         When using Automatic credentials source, this API is blocked for GitHub provider and for
        Service Principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Supported only when myGitCredentials.source is ConfiguredConnection


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param git_connect_request: Connect to the Git request payload. Required.
        :type git_connect_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def connect(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, git_connect_request: Union[_models.GitConnectRequest, IO[bytes]], **kwargs: Any
    ) -> None:
        """Connect a specific workspace to a git repository and branch.

        This operation does not sync between the workspace and the connected branch. To complete the
        sync, use the `Initialize Connection </rest/api/fabric/core/git/initialize-connection>`_
        operation and follow with either the `Commit To Git </rest/api/fabric/core/git/commit-to-git>`_
        or the `Update From Git </rest/api/fabric/core/git/update-from-git>`_ operation.

        To get started with GitHub, see: `Get started with Git integration
        </fabric/cicd/git-integration/git-get-started?tabs=github>`_.

        To get the connection ID, see `Automate Git integration
        </fabric/cicd/git-integration/git-automation#get-or-create-git-provider-credentials-connection>`_.

        Permissions
        -----------

        The caller must have an *admin* role for the workspace.

        For configured connection Git credentials, the caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         When using Automatic credentials source, this API is blocked for GitHub provider and for
        Service Principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Supported only when myGitCredentials.source is ConfiguredConnection


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param git_connect_request: Connect to the Git request payload. Is either a GitConnectRequest
         type or a IO[bytes] type. Required.
        :type git_connect_request: ~microsoft.fabric.api.core.models.GitConnectRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(git_connect_request, (IOBase, bytes)):
            _content = git_connect_request
        else:
            _json = self._serialize.body(git_connect_request, "GitConnectRequest")

        _request = build_git_connect_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def disconnect(self, workspace_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Disconnect a specific workspace from the Git repository and branch it is connected to.

        Permissions
        -----------

        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_git_disconnect_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    def _initialize_connection_initial(
        self,
        workspace_id: str,
        git_initialize_connection_request: Optional[Union[_models.InitializeGitConnectionRequest, IO[bytes]]] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(git_initialize_connection_request, (IOBase, bytes)):
            _content = git_initialize_connection_request
        else:
            if git_initialize_connection_request is not None:
                _json = self._serialize.body(git_initialize_connection_request, "InitializeGitConnectionRequest")
            else:
                _json = None

        _request = build_git_initialize_connection_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_initialize_connection(
        self,
        workspace_id: str,
        git_initialize_connection_request: Optional[_models.InitializeGitConnectionRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.InitializeGitConnectionResponse]:
        """Initialize a connection for a workspace that's connected to Git.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        This API should be called after a successful call to the `Connect
        </rest/api/fabric/core/git/connect>`_ API. To complete a full sync of the workspace, use the
        `Required Action <initialize-connection#requiredaction>`_ operation to call the relevant sync
        operation, either `Commit To Git </rest/api/fabric/core/git/commit-to-git>`_ or `Update From
        Git </rest/api/fabric/core/git/update-from-git>`_.

        Permissions
        -----------

        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param git_initialize_connection_request: Initialize the connection request payload. Default
         value is None.
        :type git_initialize_connection_request:
         ~microsoft.fabric.api.core.models.InitializeGitConnectionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns InitializeGitConnectionResponse
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.InitializeGitConnectionResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_initialize_connection(
        self,
        workspace_id: str,
        git_initialize_connection_request: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.InitializeGitConnectionResponse]:
        """Initialize a connection for a workspace that's connected to Git.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        This API should be called after a successful call to the `Connect
        </rest/api/fabric/core/git/connect>`_ API. To complete a full sync of the workspace, use the
        `Required Action <initialize-connection#requiredaction>`_ operation to call the relevant sync
        operation, either `Commit To Git </rest/api/fabric/core/git/commit-to-git>`_ or `Update From
        Git </rest/api/fabric/core/git/update-from-git>`_.

        Permissions
        -----------

        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param git_initialize_connection_request: Initialize the connection request payload. Default
         value is None.
        :type git_initialize_connection_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns InitializeGitConnectionResponse
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.InitializeGitConnectionResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_initialize_connection(
        self,
        workspace_id: str,
        git_initialize_connection_request: Optional[Union[_models.InitializeGitConnectionRequest, IO[bytes]]] = None,
        **kwargs: Any,
    ) -> LROPoller[_models.InitializeGitConnectionResponse]:
        """Initialize a connection for a workspace that's connected to Git.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        This API should be called after a successful call to the `Connect
        </rest/api/fabric/core/git/connect>`_ API. To complete a full sync of the workspace, use the
        `Required Action <initialize-connection#requiredaction>`_ operation to call the relevant sync
        operation, either `Commit To Git </rest/api/fabric/core/git/commit-to-git>`_ or `Update From
        Git </rest/api/fabric/core/git/update-from-git>`_.

        Permissions
        -----------

        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param git_initialize_connection_request: Initialize the connection request payload. Is either
         a InitializeGitConnectionRequest type or a IO[bytes] type. Default value is None.
        :type git_initialize_connection_request:
         ~microsoft.fabric.api.core.models.InitializeGitConnectionRequest or IO[bytes]
        :return: An instance of LROPoller that returns InitializeGitConnectionResponse
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.InitializeGitConnectionResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.InitializeGitConnectionResponse] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._initialize_connection_initial(
                workspace_id=workspace_id,
                git_initialize_connection_request=git_initialize_connection_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("InitializeGitConnectionResponse", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.InitializeGitConnectionResponse].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.InitializeGitConnectionResponse](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _update_from_git_initial(
        self, workspace_id: str, update_from_git_request: Union[_models.UpdateFromGitRequest, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_from_git_request, (IOBase, bytes)):
            _content = update_from_git_request
        else:
            _json = self._serialize.body(update_from_git_request, "UpdateFromGitRequest")

        _request = build_git_update_from_git_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update_from_git(
        self,
        workspace_id: str,
        update_from_git_request: _models.UpdateFromGitRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Updates the workspace with commits pushed to the connected branch.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        The update only affects items in the workspace that were changed in those commits. If called
        after the `Connect </rest/api/fabric/core/git/connect>`_ and `Initialize Connection
        </rest/api/fabric/core/git/initialize-connection>`_ APIs, it will perform a full update of the
        entire workspace.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitUpdate.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_from_git_request: Update from a Git request payload. Required.
        :type update_from_git_request: ~microsoft.fabric.api.core.models.UpdateFromGitRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_update_from_git(
        self,
        workspace_id: str,
        update_from_git_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Updates the workspace with commits pushed to the connected branch.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        The update only affects items in the workspace that were changed in those commits. If called
        after the `Connect </rest/api/fabric/core/git/connect>`_ and `Initialize Connection
        </rest/api/fabric/core/git/initialize-connection>`_ APIs, it will perform a full update of the
        entire workspace.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitUpdate.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_from_git_request: Update from a Git request payload. Required.
        :type update_from_git_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_update_from_git(
        self, workspace_id: str, update_from_git_request: Union[_models.UpdateFromGitRequest, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Updates the workspace with commits pushed to the connected branch.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        The update only affects items in the workspace that were changed in those commits. If called
        after the `Connect </rest/api/fabric/core/git/connect>`_ and `Initialize Connection
        </rest/api/fabric/core/git/initialize-connection>`_ APIs, it will perform a full update of the
        entire workspace.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitUpdate.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_from_git_request: Update from a Git request payload. Is either a
         UpdateFromGitRequest type or a IO[bytes] type. Required.
        :type update_from_git_request: ~microsoft.fabric.api.core.models.UpdateFromGitRequest or
         IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_from_git_initial(
                workspace_id=workspace_id,
                update_from_git_request=update_from_git_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _get_status_initial(self, workspace_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_git_get_status_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_get_status(self, workspace_id: str, **kwargs: Any) -> LROPoller[_models.GitStatusResponse]:
        """Returns the ``Git status`` of items in the workspace, that can be committed to Git.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        The status indicates changes to items since the last workspace and remote branch sync. If the
        remote and workspace items were both modified, the API flags a conflict.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitUpdate.All or Workspace.GitCommit.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: An instance of LROPoller that returns GitStatusResponse
        :rtype: ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.GitStatusResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GitStatusResponse] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._get_status_initial(
                workspace_id=workspace_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("GitStatusResponse", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.GitStatusResponse].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.GitStatusResponse](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _commit_to_git_initial(
        self, workspace_id: str, commit_to_git_request: Union[_models.CommitToGitRequest, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(commit_to_git_request, (IOBase, bytes)):
            _content = commit_to_git_request
        else:
            _json = self._serialize.body(commit_to_git_request, "CommitToGitRequest")

        _request = build_git_commit_to_git_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_commit_to_git(
        self,
        workspace_id: str,
        commit_to_git_request: _models.CommitToGitRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Commits the changes made in the workspace to the connected remote branch.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        You can choose to commit all changes or only specific changed items. To sync the workspace for
        the first time, use this API after the `Connect </rest/api/fabric/core/git/connect>`_ and
        `Initialize Connection </rest/api/fabric/core/git/initialize-connection>`_ APIs.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitCommit.All.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param commit_to_git_request: Commit to the Git request payload. Required.
        :type commit_to_git_request: ~microsoft.fabric.api.core.models.CommitToGitRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_commit_to_git(
        self,
        workspace_id: str,
        commit_to_git_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Commits the changes made in the workspace to the connected remote branch.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        You can choose to commit all changes or only specific changed items. To sync the workspace for
        the first time, use this API after the `Connect </rest/api/fabric/core/git/connect>`_ and
        `Initialize Connection </rest/api/fabric/core/git/initialize-connection>`_ APIs.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitCommit.All.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param commit_to_git_request: Commit to the Git request payload. Required.
        :type commit_to_git_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_commit_to_git(
        self, workspace_id: str, commit_to_git_request: Union[_models.CommitToGitRequest, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Commits the changes made in the workspace to the connected remote branch.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        To use this API, the caller's Git credentials must be configured using `Update My Git
        Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API. You can use the `Get
        My Git Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to check the Git
        credentials configuration.

        You can choose to commit all changes or only specific changed items. To sync the workspace for
        the first time, use this API after the `Connect </rest/api/fabric/core/git/connect>`_ and
        `Initialize Connection </rest/api/fabric/core/git/initialize-connection>`_ APIs.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.GitCommit.All.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param commit_to_git_request: Commit to the Git request payload. Is either a CommitToGitRequest
         type or a IO[bytes] type. Required.
        :type commit_to_git_request: ~microsoft.fabric.api.core.models.CommitToGitRequest or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._commit_to_git_initial(
                workspace_id=workspace_id,
                commit_to_git_request=commit_to_git_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_my_git_credentials(self, workspace_id: str, **kwargs: Any) -> _models.GitCredentialsConfigurationResponse:
        """Returns the user's Git credentials configuration details.

        Indicates how the user's credentials are obtained for accessing the relevant Git provider,
        automatically or through configured connection. If the user's credentials aren't configured, go
        to `Update My Git Credentials </rest/api/fabric/core/git/update-my-git-credentials>`_ API.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :return: GitCredentialsConfigurationResponse
        :rtype: ~microsoft.fabric.api.core.models.GitCredentialsConfigurationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GitCredentialsConfigurationResponse] = kwargs.pop("cls", None)

        _request = build_git_get_my_git_credentials_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("GitCredentialsConfigurationResponse", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_my_git_credentials(
        self,
        workspace_id: str,
        update_git_credentials_request: _models.UpdateGitCredentialsRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GitCredentialsConfigurationResponse:
        """Updates the user's Git credentials configuration details.

        Each user in the workspace has their own configured Git credentials. You can use `Get My Git
        Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to get the Git credentials
        configuration.

        To get the connection ID, see `Automate Git integration
        </fabric/cicd/git-integration/git-automation#get-or-create-git-provider-credentials-connection>`_.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        For configured connection Git credentials, the caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         When using Automatic credentials source, this API is blocked for GitHub provider and for
        Service Principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Supported only when source is ConfiguredConnection or None


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_git_credentials_request: Updates the user's Git credentials request payload.
         Required.
        :type update_git_credentials_request:
         ~microsoft.fabric.api.core.models.UpdateGitCredentialsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GitCredentialsConfigurationResponse
        :rtype: ~microsoft.fabric.api.core.models.GitCredentialsConfigurationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_my_git_credentials(
        self,
        workspace_id: str,
        update_git_credentials_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GitCredentialsConfigurationResponse:
        """Updates the user's Git credentials configuration details.

        Each user in the workspace has their own configured Git credentials. You can use `Get My Git
        Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to get the Git credentials
        configuration.

        To get the connection ID, see `Automate Git integration
        </fabric/cicd/git-integration/git-automation#get-or-create-git-provider-credentials-connection>`_.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        For configured connection Git credentials, the caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         When using Automatic credentials source, this API is blocked for GitHub provider and for
        Service Principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Supported only when source is ConfiguredConnection or None


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_git_credentials_request: Updates the user's Git credentials request payload.
         Required.
        :type update_git_credentials_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GitCredentialsConfigurationResponse
        :rtype: ~microsoft.fabric.api.core.models.GitCredentialsConfigurationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_my_git_credentials(
        self,
        workspace_id: str,
        update_git_credentials_request: Union[_models.UpdateGitCredentialsRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.GitCredentialsConfigurationResponse:
        """Updates the user's Git credentials configuration details.

        Each user in the workspace has their own configured Git credentials. You can use `Get My Git
        Credentials </rest/api/fabric/core/git/get-my-git-credentials>`_ API to get the Git credentials
        configuration.

        To get the connection ID, see `Automate Git integration
        </fabric/cicd/git-integration/git-automation#get-or-create-git-provider-credentials-connection>`_.

        Permissions
        -----------

        The caller must have a *contributor* or higher workspace role.

        For configured connection Git credentials, the caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------

         When using Automatic credentials source, this API is blocked for GitHub provider and for
        Service Principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Supported only when source is ConfiguredConnection or None


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param update_git_credentials_request: Updates the user's Git credentials request payload. Is
         either a UpdateGitCredentialsRequest type or a IO[bytes] type. Required.
        :type update_git_credentials_request:
         ~microsoft.fabric.api.core.models.UpdateGitCredentialsRequest or IO[bytes]
        :return: GitCredentialsConfigurationResponse
        :rtype: ~microsoft.fabric.api.core.models.GitCredentialsConfigurationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GitCredentialsConfigurationResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_git_credentials_request, (IOBase, bytes)):
            _content = update_git_credentials_request
        else:
            _json = self._serialize.body(update_git_credentials_request, "UpdateGitCredentialsRequest")

        _request = build_git_update_my_git_credentials_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("GitCredentialsConfigurationResponse", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CapacitiesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`capacities` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_capacities(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.Capacity"]:
        """Returns a list of capacities the principal can access (either administrator or a contributor).

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Required Delegated Scopes
        -------------------------

        Capacity.Read.All or Capacity.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Capacity
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Capacity]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Capacities] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_capacities_list_capacities_request(
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Capacities, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class LongRunningOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`long_running_operations` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_operation_state(self, operation_id: str, **kwargs: Any) -> _models.OperationState:
        """Returns the current state of the long running operation.

        You get the operationId from x-ms-operation-id header return by the API that initiated the
        operation.
         Once the operation status is 'Succeeded' use the `Get Operation Result API
        </rest/api/fabric/core/long-running-operations/get-operation-result>`_ to retrieve the result.

        Permissions
        -----------

        Same as the permissions required for the API that initiated the operation.

        Required Delegated Scope
        ------------------------

        Same as the scopes required for the API that initiated the operation.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param operation_id: The operation ID. Required.
        :type operation_id: str
        :return: OperationState
        :rtype: ~microsoft.fabric.api.core.models.OperationState
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationState] = kwargs.pop("cls", None)

        _request = build_long_running_operations_get_operation_state_request(
            operation_id=operation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
        response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))

        deserialized = self._deserialize("OperationState", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_operation_result(self, operation_id: str, **kwargs: Any) -> Iterator[bytes]:
        """Returns the result of the long running operation.

        You get the operationId from x-ms-operation-id header return by the API that initiated the
        operation.

        Permissions
        -----------

        Same as the permissions required for the API that initiated the operation.

        Required Delegated Scope
        ------------------------

        Same as the scopes required for the API that initiated the operation.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param operation_id: The operation ID. Required.
        :type operation_id: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_long_running_operations_get_operation_result_request(
            operation_id=operation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class OneLakeShortcutsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`one_lake_shortcuts` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _creates_shortcuts_in_bulk_initial(
        self,
        workspace_id: str,
        item_id: str,
        bulk_create_shortcuts_request: Union[_models.BulkCreateShortcutsRequest, IO[bytes]],
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(bulk_create_shortcuts_request, (IOBase, bytes)):
            _content = bulk_create_shortcuts_request
        else:
            _json = self._serialize.body(bulk_create_shortcuts_request, "BulkCreateShortcutsRequest")

        _request = build_one_lake_shortcuts_creates_shortcuts_in_bulk_request(
            workspace_id=workspace_id,
            item_id=item_id,
            shortcut_conflict_policy=shortcut_conflict_policy,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_creates_shortcuts_in_bulk(
        self,
        workspace_id: str,
        item_id: str,
        bulk_create_shortcuts_request: _models.BulkCreateShortcutsRequest,
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.BulkCreateShortcutResponse]:
        """Creates bulk shortcuts.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param bulk_create_shortcuts_request: A shortcut bulk create request includes an array of
         shortcut objects, each representing a reference pointing to internal or external storage
         locations within OneLake. Required.
        :type bulk_create_shortcuts_request:
         ~microsoft.fabric.api.core.models.BulkCreateShortcutsRequest
        :keyword shortcut_conflict_policy: When provided, it defines the action to take when a shortcut
         with the same name and path already exists. The default action is 'Abort'. Additional
         ShortcutConflictPolicy types may be added over time. Known values are: "Abort",
         "GenerateUniqueName", "CreateOrOverwrite", and "OverwriteOnly". Default value is None.
        :paramtype shortcut_conflict_policy: str or
         ~microsoft.fabric.api.core.models.ShortcutConflictPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns BulkCreateShortcutResponse
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.BulkCreateShortcutResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_creates_shortcuts_in_bulk(
        self,
        workspace_id: str,
        item_id: str,
        bulk_create_shortcuts_request: IO[bytes],
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.BulkCreateShortcutResponse]:
        """Creates bulk shortcuts.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param bulk_create_shortcuts_request: A shortcut bulk create request includes an array of
         shortcut objects, each representing a reference pointing to internal or external storage
         locations within OneLake. Required.
        :type bulk_create_shortcuts_request: IO[bytes]
        :keyword shortcut_conflict_policy: When provided, it defines the action to take when a shortcut
         with the same name and path already exists. The default action is 'Abort'. Additional
         ShortcutConflictPolicy types may be added over time. Known values are: "Abort",
         "GenerateUniqueName", "CreateOrOverwrite", and "OverwriteOnly". Default value is None.
        :paramtype shortcut_conflict_policy: str or
         ~microsoft.fabric.api.core.models.ShortcutConflictPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns BulkCreateShortcutResponse
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.BulkCreateShortcutResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_creates_shortcuts_in_bulk(
        self,
        workspace_id: str,
        item_id: str,
        bulk_create_shortcuts_request: Union[_models.BulkCreateShortcutsRequest, IO[bytes]],
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        **kwargs: Any,
    ) -> LROPoller[_models.BulkCreateShortcutResponse]:
        """Creates bulk shortcuts.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param bulk_create_shortcuts_request: A shortcut bulk create request includes an array of
         shortcut objects, each representing a reference pointing to internal or external storage
         locations within OneLake. Is either a BulkCreateShortcutsRequest type or a IO[bytes] type.
         Required.
        :type bulk_create_shortcuts_request:
         ~microsoft.fabric.api.core.models.BulkCreateShortcutsRequest or IO[bytes]
        :keyword shortcut_conflict_policy: When provided, it defines the action to take when a shortcut
         with the same name and path already exists. The default action is 'Abort'. Additional
         ShortcutConflictPolicy types may be added over time. Known values are: "Abort",
         "GenerateUniqueName", "CreateOrOverwrite", and "OverwriteOnly". Default value is None.
        :paramtype shortcut_conflict_policy: str or
         ~microsoft.fabric.api.core.models.ShortcutConflictPolicy
        :return: An instance of LROPoller that returns BulkCreateShortcutResponse
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.BulkCreateShortcutResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.BulkCreateShortcutResponse] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._creates_shortcuts_in_bulk_initial(
                workspace_id=workspace_id,
                item_id=item_id,
                bulk_create_shortcuts_request=bulk_create_shortcuts_request,
                shortcut_conflict_policy=shortcut_conflict_policy,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("BulkCreateShortcutResponse", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.BulkCreateShortcutResponse].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.BulkCreateShortcutResponse](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def list_shortcuts(
        self,
        workspace_id: str,
        item_id: str,
        *,
        parent_path: Optional[str] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.ShortcutTransformFlagged"]:
        """Returns a list of shortcuts for the item, including all the subfolders exhaustively.

        Required Delegated Scopes
        -------------------------

         OneLake.Read.All or OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :keyword parent_path: The starting path from which to retrieve the shortcuts. Default value is
         None.
        :paramtype parent_path: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ShortcutTransformFlagged
        :rtype:
         ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ShortcutTransformFlagged]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Shortcuts] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_one_lake_shortcuts_list_shortcuts_request(
                    workspace_id=workspace_id,
                    item_id=item_id,
                    parent_path=parent_path,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Shortcuts, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_shortcut(
        self,
        workspace_id: str,
        item_id: str,
        create_shortcut_request: _models.CreateShortcutRequest,
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Shortcut:
        """Creates a new shortcut or updates an existing shortcut.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param create_shortcut_request: A shortcut create request includes a shortcut object
         representing a reference pointing to internal or external storage locations within OneLake. The
         shortcut is defined by its name, the path where it's created, and the target indicating the
         destination storage location. Required.
        :type create_shortcut_request: ~microsoft.fabric.api.core.models.CreateShortcutRequest
        :keyword shortcut_conflict_policy: When provided, it defines the action to take when a shortcut
         with the same name and path already exists. The default action is 'Abort'. Additional
         ShortcutConflictPolicy types may be added over time. Known values are: "Abort",
         "GenerateUniqueName", "CreateOrOverwrite", and "OverwriteOnly". Default value is None.
        :paramtype shortcut_conflict_policy: str or
         ~microsoft.fabric.api.core.models.ShortcutConflictPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Shortcut
        :rtype: ~microsoft.fabric.api.core.models.Shortcut
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_shortcut(
        self,
        workspace_id: str,
        item_id: str,
        create_shortcut_request: IO[bytes],
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Shortcut:
        """Creates a new shortcut or updates an existing shortcut.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param create_shortcut_request: A shortcut create request includes a shortcut object
         representing a reference pointing to internal or external storage locations within OneLake. The
         shortcut is defined by its name, the path where it's created, and the target indicating the
         destination storage location. Required.
        :type create_shortcut_request: IO[bytes]
        :keyword shortcut_conflict_policy: When provided, it defines the action to take when a shortcut
         with the same name and path already exists. The default action is 'Abort'. Additional
         ShortcutConflictPolicy types may be added over time. Known values are: "Abort",
         "GenerateUniqueName", "CreateOrOverwrite", and "OverwriteOnly". Default value is None.
        :paramtype shortcut_conflict_policy: str or
         ~microsoft.fabric.api.core.models.ShortcutConflictPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Shortcut
        :rtype: ~microsoft.fabric.api.core.models.Shortcut
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_shortcut(
        self,
        workspace_id: str,
        item_id: str,
        create_shortcut_request: Union[_models.CreateShortcutRequest, IO[bytes]],
        *,
        shortcut_conflict_policy: Optional[Union[str, _models.ShortcutConflictPolicy]] = None,
        **kwargs: Any,
    ) -> _models.Shortcut:
        """Creates a new shortcut or updates an existing shortcut.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param create_shortcut_request: A shortcut create request includes a shortcut object
         representing a reference pointing to internal or external storage locations within OneLake. The
         shortcut is defined by its name, the path where it's created, and the target indicating the
         destination storage location. Is either a CreateShortcutRequest type or a IO[bytes] type.
         Required.
        :type create_shortcut_request: ~microsoft.fabric.api.core.models.CreateShortcutRequest or
         IO[bytes]
        :keyword shortcut_conflict_policy: When provided, it defines the action to take when a shortcut
         with the same name and path already exists. The default action is 'Abort'. Additional
         ShortcutConflictPolicy types may be added over time. Known values are: "Abort",
         "GenerateUniqueName", "CreateOrOverwrite", and "OverwriteOnly". Default value is None.
        :paramtype shortcut_conflict_policy: str or
         ~microsoft.fabric.api.core.models.ShortcutConflictPolicy
        :return: Shortcut
        :rtype: ~microsoft.fabric.api.core.models.Shortcut
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Shortcut] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_shortcut_request, (IOBase, bytes)):
            _content = create_shortcut_request
        else:
            _json = self._serialize.body(create_shortcut_request, "CreateShortcutRequest")

        _request = build_one_lake_shortcuts_create_shortcut_request(
            workspace_id=workspace_id,
            item_id=item_id,
            shortcut_conflict_policy=shortcut_conflict_policy,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = self._deserialize("Shortcut", pipeline_response.http_response)

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

            deserialized = self._deserialize("Shortcut", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_shortcut(
        self, workspace_id: str, item_id: str, shortcut_path: str, shortcut_name: str, **kwargs: Any
    ) -> _models.Shortcut:
        """Returns shortcut properties.

        Required Delegated Scopes
        -------------------------

         OneLake.Read.All or OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param shortcut_path: The creation path of the shortcut. For more information see: `Directory
         and file names
         </rest/api/storageservices/Naming-and-Referencing-Shares--Directories--Files--and-Metadata#directory-and-file-names>`_.
         Required.
        :type shortcut_path: str
        :param shortcut_name: The name of the shortcut. For more information see: `Directory and file
         names
         </rest/api/storageservices/Naming-and-Referencing-Shares--Directories--Files--and-Metadata#directory-and-file-names>`_.
         Required.
        :type shortcut_name: str
        :return: Shortcut
        :rtype: ~microsoft.fabric.api.core.models.Shortcut
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Shortcut] = kwargs.pop("cls", None)

        _request = build_one_lake_shortcuts_get_shortcut_request(
            workspace_id=workspace_id,
            item_id=item_id,
            shortcut_path=shortcut_path,
            shortcut_name=shortcut_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Shortcut", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_shortcut(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, item_id: str, shortcut_path: str, shortcut_name: str, **kwargs: Any
    ) -> None:
        """Deletes the shortcut but does not delete the destination storage folder.

        Required Delegated Scopes
        -------------------------

         OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :param item_id: The ID of the data item. Required.
        :type item_id: str
        :param shortcut_path: The path of the shortcut to be deleted. For more information see:
         `Directory and file names
         </rest/api/storageservices/Naming-and-Referencing-Shares--Directories--Files--and-Metadata#directory-and-file-names>`_.
         Required.
        :type shortcut_path: str
        :param shortcut_name: The name of the shortcut to delete. For more information see: `Directory
         and file names
         </rest/api/storageservices/Naming-and-Referencing-Shares--Directories--Files--and-Metadata#directory-and-file-names>`_.
         Required.
        :type shortcut_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_one_lake_shortcuts_delete_shortcut_request(
            workspace_id=workspace_id,
            item_id=item_id,
            shortcut_path=shortcut_path,
            shortcut_name=shortcut_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    def _reset_shortcut_cache_initial(self, workspace_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_one_lake_shortcuts_reset_shortcut_cache_request(
            workspace_id=workspace_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_reset_shortcut_cache(self, workspace_id: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes any cached files that were stored while reading from shortcuts.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Required Delegated Scopes
        -------------------------

        OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The ID of the workspace. Required.
        :type workspace_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._reset_shortcut_cache_initial(
                workspace_id=workspace_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class TagsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`tags` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_tags(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.Tag"]:
        """Returns a list of all the tenant's tags.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Required Delegated Scopes
        -------------------------

        Tag.Read.All

        Limitations
        -----------

        Maximum 25 requests per one minute per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Tag
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Tag]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Tags] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_tags_list_tags_request(
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Tags, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def apply_tags(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        apply_tags_request: _models.ApplyTagsRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Apply tags on an item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

         ItemMetadata.ReadWrite.All or these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          For more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

        Maximum 25 requests per hour per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param apply_tags_request: The request payload for applying tags. Required.
        :type apply_tags_request: ~microsoft.fabric.api.core.models.ApplyTagsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def apply_tags(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        apply_tags_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Apply tags on an item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

         ItemMetadata.ReadWrite.All or these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          For more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

        Maximum 25 requests per hour per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param apply_tags_request: The request payload for applying tags. Required.
        :type apply_tags_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def apply_tags(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        apply_tags_request: Union[_models.ApplyTagsRequest, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """Apply tags on an item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

         ItemMetadata.ReadWrite.All or these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          For more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

        Maximum 25 requests per hour per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param apply_tags_request: The request payload for applying tags. Is either a ApplyTagsRequest
         type or a IO[bytes] type. Required.
        :type apply_tags_request: ~microsoft.fabric.api.core.models.ApplyTagsRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(apply_tags_request, (IOBase, bytes)):
            _content = apply_tags_request
        else:
            _json = self._serialize.body(apply_tags_request, "ApplyTagsRequest")

        _request = build_tags_apply_tags_request(
            workspace_id=workspace_id,
            item_id=item_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def unapply_tags(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        unapply_tags_request: _models.UnapplyTagsRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Unapply tags from an item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

         ItemMetadata.ReadWrite.All or these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          For more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

        Maximum 25 requests per hour per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param unapply_tags_request: The request payload for unapplying tags. Required.
        :type unapply_tags_request: ~microsoft.fabric.api.core.models.UnapplyTagsRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def unapply_tags(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        unapply_tags_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Unapply tags from an item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

         ItemMetadata.ReadWrite.All or these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          For more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

        Maximum 25 requests per hour per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param unapply_tags_request: The request payload for unapplying tags. Required.
        :type unapply_tags_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def unapply_tags(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        unapply_tags_request: Union[_models.UnapplyTagsRequest, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """Unapply tags from an item.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

         ItemMetadata.ReadWrite.All or these scope types:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Notebook.ReadWrite.All)

          For more information about scopes, see `Scopes article </rest/api/fabric/articles/scopes>`_.

        Limitations
        -----------

        Maximum 25 requests per hour per principal.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param unapply_tags_request: The request payload for unapplying tags. Is either a
         UnapplyTagsRequest type or a IO[bytes] type. Required.
        :type unapply_tags_request: ~microsoft.fabric.api.core.models.UnapplyTagsRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(unapply_tags_request, (IOBase, bytes)):
            _content = unapply_tags_request
        else:
            _json = self._serialize.body(unapply_tags_request, "UnapplyTagsRequest")

        _request = build_tags_unapply_tags_request(
            workspace_id=workspace_id,
            item_id=item_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class DomainsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`domains` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_domains(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.Domain"]:
        """Returns a list of all the tenant's domains.

        Required Delegated Scopes
        -------------------------

        Domain.Read.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Domain
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Domains] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_domains_list_domains_request(
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Domains, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_domain(self, domain_id: str, **kwargs: Any) -> _models.Domain:
        """Returns specified domain information.

        Required Delegated Scopes
        -------------------------

        Domain.Read.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param domain_id: The domain ID. Required.
        :type domain_id: str
        :return: Domain
        :rtype: ~microsoft.fabric.api.core.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Domain] = kwargs.pop("cls", None)

        _request = build_domains_get_domain_request(
            domain_id=domain_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Domain", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DeploymentPipelinesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`deployment_pipelines` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_deployment_pipelines(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.DeploymentPipeline"]:
        """Returns a list of deployment pipelines the user can access.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of DeploymentPipeline
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.DeploymentPipeline]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.DeploymentPipelines] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deployment_pipelines_list_deployment_pipelines_request(
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.DeploymentPipelines, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_deployment_pipeline(
        self,
        create_deployment_pipeline_request: _models.CreateDeploymentPipelineRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Creates a new deployment pipeline.

        Permissions
        -----------

         Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_deployment_pipeline_request: The create pipeline request. Required.
        :type create_deployment_pipeline_request:
         ~microsoft.fabric.api.core.models.CreateDeploymentPipelineRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_deployment_pipeline(
        self, create_deployment_pipeline_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Creates a new deployment pipeline.

        Permissions
        -----------

         Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_deployment_pipeline_request: The create pipeline request. Required.
        :type create_deployment_pipeline_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_deployment_pipeline(
        self,
        create_deployment_pipeline_request: Union[_models.CreateDeploymentPipelineRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Creates a new deployment pipeline.

        Permissions
        -----------

         Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_deployment_pipeline_request: The create pipeline request. Is either a
         CreateDeploymentPipelineRequest type or a IO[bytes] type. Required.
        :type create_deployment_pipeline_request:
         ~microsoft.fabric.api.core.models.CreateDeploymentPipelineRequest or IO[bytes]
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DeploymentPipelineExtendedInfo] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_deployment_pipeline_request, (IOBase, bytes)):
            _content = create_deployment_pipeline_request
        else:
            _json = self._serialize.body(create_deployment_pipeline_request, "CreateDeploymentPipelineRequest")

        _request = build_deployment_pipelines_create_deployment_pipeline_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineExtendedInfo", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_deployment_pipeline(
        self, deployment_pipeline_id: str, **kwargs: Any
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Returns the specified deployment pipeline metadata.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeploymentPipelineExtendedInfo] = kwargs.pop("cls", None)

        _request = build_deployment_pipelines_get_deployment_pipeline_request(
            deployment_pipeline_id=deployment_pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineExtendedInfo", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_deployment_pipeline(
        self,
        deployment_pipeline_id: str,
        update_pipeline_request: _models.UpdateDeploymentPipelineRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Updates the properties of the specified deployment pipeline.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param update_pipeline_request: The update pipeline request. Required.
        :type update_pipeline_request:
         ~microsoft.fabric.api.core.models.UpdateDeploymentPipelineRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_deployment_pipeline(
        self,
        deployment_pipeline_id: str,
        update_pipeline_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Updates the properties of the specified deployment pipeline.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param update_pipeline_request: The update pipeline request. Required.
        :type update_pipeline_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_deployment_pipeline(
        self,
        deployment_pipeline_id: str,
        update_pipeline_request: Union[_models.UpdateDeploymentPipelineRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.DeploymentPipelineExtendedInfo:
        """Updates the properties of the specified deployment pipeline.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param update_pipeline_request: The update pipeline request. Is either a
         UpdateDeploymentPipelineRequest type or a IO[bytes] type. Required.
        :type update_pipeline_request:
         ~microsoft.fabric.api.core.models.UpdateDeploymentPipelineRequest or IO[bytes]
        :return: DeploymentPipelineExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DeploymentPipelineExtendedInfo] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_pipeline_request, (IOBase, bytes)):
            _content = update_pipeline_request
        else:
            _json = self._serialize.body(update_pipeline_request, "UpdateDeploymentPipelineRequest")

        _request = build_deployment_pipelines_update_deployment_pipeline_request(
            deployment_pipeline_id=deployment_pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineExtendedInfo", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_deployment_pipeline(  # pylint: disable=inconsistent-return-statements
        self, deployment_pipeline_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified deployment pipeline.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        This operation will fail if there's an active deployment operation.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_deployment_pipelines_delete_deployment_pipeline_request(
            deployment_pipeline_id=deployment_pipeline_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_deployment_pipeline_role_assignments(  # pylint: disable=name-too-long
        self, deployment_pipeline_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.DeploymentPipelineRoleAssignment"]:
        """Returns a list of deployment pipeline role assignments.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of DeploymentPipelineRoleAssignment
        :rtype:
         ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.DeploymentPipelineRoleAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.DeploymentPipelineRoleAssignments] = kwargs.pop(
            "cls", None
        )  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deployment_pipelines_list_deployment_pipeline_role_assignments_request(
                    deployment_pipeline_id=deployment_pipeline_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.DeploymentPipelineRoleAssignments, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add_deployment_pipeline_role_assignment(
        self,
        deployment_pipeline_id: str,
        deployment_pipeline_role_assignment_request: _models.AddDeploymentPipelineRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineRoleAssignment:
        """Adds a deployment pipeline role assignment.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param deployment_pipeline_role_assignment_request: Add deployment pipeline role assignment
         request payload. Required.
        :type deployment_pipeline_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddDeploymentPipelineRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_deployment_pipeline_role_assignment(
        self,
        deployment_pipeline_id: str,
        deployment_pipeline_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineRoleAssignment:
        """Adds a deployment pipeline role assignment.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param deployment_pipeline_role_assignment_request: Add deployment pipeline role assignment
         request payload. Required.
        :type deployment_pipeline_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_deployment_pipeline_role_assignment(
        self,
        deployment_pipeline_id: str,
        deployment_pipeline_role_assignment_request: Union[
            _models.AddDeploymentPipelineRoleAssignmentRequest, IO[bytes]
        ],
        **kwargs: Any,
    ) -> _models.DeploymentPipelineRoleAssignment:
        """Adds a deployment pipeline role assignment.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param deployment_pipeline_role_assignment_request: Add deployment pipeline role assignment
         request payload. Is either a AddDeploymentPipelineRoleAssignmentRequest type or a IO[bytes]
         type. Required.
        :type deployment_pipeline_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddDeploymentPipelineRoleAssignmentRequest or IO[bytes]
        :return: DeploymentPipelineRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DeploymentPipelineRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(deployment_pipeline_role_assignment_request, (IOBase, bytes)):
            _content = deployment_pipeline_role_assignment_request
        else:
            _json = self._serialize.body(
                deployment_pipeline_role_assignment_request, "AddDeploymentPipelineRoleAssignmentRequest"
            )

        _request = build_deployment_pipelines_add_deployment_pipeline_role_assignment_request(
            deployment_pipeline_id=deployment_pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_deployment_pipeline_role_assignment(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, deployment_pipeline_id: str, principal_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified deployment pipeline role assignment.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param principal_id: The principal ID. Required.
        :type principal_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_deployment_pipelines_delete_deployment_pipeline_role_assignment_request(
            deployment_pipeline_id=deployment_pipeline_id,
            principal_id=principal_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_deployment_pipeline_operations(
        self, deployment_pipeline_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.DeploymentPipelineOperation"]:
        """Returns a list of the up-to-20 most recent deploy operations performed on the specified
        deployment pipeline.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of DeploymentPipelineOperation
        :rtype:
         ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.DeploymentPipelineOperation]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.DeploymentPipelineOperations] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deployment_pipelines_list_deployment_pipeline_operations_request(
                    deployment_pipeline_id=deployment_pipeline_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.DeploymentPipelineOperations, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deployment_pipeline_operation(
        self, deployment_pipeline_id: str, operation_id: str, **kwargs: Any
    ) -> _models.DeploymentPipelineOperationExtendedInfo:
        """Returns the details of the specified deploy operation performed on the specified deployment
        pipeline, including the deployment execution plan.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param operation_id: The operation ID. Required.
        :type operation_id: str
        :return: DeploymentPipelineOperationExtendedInfo
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineOperationExtendedInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeploymentPipelineOperationExtendedInfo] = kwargs.pop("cls", None)

        _request = build_deployment_pipelines_get_deployment_pipeline_operation_request(
            deployment_pipeline_id=deployment_pipeline_id,
            operation_id=operation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineOperationExtendedInfo", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_deployment_pipeline_stages(
        self, deployment_pipeline_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.DeploymentPipelineStage"]:
        """Returns the specified deployment pipeline stages.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of DeploymentPipelineStage
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.DeploymentPipelineStage]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.DeploymentPipelineStages] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deployment_pipelines_list_deployment_pipeline_stages_request(
                    deployment_pipeline_id=deployment_pipeline_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.DeploymentPipelineStages, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deployment_pipeline_stage(
        self, deployment_pipeline_id: str, stage_id: str, **kwargs: Any
    ) -> _models.DeploymentPipelineStage:
        """Returns the specified deployment pipeline stage metadata.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :return: DeploymentPipelineStage
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineStage
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeploymentPipelineStage] = kwargs.pop("cls", None)

        _request = build_deployment_pipelines_get_deployment_pipeline_stage_request(
            deployment_pipeline_id=deployment_pipeline_id,
            stage_id=stage_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineStage", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_deployment_pipeline_stage(
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        update_pipeline_stage_request: _models.DeploymentPipelineStageRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineStage:
        """Updates the properties of the specified deployment pipeline stage.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :param update_pipeline_stage_request: The update pipeline stage request. Required.
        :type update_pipeline_stage_request:
         ~microsoft.fabric.api.core.models.DeploymentPipelineStageRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineStage
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineStage
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_deployment_pipeline_stage(
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        update_pipeline_stage_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.DeploymentPipelineStage:
        """Updates the properties of the specified deployment pipeline stage.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :param update_pipeline_stage_request: The update pipeline stage request. Required.
        :type update_pipeline_stage_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeploymentPipelineStage
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineStage
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_deployment_pipeline_stage(
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        update_pipeline_stage_request: Union[_models.DeploymentPipelineStageRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.DeploymentPipelineStage:
        """Updates the properties of the specified deployment pipeline stage.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :param update_pipeline_stage_request: The update pipeline stage request. Is either a
         DeploymentPipelineStageRequest type or a IO[bytes] type. Required.
        :type update_pipeline_stage_request:
         ~microsoft.fabric.api.core.models.DeploymentPipelineStageRequest or IO[bytes]
        :return: DeploymentPipelineStage
        :rtype: ~microsoft.fabric.api.core.models.DeploymentPipelineStage
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DeploymentPipelineStage] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_pipeline_stage_request, (IOBase, bytes)):
            _content = update_pipeline_stage_request
        else:
            _json = self._serialize.body(update_pipeline_stage_request, "DeploymentPipelineStageRequest")

        _request = build_deployment_pipelines_update_deployment_pipeline_stage_request(
            deployment_pipeline_id=deployment_pipeline_id,
            stage_id=stage_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeploymentPipelineStage", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_deployment_pipeline_stage_items(
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        *,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.DeploymentPipelineStageItem"]:
        """Returns the supported items from the workspace assigned to the specified stage of the specified
        deployment pipeline.

        To learn about items that are supported in deployment pipelines, see: `Supported items
        </fabric/cicd/deployment-pipelines/intro-to-deployment-pipelines#supported-items>`_.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The user must be at least a workspace contributor assigned to the specified stage. For more
        information, see: `Permissions <https://go.microsoft.com/fwlink/?linkid=2235654>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.Read.All or Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of DeploymentPipelineStageItem
        :rtype:
         ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.DeploymentPipelineStageItem]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.DeploymentPipelineStageItems] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_deployment_pipelines_list_deployment_pipeline_stage_items_request(
                    deployment_pipeline_id=deployment_pipeline_id,
                    stage_id=stage_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.DeploymentPipelineStageItems, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _deploy_stage_content_initial(
        self, deployment_pipeline_id: str, deploy_request: Union[_models.DeployRequest, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(deploy_request, (IOBase, bytes)):
            _content = deploy_request
        else:
            _json = self._serialize.body(deploy_request, "DeployRequest")

        _request = build_deployment_pipelines_deploy_stage_content_request(
            deployment_pipeline_id=deployment_pipeline_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            deserialized = response.iter_bytes()

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["x-ms-operation-id"] = self._deserialize("str", response.headers.get("x-ms-operation-id"))
            response_headers["deployment-id"] = self._deserialize("str", response.headers.get("deployment-id"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_deploy_stage_content(
        self,
        deployment_pipeline_id: str,
        deploy_request: _models.DeployRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.DeploymentPipelineOperationExtendedInfo]:
        """Deploys items from the specified stage of the specified deployment pipeline.

        To learn about items that are supported in deployment pipelines, see: `Supported items
        </fabric/cicd/deployment-pipelines/intro-to-deployment-pipelines#supported-items>`_.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The user must be at least a contributor on both source and target deployment workspaces. For
        more information, see: `Permissions <https://go.microsoft.com/fwlink/?linkid=2235654>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param deploy_request: The deploy request. Required.
        :type deploy_request: ~microsoft.fabric.api.core.models.DeployRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns DeploymentPipelineOperationExtendedInfo
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.DeploymentPipelineOperationExtendedInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_deploy_stage_content(
        self,
        deployment_pipeline_id: str,
        deploy_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.DeploymentPipelineOperationExtendedInfo]:
        """Deploys items from the specified stage of the specified deployment pipeline.

        To learn about items that are supported in deployment pipelines, see: `Supported items
        </fabric/cicd/deployment-pipelines/intro-to-deployment-pipelines#supported-items>`_.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The user must be at least a contributor on both source and target deployment workspaces. For
        more information, see: `Permissions <https://go.microsoft.com/fwlink/?linkid=2235654>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param deploy_request: The deploy request. Required.
        :type deploy_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns DeploymentPipelineOperationExtendedInfo
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.DeploymentPipelineOperationExtendedInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_deploy_stage_content(
        self, deployment_pipeline_id: str, deploy_request: Union[_models.DeployRequest, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.DeploymentPipelineOperationExtendedInfo]:
        """Deploys items from the specified stage of the specified deployment pipeline.

        To learn about items that are supported in deployment pipelines, see: `Supported items
        </fabric/cicd/deployment-pipelines/intro-to-deployment-pipelines#supported-items>`_.

        This API supports `long running operations (LRO)
        </rest/api/fabric/articles/long-running-operation>`_.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The user must be at least a contributor on both source and target deployment workspaces. For
        more information, see: `Permissions <https://go.microsoft.com/fwlink/?linkid=2235654>`_.

        Required Delegated Scopes
        -------------------------

        Pipeline.Deploy

        Limitations
        -----------

        Maximum 300 deployed items per request.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Only supported when all the `items
        </rest/api/fabric/articles/item-management/item-management-overview>`_ involved in the
        operation support service principals


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param deploy_request: The deploy request. Is either a DeployRequest type or a IO[bytes] type.
         Required.
        :type deploy_request: ~microsoft.fabric.api.core.models.DeployRequest or IO[bytes]
        :return: An instance of LROPoller that returns DeploymentPipelineOperationExtendedInfo
        :rtype:
         ~azure.core.polling.LROPoller[~microsoft.fabric.api.core.models.DeploymentPipelineOperationExtendedInfo]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DeploymentPipelineOperationExtendedInfo] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._deploy_stage_content_initial(
                deployment_pipeline_id=deployment_pipeline_id,
                deploy_request=deploy_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("DeploymentPipelineOperationExtendedInfo", pipeline_response.http_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, LROBasePolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.DeploymentPipelineOperationExtendedInfo].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.DeploymentPipelineOperationExtendedInfo](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    def assign_workspace_to_stage(  # pylint: disable=inconsistent-return-statements
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        deployment_pipeline_assign_workspace_request: _models.DeploymentPipelineAssignWorkspaceRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified deployment pipeline stage.

        This operation will fail if there's an active deployment operation.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * The specified deployment pipeline stage must not be assigned to any other workspace.

          * Only workspace admins can assign it to a deployment pipeline stage.

        * The specified workspace isn't assigned to any other deployment pipeline stage.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :param deployment_pipeline_assign_workspace_request: The assign workspace request. Required.
        :type deployment_pipeline_assign_workspace_request:
         ~microsoft.fabric.api.core.models.DeploymentPipelineAssignWorkspaceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def assign_workspace_to_stage(  # pylint: disable=inconsistent-return-statements
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        deployment_pipeline_assign_workspace_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified deployment pipeline stage.

        This operation will fail if there's an active deployment operation.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * The specified deployment pipeline stage must not be assigned to any other workspace.

          * Only workspace admins can assign it to a deployment pipeline stage.

        * The specified workspace isn't assigned to any other deployment pipeline stage.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :param deployment_pipeline_assign_workspace_request: The assign workspace request. Required.
        :type deployment_pipeline_assign_workspace_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def assign_workspace_to_stage(  # pylint: disable=inconsistent-return-statements
        self,
        deployment_pipeline_id: str,
        stage_id: str,
        deployment_pipeline_assign_workspace_request: Union[
            _models.DeploymentPipelineAssignWorkspaceRequest, IO[bytes]
        ],
        **kwargs: Any,
    ) -> None:
        """Assigns the specified workspace to the specified deployment pipeline stage.

        This operation will fail if there's an active deployment operation.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.
        The caller must have an *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All and Workspace.ReadWrite.All

        Limitations
        -----------


        * The specified deployment pipeline stage must not be assigned to any other workspace.

          * Only workspace admins can assign it to a deployment pipeline stage.

        * The specified workspace isn't assigned to any other deployment pipeline stage.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :param deployment_pipeline_assign_workspace_request: The assign workspace request. Is either a
         DeploymentPipelineAssignWorkspaceRequest type or a IO[bytes] type. Required.
        :type deployment_pipeline_assign_workspace_request:
         ~microsoft.fabric.api.core.models.DeploymentPipelineAssignWorkspaceRequest or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(deployment_pipeline_assign_workspace_request, (IOBase, bytes)):
            _content = deployment_pipeline_assign_workspace_request
        else:
            _json = self._serialize.body(
                deployment_pipeline_assign_workspace_request, "DeploymentPipelineAssignWorkspaceRequest"
            )

        _request = build_deployment_pipelines_assign_workspace_to_stage_request(
            deployment_pipeline_id=deployment_pipeline_id,
            stage_id=stage_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def unassign_workspace_from_stage(  # pylint: disable=inconsistent-return-statements
        self, deployment_pipeline_id: str, stage_id: str, **kwargs: Any
    ) -> None:
        """Unassigns the workspace from the specified stage in the specified deployment pipeline.

        This operation will fail if there's an active deployment operation.

        Permissions
        -----------

        The caller must have an *admin* deployment pipelines role.

        Required Delegated Scopes
        -------------------------

        Pipeline.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param deployment_pipeline_id: The deployment pipeline ID. Required.
        :type deployment_pipeline_id: str
        :param stage_id: The deployment pipeline stage ID. Required.
        :type stage_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_deployment_pipelines_unassign_workspace_from_stage_request(
            deployment_pipeline_id=deployment_pipeline_id,
            stage_id=stage_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class OneLakeDataAccessSecurityOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`one_lake_data_access_security` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_data_access_roles(
        self, workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> _models.DataAccessRoles:
        """Returns a list of OneLake roles.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Required Delegated Scopes
        -------------------------

         OneLake.Read.All or OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The ID of the Fabric item to put the roles. Required.
        :type item_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: DataAccessRoles
        :rtype: ~microsoft.fabric.api.core.models.DataAccessRoles
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DataAccessRoles] = kwargs.pop("cls", None)

        _request = build_one_lake_data_access_security_list_data_access_roles_request(
            workspace_id=workspace_id,
            item_id=item_id,
            continuation_token_parameter=continuation_token_parameter,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Etag"] = self._deserialize("str", response.headers.get("Etag"))

        deserialized = self._deserialize("DataAccessRoles", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_update_data_access_roles(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        create_or_update_data_access_roles_request: _models.CreateOrUpdateDataAccessRolesRequest,
        *,
        dry_run: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any,
    ) -> None:
        """Creates or updates data access roles in OneLake.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Required Delegated Scopes
        -------------------------

         OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The ID of the Fabric item to put the roles. Required.
        :type item_id: str
        :param create_or_update_data_access_roles_request: Contains definition of roles used to manage
         data access security and ensure that only authorized users can view, edit, or delete certain
         data. Calling this API updates role definitions and creates, updates, or deletes roles to match
         the provided payload. Required.
        :type create_or_update_data_access_roles_request:
         ~microsoft.fabric.api.core.models.CreateOrUpdateDataAccessRolesRequest
        :keyword dry_run: Used to trigger a dry run of the API call. True - The API call will trigger a
         dry run and no roles will be changed. False - Will not trigger a dry run and roles will be
         updated. Default value is None.
        :paramtype dry_run: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_update_data_access_roles(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        create_or_update_data_access_roles_request: IO[bytes],
        *,
        dry_run: Optional[bool] = None,
        content_type: str = "application/json",
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any,
    ) -> None:
        """Creates or updates data access roles in OneLake.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Required Delegated Scopes
        -------------------------

         OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The ID of the Fabric item to put the roles. Required.
        :type item_id: str
        :param create_or_update_data_access_roles_request: Contains definition of roles used to manage
         data access security and ensure that only authorized users can view, edit, or delete certain
         data. Calling this API updates role definitions and creates, updates, or deletes roles to match
         the provided payload. Required.
        :type create_or_update_data_access_roles_request: IO[bytes]
        :keyword dry_run: Used to trigger a dry run of the API call. True - The API call will trigger a
         dry run and no roles will be changed. False - Will not trigger a dry run and roles will be
         updated. Default value is None.
        :paramtype dry_run: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_update_data_access_roles(  # pylint: disable=inconsistent-return-statements
        self,
        workspace_id: str,
        item_id: str,
        create_or_update_data_access_roles_request: Union[_models.CreateOrUpdateDataAccessRolesRequest, IO[bytes]],
        *,
        dry_run: Optional[bool] = None,
        etag: Optional[str] = None,
        match_condition: Optional[MatchConditions] = None,
        **kwargs: Any,
    ) -> None:
        """Creates or updates data access roles in OneLake.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Required Delegated Scopes
        -------------------------

         OneLake.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The ID of the Fabric item to put the roles. Required.
        :type item_id: str
        :param create_or_update_data_access_roles_request: Contains definition of roles used to manage
         data access security and ensure that only authorized users can view, edit, or delete certain
         data. Calling this API updates role definitions and creates, updates, or deletes roles to match
         the provided payload. Is either a CreateOrUpdateDataAccessRolesRequest type or a IO[bytes]
         type. Required.
        :type create_or_update_data_access_roles_request:
         ~microsoft.fabric.api.core.models.CreateOrUpdateDataAccessRolesRequest or IO[bytes]
        :keyword dry_run: Used to trigger a dry run of the API call. True - The API call will trigger a
         dry run and no roles will be changed. False - Will not trigger a dry run and roles will be
         updated. Default value is None.
        :paramtype dry_run: bool
        :keyword etag: check if resource is changed. Set None to skip checking etag. Default value is
         None.
        :paramtype etag: str
        :keyword match_condition: The match condition to use upon the etag. Default value is None.
        :paramtype match_condition: ~azure.core.MatchConditions
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        if match_condition == MatchConditions.IfNotModified:
            error_map[412] = ResourceModifiedError
        elif match_condition == MatchConditions.IfPresent:
            error_map[412] = ResourceNotFoundError
        elif match_condition == MatchConditions.IfMissing:
            error_map[412] = ResourceExistsError
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_or_update_data_access_roles_request, (IOBase, bytes)):
            _content = create_or_update_data_access_roles_request
        else:
            _json = self._serialize.body(
                create_or_update_data_access_roles_request, "CreateOrUpdateDataAccessRolesRequest"
            )

        _request = build_one_lake_data_access_security_create_or_update_data_access_roles_request(
            workspace_id=workspace_id,
            item_id=item_id,
            dry_run=dry_run,
            etag=etag,
            match_condition=match_condition,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Etag"] = self._deserialize("str", response.headers.get("Etag"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore


class ExternalDataSharesProviderOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`external_data_shares_provider` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create_external_data_share(
        self,
        workspace_id: str,
        item_id: str,
        create_external_data_share_request: _models.CreateExternalDataShareRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ExternalDataShare:
        """Creates an external data share for a given path or list of paths in the specified item.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Supported item types: See `External data sharing in Microsoft Fabric - Supported item types
        </fabric/governance/external-data-sharing-overview#supported-fabric-item-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param create_external_data_share_request: The request payload for creating an external data
         share. Required.
        :type create_external_data_share_request:
         ~microsoft.fabric.api.core.models.CreateExternalDataShareRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExternalDataShare
        :rtype: ~microsoft.fabric.api.core.models.ExternalDataShare
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_external_data_share(
        self,
        workspace_id: str,
        item_id: str,
        create_external_data_share_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ExternalDataShare:
        """Creates an external data share for a given path or list of paths in the specified item.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Supported item types: See `External data sharing in Microsoft Fabric - Supported item types
        </fabric/governance/external-data-sharing-overview#supported-fabric-item-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param create_external_data_share_request: The request payload for creating an external data
         share. Required.
        :type create_external_data_share_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ExternalDataShare
        :rtype: ~microsoft.fabric.api.core.models.ExternalDataShare
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_external_data_share(
        self,
        workspace_id: str,
        item_id: str,
        create_external_data_share_request: Union[_models.CreateExternalDataShareRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.ExternalDataShare:
        """Creates an external data share for a given path or list of paths in the specified item.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Supported item types: See `External data sharing in Microsoft Fabric - Supported item types
        </fabric/governance/external-data-sharing-overview#supported-fabric-item-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param create_external_data_share_request: The request payload for creating an external data
         share. Is either a CreateExternalDataShareRequest type or a IO[bytes] type. Required.
        :type create_external_data_share_request:
         ~microsoft.fabric.api.core.models.CreateExternalDataShareRequest or IO[bytes]
        :return: ExternalDataShare
        :rtype: ~microsoft.fabric.api.core.models.ExternalDataShare
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ExternalDataShare] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_external_data_share_request, (IOBase, bytes)):
            _content = create_external_data_share_request
        else:
            _json = self._serialize.body(create_external_data_share_request, "CreateExternalDataShareRequest")

        _request = build_external_data_shares_provider_create_external_data_share_request(
            workspace_id=workspace_id,
            item_id=item_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("ExternalDataShare", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_external_data_shares_in_item(
        self, workspace_id: str, item_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.ExternalDataShare"]:
        """Returns a list of the external data shares that exist for the specified item.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ExternalDataShare
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ExternalDataShare]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ExternalDataShares] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_external_data_shares_provider_list_external_data_shares_in_item_request(
                    workspace_id=workspace_id,
                    item_id=item_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ExternalDataShares, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_external_data_share(
        self, workspace_id: str, item_id: str, external_data_share_id: str, **kwargs: Any
    ) -> _models.ExternalDataShare:
        """Returns the details of the specified external data share.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param external_data_share_id: The external data share ID. Required.
        :type external_data_share_id: str
        :return: ExternalDataShare
        :rtype: ~microsoft.fabric.api.core.models.ExternalDataShare
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExternalDataShare] = kwargs.pop("cls", None)

        _request = build_external_data_shares_provider_get_external_data_share_request(
            workspace_id=workspace_id,
            item_id=item_id,
            external_data_share_id=external_data_share_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ExternalDataShare", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_external_data_share(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, item_id: str, external_data_share_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified external data share.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param external_data_share_id: The external data share ID. Required.
        :type external_data_share_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_external_data_shares_provider_delete_external_data_share_request(
            workspace_id=workspace_id,
            item_id=item_id,
            external_data_share_id=external_data_share_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def revoke_external_data_share(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, item_id: str, external_data_share_id: str, **kwargs: Any
    ) -> None:
        """Revokes the specified external data share. This action cannot be undone.

        Permissions
        -----------

        The caller must have *read* and *reshare* permissions on the item.

        Required Delegated Scopes
        -------------------------

        Item APIs can have one of these scopes in their token:


        * Generic scope: Item.ExternalDataShare.All
        *
          Specific scope: *itemType*.ExternalDataShare.All, for example:
        Lakehouse.ExternalDataShare.All

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *External data sharing* admin switch for the calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param item_id: The item ID. Required.
        :type item_id: str
        :param external_data_share_id: The external data share ID. Required.
        :type external_data_share_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_external_data_shares_provider_revoke_external_data_share_request(
            workspace_id=workspace_id,
            item_id=item_id,
            external_data_share_id=external_data_share_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class ExternalDataSharesRecipientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`external_data_shares_recipient` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_external_data_share_invitation_details(  # pylint: disable=name-too-long
        self, invitation_id: str, *, provider_tenant_id: str, **kwargs: Any
    ) -> _models.ExternalDataShareInvitationDetails:
        """Returns information about an external data share invitation.

        Required Delegated Scopes
        -------------------------

        ExternalDataShare.Accept.All

        Required Tenant Settings
        ------------------------

        To use this API, enable the *Users can accept external data shares* admin switch for the
        calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - No


        Interface
        ---------.

        :param invitation_id: The external data share invitation ID. Required.
        :type invitation_id: str
        :keyword provider_tenant_id: The external data share provider tenant ID. Required.
        :paramtype provider_tenant_id: str
        :return: ExternalDataShareInvitationDetails
        :rtype: ~microsoft.fabric.api.core.models.ExternalDataShareInvitationDetails
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ExternalDataShareInvitationDetails] = kwargs.pop("cls", None)

        _request = build_external_data_shares_recipient_get_external_data_share_invitation_details_request(
            invitation_id=invitation_id,
            provider_tenant_id=provider_tenant_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ExternalDataShareInvitationDetails", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def accept_external_data_share_invitation(
        self,
        invitation_id: str,
        accept_external_data_share_request: _models.AcceptExternalDataShareInvitationRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AcceptExternalDataShareInvitationResponse:
        """Accepts an external data share invitation into a specified data item.

        Permissions
        -----------

        The caller must have *write* permissions on the item.

        Required Delegated Scopes
        -------------------------

        ExternalDataShare.Accept.All and for the specified item, one of the 2 types of scopes:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Lakehouse.ReadWrite.All)

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *Users can accept external data shares* admin switch for the
        calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - No


        Interface
        ---------.

        :param invitation_id: The external data share invitation ID. Required.
        :type invitation_id: str
        :param accept_external_data_share_request: The request payload for accepting an external data
         share invitation. Required.
        :type accept_external_data_share_request:
         ~microsoft.fabric.api.core.models.AcceptExternalDataShareInvitationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AcceptExternalDataShareInvitationResponse
        :rtype: ~microsoft.fabric.api.core.models.AcceptExternalDataShareInvitationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def accept_external_data_share_invitation(
        self,
        invitation_id: str,
        accept_external_data_share_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AcceptExternalDataShareInvitationResponse:
        """Accepts an external data share invitation into a specified data item.

        Permissions
        -----------

        The caller must have *write* permissions on the item.

        Required Delegated Scopes
        -------------------------

        ExternalDataShare.Accept.All and for the specified item, one of the 2 types of scopes:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Lakehouse.ReadWrite.All)

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *Users can accept external data shares* admin switch for the
        calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - No


        Interface
        ---------.

        :param invitation_id: The external data share invitation ID. Required.
        :type invitation_id: str
        :param accept_external_data_share_request: The request payload for accepting an external data
         share invitation. Required.
        :type accept_external_data_share_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AcceptExternalDataShareInvitationResponse
        :rtype: ~microsoft.fabric.api.core.models.AcceptExternalDataShareInvitationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def accept_external_data_share_invitation(
        self,
        invitation_id: str,
        accept_external_data_share_request: Union[_models.AcceptExternalDataShareInvitationRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.AcceptExternalDataShareInvitationResponse:
        """Accepts an external data share invitation into a specified data item.

        Permissions
        -----------

        The caller must have *write* permissions on the item.

        Required Delegated Scopes
        -------------------------

        ExternalDataShare.Accept.All and for the specified item, one of the 2 types of scopes:


        * Generic scope: Item.ReadWrite.All
        *
          Specific scope: *itemType*.ReadWrite.All (for example: Lakehouse.ReadWrite.All)

          For more information about scopes, see `scopes article </rest/api/fabric/articles/scopes>`_.

        Required Tenant Settings
        ------------------------

        To use this API, enable the *Users can accept external data shares* admin switch for the
        calling principal.

        Limitations
        -----------

        Maximum 10 requests per minute.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - No


        Interface
        ---------.

        :param invitation_id: The external data share invitation ID. Required.
        :type invitation_id: str
        :param accept_external_data_share_request: The request payload for accepting an external data
         share invitation. Is either a AcceptExternalDataShareInvitationRequest type or a IO[bytes]
         type. Required.
        :type accept_external_data_share_request:
         ~microsoft.fabric.api.core.models.AcceptExternalDataShareInvitationRequest or IO[bytes]
        :return: AcceptExternalDataShareInvitationResponse
        :rtype: ~microsoft.fabric.api.core.models.AcceptExternalDataShareInvitationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AcceptExternalDataShareInvitationResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(accept_external_data_share_request, (IOBase, bytes)):
            _content = accept_external_data_share_request
        else:
            _json = self._serialize.body(accept_external_data_share_request, "AcceptExternalDataShareInvitationRequest")

        _request = build_external_data_shares_recipient_accept_external_data_share_invitation_request(
            invitation_id=invitation_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("AcceptExternalDataShareInvitationResponse", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class FoldersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`folders` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_folders(
        self,
        workspace_id: str,
        *,
        root_folder_id: Optional[str] = None,
        recursive: Optional[bool] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.Folder"]:
        """Returns a list of folders from the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------

         The caller must have *viewer* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :keyword root_folder_id: This parameter allows users to filter folders based on a specific root
         folder. If not provided, the workspace is used as the root folder. Default value is None.
        :paramtype root_folder_id: str
        :keyword recursive: Lists folders in a folder and its nested folders, or just a folder only.
         True - All folders in the folder and its nested folders are listed, False - Only folders in the
         folder are listed. The default value is true. Default value is None.
        :paramtype recursive: bool
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Folder
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Folder]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.Folders] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_folders_list_folders_request(
                    workspace_id=workspace_id,
                    root_folder_id=root_folder_id,
                    recursive=recursive,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.Folders, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_folder(
        self,
        workspace_id: str,
        create_folder_request: _models.CreateFolderRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Folder:
        """Creates a folder in the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_folder_request: Create folder request payload. Required.
        :type create_folder_request: ~microsoft.fabric.api.core.models.CreateFolderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_folder(
        self,
        workspace_id: str,
        create_folder_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Folder:
        """Creates a folder in the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_folder_request: Create folder request payload. Required.
        :type create_folder_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_folder(
        self, workspace_id: str, create_folder_request: Union[_models.CreateFolderRequest, IO[bytes]], **kwargs: Any
    ) -> _models.Folder:
        """Creates a folder in the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_folder_request: Create folder request payload. Is either a CreateFolderRequest
         type or a IO[bytes] type. Required.
        :type create_folder_request: ~microsoft.fabric.api.core.models.CreateFolderRequest or IO[bytes]
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Folder] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_folder_request, (IOBase, bytes)):
            _content = create_folder_request
        else:
            _json = self._serialize.body(create_folder_request, "CreateFolderRequest")

        _request = build_folders_create_folder_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Folder", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_folder(self, workspace_id: str, folder_id: str, **kwargs: Any) -> _models.Folder:
        """Returns the properties of the specified folder.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *viewer* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Folder] = kwargs.pop("cls", None)

        _request = build_folders_get_folder_request(
            workspace_id=workspace_id,
            folder_id=folder_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Folder", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_folder(
        self,
        workspace_id: str,
        folder_id: str,
        update_folder_request: _models.UpdateFolderRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Folder:
        """Updates the properties of the specified folder.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :param update_folder_request: Update folder request payload. Required.
        :type update_folder_request: ~microsoft.fabric.api.core.models.UpdateFolderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_folder(
        self,
        workspace_id: str,
        folder_id: str,
        update_folder_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Folder:
        """Updates the properties of the specified folder.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :param update_folder_request: Update folder request payload. Required.
        :type update_folder_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_folder(
        self,
        workspace_id: str,
        folder_id: str,
        update_folder_request: Union[_models.UpdateFolderRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.Folder:
        """Updates the properties of the specified folder.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :param update_folder_request: Update folder request payload. Is either a UpdateFolderRequest
         type or a IO[bytes] type. Required.
        :type update_folder_request: ~microsoft.fabric.api.core.models.UpdateFolderRequest or IO[bytes]
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Folder] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_folder_request, (IOBase, bytes)):
            _content = update_folder_request
        else:
            _json = self._serialize.body(update_folder_request, "UpdateFolderRequest")

        _request = build_folders_update_folder_request(
            workspace_id=workspace_id,
            folder_id=folder_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Folder", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_folder(  # pylint: disable=inconsistent-return-statements
        self, workspace_id: str, folder_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified folder.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Limitations
        -----------


        * This API is supported only for the empty folder. Deleting a folder with any items or nested
        folders inside is not allowed, and returns a FolderNotEmpty error response.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_folders_delete_folder_request(
            workspace_id=workspace_id,
            folder_id=folder_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def move_folder(
        self,
        workspace_id: str,
        folder_id: str,
        move_folder_request: _models.MoveFolderRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Folder:
        """Moves the specified folder within the same workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :param move_folder_request: Move folder request payload. Required.
        :type move_folder_request: ~microsoft.fabric.api.core.models.MoveFolderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def move_folder(
        self,
        workspace_id: str,
        folder_id: str,
        move_folder_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Folder:
        """Moves the specified folder within the same workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :param move_folder_request: Move folder request payload. Required.
        :type move_folder_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def move_folder(
        self,
        workspace_id: str,
        folder_id: str,
        move_folder_request: Union[_models.MoveFolderRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.Folder:
        """Moves the specified folder within the same workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *contributor* or higher role on the workspace.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param folder_id: The folder ID. Required.
        :type folder_id: str
        :param move_folder_request: Move folder request payload. Is either a MoveFolderRequest type or
         a IO[bytes] type. Required.
        :type move_folder_request: ~microsoft.fabric.api.core.models.MoveFolderRequest or IO[bytes]
        :return: Folder
        :rtype: ~microsoft.fabric.api.core.models.Folder
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Folder] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(move_folder_request, (IOBase, bytes)):
            _content = move_folder_request
        else:
            _json = self._serialize.body(move_folder_request, "MoveFolderRequest")

        _request = build_folders_move_folder_request(
            workspace_id=workspace_id,
            folder_id=folder_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Folder", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ManagedPrivateEndpointsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`managed_private_endpoints` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_workspace_managed_private_endpoints(
        self, workspace_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.ManagedPrivateEndpoint"]:
        """Returns a list of managed private endpoints associated with the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

         The caller must have *viewer* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ManagedPrivateEndpoint
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ManagedPrivateEndpoint]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ManagedPrivateEndpoints] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_managed_private_endpoints_list_workspace_managed_private_endpoints_request(
                    workspace_id=workspace_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ManagedPrivateEndpoints, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_workspace_managed_private_endpoint(  # pylint: disable=name-too-long
        self,
        workspace_id: str,
        create_managed_private_endpoint_request: _models.CreateManagedPrivateEndpointRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ManagedPrivateEndpoint:
        """Creates a managed private endpoint in the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All.

        Limitations
        -----------


        * To create managed private endpoint the workspace must be on a supported Fabric capacity. For
        more information see: `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_managed_private_endpoint_request: Create managed private endpoint request
         payload. Required.
        :type create_managed_private_endpoint_request:
         ~microsoft.fabric.api.core.models.CreateManagedPrivateEndpointRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ManagedPrivateEndpoint
        :rtype: ~microsoft.fabric.api.core.models.ManagedPrivateEndpoint
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_workspace_managed_private_endpoint(  # pylint: disable=name-too-long
        self,
        workspace_id: str,
        create_managed_private_endpoint_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ManagedPrivateEndpoint:
        """Creates a managed private endpoint in the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All.

        Limitations
        -----------


        * To create managed private endpoint the workspace must be on a supported Fabric capacity. For
        more information see: `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_managed_private_endpoint_request: Create managed private endpoint request
         payload. Required.
        :type create_managed_private_endpoint_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ManagedPrivateEndpoint
        :rtype: ~microsoft.fabric.api.core.models.ManagedPrivateEndpoint
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_workspace_managed_private_endpoint(  # pylint: disable=name-too-long
        self,
        workspace_id: str,
        create_managed_private_endpoint_request: Union[_models.CreateManagedPrivateEndpointRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.ManagedPrivateEndpoint:
        """Creates a managed private endpoint in the specified workspace.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All.

        Limitations
        -----------


        * To create managed private endpoint the workspace must be on a supported Fabric capacity. For
        more information see: `Microsoft Fabric license types
        </fabric/enterprise/licenses#microsoft-fabric-license-types>`_.

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param create_managed_private_endpoint_request: Create managed private endpoint request
         payload. Is either a CreateManagedPrivateEndpointRequest type or a IO[bytes] type. Required.
        :type create_managed_private_endpoint_request:
         ~microsoft.fabric.api.core.models.CreateManagedPrivateEndpointRequest or IO[bytes]
        :return: ManagedPrivateEndpoint
        :rtype: ~microsoft.fabric.api.core.models.ManagedPrivateEndpoint
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_managed_private_endpoint_request, (IOBase, bytes)):
            _content = create_managed_private_endpoint_request
        else:
            _json = self._serialize.body(create_managed_private_endpoint_request, "CreateManagedPrivateEndpointRequest")

        _request = build_managed_private_endpoints_create_workspace_managed_private_endpoint_request(
            workspace_id=workspace_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_workspace_managed_private_endpoint(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, workspace_id: str, managed_private_endpoint_id: str, **kwargs: Any
    ) -> None:
        """Deletes the specified managed private endpoint.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *admin* workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param managed_private_endpoint_id: The managed private endpoint ID. Required.
        :type managed_private_endpoint_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_managed_private_endpoints_delete_workspace_managed_private_endpoint_request(
            workspace_id=workspace_id,
            managed_private_endpoint_id=managed_private_endpoint_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_workspace_managed_private_endpoint(
        self, workspace_id: str, managed_private_endpoint_id: str, **kwargs: Any
    ) -> _models.ManagedPrivateEndpoint:
        """Gets the specified managed private endpoint.

        ..

           [!NOTE]
           This API is part of a Preview release and is provided for evaluation and development
        purposes only. It may change based on feedback and is not recommended for production use.


        Permissions
        -----------

        The caller must have *viewer* or higher workspace role.

        Required Delegated Scopes
        -------------------------

        Workspace.Read.All or Workspace.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param workspace_id: The workspace ID. Required.
        :type workspace_id: str
        :param managed_private_endpoint_id: The managed private endpoint ID. Required.
        :type managed_private_endpoint_id: str
        :return: ManagedPrivateEndpoint
        :rtype: ~microsoft.fabric.api.core.models.ManagedPrivateEndpoint
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)

        _request = build_managed_private_endpoints_get_workspace_managed_private_endpoint_request(
            workspace_id=workspace_id,
            managed_private_endpoint_id=managed_private_endpoint_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ConnectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`connections` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_connections(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.Connection"]:
        """Returns a list of on-premises, virtual network and cloud connections the user has permission
        for.

        Permissions
        -----------

        The caller must have permission for the connection.

        Required Delegated Scopes
        -------------------------

        Connection.Read.All or Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Connection
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Connection]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ListConnectionsResponse] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_connections_list_connections_request(
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ListConnectionsResponse, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_connection(
        self,
        create_connection_request: _models.CreateConnectionRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Connection:
        """Creates a connection.

        To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_.

        Permissions
        -----------


        * If creating a gateway connection, the caller must have permissions for the gateway..
        * Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_connection_request: The request payload for creating the connection. Required.
        :type create_connection_request: ~microsoft.fabric.api.core.models.CreateConnectionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_connection(
        self, create_connection_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Connection:
        """Creates a connection.

        To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_.

        Permissions
        -----------


        * If creating a gateway connection, the caller must have permissions for the gateway..
        * Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_connection_request: The request payload for creating the connection. Required.
        :type create_connection_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_connection(
        self, create_connection_request: Union[_models.CreateConnectionRequest, IO[bytes]], **kwargs: Any
    ) -> _models.Connection:
        """Creates a connection.

        To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_.

        Permissions
        -----------


        * If creating a gateway connection, the caller must have permissions for the gateway..
        * Service Principals must have permission granted by Fabric administrator. For more information
        see: `Service principals can create workspaces, connections, and deployment pipelines
        </fabric/admin/service-admin-portal-developer#service-principals-can-create-workspaces-connections-and-deployment-pipelines>`_.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_connection_request: The request payload for creating the connection. Is either a
         CreateConnectionRequest type or a IO[bytes] type. Required.
        :type create_connection_request: ~microsoft.fabric.api.core.models.CreateConnectionRequest or
         IO[bytes]
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Connection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_connection_request, (IOBase, bytes)):
            _content = create_connection_request
        else:
            _json = self._serialize.body(create_connection_request, "CreateConnectionRequest")

        _request = build_connections_create_connection_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Connection", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_connection(self, connection_id: str, **kwargs: Any) -> _models.Connection:
        """Get connection by ID.

        Permissions
        -----------

        The caller must have permission for the connection or admin permission for the gateway of the
        connection.

        Required Delegated Scopes
        -------------------------

        Connection.Read.All or Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Connection] = kwargs.pop("cls", None)

        _request = build_connections_get_connection_request(
            connection_id=connection_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Connection", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_connection(
        self,
        connection_id: str,
        update_connection_request: _models.UpdateConnectionRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Connection:
        """Updates connection by ID.

        To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_.

        Permissions
        -----------

        The caller must have permission for the connection or admin permission for the gateway of the
        connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param update_connection_request: The request payload for updating the connection. Required.
        :type update_connection_request: ~microsoft.fabric.api.core.models.UpdateConnectionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_connection(
        self,
        connection_id: str,
        update_connection_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Connection:
        """Updates connection by ID.

        To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_.

        Permissions
        -----------

        The caller must have permission for the connection or admin permission for the gateway of the
        connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param update_connection_request: The request payload for updating the connection. Required.
        :type update_connection_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_connection(
        self,
        connection_id: str,
        update_connection_request: Union[_models.UpdateConnectionRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.Connection:
        """Updates connection by ID.

        To encrypt credentials, see `Configure credentials programmatically
        </power-bi/developer/embedded/configure-credentials>`_.

        Permissions
        -----------

        The caller must have permission for the connection or admin permission for the gateway of the
        connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param update_connection_request: The request payload for updating the connection. Is either a
         UpdateConnectionRequest type or a IO[bytes] type. Required.
        :type update_connection_request: ~microsoft.fabric.api.core.models.UpdateConnectionRequest or
         IO[bytes]
        :return: Connection
        :rtype: ~microsoft.fabric.api.core.models.Connection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Connection] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_connection_request, (IOBase, bytes)):
            _content = update_connection_request
        else:
            _json = self._serialize.body(update_connection_request, "UpdateConnectionRequest")

        _request = build_connections_update_connection_request(
            connection_id=connection_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Connection", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_connection(  # pylint: disable=inconsistent-return-statements
        self, connection_id: str, **kwargs: Any
    ) -> None:
        """Delete connection by ID.

        Permissions
        -----------

        The caller must have owner permission for the connection or admin permission for the gateway of
        the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_connections_delete_connection_request(
            connection_id=connection_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_supported_connection_types(
        self,
        *,
        gateway_id: Optional[str] = None,
        show_all_creation_methods: Optional[bool] = None,
        continuation_token_parameter: Optional[str] = None,
        **kwargs: Any,
    ) -> Iterable["_models.ConnectionCreationMetadata"]:
        """Lists supported connection types.

        Permissions
        -----------

        If called with gatewayId, the caller must have permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Connection.Read.All or Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword gateway_id: The gateway to list supported connection types. If omitted, the API lists
         supported connection types in the cloud. Default value is None.
        :paramtype gateway_id: str
        :keyword show_all_creation_methods: Setting that controls whether to show all creation methods.
         True - Show all creation methods, False - Show only recommended creation methods. Default value
         is None.
        :paramtype show_all_creation_methods: bool
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ConnectionCreationMetadata
        :rtype:
         ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ConnectionCreationMetadata]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ListSupportedConnectionTypesResponse] = kwargs.pop(
            "cls", None
        )  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_connections_list_supported_connection_types_request(
                    gateway_id=gateway_id,
                    show_all_creation_methods=show_all_creation_methods,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ListSupportedConnectionTypesResponse,  # pylint: disable=protected-access
                pipeline_response,
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_connection_role_assignments(
        self, connection_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.ConnectionRoleAssignment"]:
        """Returns a list of connection role assignments.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------


        * The caller must have *User* or higher role on the connection or be an *Admin* on the gateway
        that's bound to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.Read.All or Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of ConnectionRoleAssignment
        :rtype:
         ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.ConnectionRoleAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ConnectionRoleAssignments] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_connections_list_connection_role_assignments_request(
                    connection_id=connection_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ConnectionRoleAssignments, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add_connection_role_assignment(
        self,
        connection_id: str,
        add_connection_role_assignment_request: _models.AddConnectionRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ConnectionRoleAssignment:
        """Adds a connection role assignment.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *UserWithReshare* or higher role on the connection or be an *Admin* on
        the gateway that's bound to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param add_connection_role_assignment_request: The request payload for adding a connection role
         assignment. Required.
        :type add_connection_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddConnectionRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_connection_role_assignment(
        self,
        connection_id: str,
        add_connection_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ConnectionRoleAssignment:
        """Adds a connection role assignment.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *UserWithReshare* or higher role on the connection or be an *Admin* on
        the gateway that's bound to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param add_connection_role_assignment_request: The request payload for adding a connection role
         assignment. Required.
        :type add_connection_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_connection_role_assignment(
        self,
        connection_id: str,
        add_connection_role_assignment_request: Union[_models.AddConnectionRoleAssignmentRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.ConnectionRoleAssignment:
        """Adds a connection role assignment.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *UserWithReshare* or higher role on the connection or be an *Admin* on
        the gateway that's bound to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param add_connection_role_assignment_request: The request payload for adding a connection role
         assignment. Is either a AddConnectionRoleAssignmentRequest type or a IO[bytes] type. Required.
        :type add_connection_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddConnectionRoleAssignmentRequest or IO[bytes]
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConnectionRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(add_connection_role_assignment_request, (IOBase, bytes)):
            _content = add_connection_role_assignment_request
        else:
            _json = self._serialize.body(add_connection_role_assignment_request, "AddConnectionRoleAssignmentRequest")

        _request = build_connections_add_connection_role_assignment_request(
            connection_id=connection_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("ConnectionRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_connection_role_assignment(
        self, connection_id: str, connection_role_assignment_id: str, **kwargs: Any
    ) -> _models.ConnectionRoleAssignment:
        """Returns the principal's role assignment for the connection.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *User* or higher role on the connection or be an *Admin* on the gateway
        that's bound to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.Read.All or Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param connection_role_assignment_id: The ID of the connection role assignment. Required.
        :type connection_role_assignment_id: str
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConnectionRoleAssignment] = kwargs.pop("cls", None)

        _request = build_connections_get_connection_role_assignment_request(
            connection_id=connection_id,
            connection_role_assignment_id=connection_role_assignment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ConnectionRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_connection_role_assignment(
        self,
        connection_id: str,
        connection_role_assignment_id: str,
        update_connection_role_assignment_request: _models.UpdateConnectionRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ConnectionRoleAssignment:
        """Updates the principal's role assignment for the connection.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must be an *Owner* of the connection or be an *Admin* on the gateway that's bound
        to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param connection_role_assignment_id: The ID of the role assignment. Required.
        :type connection_role_assignment_id: str
        :param update_connection_role_assignment_request: Update connection role assignment request
         payload. Required.
        :type update_connection_role_assignment_request:
         ~microsoft.fabric.api.core.models.UpdateConnectionRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_connection_role_assignment(
        self,
        connection_id: str,
        connection_role_assignment_id: str,
        update_connection_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.ConnectionRoleAssignment:
        """Updates the principal's role assignment for the connection.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must be an *Owner* of the connection or be an *Admin* on the gateway that's bound
        to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param connection_role_assignment_id: The ID of the role assignment. Required.
        :type connection_role_assignment_id: str
        :param update_connection_role_assignment_request: Update connection role assignment request
         payload. Required.
        :type update_connection_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_connection_role_assignment(
        self,
        connection_id: str,
        connection_role_assignment_id: str,
        update_connection_role_assignment_request: Union[_models.UpdateConnectionRoleAssignmentRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.ConnectionRoleAssignment:
        """Updates the principal's role assignment for the connection.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must be an *Owner* of the connection or be an *Admin* on the gateway that's bound
        to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param connection_role_assignment_id: The ID of the role assignment. Required.
        :type connection_role_assignment_id: str
        :param update_connection_role_assignment_request: Update connection role assignment request
         payload. Is either a UpdateConnectionRoleAssignmentRequest type or a IO[bytes] type. Required.
        :type update_connection_role_assignment_request:
         ~microsoft.fabric.api.core.models.UpdateConnectionRoleAssignmentRequest or IO[bytes]
        :return: ConnectionRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.ConnectionRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ConnectionRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_connection_role_assignment_request, (IOBase, bytes)):
            _content = update_connection_role_assignment_request
        else:
            _json = self._serialize.body(
                update_connection_role_assignment_request, "UpdateConnectionRoleAssignmentRequest"
            )

        _request = build_connections_update_connection_role_assignment_request(
            connection_id=connection_id,
            connection_role_assignment_id=connection_role_assignment_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ConnectionRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_connection_role_assignment(  # pylint: disable=inconsistent-return-statements
        self, connection_id: str, connection_role_assignment_id: str, **kwargs: Any
    ) -> None:
        """Delete the specified role assignment for the connection.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must be an *Owner* of the connection or be an *Admin* on the gateway that's bound
        to the connection.

        Required Delegated Scopes
        -------------------------

        Connection.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param connection_id: The ID of the connection. Required.
        :type connection_id: str
        :param connection_role_assignment_id: The ID of the role assignment. Required.
        :type connection_role_assignment_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_connections_delete_connection_role_assignment_request(
            connection_id=connection_id,
            connection_role_assignment_id=connection_role_assignment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class GatewaysOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.fabric.api.core.FabricCoreClient`'s
        :attr:`gateways` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_gateways(
        self, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.Gateway"]:
        """Returns a list of all gateways the user has permission for, including on-premises, on-premises
        (personal mode), and virtual network gateways.

        Permissions
        -----------

        The caller must have permissions for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.Read.All or Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of Gateway
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.Gateway]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.ListGatewaysResponse] = kwargs.pop("cls", None)  # pylint: disable=protected-access

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_gateways_list_gateways_request(
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.ListGatewaysResponse, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_gateway(
        self,
        create_gateway_request: _models.CreateGatewayRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Gateway:
        """Creates a gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_gateway_request: The request payload for creating the gateway. Required.
        :type create_gateway_request: ~microsoft.fabric.api.core.models.CreateGatewayRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_gateway(
        self, create_gateway_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Gateway:
        """Creates a gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_gateway_request: The request payload for creating the gateway. Required.
        :type create_gateway_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_gateway(
        self, create_gateway_request: Union[_models.CreateGatewayRequest, IO[bytes]], **kwargs: Any
    ) -> _models.Gateway:
        """Creates a gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param create_gateway_request: The request payload for creating the gateway. Is either a
         CreateGatewayRequest type or a IO[bytes] type. Required.
        :type create_gateway_request: ~microsoft.fabric.api.core.models.CreateGatewayRequest or
         IO[bytes]
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Gateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(create_gateway_request, (IOBase, bytes)):
            _content = create_gateway_request
        else:
            _json = self._serialize.body(create_gateway_request, "CreateGatewayRequest")

        _request = build_gateways_create_gateway_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Gateway", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_gateway(self, gateway_id: str, **kwargs: Any) -> _models.Gateway:
        """Get gateway by ID.

        Permissions
        -----------

        The caller must have permissions for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.Read.All or Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Gateway] = kwargs.pop("cls", None)

        _request = build_gateways_get_gateway_request(
            gateway_id=gateway_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Gateway", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_gateway(
        self,
        gateway_id: str,
        update_gateway_request: _models.UpdateGatewayRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Gateway:
        """Updates gateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param update_gateway_request: The request payload for updating the gateway. Required.
        :type update_gateway_request: ~microsoft.fabric.api.core.models.UpdateGatewayRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_gateway(
        self,
        gateway_id: str,
        update_gateway_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Gateway:
        """Updates gateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param update_gateway_request: The request payload for updating the gateway. Required.
        :type update_gateway_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_gateway(
        self, gateway_id: str, update_gateway_request: Union[_models.UpdateGatewayRequest, IO[bytes]], **kwargs: Any
    ) -> _models.Gateway:
        """Updates gateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param update_gateway_request: The request payload for updating the gateway. Is either a
         UpdateGatewayRequest type or a IO[bytes] type. Required.
        :type update_gateway_request: ~microsoft.fabric.api.core.models.UpdateGatewayRequest or
         IO[bytes]
        :return: Gateway
        :rtype: ~microsoft.fabric.api.core.models.Gateway
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Gateway] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_gateway_request, (IOBase, bytes)):
            _content = update_gateway_request
        else:
            _json = self._serialize.body(update_gateway_request, "UpdateGatewayRequest")

        _request = build_gateways_update_gateway_request(
            gateway_id=gateway_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("Gateway", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_gateway(self, gateway_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete gateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_gateways_delete_gateway_request(
            gateway_id=gateway_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_gateway_members(self, gateway_id: str, **kwargs: Any) -> _models.ListGatewayMembersResponse:
        """Lists gateway members of an OnPremisesGateway by ID.

        Permissions
        -----------


        * The caller must have permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.Read.All or Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :return: ListGatewayMembersResponse
        :rtype: ~microsoft.fabric.api.core.models.ListGatewayMembersResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListGatewayMembersResponse] = kwargs.pop("cls", None)

        _request = build_gateways_list_gateway_members_request(
            gateway_id=gateway_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ListGatewayMembersResponse", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_gateway_member(
        self,
        gateway_id: str,
        gateway_member_id: str,
        update_gateway_member_request: _models.UpdateGatewayMemberRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.OnPremisesGatewayMember:
        """Updates gateway member of an OnPremisesGateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_member_id: The ID of the gateway member. Required.
        :type gateway_member_id: str
        :param update_gateway_member_request: The request payload for updating the gateway member.
         Required.
        :type update_gateway_member_request:
         ~microsoft.fabric.api.core.models.UpdateGatewayMemberRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OnPremisesGatewayMember
        :rtype: ~microsoft.fabric.api.core.models.OnPremisesGatewayMember
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_gateway_member(
        self,
        gateway_id: str,
        gateway_member_id: str,
        update_gateway_member_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.OnPremisesGatewayMember:
        """Updates gateway member of an OnPremisesGateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_member_id: The ID of the gateway member. Required.
        :type gateway_member_id: str
        :param update_gateway_member_request: The request payload for updating the gateway member.
         Required.
        :type update_gateway_member_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: OnPremisesGatewayMember
        :rtype: ~microsoft.fabric.api.core.models.OnPremisesGatewayMember
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_gateway_member(
        self,
        gateway_id: str,
        gateway_member_id: str,
        update_gateway_member_request: Union[_models.UpdateGatewayMemberRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.OnPremisesGatewayMember:
        """Updates gateway member of an OnPremisesGateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_member_id: The ID of the gateway member. Required.
        :type gateway_member_id: str
        :param update_gateway_member_request: The request payload for updating the gateway member. Is
         either a UpdateGatewayMemberRequest type or a IO[bytes] type. Required.
        :type update_gateway_member_request:
         ~microsoft.fabric.api.core.models.UpdateGatewayMemberRequest or IO[bytes]
        :return: OnPremisesGatewayMember
        :rtype: ~microsoft.fabric.api.core.models.OnPremisesGatewayMember
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OnPremisesGatewayMember] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_gateway_member_request, (IOBase, bytes)):
            _content = update_gateway_member_request
        else:
            _json = self._serialize.body(update_gateway_member_request, "UpdateGatewayMemberRequest")

        _request = build_gateways_update_gateway_member_request(
            gateway_id=gateway_id,
            gateway_member_id=gateway_member_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("OnPremisesGatewayMember", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_gateway_member(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, gateway_member_id: str, **kwargs: Any
    ) -> None:
        """Delete gateway member of an OnPremisesGateway by ID.

        Permissions
        -----------

        The caller must have admin permission for the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_member_id: The ID of the gateway member. Required.
        :type gateway_member_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_gateways_delete_gateway_member_request(
            gateway_id=gateway_id,
            gateway_member_id=gateway_member_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_gateway_role_assignments(
        self, gateway_id: str, *, continuation_token_parameter: Optional[str] = None, **kwargs: Any
    ) -> Iterable["_models.GatewayRoleAssignment"]:
        """Returns a list of gateway role assignments.

        This API supports `pagination </rest/api/fabric/articles/pagination>`_.

        Permissions
        -----------


        * The caller must have *ConnectionCreator* or higher role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.Read.All or Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :keyword continuation_token_parameter: A token for retrieving the next page of results. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :return: An iterator like instance of GatewayRoleAssignment
        :rtype: ~azure.core.paging.ItemPaged[~microsoft.fabric.api.core.models.GatewayRoleAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models._models.GatewayRoleAssignments] = kwargs.pop(  # pylint: disable=protected-access
            "cls", None
        )

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_gateways_list_gateway_role_assignments_request(
                    gateway_id=gateway_id,
                    continuation_token_parameter=continuation_token_parameter,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                _request = HttpRequest("GET", next_link)
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = self._deserialize(
                _models._models.GatewayRoleAssignments, pipeline_response  # pylint: disable=protected-access
            )
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.continuation_uri or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def add_gateway_role_assignment(
        self,
        gateway_id: str,
        add_gateway_role_assignment_request: _models.AddGatewayRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GatewayRoleAssignment:
        """Adds a gateway role assignment.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Service Principal Profiles are not supported for Gateway Role Assignments.
        --------------------------------------------------------------------------

        Permissions
        -----------


        * The caller must have *ConnectionCreatorWithResharing* or higher role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param add_gateway_role_assignment_request: The request payload for adding a gateway role
         assignment. Required.
        :type add_gateway_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddGatewayRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_gateway_role_assignment(
        self,
        gateway_id: str,
        add_gateway_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GatewayRoleAssignment:
        """Adds a gateway role assignment.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Service Principal Profiles are not supported for Gateway Role Assignments.
        --------------------------------------------------------------------------

        Permissions
        -----------


        * The caller must have *ConnectionCreatorWithResharing* or higher role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param add_gateway_role_assignment_request: The request payload for adding a gateway role
         assignment. Required.
        :type add_gateway_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_gateway_role_assignment(
        self,
        gateway_id: str,
        add_gateway_role_assignment_request: Union[_models.AddGatewayRoleAssignmentRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.GatewayRoleAssignment:
        """Adds a gateway role assignment.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Service Principal Profiles are not supported for Gateway Role Assignments.
        --------------------------------------------------------------------------

        Permissions
        -----------


        * The caller must have *ConnectionCreatorWithResharing* or higher role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param add_gateway_role_assignment_request: The request payload for adding a gateway role
         assignment. Is either a AddGatewayRoleAssignmentRequest type or a IO[bytes] type. Required.
        :type add_gateway_role_assignment_request:
         ~microsoft.fabric.api.core.models.AddGatewayRoleAssignmentRequest or IO[bytes]
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GatewayRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(add_gateway_role_assignment_request, (IOBase, bytes)):
            _content = add_gateway_role_assignment_request
        else:
            _json = self._serialize.body(add_gateway_role_assignment_request, "AddGatewayRoleAssignmentRequest")

        _request = build_gateways_add_gateway_role_assignment_request(
            gateway_id=gateway_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = self._deserialize("GatewayRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_gateway_role_assignment(
        self, gateway_id: str, gateway_role_assignment_id: str, **kwargs: Any
    ) -> _models.GatewayRoleAssignment:
        """Returns the principal's role assignment for the gateway.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *ConnectionCreator* or higher role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.Read.All or Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_role_assignment_id: The ID of the gateway role assignment. Required.
        :type gateway_role_assignment_id: str
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.GatewayRoleAssignment] = kwargs.pop("cls", None)

        _request = build_gateways_get_gateway_role_assignment_request(
            gateway_id=gateway_id,
            gateway_role_assignment_id=gateway_role_assignment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("GatewayRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_gateway_role_assignment(
        self,
        gateway_id: str,
        gateway_role_assignment_id: str,
        update_gateway_role_assignment_request: _models.UpdateGatewayRoleAssignmentRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GatewayRoleAssignment:
        """Updates the principal's role assignment for the gateway.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *Admin* role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_role_assignment_id: The ID of the role assignment. Required.
        :type gateway_role_assignment_id: str
        :param update_gateway_role_assignment_request: Update gateway role assignment request payload.
         Required.
        :type update_gateway_role_assignment_request:
         ~microsoft.fabric.api.core.models.UpdateGatewayRoleAssignmentRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_gateway_role_assignment(
        self,
        gateway_id: str,
        gateway_role_assignment_id: str,
        update_gateway_role_assignment_request: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GatewayRoleAssignment:
        """Updates the principal's role assignment for the gateway.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *Admin* role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_role_assignment_id: The ID of the role assignment. Required.
        :type gateway_role_assignment_id: str
        :param update_gateway_role_assignment_request: Update gateway role assignment request payload.
         Required.
        :type update_gateway_role_assignment_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_gateway_role_assignment(
        self,
        gateway_id: str,
        gateway_role_assignment_id: str,
        update_gateway_role_assignment_request: Union[_models.UpdateGatewayRoleAssignmentRequest, IO[bytes]],
        **kwargs: Any,
    ) -> _models.GatewayRoleAssignment:
        """Updates the principal's role assignment for the gateway.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *Admin* role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_role_assignment_id: The ID of the role assignment. Required.
        :type gateway_role_assignment_id: str
        :param update_gateway_role_assignment_request: Update gateway role assignment request payload.
         Is either a UpdateGatewayRoleAssignmentRequest type or a IO[bytes] type. Required.
        :type update_gateway_role_assignment_request:
         ~microsoft.fabric.api.core.models.UpdateGatewayRoleAssignmentRequest or IO[bytes]
        :return: GatewayRoleAssignment
        :rtype: ~microsoft.fabric.api.core.models.GatewayRoleAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GatewayRoleAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(update_gateway_role_assignment_request, (IOBase, bytes)):
            _content = update_gateway_role_assignment_request
        else:
            _json = self._serialize.body(update_gateway_role_assignment_request, "UpdateGatewayRoleAssignmentRequest")

        _request = build_gateways_update_gateway_role_assignment_request(
            gateway_id=gateway_id,
            gateway_role_assignment_id=gateway_role_assignment_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("GatewayRoleAssignment", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_gateway_role_assignment(  # pylint: disable=inconsistent-return-statements
        self, gateway_id: str, gateway_role_assignment_id: str, **kwargs: Any
    ) -> None:
        """Delete the specified role assignment for the gateway.

        To get the principal user ID required for request body, see `Find the user ID
        </partner-center/find-ids-and-domain-names#find-the-user-object-id>`_.

        Permissions
        -----------


        * The caller must have *Admin* role on the gateway.

        Required Delegated Scopes
        -------------------------

        Gateway.ReadWrite.All

        Microsoft Entra supported identities
        ------------------------------------

        This API supports the Microsoft `identities </rest/api/fabric/articles/identity-support>`_
        listed in this section.

        .. list-table::
           :header-rows: 1

           * - Identity
             - Support
           * - User
             - Yes
           * - `Service principal
        </entra/identity-platform/app-objects-and-service-principals#service-principal-object>`_ and
        `Managed identities </entra/identity/managed-identities-azure-resources/overview>`_
             - Yes


        Interface
        ---------.

        :param gateway_id: The ID of the gateway. Required.
        :type gateway_id: str
        :param gateway_role_assignment_id: The ID of the role assignment. Required.
        :type gateway_role_assignment_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_gateways_delete_gateway_role_assignment_request(
            gateway_id=gateway_id,
            gateway_role_assignment_id=gateway_role_assignment_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore
