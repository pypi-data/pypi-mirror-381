# coding: utf-8

"""
    GenerativeService API

    API for using Large Models that generate multimodal content and have  additional capabilities beyond text generation.

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.model_schema import ModelSchema
from typing import Optional, Set
from typing_extensions import Self

class FunctionDeclaration(BaseModel):
    """
    Structured representation of a function declaration as defined by the  [OpenAPI 3.03 specification](https://spec.openapis.org/oas/v3.0.3). Included  in this declaration are the function name and parameters. This  FunctionDeclaration is a representation of a block of code that can be used  as a `Tool` by the model and executed by the client.
    """ # noqa: E501
    name: StrictStr = Field(description="Required. The name of the function.  Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum  length of 63.")
    description: StrictStr = Field(description="Required. A brief description of the function.")
    parameters: Optional[ModelSchema] = Field(default=None, description="Optional. Describes the parameters to this function. Reflects the Open  API 3.03 Parameter Object string Key: the name of the parameter. Parameter  names are case sensitive. Schema Value: the Schema defining the type used  for the parameter.")
    parameters_json_schema: Optional[Any] = Field(default=None, description="Optional. Describes the parameters to the function in JSON Schema format.  The schema must describe an object where the properties are the parameters  to the function. For example:   ```  {    \"type\": \"object\",    \"properties\": {      \"name\": { \"type\": \"string\" },      \"age\": { \"type\": \"integer\" }    },    \"additionalProperties\": false,    \"required\": [\"name\", \"age\"],    \"propertyOrdering\": [\"name\", \"age\"]  }  ```   This field is mutually exclusive with `parameters`.", alias="parametersJsonSchema")
    response: Optional[ModelSchema] = Field(default=None, description="Optional. Describes the output from this function in JSON Schema format.  Reflects the Open API 3.03 Response Object. The Schema defines the type  used for the response value of the function.")
    response_json_schema: Optional[Any] = Field(default=None, description="Optional. Describes the output from this function in JSON Schema format.  The value specified by the schema is the response value of the function.   This field is mutually exclusive with `response`.", alias="responseJsonSchema")
    behavior: Optional[StrictInt] = Field(default=None, description="Optional. Specifies the function Behavior.  Currently only supported by the BidiGenerateContent method.")
    __properties: ClassVar[List[str]] = ["name", "description", "parameters", "parametersJsonSchema", "response", "responseJsonSchema", "behavior"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FunctionDeclaration from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of parameters
        if self.parameters:
            _dict['parameters'] = self.parameters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of response
        if self.response:
            _dict['response'] = self.response.to_dict()
        # set to None if parameters_json_schema (nullable) is None
        # and model_fields_set contains the field
        if self.parameters_json_schema is None and "parameters_json_schema" in self.model_fields_set:
            _dict['parametersJsonSchema'] = None

        # set to None if response_json_schema (nullable) is None
        # and model_fields_set contains the field
        if self.response_json_schema is None and "response_json_schema" in self.model_fields_set:
            _dict['responseJsonSchema'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FunctionDeclaration from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "description": obj.get("description"),
            "parameters": ModelSchema.from_dict(obj["parameters"]) if obj.get("parameters") is not None else None,
            "parametersJsonSchema": obj.get("parametersJsonSchema"),
            "response": ModelSchema.from_dict(obj["response"]) if obj.get("response") is not None else None,
            "responseJsonSchema": obj.get("responseJsonSchema"),
            "behavior": obj.get("behavior")
        })
        return _obj


