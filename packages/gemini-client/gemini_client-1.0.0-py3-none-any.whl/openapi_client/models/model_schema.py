# coding: utf-8

"""
    GenerativeService API

    API for using Large Models that generate multimodal content and have  additional capabilities beyond text generation.

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class ModelSchema(BaseModel):
    """
    The `Schema` object allows the definition of input and output data types.  These types can be objects, but also primitives and arrays.  Represents a select subset of an [OpenAPI 3.0 schema  object](https://spec.openapis.org/oas/v3.0.3#schema).
    """ # noqa: E501
    type: StrictInt = Field(description="Required. Data type.")
    format: Optional[StrictStr] = Field(default=None, description="Optional. The format of the data. This is used only for primitive  datatypes. Supported formats:   for NUMBER type: float, double   for INTEGER type: int32, int64   for STRING type: enum, date-time")
    title: Optional[StrictStr] = Field(default=None, description="Optional. The title of the schema.")
    description: Optional[StrictStr] = Field(default=None, description="Optional. A brief description of the parameter. This could contain examples  of use. Parameter description may be formatted as Markdown.")
    nullable: Optional[StrictBool] = Field(default=None, description="Optional. Indicates if the value may be null.")
    enum: Optional[List[StrictStr]] = Field(default=None, description="Optional. Possible values of the element of Type.STRING with enum format.  For example we can define an Enum Direction as :  {type:STRING, format:enum, enum:[\"EAST\", NORTH\", \"SOUTH\", \"WEST\"]}")
    items: Optional[ModelSchema] = Field(default=None, description="Optional. Schema of the elements of Type.ARRAY.")
    max_items: Optional[StrictStr] = Field(default=None, description="Optional. Maximum number of the elements for Type.ARRAY.", alias="maxItems")
    min_items: Optional[StrictStr] = Field(default=None, description="Optional. Minimum number of the elements for Type.ARRAY.", alias="minItems")
    properties: Optional[Dict[str, ModelSchema]] = Field(default=None, description="Optional. Properties of Type.OBJECT.")
    required: Optional[List[StrictStr]] = Field(default=None, description="Optional. Required properties of Type.OBJECT.")
    min_properties: Optional[StrictStr] = Field(default=None, description="Optional. Minimum number of the properties for Type.OBJECT.", alias="minProperties")
    max_properties: Optional[StrictStr] = Field(default=None, description="Optional. Maximum number of the properties for Type.OBJECT.", alias="maxProperties")
    minimum: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER  Minimum value of the Type.INTEGER and Type.NUMBER")
    maximum: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Optional. Maximum value of the Type.INTEGER and Type.NUMBER")
    min_length: Optional[StrictStr] = Field(default=None, description="Optional. SCHEMA FIELDS FOR TYPE STRING  Minimum length of the Type.STRING", alias="minLength")
    max_length: Optional[StrictStr] = Field(default=None, description="Optional. Maximum length of the Type.STRING", alias="maxLength")
    pattern: Optional[StrictStr] = Field(default=None, description="Optional. Pattern of the Type.STRING to restrict a string to a regular  expression.")
    example: Optional[Any] = Field(default=None, description="Optional. Example of the object. Will only populated when the object is the  root.")
    any_of: Optional[List[ModelSchema]] = Field(default=None, description="Optional. The value should be validated against any (one or more) of the  subschemas in the list.", alias="anyOf")
    property_ordering: Optional[List[StrictStr]] = Field(default=None, description="Optional. The order of the properties.  Not a standard field in open api spec. Used to determine the order of the  properties in the response.", alias="propertyOrdering")
    default: Optional[Any] = Field(default=None, description="Optional. Default value of the field. Per JSON Schema, this field is  intended for documentation generators and doesn't affect validation. Thus  it's included here and ignored so that developers who send schemas with a  `default` field don't get unknown-field errors.")
    __properties: ClassVar[List[str]] = ["type", "format", "title", "description", "nullable", "enum", "items", "maxItems", "minItems", "properties", "required", "minProperties", "maxProperties", "minimum", "maximum", "minLength", "maxLength", "pattern", "example", "anyOf", "propertyOrdering", "default"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ModelSchema from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of items
        if self.items:
            _dict['items'] = self.items.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in properties (dict)
        _field_dict = {}
        if self.properties:
            for _key_properties in self.properties:
                if self.properties[_key_properties]:
                    _field_dict[_key_properties] = self.properties[_key_properties].to_dict()
            _dict['properties'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in any_of (list)
        _items = []
        if self.any_of:
            for _item_any_of in self.any_of:
                if _item_any_of:
                    _items.append(_item_any_of.to_dict())
            _dict['anyOf'] = _items
        # set to None if example (nullable) is None
        # and model_fields_set contains the field
        if self.example is None and "example" in self.model_fields_set:
            _dict['example'] = None

        # set to None if default (nullable) is None
        # and model_fields_set contains the field
        if self.default is None and "default" in self.model_fields_set:
            _dict['default'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ModelSchema from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "type": obj.get("type"),
            "format": obj.get("format"),
            "title": obj.get("title"),
            "description": obj.get("description"),
            "nullable": obj.get("nullable"),
            "enum": obj.get("enum"),
            "items": ModelSchema.from_dict(obj["items"]) if obj.get("items") is not None else None,
            "maxItems": obj.get("maxItems"),
            "minItems": obj.get("minItems"),
            "properties": dict(
                (_k, ModelSchema.from_dict(_v))
                for _k, _v in obj["properties"].items()
            )
            if obj.get("properties") is not None
            else None,
            "required": obj.get("required"),
            "minProperties": obj.get("minProperties"),
            "maxProperties": obj.get("maxProperties"),
            "minimum": obj.get("minimum"),
            "maximum": obj.get("maximum"),
            "minLength": obj.get("minLength"),
            "maxLength": obj.get("maxLength"),
            "pattern": obj.get("pattern"),
            "example": obj.get("example"),
            "anyOf": [ModelSchema.from_dict(_item) for _item in obj["anyOf"]] if obj.get("anyOf") is not None else None,
            "propertyOrdering": obj.get("propertyOrdering"),
            "default": obj.get("default")
        })
        return _obj

# TODO: Rewrite to not use raise_errors
ModelSchema.model_rebuild(raise_errors=False)

