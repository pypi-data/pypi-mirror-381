import subprocess
from pathlib import Path
import sys
import inquirer
import rich_click as click
from pydantic import BaseModel, Field
import yaml
from cryptography.hazmat.primitives import serialization as crypto_serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend as crypto_default_backend
import typer
import signal
import atexit
import tempfile
import os
from arkitekt_server.config import (
    ArkitektServerConfig,
    BaseServiceConfig,
    RekuestConfig,
    KeyPair,
    EmailConfig,
    User,
)
from arkitekt_server.create import create_server
from typer.core import TyperGroup
from arkitekt_server.diff import run_dry_run_diff
from arkitekt_server.config import generate_name, Organization
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.markdown import Markdown
from .logo import ASCI_LOGO
from arkitekt_server.wizard import prompt_config


console = Console()

app = typer.Typer(
    rich_markup_mode="rich",
    help="Arkitekt server CLI for managing your local Arkitekt server deployment.",
)

init_app = typer.Typer()
app.add_typer(
    init_app, name="init", help="Initialize an Arkitekt deployment configuration"
)


auth_app = typer.Typer()
app.add_typer(
    auth_app, name="auth", help="Authentication related settings and commands"
)


inspect_app = typer.Typer()
app.add_typer(
    inspect_app, name="inspect", help="Inspect the Arkitekt server configuration"
)


build_app = typer.Typer()
app.add_typer(build_app, name="build", help="Build deployments for Arkitekt server")


user_app = typer.Typer()
auth_app.add_typer(user_app, name="user", help="Standard user management commands")


group_app = typer.Typer()
auth_app.add_typer(user_app, name="group", help="Group management commands")


admin_app = typer.Typer()
auth_app.add_typer(admin_app, name="admin", help="Admin users management commands")


service_app = typer.Typer()
app.add_typer(service_app, name="service", help="Service management commands")


class YamlFile(BaseModel):
    version: str
    config: ArkitektServerConfig


def update_or_create_yaml_file(file_path: str, new_config: ArkitektServerConfig):
    """Update or create a YAML file with the given data."""

    with open("arkitekt_server_config.yaml", "w") as f:
        yaml_data = YamlFile(version="1.0", config=new_config)
        yaml.dump(yaml_data.model_dump(), f, default_flow_style=False)

    # create gitignore file if it does not exist
    try:
        with open(".gitignore", "r") as f:
            gitignore_content = f.read()
    except FileNotFoundError:
        gitignore_content = ""

    if "arkitekt_server_config.yaml" not in gitignore_content:
        with open(".gitignore", "a") as f:
            f.write("\narkitekt_server_config.yaml\n")
            f.write("# Arkitekt server config file\n")
            f.write(
                "# This file is automatically generated and should not be modified manually.\n"
            )
            f.write(
                "# It contains sensitive information and should not be committed to version control.\n"
            )


def load_or_create_yaml_file(file_path: str) -> ArkitektServerConfig:
    """Load or create a YAML file with default configuration."""
    try:
        with open("arkitekt_server_config.yaml", "r") as f:
            data = yaml.safe_load(f)
            return ArkitektServerConfig(**data["config"])
    except FileNotFoundError:
        raise FileNotFoundError(
            f"Configuration file '{file_path}' not found. Please run 'arkitekt init' to create a new configuration."
        )


def load_yaml_file(file_path: str) -> ArkitektServerConfig:
    """Load a YAML file and return the configuration."""
    try:
        with open(file_path, "r") as f:
            data = yaml.safe_load(f)
            return ArkitektServerConfig(**data["config"])
    except FileNotFoundError:
        raise FileNotFoundError(f"Configuration file '{file_path}' not found.")
    except yaml.YAMLError as e:
        raise ValueError(f"Error parsing YAML file: {e}")


def show_important_information(config: ArkitektServerConfig):
    """Display important information about the configuration."""

    print("Admin User:" + config.global_admin)
    print("Admin Password: " + config.global_admin_password)


@init_app.command()
def stable(
    defaults: bool = False, port: int | None = None, ssl_port: int | None = None
):
    """Build commands for Arkitekt server.

    Creates a config that can be used to run the Arkitekt server.



    """

    # Create a default configuration file if it doesn't exist
    config = ArkitektServerConfig() if defaults else prompt_config(console)
    if port is not None:
        config.gateway.exposed_http_port = port
    if ssl_port is not None:
        config.gateway.exposed_https_port = ssl_port

    print("Creating default configuration file for Arkitekt server...")
    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    # load the yaml file


@init_app.command()
def default(defaults: bool = False, port: int | None = None):
    """Build commands for Arkitekt server.

    Creates a config that can be used to run the Arkitekt server.



    """

    # Create a default configuration file if it doesn't exist
    config = ArkitektServerConfig() if defaults else prompt_config(console)
    if port is not None:
        config.gateway.exposed_http_port = port

    print("Creating default configuration file for Arkitekt server...")
    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    # load the yaml file


@init_app.command()
def dev(defaults: bool = False, port: int | None = None):
    """Build commands for Arkitekt server.


    Creates a config that can be used to run the Arkitekt server.



    """

    # Create a default configuration file if it doesn't exist
    config = ArkitektServerConfig() if defaults else prompt_config(console)
    if port is not None:
        config.gateway.exposed_http_port = port

    config.rekuest.mount_github = True
    config.kabinet.mount_github = True
    config.mikro.mount_github = True
    config.fluss.mount_github = True
    config.deployer.mount_github = True
    config.kraph.mount_github = True
    print("Creating default configuration file for Arkitekt server...")
    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    # load the yaml file


@inspect_app.command()
def admin():
    """Show the current Arkitekt addmin user configuration."""

    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    show_important_information(config)


@inspect_app.command()
def users():
    """Show the configured users in the Arkitekt server."""

    config = load_yaml_file("arkitekt_server_config.yaml")

    for user in config.users:
        print(f"Username: {user.username}")
        print(f"Email: {user.email}")
        print(
            f"Password: {user.password}"
        )  # Note: In a real application, never print passwords
        print(f"Active Organization: {user.active_organization}")
        for membership in user.memberships:
            print(f"Organization: {membership.organization}")
            print(f"Roles: {', '.join(membership.roles)}")


@init_app.command()
def minimal():
    """Build a minimal configuration for the Arkitekt server.

    This command creates a minimal configuration file that can be used to run the Arkitekt server.
    It includes only the most essential settings and services required to start the server.

    """

    # Create a default configuration file if it doesn't exist
    config = ArkitektServerConfig()

    print("Creating default configuration file for Arkitekt server...")
    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    # load the yaml file


@user_app.command()
def add():
    """Add a new user to the Arkitekt server configuration."""

    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    username = click.prompt("Enter the username for the user", type=str)

    password = click.prompt(
        "Enter the password for the user", type=str, hide_input=True
    )

    email = click.prompt("Enter the email for the user", type=str, default=None)

    config.users.append(
        User(
            username=username,
            password=password,
            email=email,
        )
    )
    # Here you would typically hash the password and store it securely
    # For simplicity, we will just store it in plain text (not recommended for production)

    update_or_create_yaml_file("arkitekt_server_config.yaml", config)


@user_app.command()
def remove(name: str):
    """Remove a user from the Arkitekt server configuration."""
    print("Removing user is not implemented yet.")


@service_app.command()
def rekuest(enable: bool = True):
    """Add the Rekuest service to the Arkitekt server configuration."""

    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    rekuest_service = RekuestConfig()

    config.kabinet.enabled = enable

    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    click.echo("Rekuest service added with default configuration.")


@service_app.command()
def mikro(
    enable: bool = True,
):
    """Add the Mikro service to the Arkitekt server configuration."""

    config = load_or_create_yaml_file("arkitekt_server_config.yaml")
    config.kabinet.enabled = enable

    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    click.echo("Mikro service added with default configuration.")


@service_app.command()
def kabinet(enable: bool = True):
    """Add the Kabinet service to the Arkitekt server configuration."""

    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    config.kabinet.enabled = enable

    update_or_create_yaml_file("arkitekt_server_config.yaml", config)

    click.echo("Kabinet service added with default configuration.")


@build_app.command()
def docker(path: Path = Path("."), yes: bool = False):
    """Build the Docker image for the Arkitekt server."""

    # load the yaml file
    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    run_dry_run_diff(config, path, allow_deletes=False, yes=yes)


@build_app.command()
def kubernetes(path: Path = Path("."), yes: bool = False):
    """Build the Docker image for the Arkitekt server."""

    # load the yaml file
    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    raise Exception("Kubernetes support is not implemented yet.")


@app.command()
def migrate():
    """Migrate your Arkiter server configuration to a new version"""

    # load the yaml file
    config = load_or_create_yaml_file("arkitekt_server_config.yaml")

    # Here you would typically perform migration tasks, such as updating the schema or data format.
    # For simplicity, we will just print the current configuration.
    raise NotImplementedError(
        "Migration is not implemented yet. Please update your configuration manually."
    )


@app.command()
def start():
    """Start the Arkitekt server (with Docker Compose)."""

    # load the yaml file
    config = load_yaml_file("arkitekt_server_config.yaml")

    try:
        subprocess.run(["docker", "compose", "up"], check=True)
    except subprocess.CalledProcessError as e:
        # Print the error message (this will show stderr live)
        click.secho("‚ùå Failed to start docker compose:", fg="red", bold=True)
        raise typer.Exit(code=e.returncode)


@app.command()
def update():
    """Update the Arkitekt server by pulling the latest images."""

    # load the yaml file
    config = load_yaml_file("arkitekt_server_config.yaml")

    try:
        subprocess.run(["docker", "compose", "pull"], check=True)
    except subprocess.CalledProcessError as e:
        # Print the error message (this will show stderr live)
        click.secho("‚ùå Failed to start docker compose:", fg="red", bold=True)
        raise typer.Exit(code=e.returncode)


@app.command()
def ephemeral(
    port: int = typer.Option(
        24891, help="HTTP port to expose (will be auto-assigned if not specified)"
    ),
    https_port: int = typer.Option(
        None, help="HTTPS port to expose (disabled by default for ephemeral)"
    ),
    defaults: bool = typer.Option(
        True, help="Use default configuration without prompts"
    ),
):
    """
    Create and start a temporary Arkitekt server instance.

    This command creates a temporary server configuration in a temp directory,
    starts it with Docker Compose, and automatically cleans up when interrupted.
    Perfect for testing or development purposes.
    """
    temp_dir = None
    docker_process = None

    def cleanup():
        """Clean up temporary resources"""
        if docker_process and docker_process.poll() is None:
            console.print("üßπ Stopping Docker Compose services...", style="yellow")
            try:
                # Stop docker compose in the temp directory
                if temp_dir and temp_dir.exists():
                    subprocess.run(
                        ["docker", "compose", "down", "--remove-orphans"],
                        cwd=temp_dir,
                        check=True,
                        capture_output=True,
                    )
                    console.print("‚úÖ Docker services stopped", style="green")
            except subprocess.CalledProcessError as e:
                console.print(f"‚ö†Ô∏è Error stopping Docker services: {e}", style="yellow")

        if temp_dir and temp_dir.exists():
            console.print("üóëÔ∏è Cleaning up temporary directory...", style="yellow")
            try:
                import shutil

                shutil.rmtree(temp_dir)
                console.print("‚úÖ Temporary directory cleaned up", style="green")
            except Exception as e:
                console.print(
                    f"‚ö†Ô∏è Error cleaning up temp directory: {e}", style="yellow"
                )

    def signal_handler(signum, frame):
        """Handle interrupt signals"""
        console.print("\nüõë Received interrupt signal, cleaning up...", style="yellow")
        cleanup()
        raise typer.Exit(0)

    # Register signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Register cleanup function to run on exit
    atexit.register(cleanup)

    try:
        # Create temporary directory
        temp_dir = Path(tempfile.mkdtemp(prefix="arkitekt_ephemeral_"))
        console.print(
            f"üìÅ Created temporary server directory: {temp_dir}", style="blue"
        )

        # Create default configuration
        config = ArkitektServerConfig() if defaults else prompt_config(console)

        # Override ports if specified
        if port is not None:
            config.gateway.exposed_http_port = port
        else:
            # Auto-assign a random port to avoid conflicts
            import random

            config.gateway.exposed_http_port = random.randint(8000, 9000)

        # Handle HTTPS configuration for ephemeral setup
        if https_port is not None:
            config.gateway.exposed_https_port = https_port
            config.gateway.ssl = True
        else:
            # For ephemeral setup, assign a random HTTPS port but disable SSL to avoid conflicts
            import random

            config.gateway.exposed_https_port = random.randint(9000, 10000)
            config.gateway.ssl = False

        # Ensure we use volumes instead of bind mounts for ephemeral setup
        config.minio.mount = None
        config.db.mount = None

        console.print(
            f"üöÄ Creating ephemeral Arkitekt server on port {config.gateway.exposed_http_port}...",
            style="green",
        )

        # Generate server configuration files
        create_server(temp_dir, config)

        # Show important configuration info
        console.print("üìã Server Configuration:", style="bold blue")
        console.print(f"  ‚Ä¢ Admin User: {config.global_admin}", style="blue")
        console.print(
            f"  ‚Ä¢ Admin Password: {config.global_admin_password}", style="blue"
        )
        console.print(
            f"  ‚Ä¢ HTTP Port: {config.gateway.exposed_http_port}", style="blue"
        )
        console.print(
            f"  ‚Ä¢ Server URL: http://localhost:{config.gateway.exposed_http_port}",
            style="blue",
        )
        if config.gateway.ssl and config.gateway.exposed_https_port:
            console.print(
                f"  ‚Ä¢ HTTPS Port: {config.gateway.exposed_https_port}", style="blue"
            )
            console.print(
                f"  ‚Ä¢ Secure URL: https://localhost:{config.gateway.exposed_https_port}",
                style="blue",
            )

        # Start docker compose
        console.print("üê≥ Starting Docker Compose services...", style="green")
        docker_process = subprocess.Popen(
            ["docker", "compose", "up"], cwd=temp_dir, text=True
        )

        # Wait for the process to complete
        docker_process.wait()

    except KeyboardInterrupt:
        console.print("\nüõë Received keyboard interrupt", style="yellow")
    except Exception as e:
        console.print(f"‚ùå Error running ephemeral server: {e}", style="red")
        raise typer.Exit(1)
    finally:
        cleanup()


def main():
    if "--help" in sys.argv or len(sys.argv) == 1:
        click.secho(ASCI_LOGO, fg="cyan", bold=True)
    """Main entry point for the Arkitekt server CLI."""
    app()
