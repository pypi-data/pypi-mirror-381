use automesh::{
    FiniteElementMethods, HexahedralFiniteElements, NSD, Remove, Scale, Smoothing, Translate,
    Voxels,
};
use conspire::math::TestError;
use std::{
    fs::File,
    io::{BufRead, BufReader, Read},
    str,
};

fn read_both_lines(
    gold: &mut String,
    gold_reader: &mut BufReader<File>,
    line: &mut String,
    line_reader: &mut BufReader<File>,
) {
    gold.clear();
    line.clear();
    gold_reader.read_line(gold).unwrap();
    line_reader.read_line(line).unwrap();
}

fn read_both_files(
    gold: &mut String,
    gold_reader: &mut BufReader<File>,
    line: &mut String,
    line_reader: &mut BufReader<File>,
) {
    gold.clear();
    line.clear();
    gold_reader.read_to_string(gold).unwrap();
    line_reader.read_to_string(line).unwrap();
}

fn compare_files(
    file_path: &str,
    gold_path: &str,
    spn_path: &str,
    nel: [usize; NSD],
    scale: Scale,
    translate: Translate,
) {
    let voxels = Voxels::from_spn(
        spn_path,
        nel.into(),
        Remove::from(Some(vec![0_u8])),
        scale,
        translate,
    )
    .unwrap();
    let fem = HexahedralFiniteElements::from(voxels);
    fem.write_inp(file_path).unwrap();
    let mut gold = String::new();
    let mut line = String::new();
    let mut gold_reader = BufReader::new(File::open(gold_path).unwrap());
    let mut line_reader = BufReader::new(File::open(file_path).unwrap());
    // ** autotwin.automesh
    read_both_lines(&mut gold, &mut gold_reader, &mut line, &mut line_reader);
    // ** version a.b.c
    read_both_lines(&mut gold, &mut gold_reader, &mut line, &mut line_reader);
    let version_prefix_len = 11;
    let version_prefix_gold = &gold.as_bytes()[0..version_prefix_len];
    let version_prefix_line = &line.as_bytes()[0..version_prefix_len];
    assert_eq!(version_prefix_gold, version_prefix_line);
    // compare a.b.c
    let version_gold = format!("{}\n", env!("CARGO_PKG_VERSION"));
    let version_line = str::from_utf8(&line.as_bytes()[version_prefix_len..]).unwrap();
    assert_eq!(version_gold, version_line);
    // ** autogenerated on YYYY-MM-DD HH:MM:SS.SSSSSS UTC
    read_both_lines(&mut gold, &mut gold_reader, &mut line, &mut line_reader);
    let date_time_prefix = 20;
    let time_prefix_gold = &gold[0..date_time_prefix];
    let time_prefix_line = &line[0..date_time_prefix];
    assert_eq!(time_prefix_gold, time_prefix_line);
    // Read balance of file: nodes and elements
    read_both_files(&mut gold, &mut gold_reader, &mut line, &mut line_reader);
    assert_eq!(gold, line);
}

//#[cfg(not(target_os = "windows"))]
//mod read_inp {
//    use super::*;
//    use automesh::HexahedralFiniteElements;
//    #[test]
//    fn letter_f_3d() {
//        let voxels = Voxels::from_spn(
//            "tests/input/letter_f_3d.spn",
//            [4, 5, 3].into(),
//            Remove::from(Some(vec![0_u8])),
//            Scale::default(),
//            Translate::default(),
//        )
//        .unwrap();
//        let fem = HexahedralFiniteElements::from(voxels);
//        fem.write_inp("target/letter_f_3d.inp").unwrap();
//        let read = HexahedralFiniteElements::from_inp("target/letter_f_3d.inp").unwrap();
//        assert_eq!(fem.get_element_blocks(), read.get_element_blocks());
//        assert_eq!(
//            fem.get_element_node_connectivity(),
//            read.get_element_node_connectivity()
//        );
//        fem.get_nodal_coordinates()
//            .iter()
//            .zip(read.get_nodal_coordinates().iter())
//            .for_each(|(a, b)| a.iter().zip(b.iter()).for_each(|(c, d)| assert_eq!(c, d)));
//    }
//}

#[cfg(not(target_os = "windows"))]
mod write_inp {
    use super::*;
    #[test]
    fn letter_f_3d() {
        compare_files(
            "target/letter_f_3d.inp",
            "tests/input/letter_f_3d.inp",
            "tests/input/letter_f_3d.spn",
            [4, 5, 3],
            [1.0, 1.0, 1.0].into(),
            [0.0, 0.0, 0.0].into(),
        );
    }
    #[test]
    fn sparse() {
        compare_files(
            "target/sparse.inp",
            "tests/input/sparse.inp",
            "tests/input/sparse.spn",
            [5, 5, 5],
            [1.0, 1.0, 1.0].into(),
            [0.0, 0.0, 0.0].into(),
        );
    }
}

mod write_mesh {
    use super::*;
    #[test]
    fn letter_f_3d() {
        let voxels = Voxels::from_spn(
            "tests/input/letter_f_3d.spn",
            [4, 5, 3].into(),
            Remove::from(Some(vec![0_u8])),
            Scale::default(),
            Translate::default(),
        )
        .unwrap();
        let fem = HexahedralFiniteElements::from(voxels);
        fem.write_mesh("target/letter_f_3d.mesh").unwrap();
    }
}

mod write_vtk {
    use super::*;
    #[test]
    fn letter_f_3d() {
        let voxels = Voxels::from_spn(
            "tests/input/letter_f_3d.spn",
            [4, 5, 3].into(),
            Remove::from(Some(vec![0_u8])),
            Scale::default(),
            Translate::default(),
        )
        .unwrap();
        let fem = HexahedralFiniteElements::from(voxels);
        fem.write_vtk("target/letter_f_3d.vtk").unwrap();
    }
}

#[test]
fn smooth_energetic() -> Result<(), TestError> {
    let mut finite_elements =
        HexahedralFiniteElements::from_exo("tests/input/cube_1_10.exo").unwrap();
    finite_elements.node_element_connectivity()?;
    finite_elements.node_node_connectivity()?;
    finite_elements.smooth(&Smoothing::Energetic)?;
    finite_elements.write_exo("target/cube_1_10.exo").unwrap();
    Ok(())
}
