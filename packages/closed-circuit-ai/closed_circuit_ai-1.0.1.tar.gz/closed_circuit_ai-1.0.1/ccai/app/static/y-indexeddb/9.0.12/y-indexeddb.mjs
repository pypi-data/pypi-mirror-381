import*as c from"yjs";var i=e=>new Promise(e);var C=Promise.all.bind(Promise);var g=e=>new Error(e);var a=e=>i((t,r)=>{e.onerror=o=>r(new Error(o.target.error)),e.onsuccess=o=>t(o.target.result)}),_=(e,t)=>i((r,o)=>{let s=indexedDB.open(e);s.onupgradeneeded=n=>t(n.target.result),s.onerror=n=>o(g(n.target.error)),s.onsuccess=n=>{let p=n.target.result;p.onversionchange=()=>{p.close()},r(p)}}),f=e=>a(indexedDB.deleteDatabase(e)),v=(e,t)=>t.forEach(r=>e.createObjectStore.apply(e,r)),d=(e,t,r="readwrite")=>{let o=e.transaction(t,r);return t.map(s=>F(o,s))},m=(e,t)=>a(e.count(t)),I=(e,t)=>a(e.get(t)),x=(e,t)=>a(e.delete(t)),w=(e,t,r)=>a(e.put(t,r));var l=(e,t)=>a(e.add(t)),A=(e,t,r)=>a(e.getAll(t,r));var Y=(e,t,r)=>{let o=null;return L(e,t,s=>(o=s,!1),r).then(()=>o)},T=(e,t=null)=>Y(e,t,"prev");var q=(e,t)=>i((r,o)=>{e.onerror=o,e.onsuccess=async s=>{let n=s.target.result;if(n===null||await t(n)===!1)return r();n.continue()}});var L=(e,t,r,o="next")=>q(e.openKeyCursor(t,o),s=>r(s.key)),F=(e,t)=>e.objectStore(t);var B=(e,t)=>IDBKeyRange.upperBound(e,t),U=(e,t)=>IDBKeyRange.lowerBound(e,t);var u=()=>new Map;var K=(e,t,r)=>{let o=e.get(t);return o===void 0&&e.set(t,o=r()),o};var D=()=>new Set;var E=Array.from;var Z=Array.isArray;var h=class{constructor(){this._observers=u()}on(t,r){K(this._observers,t,D).add(r)}once(t,r){let o=(...s)=>{this.off(t,o),r(...s)};this.on(t,o)}off(t,r){let o=this._observers.get(t);o!==void 0&&(o.delete(r),o.size===0&&this._observers.delete(t))}emit(t,r){return E((this._observers.get(t)||u()).values()).forEach(o=>o(...r))}destroy(){this._observers=u()}};var y="custom",R="updates",k=500,z=(e,t=()=>{},r=()=>{})=>{let[o]=d(e.db,[R]);return A(o,U(e._dbref,!1)).then(s=>{e._destroyed||(t(o),c.transact(e.doc,()=>{s.forEach(n=>c.applyUpdate(e.doc,n))},e,!1),r(o))}).then(()=>T(o).then(s=>{e._dbref=s+1})).then(()=>m(o).then(s=>{e._dbsize=s})).then(()=>o)},W=(e,t=!0)=>z(e).then(r=>{(t||e._dbsize>=k)&&l(r,c.encodeStateAsUpdate(e.doc)).then(()=>x(r,B(e._dbref,!0))).then(()=>m(r).then(o=>{e._dbsize=o}))}),Q=e=>f(e),S=class extends h{constructor(t,r){super(),this.doc=r,this.name=t,this._dbref=0,this._dbsize=0,this._destroyed=!1,this.db=null,this.synced=!1,this._db=_(t,o=>v(o,[["updates",{autoIncrement:!0}],["custom"]])),this.whenSynced=i(o=>this.on("synced",()=>o(this))),this._db.then(o=>{this.db=o,z(this,p=>l(p,c.encodeStateAsUpdate(r)),()=>{if(this._destroyed)return this;this.synced=!0,this.emit("synced",[this])})}),this._storeTimeout=1e3,this._storeTimeoutId=null,this._storeUpdate=(o,s)=>{if(this.db&&s!==this){let[n]=d(this.db,[R]);l(n,o),++this._dbsize>=k&&(this._storeTimeoutId!==null&&clearTimeout(this._storeTimeoutId),this._storeTimeoutId=setTimeout(()=>{W(this,!1),this._storeTimeoutId=null},this._storeTimeout))}},r.on("update",this._storeUpdate),this.destroy=this.destroy.bind(this),r.on("destroy",this.destroy)}destroy(){return this._storeTimeoutId&&clearTimeout(this._storeTimeoutId),this.doc.off("update",this._storeUpdate),this.doc.off("destroy",this.destroy),this._destroyed=!0,this._db.then(t=>{t.close()})}clearData(){return this.destroy().then(()=>{f(this.name)})}get(t){return this._db.then(r=>{let[o]=d(r,[y],"readonly");return I(o,t)})}set(t,r){return this._db.then(o=>{let[s]=d(o,[y]);return w(s,r,t)})}del(t){return this._db.then(r=>{let[o]=d(r,[y]);return x(o,t)})}};export{S as IndexeddbPersistence,k as PREFERRED_TRIM_SIZE,Q as clearDocument,z as fetchUpdates,W as storeState};
