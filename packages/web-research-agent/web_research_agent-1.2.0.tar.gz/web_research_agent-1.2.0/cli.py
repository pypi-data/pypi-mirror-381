"""
Interactive CLI for Web Research Agent.
Provides a beautiful terminal interface with ASCII art and configuration management.
"""

import os
import sys
from pathlib import Path
from typing import Optional
import logging

# Colorama for cross-platform colors
try:
    from colorama import init, Fore, Style

    init(autoreset=True)
except ImportError:
    # Fallback if colorama not installed
    class Fore:
        CYAN = MAGENTA = YELLOW = GREEN = RED = WHITE = BLUE = ""

    class Style:
        BRIGHT = RESET_ALL = ""


# ASCII Art with gradient effect - BIG AND BOLD
ASCII_ART = r"""
‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
 ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
"""

VERSION = "1.2.0"
TAGLINE = "lock in, anon"

# Disable logging output to console by default
logging.getLogger().setLevel(logging.WARNING)


def print_banner():
    """Print the beautiful ASCII banner with gradient colors."""
    lines = ASCII_ART.strip().split("\n")

    # Create gradient effect from cyan to magenta
    colors = [Fore.CYAN, Fore.BLUE, Fore.MAGENTA, Fore.MAGENTA, Fore.BLUE, Fore.CYAN]

    print()
    for i, line in enumerate(lines):
        color = colors[i % len(colors)]
        print(f"{Style.BRIGHT}{color}{line}")

    print(
        f"\n{Style.BRIGHT}{Fore.YELLOW}                                     v{VERSION}"
    )
    print(f"{Fore.WHITE}                               {TAGLINE}")
    print(f"{Fore.CYAN}{'‚ïê' * 100}")
    print()


def get_config_path() -> Path:
    """Get the path to the configuration file."""
    # Store config in user's home directory
    config_dir = Path.home() / ".webresearch"
    config_dir.mkdir(exist_ok=True)
    return config_dir / "config.env"


def load_config() -> dict:
    """Load configuration from file."""
    config_path = get_config_path()
    config = {}

    if config_path.exists():
        with open(config_path, "r") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, value = line.split("=", 1)
                    config[key.strip()] = value.strip()

    return config


def save_config(config: dict):
    """Save configuration to file."""
    config_path = get_config_path()

    with open(config_path, "w") as f:
        f.write("# Web Research Agent Configuration\n")
        f.write("# This file is automatically generated\n\n")
        for key, value in config.items():
            f.write(f"{key}={value}\n")

    print(f"{Fore.GREEN}‚úì Configuration saved to {config_path}")


def setup_api_keys() -> dict:
    """Interactive setup for API keys."""
    print(f"{Style.BRIGHT}{Fore.CYAN}First-time Setup")
    print(f"{Fore.WHITE}Let's configure your API keys.\n")

    config = {}

    # Gemini API Key
    print(f"{Fore.YELLOW}1. Gemini API Key")
    print(
        f"{Fore.WHITE}   Get yours at: {Fore.CYAN}https://makersuite.google.com/app/apikey"
    )
    gemini_key = input(f"{Fore.GREEN}   Enter Gemini API key: {Fore.WHITE}").strip()

    if not gemini_key:
        print(f"{Fore.RED}‚úó Gemini API key is required!")
        sys.exit(1)

    config["GEMINI_API_KEY"] = gemini_key

    # Serper API Key
    print(f"\n{Fore.YELLOW}2. Serper API Key")
    print(f"{Fore.WHITE}   Get yours at: {Fore.CYAN}https://serper.dev")
    print(f"{Fore.WHITE}   (Free tier: 2,500 searches/month)")
    serper_key = input(f"{Fore.GREEN}   Enter Serper API key: {Fore.WHITE}").strip()

    if not serper_key:
        print(f"{Fore.RED}‚úó Serper API key is required!")
        sys.exit(1)

    config["SERPER_API_KEY"] = serper_key

    # Optional settings with defaults
    print(f"\n{Fore.YELLOW}3. Optional Settings {Fore.WHITE}(press Enter for defaults)")

    max_iterations = input(
        f"{Fore.GREEN}   Max iterations [{Fore.WHITE}15{Fore.GREEN}]: {Fore.WHITE}"
    ).strip()
    config["MAX_ITERATIONS"] = max_iterations if max_iterations else "15"

    temperature = input(
        f"{Fore.GREEN}   Temperature [{Fore.WHITE}0.1{Fore.GREEN}]: {Fore.WHITE}"
    ).strip()
    config["TEMPERATURE"] = temperature if temperature else "0.1"

    config["MAX_TOOL_OUTPUT_LENGTH"] = "5000"
    config["MODEL_NAME"] = "gemini-2.0-flash-exp"
    config["WEB_REQUEST_TIMEOUT"] = "30"
    config["CODE_EXECUTION_TIMEOUT"] = "60"

    print()
    save_config(config)
    print()

    return config


def check_config() -> dict:
    """Check if configuration exists, prompt for setup if needed."""
    # First check if .env file exists in current directory (development mode)
    if os.path.exists(".env"):
        from dotenv import load_dotenv

        load_dotenv()
        config = {
            "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", ""),
            "SERPER_API_KEY": os.getenv("SERPER_API_KEY", ""),
            "MAX_ITERATIONS": os.getenv("MAX_ITERATIONS", "15"),
            "TEMPERATURE": os.getenv("TEMPERATURE", "0.1"),
            "MAX_TOOL_OUTPUT_LENGTH": os.getenv("MAX_TOOL_OUTPUT_LENGTH", "5000"),
            "MODEL_NAME": os.getenv("MODEL_NAME", "gemini-2.0-flash-exp"),
            "WEB_REQUEST_TIMEOUT": os.getenv("WEB_REQUEST_TIMEOUT", "30"),
            "CODE_EXECUTION_TIMEOUT": os.getenv("CODE_EXECUTION_TIMEOUT", "60"),
        }

        if config["GEMINI_API_KEY"] and config["SERPER_API_KEY"]:
            print(f"{Fore.GREEN}‚úì Using configuration from .env file")
            return config

    # Otherwise check user's home directory config
    config = load_config()

    # Check if essential keys exist
    if "GEMINI_API_KEY" not in config or "SERPER_API_KEY" not in config:
        print(f"{Fore.YELLOW}‚ö† Configuration not found or incomplete.\n")
        config = setup_api_keys()

    return config


def apply_config_to_env(config: dict):
    """Apply configuration to environment variables."""
    for key, value in config.items():
        os.environ[key] = value


def show_menu():
    """Display the main menu."""
    print(f"{Style.BRIGHT}{Fore.CYAN}What would you like to do?")
    print(f"{Fore.WHITE}1. {Fore.GREEN}Run a research query")
    print(f"{Fore.WHITE}2. {Fore.YELLOW}Process tasks from file")
    print(f"{Fore.WHITE}3. {Fore.BLUE}View recent logs")
    print(f"{Fore.WHITE}4. {Fore.MAGENTA}Reconfigure API keys")
    print(f"{Fore.WHITE}5. {Fore.RED}Exit")
    print()


def view_logs():
    """View recent log files."""
    logs_dir = Path("logs")

    if not logs_dir.exists() or not list(logs_dir.glob("*.log")):
        print(f"{Fore.YELLOW}No log files found.")
        return

    log_files = sorted(
        logs_dir.glob("*.log"), key=lambda x: x.stat().st_mtime, reverse=True
    )

    print(f"{Style.BRIGHT}{Fore.CYAN}Recent Log Files:")
    for i, log_file in enumerate(log_files[:5], 1):
        size = log_file.stat().st_size / 1024  # KB
        mtime = log_file.stat().st_mtime
        from datetime import datetime

        time_str = datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M:%S")
        print(
            f"{Fore.WHITE}{i}. {Fore.GREEN}{log_file.name} {Fore.WHITE}({size:.1f} KB) - {time_str}"
        )

    print()
    choice = input(
        f"{Fore.GREEN}Enter number to view (or press Enter to skip): {Fore.WHITE}"
    ).strip()

    if choice.isdigit() and 1 <= int(choice) <= len(log_files[:5]):
        log_file = log_files[int(choice) - 1]
        print(f"\n{Fore.CYAN}{'=' * 80}")
        print(f"{Style.BRIGHT}Log: {log_file.name}")
        print(f"{Fore.CYAN}{'=' * 80}\n")

        with open(log_file, "r", encoding="utf-8") as f:
            content = f.read()
            # Show last 100 lines
            lines = content.split("\n")
            if len(lines) > 100:
                print(f"{Fore.YELLOW}[Showing last 100 lines...]\n")
                lines = lines[-100:]

            for line in lines:
                if "ERROR" in line:
                    print(f"{Fore.RED}{line}")
                elif "WARNING" in line:
                    print(f"{Fore.YELLOW}{line}")
                elif "INFO" in line:
                    print(f"{Fore.WHITE}{line}")
                else:
                    print(line)

        print(f"\n{Fore.CYAN}{'=' * 80}\n")


def run_interactive_query():
    """Run a single interactive research query."""
    print(f"{Style.BRIGHT}{Fore.CYAN}Research Query Mode")
    print(f"{Fore.WHITE}Enter your research question (or type 'back' to return):\n")

    query = input(f"{Fore.GREEN}‚ùØ {Fore.WHITE}").strip()

    if query.lower() == "back" or not query:
        return

    print(f"\n{Fore.YELLOW}üîç Starting research on: {Fore.WHITE}{query}")
    print(f"{Fore.CYAN}{'‚îÄ' * 80}\n")

    # Import here to avoid circular imports
    from main import initialize_agent, write_results
    from datetime import datetime

    # Initialize agent
    try:
        agent = initialize_agent(verbose=False)
    except Exception as e:
        print(f"{Fore.RED}‚úó Error initializing agent: {str(e)}")
        print(f"{Fore.YELLOW}Tip: Check your API keys with option 4.")
        return

    # Run the query
    start_time = datetime.now()

    try:
        print(f"{Fore.CYAN}Agent is thinking...\n")
        answer = agent.run(query)

        end_time = datetime.now()
        execution_time = (end_time - start_time).total_seconds()

        # Display result
        print(f"\n{Fore.CYAN}{'=' * 80}")
        print(f"{Style.BRIGHT}{Fore.GREEN}RESULT")
        print(f"{Fore.CYAN}{'=' * 80}\n")
        print(f"{Fore.WHITE}{answer}\n")
        print(f"{Fore.CYAN}{'‚îÄ' * 80}")
        print(f"{Fore.YELLOW}‚è± Completed in {execution_time:.2f} seconds")
        print(f"{Fore.CYAN}{'=' * 80}\n")

        # Offer to save
        save = (
            input(f"{Fore.GREEN}Save result to file? (y/n): {Fore.WHITE}")
            .strip()
            .lower()
        )
        if save == "y":
            filename = input(
                f"{Fore.GREEN}Filename [{Fore.WHITE}result.txt{Fore.GREEN}]: {Fore.WHITE}"
            ).strip()
            if not filename:
                filename = "result.txt"

            with open(filename, "w", encoding="utf-8") as f:
                f.write(f"Query: {query}\n")
                f.write(f"{'=' * 80}\n\n")
                f.write(answer)
                f.write(f"\n\n{'‚îÄ' * 80}\n")
                f.write(f"Execution time: {execution_time:.2f} seconds\n")

            print(f"{Fore.GREEN}‚úì Saved to {filename}\n")

    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}‚ö† Research interrupted by user.\n")
    except Exception as e:
        print(f"{Fore.RED}‚úó Error during research: {str(e)}")
        print(f"{Fore.YELLOW}Check logs for more details (option 3).\n")


def run_tasks_from_file():
    """Run tasks from a file."""
    print(f"{Style.BRIGHT}{Fore.CYAN}Process Tasks from File")
    print(f"{Fore.WHITE}Enter the path to your tasks file:\n")

    filepath = input(f"{Fore.GREEN}‚ùØ {Fore.WHITE}").strip()

    if not filepath or filepath.lower() == "back":
        return

    if not os.path.exists(filepath):
        print(f"{Fore.RED}‚úó File not found: {filepath}\n")
        return

    output_file = input(
        f"{Fore.GREEN}Output file [{Fore.WHITE}results.txt{Fore.GREEN}]: {Fore.WHITE}"
    ).strip()
    if not output_file:
        output_file = "results.txt"

    print(f"\n{Fore.YELLOW}üîç Processing tasks from: {Fore.WHITE}{filepath}")
    print(f"{Fore.YELLOW}üìù Results will be saved to: {Fore.WHITE}{output_file}")
    print(f"{Fore.CYAN}{'‚îÄ' * 80}\n")

    # Import and run
    from main import read_tasks, initialize_agent, write_results
    from datetime import datetime

    try:
        tasks = read_tasks(filepath)
        agent = initialize_agent(verbose=False)

        results = []
        for i, task in enumerate(tasks, 1):
            print(f"{Fore.CYAN}[Task {i}/{len(tasks)}] {Fore.WHITE}{task[:60]}...")

            start_time = datetime.now()
            try:
                answer = agent.run(task)
                end_time = datetime.now()
                execution_time = (end_time - start_time).total_seconds()

                result = {
                    "task": task,
                    "answer": answer,
                    "execution_time": execution_time,
                    "num_steps": len(agent.get_execution_trace()),
                    "trace": agent.get_execution_trace(),
                }

                results.append(result)
                print(f"{Fore.GREEN}‚úì Completed in {execution_time:.2f}s\n")

            except Exception as e:
                print(f"{Fore.RED}‚úó Error: {str(e)}\n")
                result = {
                    "task": task,
                    "answer": "Error occurred during processing",
                    "error": str(e),
                }
                results.append(result)

        write_results(output_file, results)
        print(f"{Fore.GREEN}‚úì All tasks completed! Results saved to {output_file}\n")

    except Exception as e:
        print(f"{Fore.RED}‚úó Error: {str(e)}\n")


def main():
    """Main CLI entry point."""
    # Print banner
    print_banner()

    # Check and load configuration
    config = check_config()
    apply_config_to_env(config)

    print(f"{Fore.GREEN}‚úì Configuration loaded")
    print()

    # Main loop
    while True:
        show_menu()

        choice = input(f"{Fore.GREEN}‚ùØ {Fore.WHITE}").strip()
        print()

        if choice == "1":
            run_interactive_query()
        elif choice == "2":
            run_tasks_from_file()
        elif choice == "3":
            view_logs()
        elif choice == "4":
            config = setup_api_keys()
            apply_config_to_env(config)
        elif choice == "5":
            print(f"{Fore.CYAN}Thanks for using Web Research Agent! üëã\n")
            sys.exit(0)
        else:
            print(f"{Fore.RED}Invalid choice. Please try again.\n")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.CYAN}Goodbye! üëã\n")
        sys.exit(0)
