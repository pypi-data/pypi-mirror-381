<html><head><title>main371</title>
<link rel="stylesheet" type="text/css" href="../pythia.css"/>
<link rel="shortcut icon" href="../pythia32.gif"/></head><body><h2>main371</h2>
Back to <a href="../ExampleKeywords.html" target="page">index.</a>
<pre><code class="language-c++">
// main371.cc is a part of the PYTHIA event generator.
// Copyright (C) 2025 Torbjorn Sjostrand.
// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
// Please respect the MCnet Guidelines, see GUIDELINES for details.

// Authors:
//            <a href="mailto:torbjorn.sjostrand@fysik.lu.se">Torbjorn Sjostrand</a>

// Keywords:
//            <a href="../ExampleKeywords.html#top">Top</a>
//            <a href="../ExampleKeywords.html#toponium">Toponium</a>

// Study ttbar production above and below threshold,
// starting out from the equations in
// V. Fadin,  V. Khoze and T. Sjostrand, Z. Phys. C48 (1990) 613,
// with some further assumptions in the below-threshold simulation.

#include &quot;Pythia8/Pythia.h&quot;
using namespace Pythia8;

//============================================================================

int main() {

  // Restrict to threshold region only or not.
  bool thresholdOnly = true;

  // Full event generation or only cross-section-oriented studies.
  bool fullEvents = false;

  // Number of events.
  int nEvent = 1000000;

  // LHC collision energy.
  double eCM = 13000.;

  // Example of possible setup values.
  // topModel = 0 is Born, = 1 is simple Coulomb,
  // = 2 is Green&apos;s above threshold, = 3 adds below-threshold mirrored,
  // = 4 includes above-and-below-threshold parts (most plausible scenario).
  int    topModel       = 4;
  double mt             = 172.5;
  double thresholdWidth = 10.;
  int    alphasOrder    = 2;
  double alphasValue    = 0.118;
  double ggSingletFrac  = 2./7.;
  double qqSingletFrac  = 0.;

  // Generator.
  Pythia pythia;

  // Feed in desired values.
  pythia.settings.mode(&quot;TopThreshold:model&quot;, topModel);
  pythia.particleData.m0(6, mt);
  pythia.settings.parm(&quot;TopThreshold:width&quot;, thresholdWidth);
  pythia.settings.mode(&quot;TopThreshold:alphasOrder&quot;, alphasOrder);
  pythia.settings.parm(&quot;TopThreshold:alphasValue&quot;, alphasValue);
  pythia.settings.parm(&quot;TopThreshold:ggSingletFrac&quot;, ggSingletFrac);
  pythia.settings.parm(&quot;TopThreshold:qqSingletFrac&quot;, qqSingletFrac);

  // Process selection. LHC at 13 TeV.
  pythia.readString(&quot;Top:gg2ttbar = on&quot;);
  pythia.readString(&quot;Top:qqbar2ttbar = on&quot;);
  pythia.settings.parm(&quot;Beams:eCM&quot;, eCM);

  // Restrict to threshold region.
  if (thresholdOnly) {
    pythia.readString(&quot;PhaseSpace:mHatMin = 300.&quot;);
    pythia.readString(&quot;PhaseSpace:mHatMax = 400.&quot;);
  }
  else pythia.readString(&quot;PhaseSpace:mHatMin = 200.&quot;);

  // Switch off (most) code parts not relevant here. Reduce printout.
  if (!fullEvents) {
    pythia.readString(&quot;PartonLevel:ISR = off&quot;);
    pythia.readString(&quot;PartonLevel:FSR = off&quot;);
    pythia.readString(&quot;PartonLevel:MPI = off&quot;);
    pythia.readString(&quot;HadronLevel:all = off&quot;);
  }
  pythia.readString(&quot;Next:numberCount = 100000&quot;);

  // If Pythia fails to initialize, exit with error.
  if (!pythia.init()) return 1;

  // Histograms.
  Hist mHatOri(&quot;original threshold&quot;, 100, -20., 80.);
  Hist mHatOriLow(&quot;original threshold&quot;, 100, -10., 30.);
  Hist mHatThr(&quot;corrected threshold&quot;, 100, -20., 80.);
  Hist mHatLow(&quot;ttbar invariant mass, low&quot;, 100, 300., 400.);
  Hist mHatAll(&quot;ttbar invariant mass, all&quot;, 100, 200., 1200.);
  Hist mTopMax(&quot;max(m_t, m_tbar) mass distribution&quot;, 100, 100., 200.);
  Hist mTopMin(&quot;min(m_t, m_tbar) mass distribution&quot;, 100, 100., 200.);
  Hist betaPair(&quot;beta factor of pair&quot;, 100, 0., 1.);
  Hist mHatOriBT(&quot;original threshold, below&quot;, 100, -20., 80.);
  Hist mHatOriBTLow(&quot;original threshold, below&quot;, 100, -10., 30.);
  Hist mHatThrBT(&quot;corrected threshold, below&quot;, 100, -10., 30.);
  Hist mHatLowBT(&quot;ttbar invariant mass, low, below&quot;, 100, 300., 400.);
  Hist mHatAllBT(&quot;ttbar invariant mass, all, below&quot;, 100, 200., 1200.);
  Hist mTopMaxBT(&quot;max(m_t, m_tbar) mass distribution, below&quot;, 100, 100., 200.);
  Hist mTopMinBT(&quot;min(m_t, m_tbar) mass distribution, below&quot;, 100, 100., 200.);
  Hist betaPairBT(&quot;beta factor of pair, below&quot;, 100, 0., 1.);
  Hist mShiftBT(&quot;shift in top mass, after - before&quot;, 100, -45., 5.);

  // Begin event loop.
  int nBelow = 0, nBelowgg = 0, nBelowqq = 0, nAbovegg = 0, nAboveqq = 0;
  double eBelow = 0.;
  for (int iEvent = 0; iEvent &lt; nEvent; ++iEvent) {

    // Generate events.
    if (!pythia.next()) continue;

    // Original threshold value and other properties.
    double eThr = pythia.info.toponiumE;
    double mt1T = pythia.info.toponiumm3;
    double mt2T = pythia.info.toponiumm4;
    double mHat = pythia.info.mHat();
    double mt1  = pythia.info.m3Hat();
    double mt2  = pythia.info.m4Hat();
    double rat1 = pow2( mt1 / mHat);
    double rat2 = pow2( mt2 / mHat);
    double beta = sqrtpos( pow2(1 - rat1 - rat2) - 4. * rat1 * rat2);

    // Histogram for all events.
    mHatOri.fill( eThr);
    mHatOriLow.fill( eThr);
    mHatThr.fill( mHat - mt1 - mt2);
    mHatLow.fill( mHat);
    mHatAll.fill( mHat);
    mTopMax.fill( max(mt1,mt2) );
    mTopMin.fill( min(mt1,mt2) );
    betaPair.fill( beta);

    // Histogram for below-threshold events.
    if (eThr &lt; 0.) {
      ++nBelow;
      if (pythia.info.code() == 601) ++nBelowgg;
      else ++nBelowqq;
      eBelow += eThr;
      mHatOriBT.fill( eThr);
      mHatOriBTLow.fill( eThr);
      mHatThrBT.fill( mHat - mt1 - mt2);
      mHatLowBT.fill( mHat);
      mHatAllBT.fill( mHat);
      mTopMaxBT.fill( max(mt1,mt2) );
      mTopMinBT.fill( min(mt1,mt2) );
      betaPairBT.fill( beta);
      mShiftBT.fill( mt1 - mt1T);
      mShiftBT.fill( mt2 - mt2T);
    } else {
      if (pythia.info.code() == 601) ++nAbovegg;
      else ++nAboveqq;
    }

  // End of event loop.
  }

  // Normalize histogram to cross section, in pb/GeV.
  double sigmapb = 1e9 * pythia.info.sigmaGen() / nEvent;
  mHatOri      *= sigmapb;
  mHatOriLow   *= 2.5 * sigmapb;
  mHatThr      *= sigmapb;
  mHatLow      *= sigmapb;
  mHatAll      *= 0.1 * sigmapb;
  mTopMax      *= sigmapb;
  mTopMin      *= sigmapb;
  betaPair     *= 100. * sigmapb;
  mHatOriBT    *= sigmapb;
  mHatOriBTLow *= 2.5 * sigmapb;
  mHatThrBT    *= sigmapb;
  mHatLowBT    *= sigmapb;
  mHatAllBT    *= 0.1 * sigmapb;
  mTopMaxBT    *= sigmapb;
  mTopMinBT    *= sigmapb;
  betaPairBT   *= 100. * sigmapb;
  mShiftBT     *= 2. * sigmapb;

  // Statistics and cross sections
  pythia.stat();
  double sigAbv   = sigmapb * (nEvent - nBelow);
  double sigAbvgg = sigmapb * nAbovegg;
  double sigAbvqq = sigmapb * nAboveqq;
  double sigBel   = sigmapb * nBelow;
  double sigBelgg = sigmapb * nBelowgg;
  double sigBelqq = sigmapb * nBelowqq;
  cout &lt;&lt; &quot;\n sigma above threshold = &quot; &lt;&lt; fixed &lt;&lt; setprecision(3)
       &lt;&lt; sigAbv &lt;&lt; &quot; pb&quot; &lt;&lt; endl &lt;&lt; &quot;   whereof gg = &quot; &lt;&lt; sigAbvgg
       &lt;&lt; &quot; and qq = &quot;&lt;&lt; sigAbvqq &lt;&lt; endl &lt;&lt; &quot; sigma below threshold = &quot;
       &lt;&lt; sigBel &lt;&lt; &quot; pb&quot; &lt;&lt; endl &lt;&lt; &quot;   whereof gg = &quot; &lt;&lt; sigBelgg
       &lt;&lt; &quot; and qq = &quot; &lt;&lt; sigBelqq &lt;&lt; endl;
  eBelow /= max(1, nBelow);
  cout &lt;&lt; &quot; average energy for below-threshold part = &quot; &lt;&lt; eBelow
       &lt;&lt; &quot; GeV&quot; &lt;&lt; endl;

  // Histograms with pyplot.
  HistPlot hpl(&quot;plot371&quot;);

  // Spectra relative to event-by-event threshold, including below.
  hpl.frame(&quot;fig371&quot;, &quot;Energy above/below threshold, original tops&quot;,
    &quot;$E$ (GeV)&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}E$ (pb/GeV)&quot;);
  hpl.add( mHatOriBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( mHatOri - mHatOriBT, &quot;h,black&quot;, &quot;above-threshold part&quot;);
  //hpl.plot(-20., 80., 0., 5.);
  hpl.plot();

  // Ditto, but with new t/tbar masses for below-threshold part.
  hpl.frame(&quot;&quot;, &quot;Energy above threshold, new top masses where necessary&quot;,
    &quot;$E&apos;$ (GeV)&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}E&apos;$ (pb/GeV)&quot;);
  hpl.add( mHatThrBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( mHatThr, &quot;h,black&quot;, &quot;all&quot;);
  //hpl.plot(-10., 40., 0., 5.);
  hpl.plot();

  // Pair mass spectra close to threshold.
  hpl.frame(&quot;&quot;, &quot;Invariant mass of ttbar pair, near threshold&quot;,
    &quot;$m(t+tbar) (GeV)$&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}m$ (pb/GeV)&quot;);
  hpl.add( mHatLowBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( mHatLow, &quot;h,black&quot;, &quot;all&quot;);
  //hpl.plot(300., 400., 0., 3.5);
  hpl.plot();

  // Pair mass spectra over full range.
  hpl.frame(&quot;&quot;, &quot;Invariant mass of ttbar pair, full range&quot;,
    &quot;$m(t+tbar) (GeV)$&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}m$ (pb/GeV)&quot;);
  hpl.add( mHatAllBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( mHatAll, &quot;h,black&quot;, &quot;all&quot;);
  hpl.plot();

  // Top/antitop mass spectra.
  hpl.frame(&quot;&quot;, &quot;Larger of top and antitop masses&quot;,
    &quot;max($m(t), m(tbar)$) (GeV)&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}m$ &quot;
    &quot;(pb/GeV)&quot;);
  hpl.add( mTopMaxBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( mTopMax, &quot;h,black&quot;, &quot;all&quot;);
  hpl.plot(100., 200., 0.01, 100., true, false);

  hpl.frame(&quot;&quot;, &quot;Smaller of top and antitop masses&quot;,
    &quot;min($m(t), m(tbar)$) (GeV)&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}m$ &quot;
    &quot;(pb/GeV)&quot;);
  hpl.add( mTopMinBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( mTopMin, &quot;h,black&quot;, &quot;all&quot;);
  hpl.plot(100., 200., 0.01, 100., true, false);

  // Top/antitop separation.
  hpl.frame(&quot;&quot;, &quot;Beta factor in t-tbar pair&quot;,
    &quot;$\\beta$&quot;, &quot;$\\mathrm{d}\\sigma/\\mathrm{d}\\beta$ (pb)&quot;);
  hpl.add( betaPairBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.add( betaPair, &quot;h,black&quot;, &quot;all&quot;);
  hpl.plot();

  // Redefinition change of top masses in below-threshold pairs.
  hpl.frame(&quot;&quot;, &quot;Shift of below-threshold top masses&quot;, &quot;$\\Delta m$ (GeV)&quot;,
    &quot;$\\mathrm{d}\\sigma/\\mathrm{d}(\\Delta m)$ (pb/GeV)&quot;);
  hpl.add( mShiftBT, &quot;h,red&quot;, &quot;below-threshold part&quot;);
  hpl.plot();

  // For inclusion in talk.
  hpl.frame(&quot;fig371mass&quot;, &quot;&quot;, &quot;$\\hat{m}$ (GeV)&quot;,
    &quot;$\\mathrm{d}\\sigma/\\mathrm{d}\\hat{m}$ (pb/GeV)&quot;, 4.8, 4.8);
  hpl.add( mHatLow, &quot;h,black&quot;, &quot;all&quot;);
  hpl.add( mHatLowBT, &quot;h,red&quot;, &quot;below threshold&quot;);
  hpl.plot();
  hpl.frame(&quot;fig371BreitWigners&quot;, &quot;&quot;, &quot;$m$ (GeV)&quot;,
    &quot;$\\mathrm{d}\\sigma/\\mathrm{d}m$ (pb/GeV)&quot;, 4.8, 4.8);
  hpl.add( mTopMax, &quot;h,black&quot;, &quot;max($m_{t1},m_{t2}$) all&quot;);
  hpl.add( mTopMin, &quot;h,blue&quot;, &quot;min($m_{t1},m_{t2}$) all&quot;);
  hpl.add( mTopMaxBT, &quot;h,red&quot;, &quot;max($m_{t1},m_{t2}$) below threshold&quot;);
  hpl.add( mTopMinBT, &quot;h,magenta&quot;, &quot;min($m_{t1},m_{t2}$) below threshold&quot;);
  hpl.plot(140., 200., 0.01, 1000., true, false);

  // Done.
  return 0;
}
</code></pre></body></html>