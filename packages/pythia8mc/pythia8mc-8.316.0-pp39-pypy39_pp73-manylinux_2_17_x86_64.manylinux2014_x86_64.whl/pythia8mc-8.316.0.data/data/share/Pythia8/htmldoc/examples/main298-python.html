<html><head><title>main298-python</title>
<link rel="stylesheet" type="text/css" href="../pythia.css"/>
<link rel="shortcut icon" href="../pythia32.gif"/></head><body><h2>main298-python</h2>
Back to <a href="../ExampleKeywords.html" target="page">index.</a>
<pre><code class="language-python">
# main298.py is a part of the PYTHIA event generator.
# Copyright (C) 2025 Artem Havryliuk and Torbjorn Sjostrand.
# PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
# Please respect the MCnet Guidelines, see GUIDELINES for details.

# Authors:
#            <a href="mailto:philten@cern.ch">Philip Ilten</a>
#            Artem Havryliuk
#            Jim Pivarski

# Keywords:
#            <a href="../ExampleKeywords.html#python">Python</a>

# Example usage of the &apos;nextBatch&apos; function in the PYTHIA event
# generator.  This script demonstrates the usage of different
# &apos;errorMode&apos; values (&apos;skip&apos;, &apos;fail&apos;, &apos;none&apos;, and a float) to generate
# events and handle failures.

# The &apos;nextBatch&apos; function generates a batch of particle physics events,
# returning the results as an Awkward Array, with behavior determined
# by the specified error mode.

# To set the path to the Pythia 8 Python interface do either
# (in a shell prompt):
#      export PYTHONPATH=$(PREFIX_LIB):$PYTHONPATH
# or the following which sets the path from within Python.
import sys
cfg = open(&quot;Makefile.inc&quot;)
lib = &quot;../lib&quot;
for line in cfg:
    if line.startswith(&quot;PREFIX_LIB=&quot;): lib = line[11:-1]; break
sys.path.insert(0, lib)

# Import the Pythia module.
import pythia8

# Import the Awkward module.
import awkward as ak

#==========================================================================

def setup():
    &quot;&quot;&quot;
    Basic Pythia setup for generation examples.
    &quot;&quot;&quot;
    # Create the Pythia instance.
    py = pythia8.Pythia(&quot;&quot;, False)
    # Configure hard QCD.
    py.readString(&quot;HardQCD:all = on&quot;)
    # Turn on some weights.
    py.readString(&quot;VariationFrag:List = {var0 frag:aLund=0.6, &quot;
                  &quot;var1 frag:aLund=0.4}&quot;)
    # Turn off most of Pythia&apos;s messages.
    py.readString(&quot;Print:quiet = on&quot;)
    # Initialize and return.
    py.init()
    return py

#==========================================================================

def generateSkip():
    &quot;&quot;&quot;
    Demonstrates event generation with errorMode=&apos;skip&apos;. In this
    mode, failed events are simply skipped, and no record of them is
    included in the result. Only successful events are returned.
    &quot;&quot;&quot;
    py = setup()
    nEvents = 10
    errorMode = &quot;skip&quot;
    run = py.nextBatch(nEvents, errorMode)
    print(&quot;Generated events (skip mode):&quot;, len(run))

#==========================================================================

def generateFail():
    &quot;&quot;&quot;
    Demonstrates event generation with errorMode=&apos;fail&apos;.
    In this mode, the process stops immediately if an event fails,
    raising a runtime exception.
    &quot;&quot;&quot;
    py = setup()
    nEvents = 10
    errorMode = &quot;fail&quot;
    try:
        run = py.nextBatch(nEvents, errorMode)
        print(&quot;All events generated successfully!&quot;)
    except RuntimeError as e:
        print(f&quot;Event generation failed: {e}&quot;)

#==========================================================================

def generateNone():
    &quot;&quot;&quot;
    Demonstrates event generation with errorMode=&apos;none&apos;. In this
    mode, failed events are included in the output array, but they are
    marked as invalid (e.g., None). The total number of events in the
    output matches the requested number.
    &quot;&quot;&quot;
    py = setup()
    nEvents = 10
    errorMode = &quot;none&quot;
    run = py.nextBatch(nEvents, errorMode)
    print(&quot;Generated events (including invalid):&quot;, len(run))

#==========================================================================

def generateFloat():
    &quot;&quot;&quot;
    Demonstrates event generation with errorMode as a float (e.g.,
    1.5). In this mode, additional attempts are allowed to ensure the
    desired number of successful events. The float value specifies a
    multiplier for the number of trials relative to the number of
    events.
    &quot;&quot;&quot;
    py = setup()
    nEvents = 10
    errorMode = 1.5
    run = py.nextBatch(nEvents, errorMode)
    print(&quot;Generated events (float mode):&quot;, len(run))
    
#==========================================================================

def demoEvent():
    &quot;&quot;&quot;
    Demonstrates how to work with the event record generated by
    &apos;nextBatch&apos;. The output is an Awkward Array containing particle
    data and event info. This function shows how to access various
    elements, such as &apos;id&apos;, &apos;x1&apos;, &apos;x2&apos;, &apos;mother1&apos;, and others, from
    the event record.
    &quot;&quot;&quot;
    py = setup()
    nEvents = 5
    # Generate events, including failed ones as &apos;None&apos;.
    errorMode = &quot;none&quot; 
    # Generate a batch of events.
    run = py.nextBatch(nEvents, errorMode)

    # Print the structure of the Awkward array.
    print(&quot;\nAwkward Array structure:&quot;)
    print(ak.fields(run))

    # Access particle-level information.
    print(&quot;\nParticle-level information:&quot;)
    prts = run.prt
    print(f&quot;IDs of particles: {prts.id}&quot;)
    print(f&quot;Mother 1: {prts.mother1}&quot;)
    print(f&quot;Momentum px: {prts.p.px}&quot;)
    print(f&quot;Momentum py: {prts.p.py}&quot;)

    # Accessing event-level information.
    print(&quot;\nEvent-level information:&quot;)
    info = run.info
    print(f&quot;x1: {info.x1}&quot;)
    print(f&quot;x2: {info.x2}&quot;)
    print(f&quot;alphaS: {info.alphaS}&quot;)
    print(f&quot;Q2Fac: {info.Q2Fac}&quot;)

    # Access weights.
    print(&quot;\nEvent weights:&quot;)
    print(info.weights)

    # Example: Accessing the first event&apos;s particle data.
    print(&quot;\nFirst event particle data:&quot;)
    print(prts[0])

#==========================================================================

def demoSlice():
    &quot;&quot;&quot;
    Demonstrates how to work with and slice the particle arrays in the
    event record.  Shows examples of accessing specific particles,
    slicing arrays, and filtering data.
    &quot;&quot;&quot;
    # Generate events with failed events as None.
    py = setup()
    nEvents = 5
    errorMode = &quot;none&quot;
    run = py.nextBatch(nEvents, errorMode)

    # Particle-level information.
    prts = run.prt
    print(&quot;\n### Particle Array Slicing and Manipulation ###&quot;)

    # Example: accessing particles from the first event.
    print(&quot;\nParticles from the first event:&quot;)
    firstEventPrts = prts[0]
    print(firstEventPrts)

    # Example: accessing only the first 5 particles of the first event.
    print(&quot;\nFirst 5 particles from the first event:&quot;)
    print(firstEventPrts[:5])

    # Example: slicing all events to retrieve the first particle of
    # each event.
    print(&quot;\nFirst particle of each event:&quot;)
    firstPrtEachEvent = prts[:, 0]
    print(firstPrtEachEvent)

    # Example: filtering particles with px &gt; 50.0 across all events.
    print(&quot;\nParticles with px &gt; 0.0182:&quot;)
    filterPrts = prts[prts.p.px &gt; 0.0182]
    print(filterPrts)

    # Example: combining slices and conditions.
    print(&quot;\nParticles from the first event with px &gt; 0.2:&quot;)
    filtered_first_event = firstEventPrts[firstEventPrts.p.px &gt; 0.2]
    print(filtered_first_event)
    
#==========================================================================

def demoWeights():
    &quot;&quot;&quot;
    Demonstrates how weights from the events are accessed and used.
    Shows examples of retrieving weights for each event and calculating
    weighted statistics.
    &quot;&quot;&quot;
    # Generate events with failed events as None.
    py = setup()
    nEvents = 5
    errorMode = &quot;none&quot;
    run = py.nextBatch(nEvents, errorMode)

    # Access the weights for each event.
    print(&quot;\n### Demonstrating Event Weights ###&quot;)
    weights = run.info.weights

    # Print the weights for all events
    print(&quot;\nEvent weights:&quot;)
    for i, weight in enumerate(weights):
        print(f&quot;Event {i + 1} weights: {weight}&quot;)

    # Example: sum over all events for each variation.
    sumWeights = ak.sum(weights, axis=0)
    print(&quot;\nSum over all events for each variation:&quot;)
    for i, sumWeight in enumerate(sumWeights):
        print(f&quot;Variation {i + 1}: {sumWeight}&quot;)
    
#==========================================================================

def demoFilter():
    &quot;&quot;&quot;
    Demonstrates how to filter out events where particles (&apos;prt&apos;) are
    &apos;None&apos;.  Uses &apos;ak.is_none&apos; to identify invalid events and provides
    examples of handling such cases.
    
    Important: We only get &apos;None&apos; events in the output when
    &apos;errorMode=&apos;none&apos;&apos; is used during event generation. In this mode,
    failed events are included in the result but marked as &apos;None&apos;,
    while successful events contain valid particle and event data.

    Example workflow:
    - Identify invalid events using &apos;ak.is_none&apos;.
    - Count the number of invalid events.
    - Filter out invalid events to retain only valid events.
    - Optionally handle or analyze invalid events separately.
    &quot;&quot;&quot;
    # Generate events with failed events as None.
    py = setup()
    nEvents = 10
    errorMode = &quot;none&quot;
    run = py.nextBatch(nEvents, errorMode)

    # Identify events where particles (&apos;prt&apos;) are &apos;None&apos;.
    print(&quot;\n### Filtering Invalid Events ###&quot;)
    invalid = ak.is_none(run.prt)
    print(&quot;\nInvalid events (where particles are None):&quot;)
    print(invalid)

    # Count the number of invalid events.
    nInvalid = ak.sum(invalid)
    print(f&quot;\nNumber of invalid events: {nInvalid}&quot;)

    # Filter out invalid events.
    valid = run[~invalid]
    print(f&quot;\nNumber of valid events after filtering: {len(valid)}&quot;)

    # Example: accessing valid particles from filtered events.
    print(&quot;\nParticles from the first valid event:&quot;)
    if len(valid) &gt; 0:
        print(valid.prt[0])
    else:
        print(&quot;No valid events found.&quot;)

    # Example: handling invalid events (optional use case).
    if nInvalid &gt; 0:
        print(&quot;\nInvalid events can be further analyzed or logged if needed.&quot;)
        # You can access invalid events like this.
        invalidEvents = run[invalid]
        print(&quot;Example of an invalid event:&quot;)
        print(invalidEvents)

# Run the examples to demonstrate different error modes.
if __name__ == &quot;__main__&quot;:
    
    print(&quot;Running event generation with errorMode=&apos;skip&apos;...&quot;)
    generateSkip()
    
    print(&quot;\nRunning event generation with errorMode=&apos;fail&apos;...&quot;)
    generateFail()
    
    print(&quot;\nRunning event generation with errorMode=&apos;none&apos;...&quot;)
    generateNone()
    
    print(&quot;\nRunning event generation with errorMode=1.5...&quot;)
    generateFloat()
    
    print(&quot;\nDemonstrating event record analysis...&quot;)
    demoEvent()
    
    print(&quot;\nDemonstrating event record analysis with slicing...&quot;)
    demoSlice()
    
    print(&quot;\nDemonstrating event record analysis with weights...&quot;)
    demoWeights()

    print(&quot;\nDemonstrating filtering invalid events...&quot;)
    demoFilter()
</code></pre></body></html>