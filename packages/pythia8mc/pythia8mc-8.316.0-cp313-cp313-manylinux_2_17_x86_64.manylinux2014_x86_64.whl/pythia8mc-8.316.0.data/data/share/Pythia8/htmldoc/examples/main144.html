<html><head><title>main144</title>
<link rel="stylesheet" type="text/css" href="../pythia.css"/>
<link rel="shortcut icon" href="../pythia32.gif"/></head><body><h2>main144</h2>
Back to <a href="../ExampleKeywords.html" target="page">index.</a>
<pre><code class="language-c++">
// main144.cc is a part of the PYTHIA event generator.
// Copyright (C) 2025 Torbjorn Sjostrand.
// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
// Please respect the MCnet Guidelines, see GUIDELINES for details.

// Authors:
//            <a href="mailto:christian.bierlich@fysik.lu.se">Christian Bierlich</a>

// Keywords:
//            <a href="../ExampleKeywords.html#analysis">Analysis</a>
//            <a href="../ExampleKeywords.html#hepmc">Hepmc</a>
//            <a href="../ExampleKeywords.html#command+file">Command&nbsp;file</a>
//            <a href="../ExampleKeywords.html#command+line+option">Command&nbsp;line&nbsp;option</a>
//            <a href="../ExampleKeywords.html#root">Root</a>
//            <a href="../ExampleKeywords.html#rivet">Rivet</a>
//            <a href="../ExampleKeywords.html#tuning">Tuning</a>

// Streamlined event generation with possibility to output ROOT files,
// output HepMC files and run RIVET analyses, all by specifying output modes
// in a cmnd file, where also the event generator settings are specified.
// The example is run with command line options, run ./main144 -h to see a
// full list. See ROOT Usage for information about ROOT output, RIVET Usage
// for information about RIVET and HepMC Interface for information about HepMC.

#include &quot;Pythia8/Pythia.h&quot;
#include &quot;Pythia8/HeavyIons.h&quot;
#include &quot;Pythia8Plugins/InputParser.h&quot;
#include &lt;chrono&gt;
#ifdef HEPMC3
#include &quot;Pythia8Plugins/HepMC3.h&quot;
#endif
#ifdef PY8ROOT
#include &quot;TSystem.h&quot;
#include &quot;TTree.h&quot;
#include &quot;TFile.h&quot;
#endif

// Use the Pythia namespace.
using namespace Pythia8;

//==========================================================================

// Define filling ROOT particle and events if using ROOT.

#ifdef PY8ROOT
#include &quot;main144Dct.h&quot;

// Fill a ROOT particle.
RootParticle::RootParticle(Pythia8::Particle &amp;prt) {
  phi = prt.phi();
  eta = prt.eta();
  y   = prt.y();
  pT  = prt.pT();
  pid = prt.id();
}

// Fill a ROOT event to a TTree.
void RootEvent::fill(const Pythia8::Info &amp;infoIn, vector&lt;RootParticle&gt; &amp;prtsIn,
  TTree *treeIn) {
  weight = infoIn.weight();
  particles = prtsIn;
  treeIn-&gt;Fill();
}
#endif

//==========================================================================

// Implement a user supplied UserHooks derived class inside this
// wrapper, which will allow you to give settings that can be supplied
// in command files.

class UserHooksWrapper : public UserHooks {

public:

  // Add the settings you want available in the run card in this method.
  void additionalSettings(Settings* settingsIn) {
    settings = settingsIn;
    settings-&gt;addFlag(&quot;UserHooks:doMPICut&quot;, false);
    settings-&gt;addMode(&quot;UserHooks:nMPICut&quot;, 0, true, false, 0, 0);
  }

  // Check if parton level can be vetoed.
  bool canVetoPartonLevel() final {
    return settings-&gt;flag(&quot;UserHooks:doMPICut&quot;);}

  // Check if parton level should be vetoed.
  bool doVetoPartonLevel(const Event&amp;) final {
    return infoPtr-&gt;nMPI() &lt; settings-&gt;mode(&quot;UserHooks:nMPICut&quot;);}

private:

  Settings* settings{};

};

//==========================================================================

// Main example execution.

int main(int argc, char* argv[]) {

  // Parser object for command line input.
  InputParser ip(&quot;Run Pythia with cmnd file input, and get Rivet, HepMC or&quot;
    &quot; standard Pythia output.&quot;,
    {&quot;./main144 [options]&quot;, &quot;./main144 -c main144.cmnd -n 1000 -o myoutput&quot;},
    &quot;Additional options in cmnd file:\n&quot;
    &quot;\tMain:writeLog = on\n\t\tRedirect output to &lt;-o prefix&gt;.log.\n&quot;
    &quot;\tMain:writeHepMC = on \n\t\tWrite HepMC output, requires HepMC linked.\n&quot;
    &quot;\tMain:writeRoot = on \n\t\tWrite a ROOT tree declared in &quot;
    &quot;RootEvent.h, requires ROOT linked.\n&quot;);

  // Set up command line options.
  ip.require(&quot;c&quot;, &quot;User-written command file, can use multiple times.&quot;,
    {&quot;-cmnd&quot;});
  ip.add(&quot;s&quot;, &quot;-1&quot;, &quot;Specify seed for the random number generator.&quot;,
    {&quot;-seed&quot;});
  ip.add(&quot;o&quot;, &quot;main144&quot;, &quot;Output prefix for log file, HepMC, and ROOT.&quot;,
    {&quot;-out&quot;});
  ip.add(&quot;n&quot;, &quot;-1&quot;, &quot;Number of events. Overrides the command files.&quot;,
    {&quot;-nevents&quot;});
  ip.add(&quot;l&quot;, &quot;false&quot;, &quot;Silence the splash screen.&quot;);
  ip.add(&quot;t&quot;, &quot;false&quot;, &quot;Time event generation.&quot;, {&quot;-time&quot;});
  ip.add(&quot;v&quot;, &quot;false&quot;, &quot;Print Pythia version number and exit.&quot;, {&quot;-version&quot;});

  // Initialize the parser and exit if necessary.
  InputParser::Status status = ip.init(argc, argv);
  if (status != InputParser::Valid) return status;

  // Print version number and exit.
  if (ip.get&lt;bool&gt;(&quot;v&quot;)) {
    cout &lt;&lt; &quot;PYTHIA version: &quot; &lt;&lt; PYTHIA_VERSION &lt;&lt; endl;
    return 0;
  }

  // Get the command files.
  vector&lt;string&gt; cmnds = ip.getVector&lt;string&gt;(&quot;c&quot;);
  if (cmnds.size() == 0) {
    cout &lt;&lt; &quot;Please provide one or more command files with the -c option.&quot;
         &lt;&lt; endl;
    return 1;
  }

  // Random number seed.
  string seed = ip.get&lt;string&gt;(&quot;s&quot;);
  // Output filename.
  string out = ip.get&lt;string&gt;(&quot;o&quot;);
  // Time event generation.
  bool writeTime = ip.get&lt;bool&gt;(&quot;t&quot;);
  // Command line number of event, overrides the one set in input .cmnd file.
  int nev = ip.get&lt;int&gt;(&quot;n&quot;);

  // Catch the splash screen in a buffer.
  stringstream splashBuf;
  std::streambuf* sBuf = cout.rdbuf();
  cout.rdbuf(splashBuf.rdbuf());
  // The Pythia object.
  Pythia pythia;
  // Direct cout back.
  cout.rdbuf(sBuf);

  // UserHooks wrapper.
  shared_ptr&lt;UserHooksWrapper&gt; userHooksWrapper =
    make_shared&lt;UserHooksWrapper&gt;();
  userHooksWrapper-&gt;additionalSettings(&amp;pythia.settings);
  pythia.setUserHooksPtr(userHooksWrapper);

  // Some extra parameters.
  pythia.settings.addFlag(&quot;Main:writeLog&quot;, false);
  pythia.settings.addFlag(&quot;Main:writeHepMC&quot;, false);
  pythia.settings.addFlag(&quot;Main:writeRoot&quot;, false);

  // Read the command files.
  for (int iCmnd = 0; iCmnd &lt; (int)cmnds.size(); ++iCmnd)
    if (!cmnds[iCmnd].empty()) pythia.readFile(cmnds[iCmnd]);

  // Set seed after reading input.
  if(seed != &quot;-1&quot;) {
    pythia.readString(&quot;Random:setSeed = on&quot;);
    pythia.readString(&quot;Random:seed = &quot;+seed);
  }

  // Read the extra parameters.
  if (nev &gt; -1) pythia.settings.mode(&quot;Main:numberOfEvents&quot;, nev);
  int nEvent                   = pythia.mode(&quot;Main:numberOfEvents&quot;);;
  int nError                   = pythia.mode(&quot;Main:timesAllowErrors&quot;);
  bool writeLog                = pythia.flag(&quot;Main:writeLog&quot;);
  bool writeHepmc              = pythia.flag(&quot;Main:writeHepMC&quot;);
  bool writeRoot               = pythia.flag(&quot;Main:writeRoot&quot;);
  bool countErrors             = nError &gt; 0;

  // Check if HepMC, and ROOT are requested and available.
  bool valid = true;
#ifndef HEPMC3
  valid = valid &amp;&amp; !writeHepmc;
  if (writeHepmc)
    cout &lt;&lt; &quot;Option Main::writeHepMC = on requires the HepMC library.\n&quot;;
#endif
#ifndef PY8ROOT
  valid = valid &amp;&amp; !writeRoot;
  if (writeRoot)
    cout &lt;&lt; &quot;Option Main::writeRoot = on requires the ROOT library.\n&quot;;
#endif
  if (!valid) return 1;

  // HepMC initialization.
#ifdef HEPMC3
  // Initialize HepMC.
  Pythia8ToHepMC hepmc;
  if (writeHepmc) hepmc.setNewFile(out + &quot;.hepmc&quot;);
#endif

  // ROOT initialization.
#ifdef PY8ROOT
  // Create the ROOT TFile and TTree.
  TFile *file;
  TTree *tree;
  RootEvent *evt;
  if (writeRoot) {

    // Open the ROOT file.
    file = TFile::Open((out + &quot;.root&quot;).c_str(), &quot;recreate&quot; );
    tree = new TTree(&quot;t&quot;, &quot;Pythia8 event tree&quot;);
    evt  = new RootEvent();

    // Set the TTree branch to the ROOT event.
    tree-&gt;Branch(&quot;events&quot;, &amp;evt);
  }
#endif

  // Logfile initialization.
  ofstream logBuf;
  streambuf *oldCout;
  if (writeLog) {
    oldCout = cout.rdbuf(logBuf.rdbuf());
    logBuf.open(out + &quot;.log&quot;);
  }

  // Remove splash screen, if requested.
  ostream cnull(NULL);
  if (ip.get&lt;bool&gt;(&quot;l&quot;)) cnull &lt;&lt; splashBuf.str();
  else cout &lt;&lt; splashBuf.str();

  // If Pythia fails to initialize, exit with error.
  if (!pythia.init()) return 1;

  // Loop over events.
  auto startAllEvents = std::chrono::high_resolution_clock::now();
  for ( int iEvent = 0; iEvent &lt; nEvent; ++iEvent ) {
    auto startThisEvent = std::chrono::high_resolution_clock::now();

    // Exit if too many failures.
    if (!pythia.next()) {
      if (countErrors &amp;&amp; --nError &lt; 0) {
        pythia.stat();
        cout &lt;&lt; &quot; \n *-------  PYTHIA STOPPED!  -----------------------*\n&quot;
             &lt;&lt; &quot; | Event generation failed due to too many errors. |\n&quot;
             &lt;&lt; &quot; *-------------------------------------------------*\n&quot;;
        return 1;
      }
      continue;
    }

    // Calculate the event time.
    auto stopThisEvent = std::chrono::high_resolution_clock::now();
    auto eventTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;
      (stopThisEvent - startThisEvent);
    double tt = eventTime.count();

    // Write to HEPMC file output.
#ifdef HEPMC3
    if (writeHepmc) hepmc.writeNextEvent(pythia);
#endif

    // Write to ROOT file output.
#ifdef PY8ROOT
    if (writeRoot) {
      vector&lt;RootParticle&gt; prts;
      for (int iPrt = 0; iPrt &lt; pythia.event.size(); ++iPrt) {
        Particle&amp; prt = pythia.event[iPrt];

        // Any particle cuts can be placed here. Here, only final
        // state particles are kept.
        if (!prt.isFinal()) continue;

        // Push back the ROOT particle.
        prts.push_back(RootParticle(prt));
      }
      // Fill the ROOT event and tree.
      evt-&gt;fill(pythia.info, prts, tree);
    }
#endif
  }

  // Finalize.
  pythia.stat();
#ifdef PY8ROOT
  if (writeRoot) {
    tree-&gt;Print();
    tree-&gt;Write();
    delete file, tree, evt;
  }
#endif

  // Print timing.
  auto stopAllEvents = std::chrono::high_resolution_clock::now();
  auto durationAll = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;
    (stopAllEvents - startAllEvents);
  if (writeTime) {
    cout &lt;&lt; &quot; \n *-------  Generation time  -----------------------*\n&quot;
         &lt;&lt; &quot; | Event generation, analysis and writing to files  |\n&quot;
         &lt;&lt; &quot; | took: &quot; &lt;&lt; double(durationAll.count()) &lt;&lt; &quot; ms or &quot;
         &lt;&lt; double(durationAll.count())/double(nEvent)
         &lt;&lt; &quot; ms per event     |\n&quot;
         &lt;&lt; &quot; *-------------------------------------------------*\n&quot;;
  }

  // Put cout back in its place.
  if (writeLog) cout.rdbuf(oldCout);
  return 0;

}
</code></pre></body></html>