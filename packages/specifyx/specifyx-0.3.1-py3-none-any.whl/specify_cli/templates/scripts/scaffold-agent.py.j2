#!/usr/bin/env python3
"""
Generate agent output files from runtime templates.

Auto-discovers available agent types from .specify/agent-templates/ directory
and generates structured output files in .specify/agents/{agent-type}/ with
proper sequence numbering and project context integration.

Generated by SpecifyX init command for {{ ai_assistant }}.
"""

import importlib.resources
import json
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import typer
from rich.console import Console
from rich.table import Table

import specify_cli.templates as templates_pkg
from specify_cli.utils.script_helpers import (
    ScriptHelpers,
    echo_debug,
    echo_error,
    echo_info,
    echo_success,
)

app = typer.Typer(add_completion=False)
console = Console()

# Define typer arguments as module-level constants to avoid B008
AGENTS_ARGUMENT = typer.Argument(
    None, help="Agent specifications (agent-name or agent-name:description)"
)


@dataclass
class AgentType:
    """Type-safe agent type definition."""

    name: str
    description: str
    template_path: Path


@dataclass
class ScaffoldRequest:
    """Type-safe scaffold request."""

    agent_name: str
    description: Optional[str] = None
    args: Optional[Dict[str, Any]] = None


def discover_agent_types(helpers: ScriptHelpers) -> Tuple[bool, List[AgentType]]:
    """
    Auto-discover available agent types from project and package templates.

    Args:
        helpers: ScriptHelpers instance

    Returns:
        Tuple[bool, List[AgentType]]: (success, agent_types)
    """
    try:
        repo_root = helpers.get_repo_root()
        project_template_dir = repo_root / ".specify" / "agent-templates"

        agent_types: List[AgentType] = []

        # First, try to discover from project templates (copied during init)
        if project_template_dir.exists():
            for template_file in project_template_dir.glob("*.md.j2"):
                agent_name = template_file.name.replace(".md.j2", "")
                description = extract_description_from_template(template_file)

                agent_types.append(
                    AgentType(
                        name=agent_name,
                        description=description,
                        template_path=template_file,
                    )
                )

        # If no project templates found, fall back to package templates
        if not agent_types:
            try:
                # Direct access to package templates

                agent_templates_dir = (
                    importlib.resources.files(templates_pkg) / "agent-templates"
                )
                if agent_templates_dir.is_dir():
                    for template_file in agent_templates_dir.iterdir():
                        if template_file.is_file() and template_file.name.endswith(
                            ".md.j2"
                        ):
                            agent_name = template_file.name.replace(".md.j2", "")

                            # Try to read description from template
                            try:
                                content = template_file.read_text(encoding="utf-8")
                                description = "Agent template"
                                if content.startswith("---"):
                                    frontmatter_end = content.find("---", 3)
                                    if frontmatter_end > 0:
                                        frontmatter_text = content[3:frontmatter_end]
                                        for line in frontmatter_text.split("\n"):
                                            line = line.strip()
                                            if line.startswith("description:"):
                                                description = (
                                                    line.split(":", 1)[1]
                                                    .strip()
                                                    .strip("\"'")
                                                )
                                                break
                            except Exception:
                                description = "Agent template"

                            agent_types.append(
                                AgentType(
                                    name=agent_name,
                                    description=description,
                                    template_path=Path(str(template_file)),
                                )
                            )

            except Exception as e:
                echo_debug(f"Failed to discover from package templates: {str(e)}", True)

        return True, agent_types

    except Exception as e:
        echo_debug(f"Failed to discover agent types: {str(e)}", True)
        return False, []


def extract_description_from_template(template_path: Path) -> str:
    """Extract description from template frontmatter."""
    try:
        content = template_path.read_text(encoding="utf-8")
        if content.startswith("---"):
            frontmatter_end = content.find("---", 3)
            if frontmatter_end > 0:
                frontmatter_text = content[3:frontmatter_end]
                for line in frontmatter_text.split("\n"):
                    line = line.strip()
                    if line.startswith("description:"):
                        return line.split(":", 1)[1].strip().strip("\"'")
    except Exception:
        pass
    return "Agent template"


def get_next_sequence_number(agent_dir: Path, date_str: str) -> str:
    """
    Get next sequence number for agent output file.

    Args:
        agent_dir: Directory for the specific agent type
        date_str: Date string in YYYY-MM-DD format

    Returns:
        str: Next sequence number as zero-padded string (e.g., "001")
    """
    if not agent_dir.exists():
        return "001"

    existing_files = list(agent_dir.glob(f"{date_str}-*-*.md"))
    if not existing_files:
        return "001"

    max_seq = 0
    for file in existing_files:
        try:
            # Extract sequence from filename: {date}-{seq}-{description}.md
            # Date format is YYYY-MM-DD, so we need to split properly
            filename = file.stem
            # Remove the date prefix (YYYY-MM-DD-)
            if filename.startswith(date_str + "-"):
                remainder = filename[len(date_str) + 1 :]  # Remove date and first dash
                # Now split the remainder to get seq-description
                parts = remainder.split("-", 1)
                if len(parts) >= 1:
                    seq = int(parts[0])
                    max_seq = max(max_seq, seq)
        except ValueError:
            continue

    return f"{max_seq + 1:03d}"


def get_project_context(helpers: ScriptHelpers) -> Dict[str, Any]:
    """
    Get current project context for template rendering.

    Args:
        helpers: ScriptHelpers instance

    Returns:
        Dict[str, Any]: Project context dictionary
    """
    try:
        current_branch = helpers.get_current_branch()
        feature_name = (
            helpers.branch_to_directory_name(current_branch)
            if current_branch
            else "unknown"
        )

        # Try to get current feature directory for specs/plans/tasks
        feature_dir = None
        specs = {}
        plans = {}
        tasks = []

        if current_branch and helpers.is_feature_branch(current_branch):
            feature_dir = helpers.find_feature_directory(current_branch)

        if feature_dir and feature_dir.exists():
            # Load available documents
            spec_file = feature_dir / "spec.md"
            if spec_file.exists():
                specs = {
                    "spec_content": spec_file.read_text(encoding="utf-8")[:1000]
                }  # Preview

            plan_file = feature_dir / "plan.md"
            if plan_file.exists():
                plans = {
                    "plan_content": plan_file.read_text(encoding="utf-8")[:1000]
                }  # Preview

            tasks_file = feature_dir / "tasks.md"
            if tasks_file.exists():
                tasks_content = tasks_file.read_text(encoding="utf-8")
                # Extract task items (simple parsing)
                for line in tasks_content.split("\n"):
                    line = line.strip()
                    if line.startswith("- [ ]") or line.startswith("- [x]"):
                        tasks.append(line[5:].strip())

        return {
            "project_name": helpers.get_project_name(),
            "author_name": helpers.get_author_name(),
            "current_feature": feature_name,
            "branch_name": current_branch or "unknown",
            "timestamp": datetime.now().isoformat(),
            "creation_date": helpers.get_current_date(),
            "creation_year": helpers.get_current_date().split("-")[0],
            "specs": specs,
            "plans": plans,
            "tasks": tasks,
            "ai_assistant": "{{ ai_assistant }}",
        }

    except Exception:
        # Fallback context
        return {
            "project_name": "unknown",
            "author_name": "Unknown",
            "current_feature": "unknown",
            "branch_name": "unknown",
            "timestamp": datetime.now().isoformat(),
            "creation_date": datetime.now().strftime("%Y-%m-%d"),
            "creation_year": str(datetime.now().year),
            "specs": {},
            "plans": {},
            "tasks": [],
            "ai_assistant": "{{ ai_assistant }}",
        }


def scaffold_agent(
    helpers: ScriptHelpers, request: ScaffoldRequest, base_output_dir: Path
) -> Tuple[bool, str]:
    """
    Scaffold a specific agent with proper file naming and context.

    Args:
        helpers: ScriptHelpers instance
        request: Scaffold request with agent name and description
        base_output_dir: Base directory for agent outputs

    Returns:
        Tuple[bool, str]: (success, output_path or error_message)
    """
    try:
        repo_root = helpers.get_repo_root()
        # Ensure agent name has proper extension for template lookup
        agent_template_name = request.agent_name
        if not agent_template_name.endswith(".md.j2"):
            agent_template_name = f"{agent_template_name}.md.j2"

        template_path = repo_root / ".specify" / "agent-templates" / agent_template_name

        if not template_path.exists():
            # Try generic agent template as fallback
            generic_template = (
                repo_root / ".specify" / "agent-templates" / "generic-agent.md.j2"
            )
            if generic_template.exists():
                template_path = generic_template
            else:
                return False, f"Agent template not found: {template_path}"

        # Create agent-specific directory
        agent_dir = base_output_dir / request.agent_name
        agent_dir.mkdir(parents=True, exist_ok=True)

        # Generate filename: {date}-{seq}-{description}.md
        date_str = datetime.now().strftime("%Y-%m-%d")
        sequence = get_next_sequence_number(agent_dir, date_str)
        description = request.description or request.agent_name

        # Sanitize description for filename
        safe_description = "".join(
            c for c in description if c.isalnum() or c in ("-", "_")
        ).lower()
        safe_description = safe_description.replace(" ", "-")

        output_path = agent_dir / f"{date_str}-{sequence}-{safe_description}.md"

        # Prepare template context
        context = get_project_context(helpers)

        # Add agent-specific context
        context.update(
            {
                "agent_type": request.agent_name,
                "agent_description": description,
                "sequence_number": sequence,
                "output_filename": output_path.name,
            }
        )

        # Add any custom arguments
        if request.args:
            context.update(request.args)

        # Render the template
        success, error = helpers.render_template_standalone(
            template_path=template_path,
            context_dict=context,
            output_path=output_path,
        )

        if not success:
            return False, f"Failed to render template: {error}"

        return True, str(output_path.absolute())

    except Exception as e:
        return False, f"Failed to scaffold agent: {str(e)}"


def parse_agent_spec(agent_spec: str) -> ScaffoldRequest:
    """
    Parse agent specification in format 'agent-name' or 'agent-name:description'.

    Args:
        agent_spec: Agent specification string

    Returns:
        ScaffoldRequest: Parsed request object
    """
    if ":" in agent_spec:
        agent_name, description = agent_spec.split(":", 1)
        return ScaffoldRequest(
            agent_name=agent_name.strip(), description=description.strip()
        )
    else:
        return ScaffoldRequest(
            agent_name=agent_spec.strip(), description=agent_spec.strip()
        )


@app.command()
def scaffold(
    agents: List[str] = AGENTS_ARGUMENT,
    list_agents: bool = typer.Option(
        False, "--list", help="List available agent types"
    ),
    output_dir: str = typer.Option(
        ".specify/agents", "--output", help="Base output directory"
    ),
    args: Optional[str] = typer.Option(
        None, "--args", help="JSON string of additional template arguments"
    ),
    json_mode: bool = typer.Option(False, "--json", help="Output in JSON format"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show detailed output"),
    quiet: bool = typer.Option(
        False, "--quiet", "-q", help="Suppress informational messages"
    ),
    debug: bool = typer.Option(False, "--debug", help="Enable debug output"),
):
    """
    Generate agent output files from runtime templates.

    Auto-discovers available agent types and generates structured output files
    with proper sequence numbering and project context integration.

    Examples:
        # List available agents
        specifyx run scaffold-agent --list

        # Generate single agent output
        specifyx run scaffold-agent code-reviewer:auth-system-review

        # Generate multiple agent outputs
        specifyx run scaffold-agent code-reviewer:auth documentation-reviewer:readme

        # Use agent name as description
        specifyx run scaffold-agent code-reviewer

        # Generate with custom arguments
        specifyx run scaffold-agent code-reviewer --args '{"focus": "security"}'

    Note: If 'specifyx' is not found, try: uvx specifyx run scaffold-agent
    """
    # Validate argument combinations
    if quiet and verbose:
        echo_error("--quiet and --verbose are mutually exclusive")
        raise typer.Exit(1)

    try:
        helpers = ScriptHelpers()
        echo_debug("Starting agent scaffolding process", debug)

        # Discover available agent types
        echo_debug("Discovering agent types...", debug)
        success, agent_types = discover_agent_types(helpers)

        if not success:
            error_msg = "Failed to discover agent types"
            if json_mode:
                print(json.dumps({"error": error_msg}))
            else:
                echo_error(error_msg)
            raise typer.Exit(1)

        # Handle --list option
        if list_agents:
            if json_mode:
                agents_data = [
                    {"name": agent.name, "description": agent.description}
                    for agent in agent_types
                ]
                print(json.dumps({"agents": agents_data}, indent=2))
            else:
                if not agent_types:
                    echo_info(
                        "No agent templates found in .specify/agent-templates/", quiet
                    )
                    echo_info("Create agent templates to use this feature", quiet)
                else:
                    table = Table(title="Available Agents")
                    table.add_column("Name", style="cyan")
                    table.add_column("Description", style="white")

                    for agent in agent_types:
                        table.add_row(agent.name, agent.description)

                    console.print(table)
            return

        # Validate agents argument
        if not agents:
            error_msg = (
                "Specify agent(s) to scaffold or use --list to see available agents"
            )
            if json_mode:
                print(json.dumps({"error": error_msg}))
            else:
                echo_error(error_msg)
                echo_info(
                    "Example: specifyx run scaffold-agent code-reviewer:auth-review",
                    quiet,
                )
            raise typer.Exit(1)

        # Parse additional arguments
        additional_args: Optional[Dict[str, Any]] = None
        if args:
            try:
                additional_args = json.loads(args)
            except json.JSONDecodeError as e:
                error_msg = f"Invalid JSON in --args: {str(e)}"
                if json_mode:
                    print(json.dumps({"error": error_msg}))
                else:
                    echo_error(error_msg)
                raise typer.Exit(1) from e

        base_output_dir = Path(output_dir)
        results = []
        failed_agents = []

        # Generate for each requested agent
        echo_info(f"Scaffolding {len(agents)} agent(s)...", quiet)

        for agent_spec in agents:
            echo_debug(f"Processing agent spec: {agent_spec}", debug)
            request = parse_agent_spec(agent_spec)
            request.args = additional_args

            # Validate agent type exists
            available_names = [agent.name for agent in agent_types]
            if (
                request.agent_name not in available_names
                and not (
                    base_output_dir.parent
                    / ".specify"
                    / "agent-templates"
                    / "generic-agent.md.j2"
                ).exists()
            ):
                error_msg = f"Agent type '{request.agent_name}' not found. Available: {', '.join(available_names)}"
                failed_agents.append({"agent": agent_spec, "error": error_msg})
                if not json_mode:
                    echo_error(f"❌ {error_msg}")
                continue

            success, result = scaffold_agent(helpers, request, base_output_dir)

            if success:
                results.append(
                    {
                        "agent": agent_spec,
                        "output_path": result,
                        "agent_name": request.agent_name,
                        "description": request.description or request.agent_name,
                    }
                )
                if not json_mode:
                    rel_path = Path(result).relative_to(helpers.get_repo_root())
                    echo_success(f"Generated: {rel_path}", quiet)
            else:
                failed_agents.append({"agent": agent_spec, "error": result})
                if not json_mode:
                    echo_error(f"❌ Failed to generate {agent_spec}: {result}")

        # Output final results
        final_result = {
            "success": len(results) > 0,
            "generated": results,
            "failed": failed_agents,
            "output_directory": str(base_output_dir.absolute()),
            "total_requested": len(agents),
            "total_generated": len(results),
            "total_failed": len(failed_agents),
        }

        if json_mode:
            print(json.dumps(final_result, indent=2))
        else:
            if results:
                echo_success(
                    f"Successfully generated {len(results)} agent output(s)!", quiet
                )
                if verbose:
                    echo_info(
                        f"Output directory: {base_output_dir.relative_to(helpers.get_repo_root())}",
                        quiet,
                    )
                    for result in results:
                        rel_path = Path(result["output_path"]).relative_to(
                            helpers.get_repo_root()
                        )
                        echo_info(f"  {result['agent_name']}: {rel_path}", quiet)

            if failed_agents:
                echo_error(f"Failed to generate {len(failed_agents)} agent output(s)")
                if verbose:
                    for failed in failed_agents:
                        echo_error(f"  {failed['agent']}: {failed['error']}")

        echo_debug("Agent scaffolding completed", debug)

        # Exit with error code if any agents failed and no agents succeeded
        if failed_agents and not results:
            raise typer.Exit(1)

    except typer.Exit:
        raise
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        if json_mode:
            print(json.dumps({"error": error_msg}))
        else:
            echo_error(error_msg)
        echo_debug(f"Exception details: {type(e).__name__}: {e}", debug)
        raise typer.Exit(1) from None


if __name__ == "__main__":
    app()
