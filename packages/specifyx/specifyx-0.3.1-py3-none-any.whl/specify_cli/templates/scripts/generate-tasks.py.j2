#!/usr/bin/env python3
"""
Generate implementation tasks from design documents.

Scans available design documents and generates a tasks.md file with specific,
executable tasks for the current feature. This is the task breakdown phase
of the Spec-Driven Development lifecycle.

Generated by SpecifyX init command for {{ ai_assistant }}.
"""

import json
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import typer
from rich.console import Console

from specify_cli.utils.script_helpers import (
    ScriptHelpers,
    echo_debug,
    echo_error,
    echo_info,
    echo_success,
)

app = typer.Typer(add_completion=False)
console = Console()


def analyze_available_documents(
    helpers: ScriptHelpers, feature_dir: Path
) -> Tuple[bool, Dict[str, Any]]:
    """
    Analyze available design documents and extract information for task generation.

    Args:
        helpers: ScriptHelpers instance
        feature_dir: Path to the feature directory

    Returns:
        Tuple[bool, Dict]: (success, analysis_result)
    """
    _ = helpers

    analysis = {
        "available_docs": [],
        "entities": [],
        "contracts": [],
        "user_stories": [],
        "tech_stack": [],
        "test_scenarios": [],
    }

    try:
        # Check for plan.md (required)
        plan_file = feature_dir / "plan.md"
        if plan_file.exists() and plan_file.stat().st_size > 0:
            analysis["available_docs"].append("plan.md")
            # TODO: Parse plan.md for tech stack information

        # Check for data-model.md
        data_model_file = feature_dir / "data-model.md"
        if data_model_file.exists() and data_model_file.stat().st_size > 0:
            analysis["available_docs"].append("data-model.md")
            # TODO: Parse data-model.md for entities

        # Check for contracts directory
        contracts_dir = feature_dir / "contracts"
        if contracts_dir.exists() and contracts_dir.is_dir():
            contract_files = (
                list(contracts_dir.glob("*.json"))
                + list(contracts_dir.glob("*.yaml"))
                + list(contracts_dir.glob("*.yml"))
            )
            if contract_files:
                analysis["available_docs"].append("contracts/")
                analysis["contracts"] = [f.name for f in contract_files]

        # Check for research.md
        research_file = feature_dir / "research.md"
        if research_file.exists() and research_file.stat().st_size > 0:
            analysis["available_docs"].append("research.md")

        # Check for quickstart.md
        quickstart_file = feature_dir / "quickstart.md"
        if quickstart_file.exists() and quickstart_file.stat().st_size > 0:
            analysis["available_docs"].append("quickstart.md")
            # TODO: Parse quickstart.md for test scenarios

        return True, analysis

    except Exception as e:
        return False, {"error": f"Failed to analyze documents: {str(e)}"}


def generate_tasks_content(
    helpers: ScriptHelpers, feature_dir: Path, analysis: Dict, context: str = ""
) -> Tuple[bool, str]:
    """
    Generate tasks.md content using the template and document analysis.

    Args:
        helpers: ScriptHelpers instance
        feature_dir: Path to the feature directory
        analysis: Document analysis results
        context: Additional context from user

    Returns:
        Tuple[bool, str]: (success, generated_content)
    """
    try:
        # Find the tasks template
        repo_root = helpers.get_repo_root()
        template_path = repo_root / ".specify" / "templates" / "tasks-template.md.j2"

        if not template_path.exists():
            return False, f"Tasks template not found at {template_path}"

        # Prepare template context
        branch_name = helpers.get_current_branch()
        feature_name = (
            helpers.branch_to_directory_name(branch_name) if branch_name else "unknown"
        )

        template_context = {
            "project_name": helpers.get_project_name(),
            "author_name": helpers.get_author_name(),
            "creation_date": helpers.get_current_date(),
            "creation_year": helpers.get_current_date().split("-")[0],
            "feature_name": feature_name,
            "branch_name": branch_name or "unknown",
            "available_documents": analysis.get("available_docs", []),
            "entities": analysis.get("entities", []),
            "contracts": analysis.get("contracts", []),
            "user_stories": analysis.get("user_stories", []),
            "tech_stack": analysis.get("tech_stack", []),
            "test_scenarios": analysis.get("test_scenarios", []),
            "context": context,
            "ai_assistant": "{{ ai_assistant }}",
        }

        # Render the template
        tasks_file = feature_dir / "tasks.md"
        success, error = helpers.render_template_standalone(
            template_path=template_path,
            context_dict=template_context,
            output_path=tasks_file,
        )

        if not success:
            return False, f"Failed to render tasks template: {error}"

        # Read the generated content
        if tasks_file.exists():
            content = tasks_file.read_text(encoding="utf-8")
            return True, content
        else:
            return False, "Tasks file was not created"

    except Exception as e:
        return False, f"Failed to generate tasks: {str(e)}"


@app.command()
def generate(
    context: str = typer.Argument("", help="Additional context for task generation"),
    spec_id: Optional[str] = typer.Option(
        None,
        "--spec-id",
        help="Spec ID to work with (e.g., '001', '004') - required when using no-branch workflow and multiple specs exist",
    ),
    json_mode: bool = typer.Option(False, "--json", help="Output in JSON format"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show detailed output"),
    quiet: bool = typer.Option(
        False, "--quiet", "-q", help="Suppress informational messages"
    ),
    debug: bool = typer.Option(False, "--debug", help="Enable debug output"),
):
    """
    Generate implementation tasks from available design documents.

    Analyzes the current feature directory for design documents and generates
    a tasks.md file with specific, executable implementation tasks.

    Examples:
        # Traditional workflow (on feature branch)
        specifyx run generate-tasks
        specifyx run generate-tasks "Focus on API endpoints" --verbose

        # No-branch workflow (specify spec ID)
        specifyx run generate-tasks --spec-id 004
        specifyx run generate-tasks "Focus on API endpoints" --spec-id 004 --json

    Note: If 'specifyx' is not found, try: uvx specifyx run generate-tasks
    """
    # Validate argument combinations
    if quiet and verbose:
        echo_error("--quiet and --verbose are mutually exclusive")
        raise typer.Exit(1)

    try:
        helpers = ScriptHelpers()
        echo_debug("Starting task generation process", debug)

        # Get current branch and feature directory
        current_branch = helpers.get_current_branch()
        if not current_branch:
            error_msg = "No current branch detected. Ensure you're in a git repository."
            if json_mode:
                print(json.dumps({"error": error_msg}))
            else:
                echo_error(error_msg)
            raise typer.Exit(1)

        # spec_id is passed as parameter from the CLI
        feature_dir = None
        error_msg = None

        # If spec_id is provided, use it directly
        if spec_id:
            feature_dir = helpers.find_spec_by_id(spec_id)
            if not feature_dir:
                available_specs = helpers.list_available_specs()
                if available_specs:
                    spec_list = "\n".join(
                        [f"  {spec['id']} - {spec['name']}" for spec in available_specs]
                    )
                    error_msg = f"Spec ID '{spec_id}' not found.\n\nAvailable specs:\n{spec_list}"
                else:
                    error_msg = f"Spec ID '{spec_id}' not found. No specs available. Create one with: specifyx run create-feature 'feature name'"
        else:
            # Traditional workflow: try to detect from branch
            if helpers.is_feature_branch(current_branch):
                feature_dir = helpers.find_feature_directory(current_branch)
                if not feature_dir:
                    error_msg = (
                        f"Cannot find feature directory for branch: {current_branch}"
                    )
            else:
                # On main/non-feature branch without spec_id - show available specs
                available_specs = helpers.list_available_specs()
                if available_specs:
                    spec_list = "\n".join(
                        [
                            f"  specifyx run generate-tasks --spec-id {spec['id']}"
                            for spec in available_specs
                        ]
                    )
                    spec_names = "\n".join(
                        [f"  {spec['id']} - {spec['name']}" for spec in available_specs]
                    )
                    error_msg = f"Multiple specs available on {current_branch} branch. Specify which one to use:\n{spec_list}\n\nAvailable specs:\n{spec_names}"
                else:
                    error_msg = "No specs found. Create one with: specifyx run create-feature 'feature name'"

        if not feature_dir or error_msg:
            if json_mode:
                print(json.dumps({"error": error_msg or "Unknown error"}))
            else:
                echo_error(error_msg or "Unknown error")
                echo_info("Run 'specifyx run setup-plan setup' first", quiet)
            raise typer.Exit(1)

        echo_debug(f"Feature directory: {feature_dir}", debug)

        # Analyze available documents
        echo_info("Analyzing design documents...", quiet)
        success, analysis = analyze_available_documents(helpers, feature_dir)

        if not success:
            error_msg = analysis.get("error", "Failed to analyze documents")
            if json_mode:
                print(json.dumps({"error": error_msg}))
            else:
                echo_error(error_msg)
            raise typer.Exit(1)

        # Check if plan.md exists (required)
        if "plan.md" not in analysis.get("available_docs", []):
            error_msg = "Required plan.md not found. Run planning phase first."
            if json_mode:
                print(json.dumps({"error": error_msg}))
            else:
                final_error_msg = error_msg or "No feature directory found"
                echo_error(final_error_msg)
                echo_info("Use the /plan command in your AI assistant first", quiet)
            raise typer.Exit(1)

        echo_debug(f"Available documents: {analysis['available_docs']}", debug)

        # Generate tasks
        echo_info("Generating implementation tasks...", quiet)
        success, content = generate_tasks_content(
            helpers, feature_dir, analysis, context
        )

        if not success:
            error_msg = content  # content contains error message on failure
            if json_mode:
                print(json.dumps({"error": error_msg}))
            else:
                echo_error(error_msg)
            raise typer.Exit(1)

        # Output results
        tasks_file = feature_dir / "tasks.md"
        result = {
            "success": True,
            "tasks_file": str(tasks_file.absolute()),
            "feature_dir": str(feature_dir.absolute()),
            "branch": current_branch,
            "available_docs": analysis["available_docs"],
            "tasks_generated": True,
        }

        if json_mode:
            print(json.dumps(result, indent=2))
        else:
            echo_success("Tasks generated successfully!", quiet)
            echo_info(
                f"Tasks file: {tasks_file.relative_to(helpers.get_repo_root())}", quiet
            )
            if verbose:
                echo_info(
                    f"Available documents ({len(analysis['available_docs'])}):", quiet
                )
                for doc in analysis["available_docs"]:
                    echo_info(f"  ✓ {doc}", quiet)

        echo_debug("Task generation completed", debug)

    except typer.Exit:
        raise
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        if json_mode:
            print(json.dumps({"error": error_msg}))
        else:
            echo_error(error_msg)
        echo_debug(f"Exception details: {type(e).__name__}: {e}", debug)
        raise typer.Exit(1) from None


if __name__ == "__main__":
    app()
