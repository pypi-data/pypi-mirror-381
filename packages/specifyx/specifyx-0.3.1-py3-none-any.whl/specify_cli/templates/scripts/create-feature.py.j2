#!/usr/bin/env python3
"""
Create a new feature with branch, directory structure, and template.

This script automates the feature creation workflow by:
1. Generating the next sequential feature number (001, 002, etc.)
2. Creating a git branch with configurable naming patterns
3. Setting up the feature specification directory structure
4. Rendering initial spec template files using Jinja2

The script integrates with SpecifyX configuration for branch naming patterns
and validates feature descriptions according to project standards.

Generated by SpecifyX init command for {{ ai_assistant }}.
"""

import re
from typing import Dict, Optional, Tuple

import typer
from rich.console import Console

from specify_cli.utils.script_helpers import ScriptHelpers

app = typer.Typer(add_completion=False)
console = Console()


def create_feature(
    description: str,
    branch_name: Optional[str] = None,
    spec_id: Optional[str] = None,
    no_branch: bool = False,
) -> Tuple[bool, Dict[str, str]]:
    """
    Create new feature with branch and spec file.

    Args:
        description: Feature description (3-100 characters, descriptive text)
        branch_name: Optional custom branch name (validated against patterns)
        spec_id: Optional custom spec ID (e.g., "001", "042") - must be unique
        json_mode: Whether to format output as JSON
        no_branch: Whether to skip branch creation and work on current branch

    Returns:
        Tuple of (success: bool, result: Dict[str, str])
        On success: result contains BRANCH_NAME, SPEC_FILE, FEATURE_NUM, FEATURE_DIR
        On failure: result contains error message under "error" key

    Raises:
        No exceptions - all errors are captured and returned in result dict
    """
    # Initialize ScriptHelpers
    helpers = ScriptHelpers()

    # Validate feature description using ScriptHelpers
    description = description.strip()
    is_valid, error = helpers.validate_feature_description(description)
    if not is_valid:
        return False, {"error": error or "Invalid feature description"}

    # Check git repository status before proceeding
    if not helpers.check_git_repository():
        return False, {
            "error": "Git repository required: Current directory is not in a git repository"
        }

    repo_root = helpers.get_repo_root()
    specs_dir = repo_root / "specs"

    # Create specs directory if it doesn't exist
    try:
        specs_dir.mkdir(exist_ok=True)
    except PermissionError:
        return False, {
            "error": f"Permission denied: Cannot create specs directory at {specs_dir}"
        }
    except Exception as e:
        return False, {"error": f"Failed to create specs directory: {str(e)}"}

    # Handle spec ID - either provided or auto-generate
    if spec_id:
        # Validate custom spec ID format
        is_valid, error = helpers.validate_spec_id_format(spec_id)
        if not is_valid:
            return False, {"error": error or "Invalid spec ID format"}

        # Check if spec ID already exists
        exists, existing_path = helpers.check_spec_id_exists(spec_id, specs_dir)
        if exists:
            return False, {
                "error": f"Spec ID '{spec_id}' already exists at: {existing_path}"
            }

        feature_num = spec_id
    else:
        # Auto-generate next available feature number
        feature_num = helpers.get_next_feature_number(specs_dir)

    # Get branch naming configuration
    branch_config = helpers.get_branch_naming_config()
    patterns = branch_config.get(
        "patterns", [f"{feature_num}-{{ '{{' }}feature-name{{ '}}' }}"]
    )
    validation_rules = branch_config.get("validation_rules", [])

    if branch_name:
        # Custom branch name provided - try smart completion first
        completed_branch, completion_success, completion_error = (
            helpers.complete_branch_name(branch_name, patterns, spec_id)
        )

        if completion_success:
            final_branch_name = completed_branch

            # Check if branch already exists
            if helpers.check_branch_exists(final_branch_name):
                return False, {"error": f"Branch '{final_branch_name}' already exists"}
        else:
            return False, {
                "error": completion_error or "Failed to complete branch name"
            }
    else:
        # No custom branch name - derive from description and first pattern

        # Create clean feature name from description
        # Convert to lowercase and replace non-alphanumeric with hyphens
        clean_desc = re.sub(r"[^a-z0-9]", "-", description.lower())
        clean_desc = re.sub(r"-+", "-", clean_desc)  # Remove multiple hyphens
        clean_desc = clean_desc.strip("-")  # Remove leading/trailing hyphens

        # Extract first 2-3 meaningful words for feature name
        words = [w for w in clean_desc.split("-") if w and len(w) > 2][:3]
        derived_feature_name = "-".join(words) if words else "feature"

        # Use first pattern from configuration
        pattern = (
            patterns[0]
            if patterns
            else f"{feature_num}-{{ '{{' }}feature-name{{ '}}' }}"
        )

        # Build context for pattern expansion
        context = {
            "feature-num": feature_num,
            "feature_num": feature_num,
            "feature-name": derived_feature_name,
            "feature_name": derived_feature_name,
            "bug-id": feature_num,  # fallback for hotfix patterns
            "bug_id": feature_num,
            "version": feature_num,  # fallback for version patterns
        }

        # Use config service to generate and validate branch name
        config_service = helpers._config_service
        final_branch_name, is_valid, error_msg = config_service.generate_branch_name(
            pattern, context, validation_rules
        )

        if not is_valid:
            return False, {
                "error": f"Failed to generate valid branch name: {error_msg}. Pattern: '{pattern}', Context: {context}"
            }

    # Validate final branch name against validation rules
    config_service = helpers._config_service
    rules_valid, rules_error = config_service.validate_branch_name_against_rules(
        final_branch_name, validation_rules
    )
    if not rules_valid:
        return False, {
            "error": f"Branch name '{final_branch_name}' validation failed: {rules_error}"
        }

    try:
        # Check if using no-branch workflow
        branch_config = helpers.get_branch_naming_config()
        patterns = branch_config.get("patterns", [])
        is_no_branch = (
            no_branch or "current" in patterns or final_branch_name == "current"
        )

        # Create smart sequential directory name
        # For no-branch workflow, derive from description instead of branch name
        if is_no_branch:
            # Create clean feature name from description for directory naming
            clean_desc = re.sub(r"[^a-z0-9]", "-", description.lower())
            clean_desc = re.sub(r"-+", "-", clean_desc)  # Remove multiple hyphens
            clean_desc = clean_desc.strip("-")  # Remove leading/trailing hyphens

            # Extract first 2-3 meaningful words for feature name
            words = [w for w in clean_desc.split("-") if w and len(w) > 2][:3]
            derived_feature_name = "-".join(words) if words else "feature"

            dir_name = f"{feature_num}-{derived_feature_name}"
        else:
            # Traditional workflow: uses format: 001-feature-name with intelligent slash handling
            dir_name = helpers.branch_to_directory_name(final_branch_name, feature_num)

        feature_dir = specs_dir / dir_name

        if not is_no_branch:
            # Create and switch to new branch using git service from helpers
            git_service = helpers._git_service
            if not git_service.create_branch(final_branch_name, repo_root):
                return False, {
                    "error": f"Failed to create branch '{final_branch_name}'. Branch may already exist or git operation failed."
                }
        else:
            # No-branch workflow: stay on current branch
            git_service = helpers._git_service
            current_branch = git_service.get_current_branch(repo_root)
            final_branch_name = current_branch or "main"

        # Create feature directory
        try:
            feature_dir.mkdir(exist_ok=True)
        except PermissionError:
            return False, {
                "error": f"Permission denied: Cannot create feature directory at {feature_dir}"
            }

        # Render spec template using Jinja2
        template_path = repo_root / ".specify" / "templates" / "spec-template.md.j2"
        spec_file = feature_dir / "spec.md"

        try:
            if template_path.exists():
                # Use the standalone template rendering function
                template_context = {
                    "feature_name": description,
                    "branch_name": final_branch_name,
                    "feature_description": description,
                    "date": helpers.get_current_date(),
                    "project_name": helpers.get_project_name(),
                    "author_name": helpers.get_author_name(),
                }
                success, error = helpers.render_template_standalone(
                    template_path=template_path,
                    context_dict=template_context,
                    output_path=spec_file,
                    make_executable=False,
                )
                if not success:
                    return False, {"error": f"Failed to render template: {error}"}
            else:
                # Template missing - this is an error condition
                return False, {
                    "error": f"Required template not found: {template_path}. Run 'specifyx init' to regenerate templates."
                }
        except PermissionError:
            return False, {
                "error": f"Permission denied: Cannot create spec file at {spec_file}"
            }
        except Exception as e:
            return False, {"error": f"Failed to create spec file: {str(e)}"}

        # Provide information about which pattern was used
        pattern_used = patterns[0] if patterns and not branch_name else "custom"

        result = {
            "BRANCH_NAME": final_branch_name,
            "SPEC_FILE": str(spec_file.absolute()),
            "FEATURE_NUM": feature_num,
            "FEATURE_DIR": str(feature_dir.absolute()),
            "PATTERN_USED": pattern_used if not branch_name else "custom",
            "AVAILABLE_PATTERNS": patterns[:3],  # Show first 3 patterns for context
        }

        return True, result

    except Exception as e:
        return False, {"error": f"Unexpected error during feature creation: {str(e)}"}


@app.command()
def main(
    description: str = typer.Argument(
        ..., help="Feature description (3-100 characters, descriptive text)"
    ),
    branch_name: Optional[str] = typer.Option(
        None,
        "--branch-name",
        help="Custom branch name (validated against configured patterns)",
    ),
    spec_id: Optional[str] = typer.Option(
        None, "--spec-id", help="Custom spec ID (e.g., '001', '042') - must be unique"
    ),
    json_mode: bool = typer.Option(
        False, "--json", help="Output results in JSON format"
    ),
    no_branch: bool = typer.Option(
        False, "--no-branch", help="Skip branch creation and work on current branch"
    ),
):
    """Create a new feature with automated branch and spec file generation.

    Automates the feature creation workflow by generating sequential feature
    numbers, creating git branches with configurable naming patterns, setting
    up directory structure, and rendering initial spec template files.

    Branch names are derived from the first configured pattern unless --branch-name
    is specified. Custom branch names must match at least one configured pattern.

    Examples:
        specifyx run create-feature "User authentication system"
        specifyx run create-feature "Add password reset flow" --branch-name "xxx-auth-reset"
        specifyx run create-feature "Fix login bug" --branch-name "hotfix/bug-001" --spec-id "042"
        specifyx run create-feature "New feature" --spec-id "007" --json
        specifyx run create-feature "Quick bugfix" --no-branch --json

    Note: If 'specifyx' is not found, try: uvx specifyx run create-feature "Feature name"
    """
    helpers = ScriptHelpers()

    # Validate description
    description = description.strip()
    if not description:
        error_msg = "Feature description cannot be empty"
        helpers.output_result({"error": error_msg}, success=False, json_mode=json_mode)
        raise typer.Exit(1)

    # Validate feature description using ScriptHelpers
    is_valid, validation_error = helpers.validate_feature_description(description)
    if not is_valid:
        error_msg = f"{validation_error}"
        helpers.output_result({"error": error_msg}, success=False, json_mode=json_mode)
        if not json_mode:
            console.print(
                "Examples: 'User authentication system', 'Add password reset flow'",
                style="dim",
            )
        raise typer.Exit(1)

    # Create the feature
    success, result = create_feature(description, branch_name, spec_id, no_branch)

    if not success:
        helpers.output_result(result, success=False, json_mode=json_mode)
        if not json_mode:
            error = result.get("error", "Unknown error occurred")
            # Provide contextual help for common errors
            if "git" in error.lower():
                console.print(
                    "\nTip: Ensure you're in a git repository and have git installed",
                    style="dim",
                )
            elif "branch" in error.lower() or "pattern" in error.lower():
                console.print(
                    "Tip: Check if branch name conflicts with existing branches or doesn't match configured patterns",
                    style="dim",
                )

                # Show available patterns for reference
                helpers = ScriptHelpers()
                branch_config = helpers.get_branch_naming_config()
                patterns = branch_config.get("patterns", [])
                if patterns:
                    console.print(
                        f"Available patterns: {', '.join(patterns[:3])}", style="dim"
                    )
            elif "permission" in error.lower():
                console.print(
                    "Tip: Check file/directory permissions in the project", style="dim"
                )
            elif "validation" in error.lower():
                console.print(
                    "Tip: Branch name may contain invalid characters or violate naming rules",
                    style="dim",
                )
        raise typer.Exit(1)

    # Output successful results
    if json_mode:
        helpers.output_result(result, success=True, json_mode=json_mode)
    else:
        console.print("âœ“ Feature created successfully!", style="green bold")
        console.print()

        # Show important information first
        console.print(f"Branch Name: {result['BRANCH_NAME']}")
        console.print(f"Feature Num: {result['FEATURE_NUM']}")
        console.print(f"Spec File: {result['SPEC_FILE']}")
        console.print(f"Feature Dir: {result['FEATURE_DIR']}")

        # Show pattern information
        pattern_info = result.get("PATTERN_USED", "unknown")
        if pattern_info != "custom":
            console.print(f"Pattern Used: {pattern_info}", style="dim")
        else:
            console.print("Used custom branch name", style="dim")

        console.print()
        console.print("Next steps:", style="bold")
        console.print("1. Edit the spec file to define requirements")
        console.print("2. Use 'git add' and 'git commit' to save changes")
        console.print("3. Begin implementation in the new branch")


if __name__ == "__main__":
    app()
