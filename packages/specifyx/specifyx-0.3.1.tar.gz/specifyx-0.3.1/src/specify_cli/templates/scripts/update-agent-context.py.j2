#!/usr/bin/env python3
"""
Update AI assistant context file with new technical information from current plan.

This script reads the current implementation plan and updates the assistant's
context file with new technical stack information, preserving existing content
and manual additions between markers.

Generated by SpecifyX init command for {{ ai_assistant }}.
"""

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import typer
from rich.console import Console

from specify_cli.assistants import get_assistant
from specify_cli.services.config_service.config_service import TomlConfigService
from specify_cli.services.memory_service import MemoryManager
from specify_cli.utils.script_helpers import ScriptHelpers

app = typer.Typer(add_completion=False)
console = Console()


# Note: extract_spec_context is now provided by ScriptHelpers.extract_spec_context()
# This reduces code duplication and improves maintainability


def generate_custom_reminders(context_info: Dict[str, Any]) -> str:
    """
    Generate custom reminders based on project state.

    Users can edit this function to customize reminders for their workflow.
    """
    reminders = []

    # Task completion reminders
    if context_info.get("current_tasks"):
        reminders.append(
            "**Remember**: Mark tasks as done by changing `- [ ]` to `- [x]` in tasks.md"
        )

    # Phase-specific reminders
    current_phase = context_info.get("current_phase", "")
    if "Implementation" in current_phase:
        reminders.append(
            "**TDD Reminder**: Write tests first, ensure they fail, then implement (Red-Green-Refactor)"
        )

    if context_info.get("progress", {}).get("tasks"):
        progress = context_info["progress"]["tasks"]
        if progress and not progress.startswith("0/"):
            reminders.append(
                "**Progress Tip**: Update plan.md checkboxes as you complete implementation phases"
            )

    # File-specific reminders
    files = context_info.get("files", [])
    if "tasks.md" in files and "plan.md" in files:
        reminders.append(
            "**Workflow**: tasks.md contains specific todos, plan.md tracks overall phases"
        )

    return "\n".join(reminders) if reminders else ""


def update_context_file(
    context_file: Path, context_info: Dict[str, Any], assistant_type: str
) -> bool:
    """Update the assistant context file with comprehensive project context."""
    if not context_file.exists():
        console.print(f"[yellow]Context file not found: {context_file}[/yellow]")
        return False

    content = context_file.read_text()

    # Check if assistant supports imports
    try:
        assistant_provider = get_assistant(assistant_type)
        supports_imports = (
            assistant_provider.imports_supported if assistant_provider else False
        )
    except Exception:
        supports_imports = False

    # Use ScriptHelpers to build enhanced context sections
    helpers = ScriptHelpers()
    sections, _ = helpers.build_context_sections(context_info, supports_imports)

    # Generate custom reminders using the user-customizable function
    reminders = generate_custom_reminders(context_info)

    if not sections:
        console.print("[yellow]No project context found to add[/yellow]")
        return False

    # Build enhanced context section with reminders
    context_content = chr(10).join(sections)
    if reminders:
        context_content += f"\n\n{reminders}"

    new_context_section = f"""<!-- PROJECT_CONTEXT_START -->
## Current Project Context
{context_content}

*Auto-updated from spec files*
<!-- PROJECT_CONTEXT_END -->"""

    # Replace or add context section
    context_pattern = r"(<!-- PROJECT_CONTEXT_START -->.*?<!-- PROJECT_CONTEXT_END -->)"
    if re.search(context_pattern, content, re.DOTALL):
        updated_content = re.sub(
            context_pattern, new_context_section, content, flags=re.DOTALL
        )
    else:
        if content.strip().endswith("---"):
            updated_content = (
                content.rsplit("---", 1)[0].rstrip()
                + "\n\n"
                + new_context_section
                + "\n\n---"
            )
        else:
            updated_content = content.rstrip() + "\n\n" + new_context_section + "\n"

    context_file.write_text(updated_content)
    console.print(
        f"[green]Updated {context_file.name} with comprehensive project context[/green]"
    )
    return True


@app.command()
def main(
    assistant: Optional[str] = typer.Argument(
        None,
        help="AI assistant type (e.g., claude). If not provided, updates all assistants from config.",
    ),
    debug: bool = typer.Option(False, "--debug", help="Enable debug output"),
    json_output: bool = typer.Option(False, "--json", help="Output results as JSON"),
):
    """Update AI assistant context file(s) with technical information from current plan.

    If no assistant is specified, updates context for all enabled assistants in project config.
    """

    def echo_info(msg: str):
        if not json_output:
            console.print(f"[blue]ℹ[/blue] {msg}")

    def echo_error(msg: str):
        if not json_output:
            console.print(f"[red]✗[/red] {msg}")

    def echo_debug(msg: str, debug_mode: bool = False):
        if debug_mode and not json_output:
            console.print(f"[dim]DEBUG: {msg}[/dim]")

    try:
        # Find current feature directory and plan
        helpers = ScriptHelpers()

        # Find spec directory with any spec files
        cwd = Path.cwd()
        spec_dir = None

        # Check if we're in a spec directory
        if (cwd / "spec.md").exists() or (cwd / "plan.md").exists():
            spec_dir = cwd
        else:
            # Look for most recent spec directory
            spec_dirs = []
            for pattern in ["specs/*/", "features/*/", "*/specs/"]:
                spec_dirs.extend(cwd.glob(pattern))

            # Filter to directories with spec files and find most recent
            valid_dirs = []
            for d in spec_dirs:
                if any((d / f).exists() for f in ["spec.md", "plan.md", "tasks.md"]):
                    # Get the most recently modified spec file
                    spec_files = [
                        f
                        for f in [d / "spec.md", d / "plan.md", d / "tasks.md"]
                        if f.exists()
                    ]
                    if spec_files:
                        recent_time = max(f.stat().st_mtime for f in spec_files)
                        valid_dirs.append((d, recent_time))

            if valid_dirs:
                # Use most recently modified spec directory
                spec_dir = max(valid_dirs, key=lambda x: x[1])[0]

        if not spec_dir:
            if json_output:
                print(json.dumps({"error": "No spec directory found with spec files"}))
            else:
                echo_error("No spec directory found")
                echo_info(
                    "Run this from a spec directory or after running /specify, /clarify, /plan, /tasks, or /analyze commands"
                )
            raise typer.Exit(1) from None

        echo_debug(f"Found spec directory: {spec_dir}", debug)

        # Extract comprehensive context from spec files using ScriptHelpers
        helpers = ScriptHelpers()
        context_info = helpers.extract_spec_context(spec_dir)

        echo_debug(f"Extracted context info: {context_info}", debug)

        # Determine which assistants to update
        if assistant:
            # Specific assistant requested
            target_assistants: List[str] = [assistant]
            echo_info(f"Updating context for specific assistant: {assistant}")
        else:
            # Load project config to get all enabled assistants
            try:
                config_service = TomlConfigService()
                project_path = helpers.get_repo_root()
                project_config = config_service.load_project_config(project_path)

                if project_config and project_config.template_settings:
                    target_assistants = project_config.template_settings.ai_assistants
                else:
                    # Fallback to default (claude)
                    target_assistants = ["claude"]

                echo_info(
                    f"Updating context for all configured assistants: {', '.join(target_assistants)}"
                )
            except Exception as e:
                echo_error(
                    f"Failed to load project config: {e}. Falling back to claude."
                )
                target_assistants = ["claude"]

        # Track results for each assistant
        results = {}
        memory_updates = []

        for assistant_name in target_assistants:
            echo_debug(f"Processing assistant: {assistant_name}", debug)

            # Get context file path from assistant registry (no hardcoding!)
            try:
                assistant_provider = get_assistant(assistant_name)
                if not assistant_provider:
                    raise ValueError("Assistant not found")

                # Get the context file path from assistant config
                context_file_path = assistant_provider.config.context_file.file

                # Find context file (the config file path is relative to repo root)
                repo_root = helpers.get_repo_root()
                context_file = repo_root / context_file_path

            except Exception as e:
                error_msg = f"Failed to get context file for {assistant_name}: {e}"
                if json_output:
                    print(json.dumps({"error": error_msg}))
                else:
                    echo_error(error_msg)
                results[assistant_name] = {"success": False, "error": str(e)}
                continue

            echo_debug(f"Context file path for {assistant_name}: {context_file}", debug)

            # Update context file
            success = update_context_file(context_file, context_info, assistant_name)
            results[assistant_name] = {
                "success": success,
                "context_file": str(context_file),
            }

            # If context updated successfully, refresh memory imports
            memory_updated = False
            try:
                assistant_provider = get_assistant(assistant_name)
                supports_imports = (
                    assistant_provider.imports_supported
                    if assistant_provider
                    else False
                )
            except Exception:
                supports_imports = False

            if success and supports_imports:
                try:
                    echo_debug(
                        f"Refreshing memory service imports for {assistant_name}...",
                        debug,
                    )
                    memory_manager = MemoryManager(repo_root)

                    # Get available memory files and generate import section
                    import_section = memory_manager.generate_import_section(
                        ai_assistant=assistant_name,
                        context_file_dir=context_file.parent,
                    )

                    if import_section:
                        # Read current content and update the Project Memory section
                        current_content = context_file.read_text()

                        # Replace or add Project Memory section
                        memory_pattern = r"## Project Memory\n.*?(?=\n##|\n---|\Z)"
                        new_memory_section = f"## Project Memory\n{import_section}"

                        if re.search(memory_pattern, current_content, re.DOTALL):
                            updated_content = re.sub(
                                memory_pattern,
                                new_memory_section,
                                current_content,
                                flags=re.DOTALL,
                            )
                        else:
                            # Add before the final --- if it exists
                            if current_content.strip().endswith("---"):
                                updated_content = (
                                    current_content.rsplit("---", 1)[0].rstrip()
                                    + "\n\n"
                                    + new_memory_section
                                    + "\n\n---"
                                )
                            else:
                                updated_content = (
                                    current_content.rstrip()
                                    + "\n\n"
                                    + new_memory_section
                                    + "\n"
                                )

                        context_file.write_text(updated_content)
                        memory_updated = True
                        memory_updates.append(assistant_name)
                        echo_debug(
                            f"Memory imports refreshed successfully for {assistant_name}",
                            debug,
                        )
                    else:
                        echo_debug(
                            f"No memory files available for import for {assistant_name}",
                            debug,
                        )

                except Exception as e:
                    echo_debug(
                        f"Memory service error for {assistant_name} (non-fatal): {e}",
                        debug,
                    )

            if success:
                if memory_updated:
                    echo_info(
                        f"Successfully updated context for {assistant_name} ({context_file.name}) and refreshed memory imports"
                    )
                else:
                    echo_info(
                        f"Successfully updated context for {assistant_name} ({context_file.name}) from {spec_dir.name}"
                    )
            else:
                echo_error(f"Failed to update context for {assistant_name}")

        # Output results
        total_success = sum(1 for r in results.values() if r["success"])
        if json_output:
            result = {
                "success": total_success == len(target_assistants),
                "spec_dir": str(spec_dir),
                "target_assistants": target_assistants,
                "results": results,
                "memory_updated": len(memory_updates) > 0,
                "memory_assistants": memory_updates,
                "context_info": context_info,
            }
            print(json.dumps(result))
        elif total_success == len(target_assistants):
            if memory_updates:
                echo_info(
                    f"Successfully updated context for {total_success}/{len(target_assistants)} assistant(s) with project context and refreshed memory imports"
                )
            else:
                echo_info(
                    f"Successfully updated context for {total_success}/{len(target_assistants)} assistant(s) with project context from {spec_dir.name}"
                )
        else:
            echo_error(
                f"Failed to update context for {len(target_assistants) - total_success}/{len(target_assistants)} assistant(s)"
            )
            raise typer.Exit(1) from None

    except Exception as e:
        if json_output:
            print(json.dumps({"error": str(e)}))
        else:
            echo_error(f"Error updating agent context: {e}")
        raise typer.Exit(1) from None


if __name__ == "__main__":
    app()
