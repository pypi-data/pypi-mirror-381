diff --git a/vendor/lapack/dhseqr.c b/vendor/lapack/dhseqr.c
index 24af3013a..cb68e03d3 100644
--- a/vendor/lapack/dhseqr.c
+++ b/vendor/lapack/dhseqr.c
@@ -20,323 +20,323 @@ static integer c__12 = 12;
 static integer c__2 = 2;
 static integer c__49 = 49;
 
-/* > \brief \b DHSEQR   
+/* > \brief \b DHSEQR
 
-    =========== DOCUMENTATION ===========   
+    =========== DOCUMENTATION ===========
 
-   Online html documentation available at   
-              http://www.netlib.org/lapack/explore-html/   
+   Online html documentation available at
+              http://www.netlib.org/lapack/explore-html/
 
-   > \htmlonly   
-   > Download DHSEQR + dependencies   
+   > \htmlonly
+   > Download DHSEQR + dependencies
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dhseqr.
-f">   
-   > [TGZ]</a>   
+f">
+   > [TGZ]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dhseqr.
-f">   
-   > [ZIP]</a>   
+f">
+   > [ZIP]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dhseqr.
-f">   
-   > [TXT]</a>   
-   > \endhtmlonly   
-
-    Definition:   
-    ===========   
-
-         SUBROUTINE DHSEQR( JOB, COMPZ, N, ILO, IHI, H, LDH, WR, WI, Z,   
-                            LDZ, WORK, LWORK, INFO )   
-
-         INTEGER            IHI, ILO, INFO, LDH, LDZ, LWORK, N   
-         CHARACTER          COMPZ, JOB   
-         DOUBLE PRECISION   H( LDH, * ), WI( * ), WORK( * ), WR( * ),   
-        $                   Z( LDZ, * )   
-
-
-   > \par Purpose:   
-    =============   
-   >   
-   > \verbatim   
-   >   
-   >    DHSEQR computes the eigenvalues of a Hessenberg matrix H   
-   >    and, optionally, the matrices T and Z from the Schur decomposition   
-   >    H = Z T Z**T, where T is an upper quasi-triangular matrix (the   
-   >    Schur form), and Z is the orthogonal matrix of Schur vectors.   
-   >   
-   >    Optionally Z may be postmultiplied into an input orthogonal   
-   >    matrix Q so that this routine can give the Schur factorization   
-   >    of a matrix A which has been reduced to the Hessenberg form H   
-   >    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.   
-   > \endverbatim   
-
-    Arguments:   
-    ==========   
-
-   > \param[in] JOB   
-   > \verbatim   
-   >          JOB is CHARACTER*1   
-   >           = 'E':  compute eigenvalues only;   
-   >           = 'S':  compute eigenvalues and the Schur form T.   
-   > \endverbatim   
-   >   
-   > \param[in] COMPZ   
-   > \verbatim   
-   >          COMPZ is CHARACTER*1   
-   >           = 'N':  no Schur vectors are computed;   
-   >           = 'I':  Z is initialized to the unit matrix and the matrix Z   
-   >                   of Schur vectors of H is returned;   
-   >           = 'V':  Z must contain an orthogonal matrix Q on entry, and   
-   >                   the product Q*Z is returned.   
-   > \endverbatim   
-   >   
-   > \param[in] N   
-   > \verbatim   
-   >          N is INTEGER   
-   >           The order of the matrix H.  N .GE. 0.   
-   > \endverbatim   
-   >   
-   > \param[in] ILO   
-   > \verbatim   
-   >          ILO is INTEGER   
-   > \endverbatim   
-   >   
-   > \param[in] IHI   
-   > \verbatim   
-   >          IHI is INTEGER   
-   >   
-   >           It is assumed that H is already upper triangular in rows   
-   >           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally   
-   >           set by a previous call to DGEBAL, and then passed to ZGEHRD   
-   >           when the matrix output by DGEBAL is reduced to Hessenberg   
-   >           form. Otherwise ILO and IHI should be set to 1 and N   
-   >           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.   
-   >           If N = 0, then ILO = 1 and IHI = 0.   
-   > \endverbatim   
-   >   
-   > \param[in,out] H   
-   > \verbatim   
-   >          H is DOUBLE PRECISION array, dimension (LDH,N)   
-   >           On entry, the upper Hessenberg matrix H.   
-   >           On exit, if INFO = 0 and JOB = 'S', then H contains the   
-   >           upper quasi-triangular matrix T from the Schur decomposition   
-   >           (the Schur form); 2-by-2 diagonal blocks (corresponding to   
-   >           complex conjugate pairs of eigenvalues) are returned in   
-   >           standard form, with H(i,i) = H(i+1,i+1) and   
-   >           H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the   
-   >           contents of H are unspecified on exit.  (The output value of   
-   >           H when INFO.GT.0 is given under the description of INFO   
-   >           below.)   
-   >   
-   >           Unlike earlier versions of DHSEQR, this subroutine may   
-   >           explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1   
-   >           or j = IHI+1, IHI+2, ... N.   
-   > \endverbatim   
-   >   
-   > \param[in] LDH   
-   > \verbatim   
-   >          LDH is INTEGER   
-   >           The leading dimension of the array H. LDH .GE. max(1,N).   
-   > \endverbatim   
-   >   
-   > \param[out] WR   
-   > \verbatim   
-   >          WR is DOUBLE PRECISION array, dimension (N)   
-   > \endverbatim   
-   >   
-   > \param[out] WI   
-   > \verbatim   
-   >          WI is DOUBLE PRECISION array, dimension (N)   
-   >   
-   >           The real and imaginary parts, respectively, of the computed   
-   >           eigenvalues. If two eigenvalues are computed as a complex   
-   >           conjugate pair, they are stored in consecutive elements of   
-   >           WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and   
-   >           WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in   
-   >           the same order as on the diagonal of the Schur form returned   
-   >           in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2   
-   >           diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and   
-   >           WI(i+1) = -WI(i).   
-   > \endverbatim   
-   >   
-   > \param[in,out] Z   
-   > \verbatim   
-   >          Z is DOUBLE PRECISION array, dimension (LDZ,N)   
-   >           If COMPZ = 'N', Z is not referenced.   
-   >           If COMPZ = 'I', on entry Z need not be set and on exit,   
-   >           if INFO = 0, Z contains the orthogonal matrix Z of the Schur   
-   >           vectors of H.  If COMPZ = 'V', on entry Z must contain an   
-   >           N-by-N matrix Q, which is assumed to be equal to the unit   
-   >           matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,   
-   >           if INFO = 0, Z contains Q*Z.   
-   >           Normally Q is the orthogonal matrix generated by DORGHR   
-   >           after the call to DGEHRD which formed the Hessenberg matrix   
-   >           H. (The output value of Z when INFO.GT.0 is given under   
-   >           the description of INFO below.)   
-   > \endverbatim   
-   >   
-   > \param[in] LDZ   
-   > \verbatim   
-   >          LDZ is INTEGER   
-   >           The leading dimension of the array Z.  if COMPZ = 'I' or   
-   >           COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.   
-   > \endverbatim   
-   >   
-   > \param[out] WORK   
-   > \verbatim   
-   >          WORK is DOUBLE PRECISION array, dimension (LWORK)   
-   >           On exit, if INFO = 0, WORK(1) returns an estimate of   
-   >           the optimal value for LWORK.   
-   > \endverbatim   
-   >   
-   > \param[in] LWORK   
-   > \verbatim   
-   >          LWORK is INTEGER   
-   >           The dimension of the array WORK.  LWORK .GE. max(1,N)   
-   >           is sufficient and delivers very good and sometimes   
-   >           optimal performance.  However, LWORK as large as 11*N   
-   >           may be required for optimal performance.  A workspace   
-   >           query is recommended to determine the optimal workspace   
-   >           size.   
-   >   
-   >           If LWORK = -1, then DHSEQR does a workspace query.   
-   >           In this case, DHSEQR checks the input parameters and   
-   >           estimates the optimal workspace size for the given   
-   >           values of N, ILO and IHI.  The estimate is returned   
-   >           in WORK(1).  No error message related to LWORK is   
-   >           issued by XERBLA.  Neither H nor Z are accessed.   
-   > \endverbatim   
-   >   
-   > \param[out] INFO   
-   > \verbatim   
-   >          INFO is INTEGER   
-   >             =  0:  successful exit   
-   >           .LT. 0:  if INFO = -i, the i-th argument had an illegal   
-   >                    value   
-   >           .GT. 0:  if INFO = i, DHSEQR failed to compute all of   
-   >                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR   
-   >                and WI contain those eigenvalues which have been   
-   >                successfully computed.  (Failures are rare.)   
-   >   
-   >                If INFO .GT. 0 and JOB = 'E', then on exit, the   
-   >                remaining unconverged eigenvalues are the eigen-   
-   >                values of the upper Hessenberg matrix rows and   
-   >                columns ILO through INFO of the final, output   
-   >                value of H.   
-   >   
-   >                If INFO .GT. 0 and JOB   = 'S', then on exit   
-   >   
-   >           (*)  (initial value of H)*U  = U*(final value of H)   
-   >   
-   >                where U is an orthogonal matrix.  The final   
-   >                value of H is upper Hessenberg and quasi-triangular   
-   >                in rows and columns INFO+1 through IHI.   
-   >   
-   >                If INFO .GT. 0 and COMPZ = 'V', then on exit   
-   >   
-   >                  (final value of Z)  =  (initial value of Z)*U   
-   >   
-   >                where U is the orthogonal matrix in (*) (regard-   
-   >                less of the value of JOB.)   
-   >   
-   >                If INFO .GT. 0 and COMPZ = 'I', then on exit   
-   >                      (final value of Z)  = U   
-   >                where U is the orthogonal matrix in (*) (regard-   
-   >                less of the value of JOB.)   
-   >   
-   >                If INFO .GT. 0 and COMPZ = 'N', then Z is not   
-   >                accessed.   
-   > \endverbatim   
-
-    Authors:   
-    ========   
-
-   > \author Univ. of Tennessee   
-   > \author Univ. of California Berkeley   
-   > \author Univ. of Colorado Denver   
-   > \author NAG Ltd.   
-
-   > \date November 2011   
-
-   > \ingroup doubleOTHERcomputational   
-
-   > \par Contributors:   
-    ==================   
-   >   
-   >       Karen Braman and Ralph Byers, Department of Mathematics,   
-   >       University of Kansas, USA   
-
-   > \par Further Details:   
-    =====================   
-   >   
-   > \verbatim   
-   >   
-   >             Default values supplied by   
-   >             ILAENV(ISPEC,'DHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).   
-   >             It is suggested that these defaults be adjusted in order   
-   >             to attain best performance in each particular   
-   >             computational environment.   
-   >   
-   >            ISPEC=12: The DLAHQR vs DLAQR0 crossover point.   
-   >                      Default: 75. (Must be at least 11.)   
-   >   
-   >            ISPEC=13: Recommended deflation window size.   
-   >                      This depends on ILO, IHI and NS.  NS is the   
-   >                      number of simultaneous shifts returned   
-   >                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)   
-   >                      The default for (IHI-ILO+1).LE.500 is NS.   
-   >                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.   
-   >   
-   >            ISPEC=14: Nibble crossover point. (See IPARMQ for   
-   >                      details.)  Default: 14% of deflation window   
-   >                      size.   
-   >   
-   >            ISPEC=15: Number of simultaneous shifts in a multishift   
-   >                      QR iteration.   
-   >   
-   >                      If IHI-ILO+1 is ...   
-   >   
-   >                      greater than      ...but less    ... the   
-   >                      or equal to ...      than        default is   
-   >   
-   >                           1               30          NS =   2(+)   
-   >                          30               60          NS =   4(+)   
-   >                          60              150          NS =  10(+)   
-   >                         150              590          NS =  **   
-   >                         590             3000          NS =  64   
-   >                        3000             6000          NS = 128   
-   >                        6000             infinity      NS = 256   
-   >   
-   >                  (+)  By default some or all matrices of this order   
-   >                       are passed to the implicit double shift routine   
-   >                       DLAHQR and this parameter is ignored.  See   
-   >                       ISPEC=12 above and comments in IPARMQ for   
-   >                       details.   
-   >   
-   >                 (**)  The asterisks (**) indicate an ad-hoc   
-   >                       function of N increasing from 10 to 64.   
-   >   
-   >            ISPEC=16: Select structured matrix multiply.   
-   >                      If the number of simultaneous shifts (specified   
-   >                      by ISPEC=15) is less than 14, then the default   
-   >                      for ISPEC=16 is 0.  Otherwise the default for   
-   >                      ISPEC=16 is 2.   
-   > \endverbatim   
-
-   > \par References:   
-    ================   
-   >   
-   >       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR   
-   >       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3   
-   >       Performance, SIAM Journal of Matrix Analysis, volume 23, pages   
-   >       929--947, 2002.   
-   > \n   
-   >       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR   
-   >       Algorithm Part II: Aggressive Early Deflation, SIAM Journal   
-   >       of Matrix Analysis, volume 23, pages 948--973, 2002.   
-
-    =====================================================================   
+f">
+   > [TXT]</a>
+   > \endhtmlonly
+
+    Definition:
+    ===========
+
+         SUBROUTINE DHSEQR( JOB, COMPZ, N, ILO, IHI, H, LDH, WR, WI, Z,
+                            LDZ, WORK, LWORK, INFO )
+
+         INTEGER            IHI, ILO, INFO, LDH, LDZ, LWORK, N
+         CHARACTER          COMPZ, JOB
+         DOUBLE PRECISION   H( LDH, * ), WI( * ), WORK( * ), WR( * ),
+        $                   Z( LDZ, * )
+
+
+   > \par Purpose:
+    =============
+   >
+   > \verbatim
+   >
+   >    DHSEQR computes the eigenvalues of a Hessenberg matrix H
+   >    and, optionally, the matrices T and Z from the Schur decomposition
+   >    H = Z T Z**T, where T is an upper quasi-triangular matrix (the
+   >    Schur form), and Z is the orthogonal matrix of Schur vectors.
+   >
+   >    Optionally Z may be postmultiplied into an input orthogonal
+   >    matrix Q so that this routine can give the Schur factorization
+   >    of a matrix A which has been reduced to the Hessenberg form H
+   >    by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
+   > \endverbatim
+
+    Arguments:
+    ==========
+
+   > \param[in] JOB
+   > \verbatim
+   >          JOB is CHARACTER*1
+   >           = 'E':  compute eigenvalues only;
+   >           = 'S':  compute eigenvalues and the Schur form T.
+   > \endverbatim
+   >
+   > \param[in] COMPZ
+   > \verbatim
+   >          COMPZ is CHARACTER*1
+   >           = 'N':  no Schur vectors are computed;
+   >           = 'I':  Z is initialized to the unit matrix and the matrix Z
+   >                   of Schur vectors of H is returned;
+   >           = 'V':  Z must contain an orthogonal matrix Q on entry, and
+   >                   the product Q*Z is returned.
+   > \endverbatim
+   >
+   > \param[in] N
+   > \verbatim
+   >          N is INTEGER
+   >           The order of the matrix H.  N .GE. 0.
+   > \endverbatim
+   >
+   > \param[in] ILO
+   > \verbatim
+   >          ILO is INTEGER
+   > \endverbatim
+   >
+   > \param[in] IHI
+   > \verbatim
+   >          IHI is INTEGER
+   >
+   >           It is assumed that H is already upper triangular in rows
+   >           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
+   >           set by a previous call to DGEBAL, and then passed to ZGEHRD
+   >           when the matrix output by DGEBAL is reduced to Hessenberg
+   >           form. Otherwise ILO and IHI should be set to 1 and N
+   >           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
+   >           If N = 0, then ILO = 1 and IHI = 0.
+   > \endverbatim
+   >
+   > \param[in,out] H
+   > \verbatim
+   >          H is DOUBLE PRECISION array, dimension (LDH,N)
+   >           On entry, the upper Hessenberg matrix H.
+   >           On exit, if INFO = 0 and JOB = 'S', then H contains the
+   >           upper quasi-triangular matrix T from the Schur decomposition
+   >           (the Schur form); 2-by-2 diagonal blocks (corresponding to
+   >           complex conjugate pairs of eigenvalues) are returned in
+   >           standard form, with H(i,i) = H(i+1,i+1) and
+   >           H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the
+   >           contents of H are unspecified on exit.  (The output value of
+   >           H when INFO.GT.0 is given under the description of INFO
+   >           below.)
+   >
+   >           Unlike earlier versions of DHSEQR, this subroutine may
+   >           explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
+   >           or j = IHI+1, IHI+2, ... N.
+   > \endverbatim
+   >
+   > \param[in] LDH
+   > \verbatim
+   >          LDH is INTEGER
+   >           The leading dimension of the array H. LDH .GE. max(1,N).
+   > \endverbatim
+   >
+   > \param[out] WR
+   > \verbatim
+   >          WR is DOUBLE PRECISION array, dimension (N)
+   > \endverbatim
+   >
+   > \param[out] WI
+   > \verbatim
+   >          WI is DOUBLE PRECISION array, dimension (N)
+   >
+   >           The real and imaginary parts, respectively, of the computed
+   >           eigenvalues. If two eigenvalues are computed as a complex
+   >           conjugate pair, they are stored in consecutive elements of
+   >           WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and
+   >           WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in
+   >           the same order as on the diagonal of the Schur form returned
+   >           in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
+   >           diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
+   >           WI(i+1) = -WI(i).
+   > \endverbatim
+   >
+   > \param[in,out] Z
+   > \verbatim
+   >          Z is DOUBLE PRECISION array, dimension (LDZ,N)
+   >           If COMPZ = 'N', Z is not referenced.
+   >           If COMPZ = 'I', on entry Z need not be set and on exit,
+   >           if INFO = 0, Z contains the orthogonal matrix Z of the Schur
+   >           vectors of H.  If COMPZ = 'V', on entry Z must contain an
+   >           N-by-N matrix Q, which is assumed to be equal to the unit
+   >           matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
+   >           if INFO = 0, Z contains Q*Z.
+   >           Normally Q is the orthogonal matrix generated by DORGHR
+   >           after the call to DGEHRD which formed the Hessenberg matrix
+   >           H. (The output value of Z when INFO.GT.0 is given under
+   >           the description of INFO below.)
+   > \endverbatim
+   >
+   > \param[in] LDZ
+   > \verbatim
+   >          LDZ is INTEGER
+   >           The leading dimension of the array Z.  if COMPZ = 'I' or
+   >           COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
+   > \endverbatim
+   >
+   > \param[out] WORK
+   > \verbatim
+   >          WORK is DOUBLE PRECISION array, dimension (LWORK)
+   >           On exit, if INFO = 0, WORK(1) returns an estimate of
+   >           the optimal value for LWORK.
+   > \endverbatim
+   >
+   > \param[in] LWORK
+   > \verbatim
+   >          LWORK is INTEGER
+   >           The dimension of the array WORK.  LWORK .GE. max(1,N)
+   >           is sufficient and delivers very good and sometimes
+   >           optimal performance.  However, LWORK as large as 11*N
+   >           may be required for optimal performance.  A workspace
+   >           query is recommended to determine the optimal workspace
+   >           size.
+   >
+   >           If LWORK = -1, then DHSEQR does a workspace query.
+   >           In this case, DHSEQR checks the input parameters and
+   >           estimates the optimal workspace size for the given
+   >           values of N, ILO and IHI.  The estimate is returned
+   >           in WORK(1).  No error message related to LWORK is
+   >           issued by XERBLA.  Neither H nor Z are accessed.
+   > \endverbatim
+   >
+   > \param[out] INFO
+   > \verbatim
+   >          INFO is INTEGER
+   >             =  0:  successful exit
+   >           .LT. 0:  if INFO = -i, the i-th argument had an illegal
+   >                    value
+   >           .GT. 0:  if INFO = i, DHSEQR failed to compute all of
+   >                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
+   >                and WI contain those eigenvalues which have been
+   >                successfully computed.  (Failures are rare.)
+   >
+   >                If INFO .GT. 0 and JOB = 'E', then on exit, the
+   >                remaining unconverged eigenvalues are the eigen-
+   >                values of the upper Hessenberg matrix rows and
+   >                columns ILO through INFO of the final, output
+   >                value of H.
+   >
+   >                If INFO .GT. 0 and JOB   = 'S', then on exit
+   >
+   >           (*)  (initial value of H)*U  = U*(final value of H)
+   >
+   >                where U is an orthogonal matrix.  The final
+   >                value of H is upper Hessenberg and quasi-triangular
+   >                in rows and columns INFO+1 through IHI.
+   >
+   >                If INFO .GT. 0 and COMPZ = 'V', then on exit
+   >
+   >                  (final value of Z)  =  (initial value of Z)*U
+   >
+   >                where U is the orthogonal matrix in (*) (regard-
+   >                less of the value of JOB.)
+   >
+   >                If INFO .GT. 0 and COMPZ = 'I', then on exit
+   >                      (final value of Z)  = U
+   >                where U is the orthogonal matrix in (*) (regard-
+   >                less of the value of JOB.)
+   >
+   >                If INFO .GT. 0 and COMPZ = 'N', then Z is not
+   >                accessed.
+   > \endverbatim
+
+    Authors:
+    ========
+
+   > \author Univ. of Tennessee
+   > \author Univ. of California Berkeley
+   > \author Univ. of Colorado Denver
+   > \author NAG Ltd.
+
+   > \date November 2011
+
+   > \ingroup doubleOTHERcomputational
+
+   > \par Contributors:
+    ==================
+   >
+   >       Karen Braman and Ralph Byers, Department of Mathematics,
+   >       University of Kansas, USA
+
+   > \par Further Details:
+    =====================
+   >
+   > \verbatim
+   >
+   >             Default values supplied by
+   >             ILAENV(ISPEC,'DHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
+   >             It is suggested that these defaults be adjusted in order
+   >             to attain best performance in each particular
+   >             computational environment.
+   >
+   >            ISPEC=12: The DLAHQR vs DLAQR0 crossover point.
+   >                      Default: 75. (Must be at least 11.)
+   >
+   >            ISPEC=13: Recommended deflation window size.
+   >                      This depends on ILO, IHI and NS.  NS is the
+   >                      number of simultaneous shifts returned
+   >                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
+   >                      The default for (IHI-ILO+1).LE.500 is NS.
+   >                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.
+   >
+   >            ISPEC=14: Nibble crossover point. (See IPARMQ for
+   >                      details.)  Default: 14% of deflation window
+   >                      size.
+   >
+   >            ISPEC=15: Number of simultaneous shifts in a multishift
+   >                      QR iteration.
+   >
+   >                      If IHI-ILO+1 is ...
+   >
+   >                      greater than      ...but less    ... the
+   >                      or equal to ...      than        default is
+   >
+   >                           1               30          NS =   2(+)
+   >                          30               60          NS =   4(+)
+   >                          60              150          NS =  10(+)
+   >                         150              590          NS =  **
+   >                         590             3000          NS =  64
+   >                        3000             6000          NS = 128
+   >                        6000             infinity      NS = 256
+   >
+   >                  (+)  By default some or all matrices of this order
+   >                       are passed to the implicit double shift routine
+   >                       DLAHQR and this parameter is ignored.  See
+   >                       ISPEC=12 above and comments in IPARMQ for
+   >                       details.
+   >
+   >                 (**)  The asterisks (**) indicate an ad-hoc
+   >                       function of N increasing from 10 to 64.
+   >
+   >            ISPEC=16: Select structured matrix multiply.
+   >                      If the number of simultaneous shifts (specified
+   >                      by ISPEC=15) is less than 14, then the default
+   >                      for ISPEC=16 is 0.  Otherwise the default for
+   >                      ISPEC=16 is 2.
+   > \endverbatim
+
+   > \par References:
+    ================
+   >
+   >       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
+   >       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
+   >       Performance, SIAM Journal of Matrix Analysis, volume 23, pages
+   >       929--947, 2002.
+   > \n
+   >       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
+   >       Algorithm Part II: Aggressive Early Deflation, SIAM Journal
+   >       of Matrix Analysis, volume 23, pages 948--973, 2002.
+
+    =====================================================================
    Subroutine */ int igraphdhseqr_(char *job, char *compz, integer *n, integer *ilo,
-	 integer *ihi, doublereal *h__, integer *ldh, doublereal *wr, 
-	doublereal *wi, doublereal *z__, integer *ldz, doublereal *work, 
+	 integer *ihi, doublereal *h__, integer *ldh, doublereal *wr,
+	doublereal *wi, doublereal *z__, integer *ldz, doublereal *work,
 	integer *lwork, integer *info)
 {
     /* System generated locals */
@@ -345,8 +345,8 @@ f">
     doublereal d__1;
     char ch__1[2];
 
-    /* Builtin functions   
-       Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Builtin functions
+       Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -356,43 +356,43 @@ f">
     logical initz;
     doublereal workl[49];
     logical wantt, wantz;
-    extern /* Subroutine */ int igraphdlaqr0_(logical *, logical *, integer *, 
-	    integer *, integer *, doublereal *, integer *, doublereal *, 
-	    doublereal *, integer *, integer *, doublereal *, integer *, 
+    extern /* Subroutine */ int igraphdlaqr0_(logical *, logical *, integer *,
+	    integer *, integer *, doublereal *, integer *, doublereal *,
+	    doublereal *, integer *, integer *, doublereal *, integer *,
 	    doublereal *, integer *, integer *), igraphdlahqr_(logical *, logical *,
-	     integer *, integer *, integer *, doublereal *, integer *, 
-	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
-	    integer *, integer *), igraphdlacpy_(char *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *), 
-	    igraphdlaset_(char *, integer *, integer *, doublereal *, doublereal *, 
+	     integer *, integer *, integer *, doublereal *, integer *,
+	    doublereal *, doublereal *, integer *, integer *, doublereal *,
+	    integer *, integer *), igraphdlacpy_(char *, integer *, integer *,
+	    doublereal *, integer *, doublereal *, integer *),
+	    igraphdlaset_(char *, integer *, integer *, doublereal *, doublereal *,
 	    doublereal *, integer *);
-    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *, 
+    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *,
 	    integer *, integer *, ftnlen, ftnlen);
     extern /* Subroutine */ int igraphxerbla_(char *, integer *, ftnlen);
     logical lquery;
 
 
-/*  -- LAPACK computational routine (version 3.4.0) --   
-    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
-    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
-       November 2011   
+/*  -- LAPACK computational routine (version 3.4.0) --
+    -- LAPACK is a software package provided by Univ. of Tennessee,    --
+    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+       November 2011
 
 
-    =====================================================================   
+    =====================================================================
 
 
-       ==== Matrices of order NTINY or smaller must be processed by   
-       .    DLAHQR because of insufficient subdiagonal scratch space.   
-       .    (This is a hard limit.) ====   
+       ==== Matrices of order NTINY or smaller must be processed by
+       .    DLAHQR because of insufficient subdiagonal scratch space.
+       .    (This is a hard limit.) ====
 
-       ==== NL allocates some local workspace to help small matrices   
-       .    through a rare DLAHQR failure.  NL .GT. NTINY = 11 is   
-       .    required and NL .LE. NMIN = ILAENV(ISPEC=12,...) is recom-   
-       .    mended.  (The default value of NMIN is 75.)  Using NL = 49   
-       .    allows up to six simultaneous shifts and a 16-by-16   
-       .    deflation window.  ====   
+       ==== NL allocates some local workspace to help small matrices
+       .    through a rare DLAHQR failure.  NL .GT. NTINY = 11 is
+       .    required and NL .LE. NMIN = ILAENV(ISPEC=12,...) is recom-
+       .    mended.  (The default value of NMIN is 75.)  Using NL = 49
+       .    allows up to six simultaneous shifts and a 16-by-16
+       .    deflation window.  ====
 
-       ==== Decode and check the input parameters. ====   
+       ==== Decode and check the input parameters. ====
 
        Parameter adjustments */
     h_dim1 = *ldh;
@@ -451,8 +451,8 @@ f">
 
 	igraphdlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &wi[
 		1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, info);
-/*        ==== Ensure reported workspace size is backward-compatible with   
-          .    previous LAPACK versions. ====   
+/*        ==== Ensure reported workspace size is backward-compatible with
+          .    previous LAPACK versions. ====
    Computing MAX */
 	d__1 = (doublereal) max(1,*n);
 	work[1] = max(d__1,work[1]);
@@ -490,7 +490,7 @@ f">
 	    return 0;
 	}
 
-/*        ==== DLAHQR/DLAQR0 crossover point ====   
+/*        ==== DLAHQR/DLAQR0 crossover point ====
 
    Writing concatenation */
 	i__2[0] = 1, a__1[0] = job;
@@ -503,37 +503,37 @@ f">
 /*        ==== DLAQR0 for big matrices; DLAHQR for small ones ==== */
 
 	if (*n > nmin) {
-	    igraphdlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], 
-		    &wi[1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, 
+	    igraphdlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1],
+		    &wi[1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork,
 		    info);
 	} else {
 
 /*           ==== Small matrix ==== */
 
-	    igraphdlahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], 
+	    igraphdlahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1],
 		    &wi[1], ilo, ihi, &z__[z_offset], ldz, info);
 
 	    if (*info > 0) {
 
-/*              ==== A rare DLAHQR failure!  DLAQR0 sometimes succeeds   
+/*              ==== A rare DLAHQR failure!  DLAQR0 sometimes succeeds
                 .    when DLAHQR fails. ==== */
 
 		kbot = *info;
 
 		if (*n >= 49) {
 
-/*                 ==== Larger matrices have enough subdiagonal scratch   
+/*                 ==== Larger matrices have enough subdiagonal scratch
                    .    space to call DLAQR0 directly. ==== */
 
-		    igraphdlaqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset], 
-			    ldh, &wr[1], &wi[1], ilo, ihi, &z__[z_offset], 
+		    igraphdlaqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset],
+			    ldh, &wr[1], &wi[1], ilo, ihi, &z__[z_offset],
 			    ldz, &work[1], lwork, info);
 
 		} else {
 
-/*                 ==== Tiny matrices don't have enough subdiagonal   
-                   .    scratch space to benefit from DLAQR0.  Hence,   
-                   .    tiny matrices must be copied into a larger   
+/*                 ==== Tiny matrices don't have enough subdiagonal
+                   .    scratch space to benefit from DLAQR0.  Hence,
+                   .    tiny matrices must be copied into a larger
                    .    array before calling DLAQR0. ==== */
 
 		    igraphdlacpy_("A", n, n, &h__[h_offset], ldh, hl, &c__49);
@@ -542,7 +542,7 @@ f">
 		    igraphdlaset_("A", &c__49, &i__1, &c_b11, &c_b11, &hl[(*n + 1) *
 			     49 - 49], &c__49);
 		    igraphdlaqr0_(&wantt, &wantz, &c__49, ilo, &kbot, hl, &c__49, &
-			    wr[1], &wi[1], ilo, ihi, &z__[z_offset], ldz, 
+			    wr[1], &wi[1], ilo, ihi, &z__[z_offset], ldz,
 			    workl, &c__49, info);
 		    if (wantt || *info != 0) {
 			igraphdlacpy_("A", n, n, hl, &c__49, &h__[h_offset], ldh);
@@ -559,8 +559,8 @@ f">
 	    igraphdlaset_("L", &i__1, &i__3, &c_b11, &c_b11, &h__[h_dim1 + 3], ldh);
 	}
 
-/*        ==== Ensure reported workspace size is backward-compatible with   
-          .    previous LAPACK versions. ====   
+/*        ==== Ensure reported workspace size is backward-compatible with
+          .    previous LAPACK versions. ====
 
    Computing MAX */
 	d__1 = (doublereal) max(1,*n);
diff --git a/vendor/lapack/dnaup2.c b/vendor/lapack/dnaup2.c
index 85613a0fe..b6a099d5c 100644
--- a/vendor/lapack/dnaup2.c
+++ b/vendor/lapack/dnaup2.c
@@ -209,7 +209,7 @@ static integer c__2 = 2;
     /* Builtin functions */
     double pow_dd(doublereal *, doublereal *);
     integer s_cmp(char *, char *, ftnlen, ftnlen);
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     double sqrt(doublereal);
 
     /* Local variables */
diff --git a/vendor/lapack/dneupd.c b/vendor/lapack/dneupd.c
index 108381378..3a84fd4cf 100644
--- a/vendor/lapack/dneupd.c
+++ b/vendor/lapack/dneupd.c
@@ -337,7 +337,7 @@ static doublereal c_b64 = -1.;
     /* Builtin functions */
     double pow_dd(doublereal *, doublereal *);
     integer s_cmp(char *, char *, ftnlen, ftnlen);
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
 
     /* Local variables */
     integer j, k, ih, jj, np;
diff --git a/vendor/lapack/dormhr.c b/vendor/lapack/dormhr.c
index 71b68ae05..ddd5653bf 100644
--- a/vendor/lapack/dormhr.c
+++ b/vendor/lapack/dormhr.c
@@ -18,185 +18,185 @@ static integer c__1 = 1;
 static integer c_n1 = -1;
 static integer c__2 = 2;
 
-/* > \brief \b DORMHR   
+/* > \brief \b DORMHR
 
-    =========== DOCUMENTATION ===========   
+    =========== DOCUMENTATION ===========
 
-   Online html documentation available at   
-              http://www.netlib.org/lapack/explore-html/   
+   Online html documentation available at
+              http://www.netlib.org/lapack/explore-html/
 
-   > \htmlonly   
-   > Download DORMHR + dependencies   
+   > \htmlonly
+   > Download DORMHR + dependencies
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dormhr.
-f">   
-   > [TGZ]</a>   
+f">
+   > [TGZ]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dormhr.
-f">   
-   > [ZIP]</a>   
+f">
+   > [ZIP]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormhr.
-f">   
-   > [TXT]</a>   
-   > \endhtmlonly   
-
-    Definition:   
-    ===========   
-
-         SUBROUTINE DORMHR( SIDE, TRANS, M, N, ILO, IHI, A, LDA, TAU, C,   
-                            LDC, WORK, LWORK, INFO )   
-
-         CHARACTER          SIDE, TRANS   
-         INTEGER            IHI, ILO, INFO, LDA, LDC, LWORK, M, N   
-         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )   
-
-
-   > \par Purpose:   
-    =============   
-   >   
-   > \verbatim   
-   >   
-   > DORMHR overwrites the general real M-by-N matrix C with   
-   >   
-   >                 SIDE = 'L'     SIDE = 'R'   
-   > TRANS = 'N':      Q * C          C * Q   
-   > TRANS = 'T':      Q**T * C       C * Q**T   
-   >   
-   > where Q is a real orthogonal matrix of order nq, with nq = m if   
-   > SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of   
-   > IHI-ILO elementary reflectors, as returned by DGEHRD:   
-   >   
-   > Q = H(ilo) H(ilo+1) . . . H(ihi-1).   
-   > \endverbatim   
-
-    Arguments:   
-    ==========   
-
-   > \param[in] SIDE   
-   > \verbatim   
-   >          SIDE is CHARACTER*1   
-   >          = 'L': apply Q or Q**T from the Left;   
-   >          = 'R': apply Q or Q**T from the Right.   
-   > \endverbatim   
-   >   
-   > \param[in] TRANS   
-   > \verbatim   
-   >          TRANS is CHARACTER*1   
-   >          = 'N':  No transpose, apply Q;   
-   >          = 'T':  Transpose, apply Q**T.   
-   > \endverbatim   
-   >   
-   > \param[in] M   
-   > \verbatim   
-   >          M is INTEGER   
-   >          The number of rows of the matrix C. M >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] N   
-   > \verbatim   
-   >          N is INTEGER   
-   >          The number of columns of the matrix C. N >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] ILO   
-   > \verbatim   
-   >          ILO is INTEGER   
-   > \endverbatim   
-   >   
-   > \param[in] IHI   
-   > \verbatim   
-   >          IHI is INTEGER   
-   >   
-   >          ILO and IHI must have the same values as in the previous call   
-   >          of DGEHRD. Q is equal to the unit matrix except in the   
-   >          submatrix Q(ilo+1:ihi,ilo+1:ihi).   
-   >          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and   
-   >          ILO = 1 and IHI = 0, if M = 0;   
-   >          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and   
-   >          ILO = 1 and IHI = 0, if N = 0.   
-   > \endverbatim   
-   >   
-   > \param[in] A   
-   > \verbatim   
-   >          A is DOUBLE PRECISION array, dimension   
-   >                               (LDA,M) if SIDE = 'L'   
-   >                               (LDA,N) if SIDE = 'R'   
-   >          The vectors which define the elementary reflectors, as   
-   >          returned by DGEHRD.   
-   > \endverbatim   
-   >   
-   > \param[in] LDA   
-   > \verbatim   
-   >          LDA is INTEGER   
-   >          The leading dimension of the array A.   
-   >          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.   
-   > \endverbatim   
-   >   
-   > \param[in] TAU   
-   > \verbatim   
-   >          TAU is DOUBLE PRECISION array, dimension   
-   >                               (M-1) if SIDE = 'L'   
-   >                               (N-1) if SIDE = 'R'   
-   >          TAU(i) must contain the scalar factor of the elementary   
-   >          reflector H(i), as returned by DGEHRD.   
-   > \endverbatim   
-   >   
-   > \param[in,out] C   
-   > \verbatim   
-   >          C is DOUBLE PRECISION array, dimension (LDC,N)   
-   >          On entry, the M-by-N matrix C.   
-   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.   
-   > \endverbatim   
-   >   
-   > \param[in] LDC   
-   > \verbatim   
-   >          LDC is INTEGER   
-   >          The leading dimension of the array C. LDC >= max(1,M).   
-   > \endverbatim   
-   >   
-   > \param[out] WORK   
-   > \verbatim   
-   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))   
-   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.   
-   > \endverbatim   
-   >   
-   > \param[in] LWORK   
-   > \verbatim   
-   >          LWORK is INTEGER   
-   >          The dimension of the array WORK.   
-   >          If SIDE = 'L', LWORK >= max(1,N);   
-   >          if SIDE = 'R', LWORK >= max(1,M).   
-   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and   
-   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal   
-   >          blocksize.   
-   >   
-   >          If LWORK = -1, then a workspace query is assumed; the routine   
-   >          only calculates the optimal size of the WORK array, returns   
-   >          this value as the first entry of the WORK array, and no error   
-   >          message related to LWORK is issued by XERBLA.   
-   > \endverbatim   
-   >   
-   > \param[out] INFO   
-   > \verbatim   
-   >          INFO is INTEGER   
-   >          = 0:  successful exit   
-   >          < 0:  if INFO = -i, the i-th argument had an illegal value   
-   > \endverbatim   
-
-    Authors:   
-    ========   
-
-   > \author Univ. of Tennessee   
-   > \author Univ. of California Berkeley   
-   > \author Univ. of Colorado Denver   
-   > \author NAG Ltd.   
-
-   > \date November 2011   
-
-   > \ingroup doubleOTHERcomputational   
-
-    =====================================================================   
-   Subroutine */ int igraphdormhr_(char *side, char *trans, integer *m, integer *n, 
+f">
+   > [TXT]</a>
+   > \endhtmlonly
+
+    Definition:
+    ===========
+
+         SUBROUTINE DORMHR( SIDE, TRANS, M, N, ILO, IHI, A, LDA, TAU, C,
+                            LDC, WORK, LWORK, INFO )
+
+         CHARACTER          SIDE, TRANS
+         INTEGER            IHI, ILO, INFO, LDA, LDC, LWORK, M, N
+         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+
+
+   > \par Purpose:
+    =============
+   >
+   > \verbatim
+   >
+   > DORMHR overwrites the general real M-by-N matrix C with
+   >
+   >                 SIDE = 'L'     SIDE = 'R'
+   > TRANS = 'N':      Q * C          C * Q
+   > TRANS = 'T':      Q**T * C       C * Q**T
+   >
+   > where Q is a real orthogonal matrix of order nq, with nq = m if
+   > SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
+   > IHI-ILO elementary reflectors, as returned by DGEHRD:
+   >
+   > Q = H(ilo) H(ilo+1) . . . H(ihi-1).
+   > \endverbatim
+
+    Arguments:
+    ==========
+
+   > \param[in] SIDE
+   > \verbatim
+   >          SIDE is CHARACTER*1
+   >          = 'L': apply Q or Q**T from the Left;
+   >          = 'R': apply Q or Q**T from the Right.
+   > \endverbatim
+   >
+   > \param[in] TRANS
+   > \verbatim
+   >          TRANS is CHARACTER*1
+   >          = 'N':  No transpose, apply Q;
+   >          = 'T':  Transpose, apply Q**T.
+   > \endverbatim
+   >
+   > \param[in] M
+   > \verbatim
+   >          M is INTEGER
+   >          The number of rows of the matrix C. M >= 0.
+   > \endverbatim
+   >
+   > \param[in] N
+   > \verbatim
+   >          N is INTEGER
+   >          The number of columns of the matrix C. N >= 0.
+   > \endverbatim
+   >
+   > \param[in] ILO
+   > \verbatim
+   >          ILO is INTEGER
+   > \endverbatim
+   >
+   > \param[in] IHI
+   > \verbatim
+   >          IHI is INTEGER
+   >
+   >          ILO and IHI must have the same values as in the previous call
+   >          of DGEHRD. Q is equal to the unit matrix except in the
+   >          submatrix Q(ilo+1:ihi,ilo+1:ihi).
+   >          If SIDE = 'L', then 1 <= ILO <= IHI <= M, if M > 0, and
+   >          ILO = 1 and IHI = 0, if M = 0;
+   >          if SIDE = 'R', then 1 <= ILO <= IHI <= N, if N > 0, and
+   >          ILO = 1 and IHI = 0, if N = 0.
+   > \endverbatim
+   >
+   > \param[in] A
+   > \verbatim
+   >          A is DOUBLE PRECISION array, dimension
+   >                               (LDA,M) if SIDE = 'L'
+   >                               (LDA,N) if SIDE = 'R'
+   >          The vectors which define the elementary reflectors, as
+   >          returned by DGEHRD.
+   > \endverbatim
+   >
+   > \param[in] LDA
+   > \verbatim
+   >          LDA is INTEGER
+   >          The leading dimension of the array A.
+   >          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
+   > \endverbatim
+   >
+   > \param[in] TAU
+   > \verbatim
+   >          TAU is DOUBLE PRECISION array, dimension
+   >                               (M-1) if SIDE = 'L'
+   >                               (N-1) if SIDE = 'R'
+   >          TAU(i) must contain the scalar factor of the elementary
+   >          reflector H(i), as returned by DGEHRD.
+   > \endverbatim
+   >
+   > \param[in,out] C
+   > \verbatim
+   >          C is DOUBLE PRECISION array, dimension (LDC,N)
+   >          On entry, the M-by-N matrix C.
+   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+   > \endverbatim
+   >
+   > \param[in] LDC
+   > \verbatim
+   >          LDC is INTEGER
+   >          The leading dimension of the array C. LDC >= max(1,M).
+   > \endverbatim
+   >
+   > \param[out] WORK
+   > \verbatim
+   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
+   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+   > \endverbatim
+   >
+   > \param[in] LWORK
+   > \verbatim
+   >          LWORK is INTEGER
+   >          The dimension of the array WORK.
+   >          If SIDE = 'L', LWORK >= max(1,N);
+   >          if SIDE = 'R', LWORK >= max(1,M).
+   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and
+   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
+   >          blocksize.
+   >
+   >          If LWORK = -1, then a workspace query is assumed; the routine
+   >          only calculates the optimal size of the WORK array, returns
+   >          this value as the first entry of the WORK array, and no error
+   >          message related to LWORK is issued by XERBLA.
+   > \endverbatim
+   >
+   > \param[out] INFO
+   > \verbatim
+   >          INFO is INTEGER
+   >          = 0:  successful exit
+   >          < 0:  if INFO = -i, the i-th argument had an illegal value
+   > \endverbatim
+
+    Authors:
+    ========
+
+   > \author Univ. of Tennessee
+   > \author Univ. of California Berkeley
+   > \author Univ. of Colorado Denver
+   > \author NAG Ltd.
+
+   > \date November 2011
+
+   > \ingroup doubleOTHERcomputational
+
+    =====================================================================
+   Subroutine */ int igraphdormhr_(char *side, char *trans, integer *m, integer *n,
 	integer *ilo, integer *ihi, doublereal *a, integer *lda, doublereal *
-	tau, doublereal *c__, integer *ldc, doublereal *work, integer *lwork, 
+	tau, doublereal *c__, integer *ldc, doublereal *work, integer *lwork,
 	integer *info)
 {
     /* System generated locals */
@@ -204,8 +204,8 @@ f">
     integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2;
     char ch__1[2];
 
-    /* Builtin functions   
-       Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Builtin functions
+       Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, nh, ni, nq, nw;
@@ -213,25 +213,25 @@ f">
     extern logical igraphlsame_(char *, char *);
     integer iinfo;
     extern /* Subroutine */ int igraphxerbla_(char *, integer *, ftnlen);
-    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *, 
+    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *,
 	    integer *, integer *, ftnlen, ftnlen);
-    extern /* Subroutine */ int igraphdormqr_(char *, char *, integer *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
+    extern /* Subroutine */ int igraphdormqr_(char *, char *, integer *, integer *,
+	    integer *, doublereal *, integer *, doublereal *, doublereal *,
 	    integer *, doublereal *, integer *, integer *);
     integer lwkopt;
     logical lquery;
 
 
-/*  -- LAPACK computational routine (version 3.4.0) --   
-    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
-    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
-       November 2011   
+/*  -- LAPACK computational routine (version 3.4.0) --
+    -- LAPACK is a software package provided by Univ. of Tennessee,    --
+    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+       November 2011
 
 
-    =====================================================================   
+    =====================================================================
 
 
-       Test the input arguments   
+       Test the input arguments
 
        Parameter adjustments */
     a_dim1 = *lda;
@@ -260,7 +260,7 @@ f">
     }
     if (! left && ! igraphlsame_(side, "R")) {
 	*info = -1;
-    } else if (! igraphlsame_(trans, "N") && ! igraphlsame_(trans, 
+    } else if (! igraphlsame_(trans, "N") && ! igraphlsame_(trans,
 	    "T")) {
 	*info = -2;
     } else if (*m < 0) {
diff --git a/vendor/lapack/dormql.c b/vendor/lapack/dormql.c
index 555ee521e..f58eab542 100644
--- a/vendor/lapack/dormql.c
+++ b/vendor/lapack/dormql.c
@@ -19,185 +19,185 @@ static integer c_n1 = -1;
 static integer c__2 = 2;
 static integer c__65 = 65;
 
-/* > \brief \b DORMQL   
+/* > \brief \b DORMQL
 
-    =========== DOCUMENTATION ===========   
+    =========== DOCUMENTATION ===========
 
-   Online html documentation available at   
-              http://www.netlib.org/lapack/explore-html/   
+   Online html documentation available at
+              http://www.netlib.org/lapack/explore-html/
 
-   > \htmlonly   
-   > Download DORMQL + dependencies   
+   > \htmlonly
+   > Download DORMQL + dependencies
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dormql.
-f">   
-   > [TGZ]</a>   
+f">
+   > [TGZ]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dormql.
-f">   
-   > [ZIP]</a>   
+f">
+   > [ZIP]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormql.
-f">   
-   > [TXT]</a>   
-   > \endhtmlonly   
-
-    Definition:   
-    ===========   
-
-         SUBROUTINE DORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
-                            WORK, LWORK, INFO )   
-
-         CHARACTER          SIDE, TRANS   
-         INTEGER            INFO, K, LDA, LDC, LWORK, M, N   
-         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )   
-
-
-   > \par Purpose:   
-    =============   
-   >   
-   > \verbatim   
-   >   
-   > DORMQL overwrites the general real M-by-N matrix C with   
-   >   
-   >                 SIDE = 'L'     SIDE = 'R'   
-   > TRANS = 'N':      Q * C          C * Q   
-   > TRANS = 'T':      Q**T * C       C * Q**T   
-   >   
-   > where Q is a real orthogonal matrix defined as the product of k   
-   > elementary reflectors   
-   >   
-   >       Q = H(k) . . . H(2) H(1)   
-   >   
-   > as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N   
-   > if SIDE = 'R'.   
-   > \endverbatim   
-
-    Arguments:   
-    ==========   
-
-   > \param[in] SIDE   
-   > \verbatim   
-   >          SIDE is CHARACTER*1   
-   >          = 'L': apply Q or Q**T from the Left;   
-   >          = 'R': apply Q or Q**T from the Right.   
-   > \endverbatim   
-   >   
-   > \param[in] TRANS   
-   > \verbatim   
-   >          TRANS is CHARACTER*1   
-   >          = 'N':  No transpose, apply Q;   
-   >          = 'T':  Transpose, apply Q**T.   
-   > \endverbatim   
-   >   
-   > \param[in] M   
-   > \verbatim   
-   >          M is INTEGER   
-   >          The number of rows of the matrix C. M >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] N   
-   > \verbatim   
-   >          N is INTEGER   
-   >          The number of columns of the matrix C. N >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] K   
-   > \verbatim   
-   >          K is INTEGER   
-   >          The number of elementary reflectors whose product defines   
-   >          the matrix Q.   
-   >          If SIDE = 'L', M >= K >= 0;   
-   >          if SIDE = 'R', N >= K >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] A   
-   > \verbatim   
-   >          A is DOUBLE PRECISION array, dimension (LDA,K)   
-   >          The i-th column must contain the vector which defines the   
-   >          elementary reflector H(i), for i = 1,2,...,k, as returned by   
-   >          DGEQLF in the last k columns of its array argument A.   
-   > \endverbatim   
-   >   
-   > \param[in] LDA   
-   > \verbatim   
-   >          LDA is INTEGER   
-   >          The leading dimension of the array A.   
-   >          If SIDE = 'L', LDA >= max(1,M);   
-   >          if SIDE = 'R', LDA >= max(1,N).   
-   > \endverbatim   
-   >   
-   > \param[in] TAU   
-   > \verbatim   
-   >          TAU is DOUBLE PRECISION array, dimension (K)   
-   >          TAU(i) must contain the scalar factor of the elementary   
-   >          reflector H(i), as returned by DGEQLF.   
-   > \endverbatim   
-   >   
-   > \param[in,out] C   
-   > \verbatim   
-   >          C is DOUBLE PRECISION array, dimension (LDC,N)   
-   >          On entry, the M-by-N matrix C.   
-   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.   
-   > \endverbatim   
-   >   
-   > \param[in] LDC   
-   > \verbatim   
-   >          LDC is INTEGER   
-   >          The leading dimension of the array C. LDC >= max(1,M).   
-   > \endverbatim   
-   >   
-   > \param[out] WORK   
-   > \verbatim   
-   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))   
-   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.   
-   > \endverbatim   
-   >   
-   > \param[in] LWORK   
-   > \verbatim   
-   >          LWORK is INTEGER   
-   >          The dimension of the array WORK.   
-   >          If SIDE = 'L', LWORK >= max(1,N);   
-   >          if SIDE = 'R', LWORK >= max(1,M).   
-   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and   
-   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal   
-   >          blocksize.   
-   >   
-   >          If LWORK = -1, then a workspace query is assumed; the routine   
-   >          only calculates the optimal size of the WORK array, returns   
-   >          this value as the first entry of the WORK array, and no error   
-   >          message related to LWORK is issued by XERBLA.   
-   > \endverbatim   
-   >   
-   > \param[out] INFO   
-   > \verbatim   
-   >          INFO is INTEGER   
-   >          = 0:  successful exit   
-   >          < 0:  if INFO = -i, the i-th argument had an illegal value   
-   > \endverbatim   
-
-    Authors:   
-    ========   
-
-   > \author Univ. of Tennessee   
-   > \author Univ. of California Berkeley   
-   > \author Univ. of Colorado Denver   
-   > \author NAG Ltd.   
-
-   > \date November 2011   
-
-   > \ingroup doubleOTHERcomputational   
-
-    =====================================================================   
-   Subroutine */ int igraphdormql_(char *side, char *trans, integer *m, integer *n, 
+f">
+   > [TXT]</a>
+   > \endhtmlonly
+
+    Definition:
+    ===========
+
+         SUBROUTINE DORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+                            WORK, LWORK, INFO )
+
+         CHARACTER          SIDE, TRANS
+         INTEGER            INFO, K, LDA, LDC, LWORK, M, N
+         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+
+
+   > \par Purpose:
+    =============
+   >
+   > \verbatim
+   >
+   > DORMQL overwrites the general real M-by-N matrix C with
+   >
+   >                 SIDE = 'L'     SIDE = 'R'
+   > TRANS = 'N':      Q * C          C * Q
+   > TRANS = 'T':      Q**T * C       C * Q**T
+   >
+   > where Q is a real orthogonal matrix defined as the product of k
+   > elementary reflectors
+   >
+   >       Q = H(k) . . . H(2) H(1)
+   >
+   > as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
+   > if SIDE = 'R'.
+   > \endverbatim
+
+    Arguments:
+    ==========
+
+   > \param[in] SIDE
+   > \verbatim
+   >          SIDE is CHARACTER*1
+   >          = 'L': apply Q or Q**T from the Left;
+   >          = 'R': apply Q or Q**T from the Right.
+   > \endverbatim
+   >
+   > \param[in] TRANS
+   > \verbatim
+   >          TRANS is CHARACTER*1
+   >          = 'N':  No transpose, apply Q;
+   >          = 'T':  Transpose, apply Q**T.
+   > \endverbatim
+   >
+   > \param[in] M
+   > \verbatim
+   >          M is INTEGER
+   >          The number of rows of the matrix C. M >= 0.
+   > \endverbatim
+   >
+   > \param[in] N
+   > \verbatim
+   >          N is INTEGER
+   >          The number of columns of the matrix C. N >= 0.
+   > \endverbatim
+   >
+   > \param[in] K
+   > \verbatim
+   >          K is INTEGER
+   >          The number of elementary reflectors whose product defines
+   >          the matrix Q.
+   >          If SIDE = 'L', M >= K >= 0;
+   >          if SIDE = 'R', N >= K >= 0.
+   > \endverbatim
+   >
+   > \param[in] A
+   > \verbatim
+   >          A is DOUBLE PRECISION array, dimension (LDA,K)
+   >          The i-th column must contain the vector which defines the
+   >          elementary reflector H(i), for i = 1,2,...,k, as returned by
+   >          DGEQLF in the last k columns of its array argument A.
+   > \endverbatim
+   >
+   > \param[in] LDA
+   > \verbatim
+   >          LDA is INTEGER
+   >          The leading dimension of the array A.
+   >          If SIDE = 'L', LDA >= max(1,M);
+   >          if SIDE = 'R', LDA >= max(1,N).
+   > \endverbatim
+   >
+   > \param[in] TAU
+   > \verbatim
+   >          TAU is DOUBLE PRECISION array, dimension (K)
+   >          TAU(i) must contain the scalar factor of the elementary
+   >          reflector H(i), as returned by DGEQLF.
+   > \endverbatim
+   >
+   > \param[in,out] C
+   > \verbatim
+   >          C is DOUBLE PRECISION array, dimension (LDC,N)
+   >          On entry, the M-by-N matrix C.
+   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+   > \endverbatim
+   >
+   > \param[in] LDC
+   > \verbatim
+   >          LDC is INTEGER
+   >          The leading dimension of the array C. LDC >= max(1,M).
+   > \endverbatim
+   >
+   > \param[out] WORK
+   > \verbatim
+   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
+   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+   > \endverbatim
+   >
+   > \param[in] LWORK
+   > \verbatim
+   >          LWORK is INTEGER
+   >          The dimension of the array WORK.
+   >          If SIDE = 'L', LWORK >= max(1,N);
+   >          if SIDE = 'R', LWORK >= max(1,M).
+   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and
+   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
+   >          blocksize.
+   >
+   >          If LWORK = -1, then a workspace query is assumed; the routine
+   >          only calculates the optimal size of the WORK array, returns
+   >          this value as the first entry of the WORK array, and no error
+   >          message related to LWORK is issued by XERBLA.
+   > \endverbatim
+   >
+   > \param[out] INFO
+   > \verbatim
+   >          INFO is INTEGER
+   >          = 0:  successful exit
+   >          < 0:  if INFO = -i, the i-th argument had an illegal value
+   > \endverbatim
+
+    Authors:
+    ========
+
+   > \author Univ. of Tennessee
+   > \author Univ. of California Berkeley
+   > \author Univ. of Colorado Denver
+   > \author NAG Ltd.
+
+   > \date November 2011
+
+   > \ingroup doubleOTHERcomputational
+
+    =====================================================================
+   Subroutine */ int igraphdormql_(char *side, char *trans, integer *m, integer *n,
 	integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
 	c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
 {
     /* System generated locals */
     address a__1[2];
-    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4, 
+    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
 	    i__5;
     char ch__1[2];
 
-    /* Builtin functions   
-       Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Builtin functions
+       Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -206,30 +206,30 @@ f">
     logical left;
     extern logical igraphlsame_(char *, char *);
     integer nbmin, iinfo;
-    extern /* Subroutine */ int igraphdorm2l_(char *, char *, integer *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
-	    integer *, doublereal *, integer *), igraphdlarfb_(char 
-	    *, char *, char *, char *, integer *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
-	    integer *, doublereal *, integer *), igraphdlarft_(char *, char *, integer *, integer *, doublereal 
+    extern /* Subroutine */ int igraphdorm2l_(char *, char *, integer *, integer *,
+	    integer *, doublereal *, integer *, doublereal *, doublereal *,
+	    integer *, doublereal *, integer *), igraphdlarfb_(char
+	    *, char *, char *, char *, integer *, integer *, integer *,
+	    doublereal *, integer *, doublereal *, integer *, doublereal *,
+	    integer *, doublereal *, integer *), igraphdlarft_(char *, char *, integer *, integer *, doublereal
 	    *, integer *, doublereal *, doublereal *, integer *), igraphxerbla_(char *, integer *, ftnlen);
-    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *, 
+    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *,
 	    integer *, integer *, ftnlen, ftnlen);
     logical notran;
     integer ldwork, lwkopt;
     logical lquery;
 
 
-/*  -- LAPACK computational routine (version 3.4.0) --   
-    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
-    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
-       November 2011   
+/*  -- LAPACK computational routine (version 3.4.0) --
+    -- LAPACK is a software package provided by Univ. of Tennessee,    --
+    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+       November 2011
 
 
-    =====================================================================   
+    =====================================================================
 
 
-       Test the input arguments   
+       Test the input arguments
 
        Parameter adjustments */
     a_dim1 = *lda;
@@ -277,15 +277,15 @@ f">
 	    lwkopt = 1;
 	} else {
 
-/*           Determine the block size.  NB may be at most NBMAX, where   
-             NBMAX is used to define the local array T.   
+/*           Determine the block size.  NB may be at most NBMAX, where
+             NBMAX is used to define the local array T.
 
-   Computing MIN   
+   Computing MIN
    Writing concatenation */
 	    i__3[0] = 1, a__1[0] = side;
 	    i__3[1] = 1, a__1[1] = trans;
 	    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
-	    i__1 = 64, i__2 = igraphilaenv_(&c__1, "DORMQL", ch__1, m, n, k, &c_n1, 
+	    i__1 = 64, i__2 = igraphilaenv_(&c__1, "DORMQL", ch__1, m, n, k, &c_n1,
 		    (ftnlen)6, (ftnlen)2);
 	    nb = min(i__1,i__2);
 	    lwkopt = nw * nb;
@@ -317,7 +317,7 @@ f">
 	iws = nw * nb;
 	if (*lwork < iws) {
 	    nb = *lwork / ldwork;
-/* Computing MAX   
+/* Computing MAX
    Writing concatenation */
 	    i__3[0] = 1, a__1[0] = side;
 	    i__3[1] = 1, a__1[1] = trans;
@@ -363,7 +363,7 @@ f">
 	    i__4 = nb, i__5 = *k - i__ + 1;
 	    ib = min(i__4,i__5);
 
-/*           Form the triangular factor of the block reflector   
+/*           Form the triangular factor of the block reflector
              H = H(i+ib-1) . . . H(i+1) H(i) */
 
 	    i__4 = nq - *k + i__ + ib - 1;
diff --git a/vendor/lapack/dormqr.c b/vendor/lapack/dormqr.c
index a33d25684..cbccdf40e 100644
--- a/vendor/lapack/dormqr.c
+++ b/vendor/lapack/dormqr.c
@@ -19,185 +19,185 @@ static integer c_n1 = -1;
 static integer c__2 = 2;
 static integer c__65 = 65;
 
-/* > \brief \b DORMQR   
+/* > \brief \b DORMQR
 
-    =========== DOCUMENTATION ===========   
+    =========== DOCUMENTATION ===========
 
-   Online html documentation available at   
-              http://www.netlib.org/lapack/explore-html/   
+   Online html documentation available at
+              http://www.netlib.org/lapack/explore-html/
 
-   > \htmlonly   
-   > Download DORMQR + dependencies   
+   > \htmlonly
+   > Download DORMQR + dependencies
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dormqr.
-f">   
-   > [TGZ]</a>   
+f">
+   > [TGZ]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dormqr.
-f">   
-   > [ZIP]</a>   
+f">
+   > [ZIP]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormqr.
-f">   
-   > [TXT]</a>   
-   > \endhtmlonly   
-
-    Definition:   
-    ===========   
-
-         SUBROUTINE DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
-                            WORK, LWORK, INFO )   
-
-         CHARACTER          SIDE, TRANS   
-         INTEGER            INFO, K, LDA, LDC, LWORK, M, N   
-         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )   
-
-
-   > \par Purpose:   
-    =============   
-   >   
-   > \verbatim   
-   >   
-   > DORMQR overwrites the general real M-by-N matrix C with   
-   >   
-   >                 SIDE = 'L'     SIDE = 'R'   
-   > TRANS = 'N':      Q * C          C * Q   
-   > TRANS = 'T':      Q**T * C       C * Q**T   
-   >   
-   > where Q is a real orthogonal matrix defined as the product of k   
-   > elementary reflectors   
-   >   
-   >       Q = H(1) H(2) . . . H(k)   
-   >   
-   > as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N   
-   > if SIDE = 'R'.   
-   > \endverbatim   
-
-    Arguments:   
-    ==========   
-
-   > \param[in] SIDE   
-   > \verbatim   
-   >          SIDE is CHARACTER*1   
-   >          = 'L': apply Q or Q**T from the Left;   
-   >          = 'R': apply Q or Q**T from the Right.   
-   > \endverbatim   
-   >   
-   > \param[in] TRANS   
-   > \verbatim   
-   >          TRANS is CHARACTER*1   
-   >          = 'N':  No transpose, apply Q;   
-   >          = 'T':  Transpose, apply Q**T.   
-   > \endverbatim   
-   >   
-   > \param[in] M   
-   > \verbatim   
-   >          M is INTEGER   
-   >          The number of rows of the matrix C. M >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] N   
-   > \verbatim   
-   >          N is INTEGER   
-   >          The number of columns of the matrix C. N >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] K   
-   > \verbatim   
-   >          K is INTEGER   
-   >          The number of elementary reflectors whose product defines   
-   >          the matrix Q.   
-   >          If SIDE = 'L', M >= K >= 0;   
-   >          if SIDE = 'R', N >= K >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] A   
-   > \verbatim   
-   >          A is DOUBLE PRECISION array, dimension (LDA,K)   
-   >          The i-th column must contain the vector which defines the   
-   >          elementary reflector H(i), for i = 1,2,...,k, as returned by   
-   >          DGEQRF in the first k columns of its array argument A.   
-   > \endverbatim   
-   >   
-   > \param[in] LDA   
-   > \verbatim   
-   >          LDA is INTEGER   
-   >          The leading dimension of the array A.   
-   >          If SIDE = 'L', LDA >= max(1,M);   
-   >          if SIDE = 'R', LDA >= max(1,N).   
-   > \endverbatim   
-   >   
-   > \param[in] TAU   
-   > \verbatim   
-   >          TAU is DOUBLE PRECISION array, dimension (K)   
-   >          TAU(i) must contain the scalar factor of the elementary   
-   >          reflector H(i), as returned by DGEQRF.   
-   > \endverbatim   
-   >   
-   > \param[in,out] C   
-   > \verbatim   
-   >          C is DOUBLE PRECISION array, dimension (LDC,N)   
-   >          On entry, the M-by-N matrix C.   
-   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.   
-   > \endverbatim   
-   >   
-   > \param[in] LDC   
-   > \verbatim   
-   >          LDC is INTEGER   
-   >          The leading dimension of the array C. LDC >= max(1,M).   
-   > \endverbatim   
-   >   
-   > \param[out] WORK   
-   > \verbatim   
-   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))   
-   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.   
-   > \endverbatim   
-   >   
-   > \param[in] LWORK   
-   > \verbatim   
-   >          LWORK is INTEGER   
-   >          The dimension of the array WORK.   
-   >          If SIDE = 'L', LWORK >= max(1,N);   
-   >          if SIDE = 'R', LWORK >= max(1,M).   
-   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and   
-   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal   
-   >          blocksize.   
-   >   
-   >          If LWORK = -1, then a workspace query is assumed; the routine   
-   >          only calculates the optimal size of the WORK array, returns   
-   >          this value as the first entry of the WORK array, and no error   
-   >          message related to LWORK is issued by XERBLA.   
-   > \endverbatim   
-   >   
-   > \param[out] INFO   
-   > \verbatim   
-   >          INFO is INTEGER   
-   >          = 0:  successful exit   
-   >          < 0:  if INFO = -i, the i-th argument had an illegal value   
-   > \endverbatim   
-
-    Authors:   
-    ========   
-
-   > \author Univ. of Tennessee   
-   > \author Univ. of California Berkeley   
-   > \author Univ. of Colorado Denver   
-   > \author NAG Ltd.   
-
-   > \date November 2011   
-
-   > \ingroup doubleOTHERcomputational   
-
-    =====================================================================   
-   Subroutine */ int igraphdormqr_(char *side, char *trans, integer *m, integer *n, 
+f">
+   > [TXT]</a>
+   > \endhtmlonly
+
+    Definition:
+    ===========
+
+         SUBROUTINE DORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+                            WORK, LWORK, INFO )
+
+         CHARACTER          SIDE, TRANS
+         INTEGER            INFO, K, LDA, LDC, LWORK, M, N
+         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+
+
+   > \par Purpose:
+    =============
+   >
+   > \verbatim
+   >
+   > DORMQR overwrites the general real M-by-N matrix C with
+   >
+   >                 SIDE = 'L'     SIDE = 'R'
+   > TRANS = 'N':      Q * C          C * Q
+   > TRANS = 'T':      Q**T * C       C * Q**T
+   >
+   > where Q is a real orthogonal matrix defined as the product of k
+   > elementary reflectors
+   >
+   >       Q = H(1) H(2) . . . H(k)
+   >
+   > as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
+   > if SIDE = 'R'.
+   > \endverbatim
+
+    Arguments:
+    ==========
+
+   > \param[in] SIDE
+   > \verbatim
+   >          SIDE is CHARACTER*1
+   >          = 'L': apply Q or Q**T from the Left;
+   >          = 'R': apply Q or Q**T from the Right.
+   > \endverbatim
+   >
+   > \param[in] TRANS
+   > \verbatim
+   >          TRANS is CHARACTER*1
+   >          = 'N':  No transpose, apply Q;
+   >          = 'T':  Transpose, apply Q**T.
+   > \endverbatim
+   >
+   > \param[in] M
+   > \verbatim
+   >          M is INTEGER
+   >          The number of rows of the matrix C. M >= 0.
+   > \endverbatim
+   >
+   > \param[in] N
+   > \verbatim
+   >          N is INTEGER
+   >          The number of columns of the matrix C. N >= 0.
+   > \endverbatim
+   >
+   > \param[in] K
+   > \verbatim
+   >          K is INTEGER
+   >          The number of elementary reflectors whose product defines
+   >          the matrix Q.
+   >          If SIDE = 'L', M >= K >= 0;
+   >          if SIDE = 'R', N >= K >= 0.
+   > \endverbatim
+   >
+   > \param[in] A
+   > \verbatim
+   >          A is DOUBLE PRECISION array, dimension (LDA,K)
+   >          The i-th column must contain the vector which defines the
+   >          elementary reflector H(i), for i = 1,2,...,k, as returned by
+   >          DGEQRF in the first k columns of its array argument A.
+   > \endverbatim
+   >
+   > \param[in] LDA
+   > \verbatim
+   >          LDA is INTEGER
+   >          The leading dimension of the array A.
+   >          If SIDE = 'L', LDA >= max(1,M);
+   >          if SIDE = 'R', LDA >= max(1,N).
+   > \endverbatim
+   >
+   > \param[in] TAU
+   > \verbatim
+   >          TAU is DOUBLE PRECISION array, dimension (K)
+   >          TAU(i) must contain the scalar factor of the elementary
+   >          reflector H(i), as returned by DGEQRF.
+   > \endverbatim
+   >
+   > \param[in,out] C
+   > \verbatim
+   >          C is DOUBLE PRECISION array, dimension (LDC,N)
+   >          On entry, the M-by-N matrix C.
+   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+   > \endverbatim
+   >
+   > \param[in] LDC
+   > \verbatim
+   >          LDC is INTEGER
+   >          The leading dimension of the array C. LDC >= max(1,M).
+   > \endverbatim
+   >
+   > \param[out] WORK
+   > \verbatim
+   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
+   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+   > \endverbatim
+   >
+   > \param[in] LWORK
+   > \verbatim
+   >          LWORK is INTEGER
+   >          The dimension of the array WORK.
+   >          If SIDE = 'L', LWORK >= max(1,N);
+   >          if SIDE = 'R', LWORK >= max(1,M).
+   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and
+   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
+   >          blocksize.
+   >
+   >          If LWORK = -1, then a workspace query is assumed; the routine
+   >          only calculates the optimal size of the WORK array, returns
+   >          this value as the first entry of the WORK array, and no error
+   >          message related to LWORK is issued by XERBLA.
+   > \endverbatim
+   >
+   > \param[out] INFO
+   > \verbatim
+   >          INFO is INTEGER
+   >          = 0:  successful exit
+   >          < 0:  if INFO = -i, the i-th argument had an illegal value
+   > \endverbatim
+
+    Authors:
+    ========
+
+   > \author Univ. of Tennessee
+   > \author Univ. of California Berkeley
+   > \author Univ. of Colorado Denver
+   > \author NAG Ltd.
+
+   > \date November 2011
+
+   > \ingroup doubleOTHERcomputational
+
+    =====================================================================
+   Subroutine */ int igraphdormqr_(char *side, char *trans, integer *m, integer *n,
 	integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
 	c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
 {
     /* System generated locals */
     address a__1[2];
-    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4, 
+    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4,
 	    i__5;
     char ch__1[2];
 
-    /* Builtin functions   
-       Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Builtin functions
+       Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i__;
@@ -206,30 +206,30 @@ f">
     logical left;
     extern logical igraphlsame_(char *, char *);
     integer nbmin, iinfo;
-    extern /* Subroutine */ int igraphdorm2r_(char *, char *, integer *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
-	    integer *, doublereal *, integer *), igraphdlarfb_(char 
-	    *, char *, char *, char *, integer *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
-	    integer *, doublereal *, integer *), igraphdlarft_(char *, char *, integer *, integer *, doublereal 
+    extern /* Subroutine */ int igraphdorm2r_(char *, char *, integer *, integer *,
+	    integer *, doublereal *, integer *, doublereal *, doublereal *,
+	    integer *, doublereal *, integer *), igraphdlarfb_(char
+	    *, char *, char *, char *, integer *, integer *, integer *,
+	    doublereal *, integer *, doublereal *, integer *, doublereal *,
+	    integer *, doublereal *, integer *), igraphdlarft_(char *, char *, integer *, integer *, doublereal
 	    *, integer *, doublereal *, doublereal *, integer *), igraphxerbla_(char *, integer *, ftnlen);
-    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *, 
+    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *,
 	    integer *, integer *, ftnlen, ftnlen);
     logical notran;
     integer ldwork, lwkopt;
     logical lquery;
 
 
-/*  -- LAPACK computational routine (version 3.4.0) --   
-    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
-    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
-       November 2011   
+/*  -- LAPACK computational routine (version 3.4.0) --
+    -- LAPACK is a software package provided by Univ. of Tennessee,    --
+    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+       November 2011
 
 
-    =====================================================================   
+    =====================================================================
 
 
-       Test the input arguments   
+       Test the input arguments
 
        Parameter adjustments */
     a_dim1 = *lda;
@@ -276,10 +276,10 @@ f">
 
     if (*info == 0) {
 
-/*        Determine the block size.  NB may be at most NBMAX, where NBMAX   
-          is used to define the local array T.   
+/*        Determine the block size.  NB may be at most NBMAX, where NBMAX
+          is used to define the local array T.
 
-   Computing MIN   
+   Computing MIN
    Writing concatenation */
 	i__3[0] = 1, a__1[0] = side;
 	i__3[1] = 1, a__1[1] = trans;
@@ -312,7 +312,7 @@ f">
 	iws = nw * nb;
 	if (*lwork < iws) {
 	    nb = *lwork / ldwork;
-/* Computing MAX   
+/* Computing MAX
    Writing concatenation */
 	    i__3[0] = 1, a__1[0] = side;
 	    i__3[1] = 1, a__1[1] = trans;
@@ -360,11 +360,11 @@ f">
 	    i__4 = nb, i__5 = *k - i__ + 1;
 	    ib = min(i__4,i__5);
 
-/*           Form the triangular factor of the block reflector   
+/*           Form the triangular factor of the block reflector
              H = H(i) H(i+1) . . . H(i+ib-1) */
 
 	    i__4 = nq - i__ + 1;
-	    igraphdlarft_("Forward", "Columnwise", &i__4, &ib, &a[i__ + i__ * 
+	    igraphdlarft_("Forward", "Columnwise", &i__4, &ib, &a[i__ + i__ *
 		    a_dim1], lda, &tau[i__], t, &c__65)
 		    ;
 	    if (left) {
@@ -384,7 +384,7 @@ f">
 /*           Apply H or H**T */
 
 	    igraphdlarfb_(side, trans, "Forward", "Columnwise", &mi, &ni, &ib, &a[
-		    i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * 
+		    i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc *
 		    c_dim1], ldc, &work[1], &ldwork);
 /* L10: */
 	}
diff --git a/vendor/lapack/dormtr.c b/vendor/lapack/dormtr.c
index 540494223..559f82ccb 100644
--- a/vendor/lapack/dormtr.c
+++ b/vendor/lapack/dormtr.c
@@ -18,176 +18,176 @@ static integer c__1 = 1;
 static integer c_n1 = -1;
 static integer c__2 = 2;
 
-/* > \brief \b DORMTR   
+/* > \brief \b DORMTR
 
-    =========== DOCUMENTATION ===========   
+    =========== DOCUMENTATION ===========
 
-   Online html documentation available at   
-              http://www.netlib.org/lapack/explore-html/   
+   Online html documentation available at
+              http://www.netlib.org/lapack/explore-html/
 
-   > \htmlonly   
-   > Download DORMTR + dependencies   
+   > \htmlonly
+   > Download DORMTR + dependencies
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dormtr.
-f">   
-   > [TGZ]</a>   
+f">
+   > [TGZ]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dormtr.
-f">   
-   > [ZIP]</a>   
+f">
+   > [ZIP]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dormtr.
-f">   
-   > [TXT]</a>   
-   > \endhtmlonly   
-
-    Definition:   
-    ===========   
-
-         SUBROUTINE DORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,   
-                            WORK, LWORK, INFO )   
-
-         CHARACTER          SIDE, TRANS, UPLO   
-         INTEGER            INFO, LDA, LDC, LWORK, M, N   
-         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )   
-
-
-   > \par Purpose:   
-    =============   
-   >   
-   > \verbatim   
-   >   
-   > DORMTR overwrites the general real M-by-N matrix C with   
-   >   
-   >                 SIDE = 'L'     SIDE = 'R'   
-   > TRANS = 'N':      Q * C          C * Q   
-   > TRANS = 'T':      Q**T * C       C * Q**T   
-   >   
-   > where Q is a real orthogonal matrix of order nq, with nq = m if   
-   > SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of   
-   > nq-1 elementary reflectors, as returned by DSYTRD:   
-   >   
-   > if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);   
-   >   
-   > if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).   
-   > \endverbatim   
-
-    Arguments:   
-    ==========   
-
-   > \param[in] SIDE   
-   > \verbatim   
-   >          SIDE is CHARACTER*1   
-   >          = 'L': apply Q or Q**T from the Left;   
-   >          = 'R': apply Q or Q**T from the Right.   
-   > \endverbatim   
-   >   
-   > \param[in] UPLO   
-   > \verbatim   
-   >          UPLO is CHARACTER*1   
-   >          = 'U': Upper triangle of A contains elementary reflectors   
-   >                 from DSYTRD;   
-   >          = 'L': Lower triangle of A contains elementary reflectors   
-   >                 from DSYTRD.   
-   > \endverbatim   
-   >   
-   > \param[in] TRANS   
-   > \verbatim   
-   >          TRANS is CHARACTER*1   
-   >          = 'N':  No transpose, apply Q;   
-   >          = 'T':  Transpose, apply Q**T.   
-   > \endverbatim   
-   >   
-   > \param[in] M   
-   > \verbatim   
-   >          M is INTEGER   
-   >          The number of rows of the matrix C. M >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] N   
-   > \verbatim   
-   >          N is INTEGER   
-   >          The number of columns of the matrix C. N >= 0.   
-   > \endverbatim   
-   >   
-   > \param[in] A   
-   > \verbatim   
-   >          A is DOUBLE PRECISION array, dimension   
-   >                               (LDA,M) if SIDE = 'L'   
-   >                               (LDA,N) if SIDE = 'R'   
-   >          The vectors which define the elementary reflectors, as   
-   >          returned by DSYTRD.   
-   > \endverbatim   
-   >   
-   > \param[in] LDA   
-   > \verbatim   
-   >          LDA is INTEGER   
-   >          The leading dimension of the array A.   
-   >          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.   
-   > \endverbatim   
-   >   
-   > \param[in] TAU   
-   > \verbatim   
-   >          TAU is DOUBLE PRECISION array, dimension   
-   >                               (M-1) if SIDE = 'L'   
-   >                               (N-1) if SIDE = 'R'   
-   >          TAU(i) must contain the scalar factor of the elementary   
-   >          reflector H(i), as returned by DSYTRD.   
-   > \endverbatim   
-   >   
-   > \param[in,out] C   
-   > \verbatim   
-   >          C is DOUBLE PRECISION array, dimension (LDC,N)   
-   >          On entry, the M-by-N matrix C.   
-   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.   
-   > \endverbatim   
-   >   
-   > \param[in] LDC   
-   > \verbatim   
-   >          LDC is INTEGER   
-   >          The leading dimension of the array C. LDC >= max(1,M).   
-   > \endverbatim   
-   >   
-   > \param[out] WORK   
-   > \verbatim   
-   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))   
-   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.   
-   > \endverbatim   
-   >   
-   > \param[in] LWORK   
-   > \verbatim   
-   >          LWORK is INTEGER   
-   >          The dimension of the array WORK.   
-   >          If SIDE = 'L', LWORK >= max(1,N);   
-   >          if SIDE = 'R', LWORK >= max(1,M).   
-   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and   
-   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal   
-   >          blocksize.   
-   >   
-   >          If LWORK = -1, then a workspace query is assumed; the routine   
-   >          only calculates the optimal size of the WORK array, returns   
-   >          this value as the first entry of the WORK array, and no error   
-   >          message related to LWORK is issued by XERBLA.   
-   > \endverbatim   
-   >   
-   > \param[out] INFO   
-   > \verbatim   
-   >          INFO is INTEGER   
-   >          = 0:  successful exit   
-   >          < 0:  if INFO = -i, the i-th argument had an illegal value   
-   > \endverbatim   
-
-    Authors:   
-    ========   
-
-   > \author Univ. of Tennessee   
-   > \author Univ. of California Berkeley   
-   > \author Univ. of Colorado Denver   
-   > \author NAG Ltd.   
-
-   > \date November 2011   
-
-   > \ingroup doubleOTHERcomputational   
-
-    =====================================================================   
-   Subroutine */ int igraphdormtr_(char *side, char *uplo, char *trans, integer *m, 
+f">
+   > [TXT]</a>
+   > \endhtmlonly
+
+    Definition:
+    ===========
+
+         SUBROUTINE DORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
+                            WORK, LWORK, INFO )
+
+         CHARACTER          SIDE, TRANS, UPLO
+         INTEGER            INFO, LDA, LDC, LWORK, M, N
+         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+
+
+   > \par Purpose:
+    =============
+   >
+   > \verbatim
+   >
+   > DORMTR overwrites the general real M-by-N matrix C with
+   >
+   >                 SIDE = 'L'     SIDE = 'R'
+   > TRANS = 'N':      Q * C          C * Q
+   > TRANS = 'T':      Q**T * C       C * Q**T
+   >
+   > where Q is a real orthogonal matrix of order nq, with nq = m if
+   > SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
+   > nq-1 elementary reflectors, as returned by DSYTRD:
+   >
+   > if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
+   >
+   > if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
+   > \endverbatim
+
+    Arguments:
+    ==========
+
+   > \param[in] SIDE
+   > \verbatim
+   >          SIDE is CHARACTER*1
+   >          = 'L': apply Q or Q**T from the Left;
+   >          = 'R': apply Q or Q**T from the Right.
+   > \endverbatim
+   >
+   > \param[in] UPLO
+   > \verbatim
+   >          UPLO is CHARACTER*1
+   >          = 'U': Upper triangle of A contains elementary reflectors
+   >                 from DSYTRD;
+   >          = 'L': Lower triangle of A contains elementary reflectors
+   >                 from DSYTRD.
+   > \endverbatim
+   >
+   > \param[in] TRANS
+   > \verbatim
+   >          TRANS is CHARACTER*1
+   >          = 'N':  No transpose, apply Q;
+   >          = 'T':  Transpose, apply Q**T.
+   > \endverbatim
+   >
+   > \param[in] M
+   > \verbatim
+   >          M is INTEGER
+   >          The number of rows of the matrix C. M >= 0.
+   > \endverbatim
+   >
+   > \param[in] N
+   > \verbatim
+   >          N is INTEGER
+   >          The number of columns of the matrix C. N >= 0.
+   > \endverbatim
+   >
+   > \param[in] A
+   > \verbatim
+   >          A is DOUBLE PRECISION array, dimension
+   >                               (LDA,M) if SIDE = 'L'
+   >                               (LDA,N) if SIDE = 'R'
+   >          The vectors which define the elementary reflectors, as
+   >          returned by DSYTRD.
+   > \endverbatim
+   >
+   > \param[in] LDA
+   > \verbatim
+   >          LDA is INTEGER
+   >          The leading dimension of the array A.
+   >          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
+   > \endverbatim
+   >
+   > \param[in] TAU
+   > \verbatim
+   >          TAU is DOUBLE PRECISION array, dimension
+   >                               (M-1) if SIDE = 'L'
+   >                               (N-1) if SIDE = 'R'
+   >          TAU(i) must contain the scalar factor of the elementary
+   >          reflector H(i), as returned by DSYTRD.
+   > \endverbatim
+   >
+   > \param[in,out] C
+   > \verbatim
+   >          C is DOUBLE PRECISION array, dimension (LDC,N)
+   >          On entry, the M-by-N matrix C.
+   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+   > \endverbatim
+   >
+   > \param[in] LDC
+   > \verbatim
+   >          LDC is INTEGER
+   >          The leading dimension of the array C. LDC >= max(1,M).
+   > \endverbatim
+   >
+   > \param[out] WORK
+   > \verbatim
+   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
+   >          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+   > \endverbatim
+   >
+   > \param[in] LWORK
+   > \verbatim
+   >          LWORK is INTEGER
+   >          The dimension of the array WORK.
+   >          If SIDE = 'L', LWORK >= max(1,N);
+   >          if SIDE = 'R', LWORK >= max(1,M).
+   >          For optimum performance LWORK >= N*NB if SIDE = 'L', and
+   >          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
+   >          blocksize.
+   >
+   >          If LWORK = -1, then a workspace query is assumed; the routine
+   >          only calculates the optimal size of the WORK array, returns
+   >          this value as the first entry of the WORK array, and no error
+   >          message related to LWORK is issued by XERBLA.
+   > \endverbatim
+   >
+   > \param[out] INFO
+   > \verbatim
+   >          INFO is INTEGER
+   >          = 0:  successful exit
+   >          < 0:  if INFO = -i, the i-th argument had an illegal value
+   > \endverbatim
+
+    Authors:
+    ========
+
+   > \author Univ. of Tennessee
+   > \author Univ. of California Berkeley
+   > \author Univ. of Colorado Denver
+   > \author NAG Ltd.
+
+   > \date November 2011
+
+   > \ingroup doubleOTHERcomputational
+
+    =====================================================================
+   Subroutine */ int igraphdormtr_(char *side, char *uplo, char *trans, integer *m,
 	integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *
 	c__, integer *ldc, doublereal *work, integer *lwork, integer *info)
 {
@@ -196,8 +196,8 @@ f">
     integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2, i__3;
     char ch__1[2];
 
-    /* Builtin functions   
-       Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
+    /* Builtin functions
+       Subroutine */ void s_cat(char *, char **, integer *, integer *, ftnlen);
 
     /* Local variables */
     integer i1, i2, nb, mi, ni, nq, nw;
@@ -206,28 +206,28 @@ f">
     integer iinfo;
     logical upper;
     extern /* Subroutine */ int igraphxerbla_(char *, integer *, ftnlen);
-    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *, 
+    extern integer igraphilaenv_(integer *, char *, char *, integer *, integer *,
 	    integer *, integer *, ftnlen, ftnlen);
-    extern /* Subroutine */ int igraphdormql_(char *, char *, integer *, integer *, 
-	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
-	    integer *, doublereal *, integer *, integer *), 
-	    igraphdormqr_(char *, char *, integer *, integer *, integer *, 
-	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
+    extern /* Subroutine */ int igraphdormql_(char *, char *, integer *, integer *,
+	    integer *, doublereal *, integer *, doublereal *, doublereal *,
+	    integer *, doublereal *, integer *, integer *),
+	    igraphdormqr_(char *, char *, integer *, integer *, integer *,
+	    doublereal *, integer *, doublereal *, doublereal *, integer *,
 	    doublereal *, integer *, integer *);
     integer lwkopt;
     logical lquery;
 
 
-/*  -- LAPACK computational routine (version 3.4.0) --   
-    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
-    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
-       November 2011   
+/*  -- LAPACK computational routine (version 3.4.0) --
+    -- LAPACK is a software package provided by Univ. of Tennessee,    --
+    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+       November 2011
 
 
-    =====================================================================   
+    =====================================================================
 
 
-       Test the input arguments   
+       Test the input arguments
 
        Parameter adjustments */
     a_dim1 = *lda;
@@ -258,7 +258,7 @@ f">
 	*info = -1;
     } else if (! upper && ! igraphlsame_(uplo, "L")) {
 	*info = -2;
-    } else if (! igraphlsame_(trans, "N") && ! igraphlsame_(trans, 
+    } else if (! igraphlsame_(trans, "N") && ! igraphlsame_(trans,
 	    "T")) {
 	*info = -3;
     } else if (*m < 0) {
diff --git a/vendor/lapack/dsaup2.c b/vendor/lapack/dsaup2.c
index 75e5d5643..094737407 100644
--- a/vendor/lapack/dsaup2.c
+++ b/vendor/lapack/dsaup2.c
@@ -214,7 +214,7 @@ static integer c__2 = 2;
     /* Builtin functions */
     double pow_dd(doublereal *, doublereal *);
     integer s_cmp(char *, char *, ftnlen, ftnlen);
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     double sqrt(doublereal);
 
     /* Local variables */
diff --git a/vendor/lapack/dseupd.c b/vendor/lapack/dseupd.c
index 1cc08d5d1..a8890bac9 100644
--- a/vendor/lapack/dseupd.c
+++ b/vendor/lapack/dseupd.c
@@ -248,7 +248,7 @@ static doublereal c_b111 = 1.;
 
     /* Builtin functions */
     integer s_cmp(char *, char *, ftnlen, ftnlen);
-    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     double pow_dd(doublereal *, doublereal *);
 
     /* Local variables */
diff --git a/vendor/lapack/ilaenv.c b/vendor/lapack/ilaenv.c
index 113c4c31f..c7f5a0a29 100644
--- a/vendor/lapack/ilaenv.c
+++ b/vendor/lapack/ilaenv.c
@@ -19,178 +19,178 @@ static real c_b163 = 0.f;
 static real c_b164 = 1.f;
 static integer c__0 = 0;
 
-/* > \brief \b ILAENV   
+/* > \brief \b ILAENV
 
-    =========== DOCUMENTATION ===========   
+    =========== DOCUMENTATION ===========
 
-   Online html documentation available at   
-              http://www.netlib.org/lapack/explore-html/   
+   Online html documentation available at
+              http://www.netlib.org/lapack/explore-html/
 
-   > \htmlonly   
-   > Download ILAENV + dependencies   
+   > \htmlonly
+   > Download ILAENV + dependencies
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ilaenv.
-f">   
-   > [TGZ]</a>   
+f">
+   > [TGZ]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ilaenv.
-f">   
-   > [ZIP]</a>   
+f">
+   > [ZIP]</a>
    > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaenv.
-f">   
-   > [TXT]</a>   
-   > \endhtmlonly   
-
-    Definition:   
-    ===========   
-
-         INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )   
-
-         CHARACTER*( * )    NAME, OPTS   
-         INTEGER            ISPEC, N1, N2, N3, N4   
-
-
-   > \par Purpose:   
-    =============   
-   >   
-   > \verbatim   
-   >   
-   > ILAENV is called from the LAPACK routines to choose problem-dependent   
-   > parameters for the local environment.  See ISPEC for a description of   
-   > the parameters.   
-   >   
-   > ILAENV returns an INTEGER   
-   > if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC   
-   > if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value.   
-   >   
-   > This version provides a set of parameters which should give good,   
-   > but not optimal, performance on many of the currently available   
-   > computers.  Users are encouraged to modify this subroutine to set   
-   > the tuning parameters for their particular machine using the option   
-   > and problem size information in the arguments.   
-   >   
-   > This routine will not function correctly if it is converted to all   
-   > lower case.  Converting it to all upper case is allowed.   
-   > \endverbatim   
-
-    Arguments:   
-    ==========   
-
-   > \param[in] ISPEC   
-   > \verbatim   
-   >          ISPEC is INTEGER   
-   >          Specifies the parameter to be returned as the value of   
-   >          ILAENV.   
-   >          = 1: the optimal blocksize; if this value is 1, an unblocked   
-   >               algorithm will give the best performance.   
-   >          = 2: the minimum block size for which the block routine   
-   >               should be used; if the usable block size is less than   
-   >               this value, an unblocked routine should be used.   
-   >          = 3: the crossover point (in a block routine, for N less   
-   >               than this value, an unblocked routine should be used)   
-   >          = 4: the number of shifts, used in the nonsymmetric   
-   >               eigenvalue routines (DEPRECATED)   
-   >          = 5: the minimum column dimension for blocking to be used;   
-   >               rectangular blocks must have dimension at least k by m,   
-   >               where k is given by ILAENV(2,...) and m by ILAENV(5,...)   
-   >          = 6: the crossover point for the SVD (when reducing an m by n   
-   >               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds   
-   >               this value, a QR factorization is used first to reduce   
-   >               the matrix to a triangular form.)   
-   >          = 7: the number of processors   
-   >          = 8: the crossover point for the multishift QR method   
-   >               for nonsymmetric eigenvalue problems (DEPRECATED)   
-   >          = 9: maximum size of the subproblems at the bottom of the   
-   >               computation tree in the divide-and-conquer algorithm   
-   >               (used by xGELSD and xGESDD)   
-   >          =10: ieee NaN arithmetic can be trusted not to trap   
-   >          =11: infinity arithmetic can be trusted not to trap   
-   >          12 <= ISPEC <= 16:   
-   >               xHSEQR or one of its subroutines,   
-   >               see IPARMQ for detailed explanation   
-   > \endverbatim   
-   >   
-   > \param[in] NAME   
-   > \verbatim   
-   >          NAME is CHARACTER*(*)   
-   >          The name of the calling subroutine, in either upper case or   
-   >          lower case.   
-   > \endverbatim   
-   >   
-   > \param[in] OPTS   
-   > \verbatim   
-   >          OPTS is CHARACTER*(*)   
-   >          The character options to the subroutine NAME, concatenated   
-   >          into a single character string.  For example, UPLO = 'U',   
-   >          TRANS = 'T', and DIAG = 'N' for a triangular routine would   
-   >          be specified as OPTS = 'UTN'.   
-   > \endverbatim   
-   >   
-   > \param[in] N1   
-   > \verbatim   
-   >          N1 is INTEGER   
-   > \endverbatim   
-   >   
-   > \param[in] N2   
-   > \verbatim   
-   >          N2 is INTEGER   
-   > \endverbatim   
-   >   
-   > \param[in] N3   
-   > \verbatim   
-   >          N3 is INTEGER   
-   > \endverbatim   
-   >   
-   > \param[in] N4   
-   > \verbatim   
-   >          N4 is INTEGER   
-   >          Problem dimensions for the subroutine NAME; these may not all   
-   >          be required.   
-   > \endverbatim   
-
-    Authors:   
-    ========   
-
-   > \author Univ. of Tennessee   
-   > \author Univ. of California Berkeley   
-   > \author Univ. of Colorado Denver   
-   > \author NAG Ltd.   
-
-   > \date November 2011   
-
-   > \ingroup auxOTHERauxiliary   
-
-   > \par Further Details:   
-    =====================   
-   >   
-   > \verbatim   
-   >   
-   >  The following conventions have been used when calling ILAENV from the   
-   >  LAPACK routines:   
-   >  1)  OPTS is a concatenation of all of the character options to   
-   >      subroutine NAME, in the same order that they appear in the   
-   >      argument list for NAME, even if they are not used in determining   
-   >      the value of the parameter specified by ISPEC.   
-   >  2)  The problem dimensions N1, N2, N3, N4 are specified in the order   
-   >      that they appear in the argument list for NAME.  N1 is used   
-   >      first, N2 second, and so on, and unused problem dimensions are   
-   >      passed a value of -1.   
-   >  3)  The parameter value returned by ILAENV is checked for validity in   
-   >      the calling subroutine.  For example, ILAENV is used to retrieve   
-   >      the optimal blocksize for STRTRI as follows:   
-   >   
-   >      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )   
-   >      IF( NB.LE.1 ) NB = MAX( 1, N )   
-   > \endverbatim   
-   >   
+f">
+   > [TXT]</a>
+   > \endhtmlonly
+
+    Definition:
+    ===========
+
+         INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )
+
+         CHARACTER*( * )    NAME, OPTS
+         INTEGER            ISPEC, N1, N2, N3, N4
+
+
+   > \par Purpose:
+    =============
+   >
+   > \verbatim
+   >
+   > ILAENV is called from the LAPACK routines to choose problem-dependent
+   > parameters for the local environment.  See ISPEC for a description of
+   > the parameters.
+   >
+   > ILAENV returns an INTEGER
+   > if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC
+   > if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value.
+   >
+   > This version provides a set of parameters which should give good,
+   > but not optimal, performance on many of the currently available
+   > computers.  Users are encouraged to modify this subroutine to set
+   > the tuning parameters for their particular machine using the option
+   > and problem size information in the arguments.
+   >
+   > This routine will not function correctly if it is converted to all
+   > lower case.  Converting it to all upper case is allowed.
+   > \endverbatim
+
+    Arguments:
+    ==========
+
+   > \param[in] ISPEC
+   > \verbatim
+   >          ISPEC is INTEGER
+   >          Specifies the parameter to be returned as the value of
+   >          ILAENV.
+   >          = 1: the optimal blocksize; if this value is 1, an unblocked
+   >               algorithm will give the best performance.
+   >          = 2: the minimum block size for which the block routine
+   >               should be used; if the usable block size is less than
+   >               this value, an unblocked routine should be used.
+   >          = 3: the crossover point (in a block routine, for N less
+   >               than this value, an unblocked routine should be used)
+   >          = 4: the number of shifts, used in the nonsymmetric
+   >               eigenvalue routines (DEPRECATED)
+   >          = 5: the minimum column dimension for blocking to be used;
+   >               rectangular blocks must have dimension at least k by m,
+   >               where k is given by ILAENV(2,...) and m by ILAENV(5,...)
+   >          = 6: the crossover point for the SVD (when reducing an m by n
+   >               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
+   >               this value, a QR factorization is used first to reduce
+   >               the matrix to a triangular form.)
+   >          = 7: the number of processors
+   >          = 8: the crossover point for the multishift QR method
+   >               for nonsymmetric eigenvalue problems (DEPRECATED)
+   >          = 9: maximum size of the subproblems at the bottom of the
+   >               computation tree in the divide-and-conquer algorithm
+   >               (used by xGELSD and xGESDD)
+   >          =10: ieee NaN arithmetic can be trusted not to trap
+   >          =11: infinity arithmetic can be trusted not to trap
+   >          12 <= ISPEC <= 16:
+   >               xHSEQR or one of its subroutines,
+   >               see IPARMQ for detailed explanation
+   > \endverbatim
+   >
+   > \param[in] NAME
+   > \verbatim
+   >          NAME is CHARACTER*(*)
+   >          The name of the calling subroutine, in either upper case or
+   >          lower case.
+   > \endverbatim
+   >
+   > \param[in] OPTS
+   > \verbatim
+   >          OPTS is CHARACTER*(*)
+   >          The character options to the subroutine NAME, concatenated
+   >          into a single character string.  For example, UPLO = 'U',
+   >          TRANS = 'T', and DIAG = 'N' for a triangular routine would
+   >          be specified as OPTS = 'UTN'.
+   > \endverbatim
+   >
+   > \param[in] N1
+   > \verbatim
+   >          N1 is INTEGER
+   > \endverbatim
+   >
+   > \param[in] N2
+   > \verbatim
+   >          N2 is INTEGER
+   > \endverbatim
+   >
+   > \param[in] N3
+   > \verbatim
+   >          N3 is INTEGER
+   > \endverbatim
+   >
+   > \param[in] N4
+   > \verbatim
+   >          N4 is INTEGER
+   >          Problem dimensions for the subroutine NAME; these may not all
+   >          be required.
+   > \endverbatim
+
+    Authors:
+    ========
+
+   > \author Univ. of Tennessee
+   > \author Univ. of California Berkeley
+   > \author Univ. of Colorado Denver
+   > \author NAG Ltd.
+
+   > \date November 2011
+
+   > \ingroup auxOTHERauxiliary
+
+   > \par Further Details:
+    =====================
+   >
+   > \verbatim
+   >
+   >  The following conventions have been used when calling ILAENV from the
+   >  LAPACK routines:
+   >  1)  OPTS is a concatenation of all of the character options to
+   >      subroutine NAME, in the same order that they appear in the
+   >      argument list for NAME, even if they are not used in determining
+   >      the value of the parameter specified by ISPEC.
+   >  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
+   >      that they appear in the argument list for NAME.  N1 is used
+   >      first, N2 second, and so on, and unused problem dimensions are
+   >      passed a value of -1.
+   >  3)  The parameter value returned by ILAENV is checked for validity in
+   >      the calling subroutine.  For example, ILAENV is used to retrieve
+   >      the optimal blocksize for STRTRI as follows:
+   >
+   >      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
+   >      IF( NB.LE.1 ) NB = MAX( 1, N )
+   > \endverbatim
+   >
     ===================================================================== */
-integer igraphilaenv_(integer *ispec, char *name__, char *opts, integer *n1, 
-	integer *n2, integer *n3, integer *n4, ftnlen name_len, ftnlen 
+integer igraphilaenv_(integer *ispec, char *name__, char *opts, integer *n1,
+	integer *n2, integer *n3, integer *n4, ftnlen name_len, ftnlen
 	opts_len)
 {
     /* System generated locals */
     integer ret_val;
 
-    /* Builtin functions   
-       Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
+    /* Builtin functions
+       Subroutine */ void s_copy(char *, char *, ftnlen, ftnlen);
     integer s_cmp(char *, char *, ftnlen, ftnlen);
 
     /* Local variables */
@@ -202,14 +202,14 @@ integer igraphilaenv_(integer *ispec, char *name__, char *opts, integer *n1,
     logical sname;
     extern integer igraphieeeck_(integer *, real *, real *);
     char subnam[6];
-    extern integer igraphiparmq_(integer *, char *, char *, integer *, integer *, 
+    extern integer igraphiparmq_(integer *, char *, char *, integer *, integer *,
 	    integer *, integer *);
 
 
-/*  -- LAPACK auxiliary routine (version 3.4.0) --   
-    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
-    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
-       November 2011   
+/*  -- LAPACK auxiliary routine (version 3.4.0) --
+    -- LAPACK is a software package provided by Univ. of Tennessee,    --
+    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+       November 2011
 
 
     ===================================================================== */
@@ -266,12 +266,12 @@ L10:
 
 /*        EBCDIC character set */
 
-	if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 162 && 
+	if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 162 &&
 		ic <= 169) {
 	    *(unsigned char *)subnam = (char) (ic + 64);
 	    for (i__ = 2; i__ <= 6; ++i__) {
 		ic = *(unsigned char *)&subnam[i__ - 1];
-		if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 
+		if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >=
 			162 && ic <= 169) {
 		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic + 64);
 		}
@@ -313,10 +313,10 @@ L10:
 
 L50:
 
-/*     ISPEC = 1:  block size   
+/*     ISPEC = 1:  block size
 
-       In these examples, separate code is provided for setting NB for   
-       real and complex.  We assume that NB will take the same value in   
+       In these examples, separate code is provided for setting NB for
+       real and complex.  We assume that NB will take the same value in
        single or double precision. */
 
     nb = 1;
@@ -328,9 +328,9 @@ L50:
 	    } else {
 		nb = 64;
 	    }
-	} else if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, 
+	} else if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3,
 		"RQF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)
-		3, (ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) 
+		3, (ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3)
 		== 0) {
 	    if (sname) {
 		nb = 32;
@@ -386,7 +386,7 @@ L50:
 	}
     } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
 	if (*(unsigned char *)c3 == 'G') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -395,7 +395,7 @@ L50:
 		nb = 32;
 	    }
 	} else if (*(unsigned char *)c3 == 'M') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -406,7 +406,7 @@ L50:
 	}
     } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
 	if (*(unsigned char *)c3 == 'G') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -415,7 +415,7 @@ L50:
 		nb = 32;
 	    }
 	} else if (*(unsigned char *)c3 == 'M') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -530,7 +530,7 @@ L60:
 	}
     } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
 	if (*(unsigned char *)c3 == 'G') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -539,7 +539,7 @@ L60:
 		nbmin = 2;
 	    }
 	} else if (*(unsigned char *)c3 == 'M') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -550,7 +550,7 @@ L60:
 	}
     } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
 	if (*(unsigned char *)c3 == 'G') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -559,7 +559,7 @@ L60:
 		nbmin = 2;
 	    }
 	} else if (*(unsigned char *)c3 == 'M') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -610,7 +610,7 @@ L70:
 	}
     } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
 	if (*(unsigned char *)c3 == 'G') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -621,7 +621,7 @@ L70:
 	}
     } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
 	if (*(unsigned char *)c3 == 'G') {
-	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
+	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ",
 		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
 		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
 		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
@@ -671,8 +671,8 @@ L120:
 
 L130:
 
-/*     ISPEC = 9:  maximum size of the subproblems at the bottom of the   
-                   computation tree in the divide-and-conquer algorithm   
+/*     ISPEC = 9:  maximum size of the subproblems at the bottom of the
+                   computation tree in the divide-and-conquer algorithm
                    (used by xGELSD and xGESDD) */
 
     ret_val = 25;
@@ -680,7 +680,7 @@ L130:
 
 L140:
 
-/*     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap   
+/*     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap
 
        ILAENV = 0 */
     ret_val = 1;
@@ -691,7 +691,7 @@ L140:
 
 L150:
 
-/*     ISPEC = 11: infinity arithmetic can be trusted not to trap   
+/*     ISPEC = 11: infinity arithmetic can be trusted not to trap
 
        ILAENV = 0 */
     ret_val = 1;
