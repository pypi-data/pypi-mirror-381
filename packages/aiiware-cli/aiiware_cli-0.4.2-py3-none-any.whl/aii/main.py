"""Main AII Beta CLI Entry Point"""

import asyncio
import sys
from pathlib import Path
from typing import Any

from .cli.command_parser import CommandParser
from .cli.interactive import InteractiveShell
from .cli.status_display import StatusDisplay
from .config.manager import get_config, init_config
from .config.output_config import OutputConfig
from .core.engine import AIIEngine
from .data.integrations.mcp_client import MCPClient, MCPServerConfig
from .data.integrations.web_search import (
    BraveSearchProvider,
    DuckDuckGoSearchProvider,
    GoogleSearchProvider,
    WebSearchClient,
    create_web_search_client_from_config,
)
from .data.providers.llm_provider import create_llm_provider
from .functions import register_all_functions
from .functions.system.system_functions import (
    ClarificationFunction,
    HelpFunction,
)

# Git commit signature - configurable footer for AI-generated commits
GIT_COMMIT_SIGNATURE = "ü§ñ Generated by aii - https://pypi.org/project/aiiware-cli"


async def main() -> int:
    """Main entry point for AII Beta"""
    try:
        # Parse command line arguments
        parser = CommandParser()
        parsed_cmd = parser.parse_args()

        # Initialize output configuration with CLI args and config files
        # Create a simple object from the parsed args dict to mimic argparse.Namespace
        class Args:
            def __init__(self, args_dict):
                for key, value in args_dict.items():
                    setattr(self, key, value)

        args_obj = Args(parsed_cmd.args) if parsed_cmd.args else None
        output_config = OutputConfig.load(cli_args=args_obj)

        # Initialize configuration
        config_manager = init_config(Path.home() / ".config" / "aii")
        config = config_manager.get_all_config()

        # Initialize engine with output configuration
        storage_path = Path.home() / ".config" / "aii"
        engine = AIIEngine(config=config, storage_path=storage_path, output_config=output_config)

        # Register all built-in functions (universal system)
        register_all_functions(engine.function_registry)
        engine.register_function(HelpFunction())
        engine.register_function(ClarificationFunction())

        # Configure integrations from config
        try:
            # Configure LLM provider
            llm_provider_name = config_manager.get("llm.provider")
            llm_model = config_manager.get("llm.model")

            # Try Pydantic AI first, fallback to custom providers
            use_pydantic_ai = True  # Enable Pydantic AI by default for testing

            if llm_provider_name == "gemini":
                api_key = config_manager.get_secret("gemini_api_key")
                if api_key:
                    llm_provider = create_llm_provider(
                        "gemini", api_key, llm_model, use_pydantic_ai
                    )
                    engine.configure(llm_provider=llm_provider)
            elif llm_provider_name == "openai":
                api_key = config_manager.get_secret("openai_api_key")
                if api_key:
                    llm_provider = create_llm_provider(
                        "openai", api_key, llm_model, use_pydantic_ai
                    )
                    engine.configure(llm_provider=llm_provider)
            elif llm_provider_name == "anthropic":
                # ALWAYS use API key authentication for reliable operation
                # Subscription authentication is experimental only via oauth command
                api_key = config_manager.get_secret("anthropic_api_key")
                # Using API key authentication for reliable operation

                if api_key:
                    # Use API key authentication
                    llm_provider = create_llm_provider(
                        "anthropic", api_key, llm_model, use_pydantic_ai
                    )
                    engine.configure(llm_provider=llm_provider)

            # Configure web search using factory function
            if config_manager.get("web_search.enabled"):
                try:
                    web_client = create_web_search_client_from_config(config_manager)
                    engine.configure(web_client=web_client)
                except Exception as e:
                    # Log but don't fail - web search is optional
                    print(f"Warning: Failed to initialize web search: {e}")

            # Configure MCP servers
            mcp_servers = config_manager.get("mcp.servers", [])
            if mcp_servers:
                server_configs = []
                for server_config in mcp_servers:
                    mcp_config = MCPServerConfig(
                        name=server_config["name"],
                        url=server_config["url"],
                        auth_token=server_config.get("auth_token"),
                        timeout=config_manager.get("mcp.timeout"),
                        retries=config_manager.get("mcp.retries"),
                    )
                    server_configs.append(mcp_config)

                if server_configs:
                    mcp_client = MCPClient(server_configs)
                    engine.configure(mcp_client=mcp_client)

        except Exception as e:
            print(f"Warning: Could not initialize all integrations: {e}")
            print("Some features may not be available.")

        # Handle different command modes
        if parsed_cmd.interactive or (
            not parsed_cmd.input_text and not parsed_cmd.command
        ):
            # Interactive mode
            shell = InteractiveShell(engine, engine.output_formatter)
            await shell.start(parsed_cmd.continue_chat)
            return 0

        elif parsed_cmd.command == "history":
            # Chat history commands
            return await handle_history_command(parsed_cmd, engine)

        elif parsed_cmd.command == "config":
            # Configuration commands
            return await handle_config_command(parsed_cmd, engine)

        elif parsed_cmd.command == "doctor":
            # Health check commands
            return await handle_doctor_command(parsed_cmd, engine)

        elif parsed_cmd.input_text:
            # Process single input
            try:
                context = None
                if parsed_cmd.continue_chat:
                    context = await engine.continue_chat(parsed_cmd.continue_chat)
                elif parsed_cmd.new_chat:
                    context = await engine.start_new_chat()
                else:
                    # Default: start new chat for single commands
                    context = await engine.start_new_chat()

                # Create status display for CLI mode
                status_display = StatusDisplay(
                    use_emojis=output_config.use_emojis,
                    use_animations=output_config.use_animations
                )

                # Show loading animation for CLI processing
                status_display.start_loading("Processing your request...", "spinner")

                try:
                    # Git commit requests now use proper GitCommitFunction with LLM-based generation

                    # Process input and handle confirmations
                    session_id = getattr(parsed_cmd, "session_id", None)
                    result = await engine.process_input(
                        parsed_cmd.input_text,
                        context=context,
                        offline_mode=parsed_cmd.offline,
                        session_id=session_id,
                    )

                    # Stop loading animation
                    status_display.stop_loading()

                except Exception:
                    # Make sure to stop loading on error
                    status_display.stop_loading()
                    raise

                # Check if this is a confirmation request - look for the confirmation text anywhere in segments
                has_confirmation = any(
                    (
                        "Confirm? (y/n):" in segment.content
                        or "Proceed with this commit? (y/n):" in segment.content
                        or "Execute this command? [y/N]:" in segment.content
                    )
                    for segment in result.segments
                )

                if has_confirmation:
                    # This is a confirmation request, display it and get user response
                    engine.output_formatter.display(result)
                    sys.stdout.flush()  # Ensure prompt is displayed immediately
                    try:
                        response = input().strip().lower()
                    except EOFError:
                        print("\n‚ùå No input available")
                        response = "n"
                    except KeyboardInterrupt:
                        print("\n‚ùå Cancelled by user")
                        response = "n"

                    if response in ("y", "yes"):
                        # User confirmed, proceed with execution
                        # Show loading animation during execution
                        status_display = StatusDisplay(
                            use_emojis=output_config.use_emojis,
                            use_animations=output_config.use_animations
                        )
                        status_display.start_loading("Executing command...", "spinner")

                        try:
                            # We need to re-process with confirmed execution
                            result = await engine.confirm_and_execute_last_recognition(
                                confirmed=True
                            )
                            status_display.stop_loading()
                            engine.output_formatter.display(result)
                        except Exception:
                            status_display.stop_loading()
                            raise
                    else:
                        # User cancelled
                        cancel_result = engine.output_formatter.format_error(
                            "Operation cancelled by user"
                        )
                        engine.output_formatter.display(cancel_result)
                else:
                    # Regular result, just display
                    engine.output_formatter.display(result)

                return 0

            except Exception as e:
                error_output = engine.output_formatter.format_error(
                    f"Processing failed: {str(e)}"
                )
                engine.output_formatter.display(error_output)
                return 1

        else:
            parser.print_help()
            return 0

    except KeyboardInterrupt:
        print("\\nInterrupted by user")
        return 130

    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        return 1

    finally:
        # Cleanup
        try:
            if "engine" in locals():
                await engine.shutdown()
        except Exception:
            pass


async def handle_history_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle chat history commands"""
    args = parsed_cmd.args
    history_action = args.get("history_action")

    try:
        if history_action == "list":
            output = await engine.list_chat_history(limit=50, archived=False)
            engine.output_formatter.display(output)

        elif history_action == "search":
            query = args.get("query", "")
            if not query:
                print("Error: Search query required")
                return 1

            output = await engine.search_chats(
                query=query,
                search_content=args.get("content", False),
                tag_filter=args.get("tag"),
            )
            engine.output_formatter.display(output)

        elif history_action == "continue":
            chat_id = args.get("chat_id")
            if not chat_id:
                print("Error: Chat ID required")
                return 1

            # Start interactive session with specific chat
            shell = InteractiveShell(engine, engine.output_formatter)
            await shell.start(chat_id)

        elif history_action == "export":
            chat_id = args.get("chat_id")
            if not chat_id:
                print("Error: Chat ID required")
                return 1

            format_type = args.get("format", "json")
            exported_data = await engine.export_chat(chat_id, format_type)

            if exported_data:
                output_file = f"{chat_id}.{format_type}"
                with open(output_file, "w", encoding="utf-8") as f:
                    f.write(exported_data)
                print(f"Chat exported to {output_file}")
            else:
                print("Export failed")
                return 1

        elif history_action == "delete":
            chat_id = args.get("chat_id")
            if not chat_id:
                print("Error: Chat ID required")
                return 1

            success = await engine.delete_chat(chat_id)
            if success:
                print(f"Chat {chat_id} deleted successfully")
            else:
                print("Delete failed")
                return 1

        else:
            print("Available history commands: list, search, continue, export, delete")
            return 1

        return 0

    except Exception as e:
        print(f"History command failed: {e}")
        return 1


async def handle_config_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle configuration commands"""
    args = parsed_cmd.args
    config_action = args.get("config_action")

    try:
        config_manager = get_config()

        if config_action == "init":
            # Use interactive setup wizard
            from aii.cli.setup import SetupWizard

            wizard = SetupWizard()
            success = await wizard.run()

            if not success:
                print("\n‚ùå Setup was not completed.")
                print("You can run 'aii config init' again anytime.")
                sys.exit(1)

            # Wizard handles all configuration, no need for additional validation
            sys.exit(0)

        elif config_action == "show":
            print("üìã Current AII Configuration:")
            print(f"- Config file: {config_manager.config_file}")
            print(f"- Storage path: {engine.storage_path}")

            # LLM provider
            llm_provider = config_manager.get("llm.provider")
            llm_model = config_manager.get("llm.model")
            llm_configured = bool(config_manager.get_secret(f"{llm_provider}_api_key"))
            print(
                f"- LLM provider: {llm_provider} ({llm_model}) - {'‚úì' if llm_configured else '‚úó'}"
            )

            # Web search
            web_enabled = config_manager.get("web_search.enabled")
            web_provider = config_manager.get("web_search.provider")
            web_configured = (
                bool(config_manager.get_secret(f"{web_provider}_api_key"))
                if web_enabled
                else False
            )
            print(
                f"- Web search: {web_provider} - {'‚úì' if web_configured else '‚úó' if web_enabled else 'disabled'}"
            )

            # Functions
            print(f"- Registered functions: {len(engine.function_registry.functions)}")

            # Validation
            issues = config_manager.validate_config()
            if issues:
                print(f"- Configuration issues: {len(issues)}")

        elif config_action == "validate":
            issues = config_manager.validate_config()
            if issues:
                print("‚ùå Configuration issues found:")
                for issue in issues:
                    print(f"  - {issue}")
                return 1
            else:
                print("‚úÖ Configuration is valid!")

        elif config_action == "reset":
            confirm = input(
                "Are you sure you want to reset configuration to defaults? (y/N): "
            )
            if confirm.lower() in ("y", "yes"):
                config_manager.reset_to_defaults()
                print("‚úÖ Configuration reset to defaults")
            else:
                print("Reset cancelled")

        elif config_action == "backup":
            backup_path = config_manager.backup_config()
            print(f"‚úÖ Configuration backed up to: {backup_path}")

        elif config_action == "set":
            # Set configuration value
            key = args.get("key")
            value = args.get("value")

            if not key or not value:
                print("‚ùå Error: Both key and value are required")
                print("Usage: aii config set <key> <value>")
                print("\nExamples:")
                print("  aii config set llm.model claude-sonnet-4-5-20250929")
                print("  aii config set llm.provider anthropic")
                print("  aii config set web_search.enabled true")
                return 1

            # Validate and set the configuration
            try:
                # Handle boolean values
                if value.lower() in ('true', 'false'):
                    value = value.lower() == 'true'

                # Validate specific keys
                if key == "llm.model":
                    # Get available models for validation
                    from aii.cli.setup.steps.model_selection import ModelSelectionStep
                    provider = config_manager.get("llm.provider", "anthropic")
                    step = ModelSelectionStep()
                    provider_models = step.MODELS.get(provider, {})

                    if provider_models:
                        valid_model_ids = [m["id"] for m in provider_models.get("models", {}).values()]
                        if value not in valid_model_ids:
                            print(f"‚ö†Ô∏è  Warning: '{value}' is not in the list of recommended models for {provider}")
                            print(f"\nüìã Available {provider} models:")
                            for m in provider_models.get("models", {}).values():
                                marker = " ‚úì" if m.get("recommended") else ""
                                print(f"  - {m['id']}{marker}")

                            # Ask for confirmation
                            confirm = input("\n‚ùì Continue anyway? (y/N): ").strip().lower()
                            if confirm not in ['y', 'yes']:
                                print("‚ùå Model change cancelled")
                                return 1

                elif key == "llm.provider":
                    valid_providers = ["anthropic", "openai", "gemini"]
                    if value not in valid_providers:
                        print(f"‚ùå Error: Invalid provider '{value}'")
                        print(f"Valid providers: {', '.join(valid_providers)}")
                        return 1

                # Set the value
                config_manager.set(key, value, save=True)
                print(f"‚úÖ Configuration updated: {key} = {value}")

                # Show relevant info after update
                if key.startswith("llm."):
                    provider = config_manager.get("llm.provider")
                    model = config_manager.get("llm.model")
                    print(f"\nüìã Current LLM config: {provider} ({model})")
                    print("\nüí° Tip: Restart any running interactive sessions for changes to take effect")

            except Exception as e:
                print(f"‚ùå Failed to set configuration: {e}")
                return 1

        elif config_action == "model":
            # Change LLM model
            model_id = args.get("model_id")

            if not model_id:
                # Show current model and available options
                from aii.cli.setup.steps.model_selection import ModelSelectionStep
                provider = config_manager.get("llm.provider", "anthropic")
                current_model = config_manager.get("llm.model")

                print(f"üìã Current model: {current_model}")
                print(f"\n‚ú® Available {provider} models:")

                step = ModelSelectionStep()
                provider_models = step.MODELS.get(provider, {})
                if provider_models:
                    for num, info in provider_models.get("models", {}).items():
                        marker = " ‚úì (recommended)" if info.get("recommended") else ""
                        current = " ‚Üê current" if info["id"] == current_model else ""
                        print(f"  {info['name']}{marker}{current}")
                        print(f"    {info['description']}")
                        print(f"    ID: {info['id']}\n")

                print("Usage: aii config model <model_id>")
                print("\nüí° Tip: You can also use custom model IDs not listed above")
                return 0

            # Set the model using the existing set logic
            try:
                from aii.cli.setup.steps.model_selection import ModelSelectionStep
                provider = config_manager.get("llm.provider", "anthropic")
                step = ModelSelectionStep()
                provider_models = step.MODELS.get(provider, {})

                if provider_models:
                    valid_model_ids = [m["id"] for m in provider_models.get("models", {}).values()]
                    if model_id not in valid_model_ids:
                        # Custom model ID - ask for confirmation
                        print(f"‚ö†Ô∏è  '{model_id}' is not in the list of recommended models for {provider}")
                        print(f"\nThis appears to be a custom model ID.")
                        print(f"Available models: {', '.join(valid_model_ids[:3])}...")
                        print(f"\nRun 'aii config model' to see all available models")

                        # Ask for confirmation
                        confirm = input(f"\nProceed with custom model '{model_id}'? (y/n): ").strip().lower()
                        if confirm != 'y':
                            print("‚ùå Model change cancelled")
                            return 1

                        print(f"\nüí° Note: Ensure '{model_id}' is a valid model ID for {provider}")

                config_manager.set("llm.model", model_id, save=True)
                print(f"‚úÖ Model updated to: {model_id}")
                print(f"\nüìã Current LLM config: {provider} ({model_id})")
                return 0

            except Exception as e:
                print(f"‚ùå Failed to set model: {e}")
                return 1

        elif config_action == "provider":
            # Change LLM provider
            provider_name = args.get("provider_name")

            if not provider_name:
                # Show current provider and available options
                current_provider = config_manager.get("llm.provider")
                current_model = config_manager.get("llm.model")

                print(f"üìã Current provider: {current_provider} ({current_model})")
                print(f"\n‚ú® Available providers:")
                print("  1. anthropic - Claude models (Sonnet, Opus, Haiku)")
                print("  2. openai    - GPT models (GPT-4o, GPT-4 Turbo)")
                print("  3. gemini    - Google Gemini models (2.5 Flash, 1.5 Pro)")
                print("\nUsage: aii config provider <provider_name>")
                print("\n‚ö†Ô∏è  Note: Changing provider may require setting a new model")
                return 0

            # Validate provider
            valid_providers = ["anthropic", "openai", "gemini"]
            if provider_name not in valid_providers:
                print(f"‚ùå Error: Invalid provider '{provider_name}'")
                print(f"Valid providers: {', '.join(valid_providers)}")
                return 1

            # Get default model for new provider
            from aii.cli.setup.steps.model_selection import ModelSelectionStep
            step = ModelSelectionStep()
            provider_models = step.MODELS.get(provider_name, {})
            default_model = provider_models.get("default", "")

            if not default_model:
                print(f"‚ùå Error: No default model found for {provider_name}")
                return 1

            # Set provider and default model together to avoid mismatch
            config_manager.set("llm.provider", provider_name, save=False)
            config_manager.set("llm.model", default_model, save=True)

            print(f"‚úÖ Provider updated to: {provider_name}")
            print(f"‚úÖ Model set to default: {default_model}")

            # Show recommendation to customize if desired
            print(f"\nüí° To use a different {provider_name} model:")
            print(f"   aii config model")
            return 0

        elif config_action == "web-search":
            # Configure web search
            action = args.get("action")
            provider = args.get("provider")

            if not action:
                # Show current web search config
                enabled = config_manager.get("web_search.enabled", False)
                current_provider = config_manager.get("web_search.provider", "duckduckgo")

                print(f"üìã Web search: {'enabled' if enabled else 'disabled'}")
                if enabled:
                    print(f"   Provider: {current_provider}")

                print(f"\n‚ú® Available actions:")
                print("  enable        - Enable web search")
                print("  disable       - Disable web search")
                print("  set-provider  - Change search provider")

                print(f"\n‚ú® Available providers:")
                print("  brave       - Fast, privacy-focused (requires API key)")
                print("  google      - Comprehensive results (requires API key)")
                print("  duckduckgo  - Free, no API key needed")

                print("\nUsage:")
                print("  aii config web-search enable")
                print("  aii config web-search set-provider brave")
                return 0

            if action == "enable":
                config_manager.set("web_search.enabled", True, save=True)
                print("‚úÖ Web search enabled")
                provider = config_manager.get("web_search.provider", "duckduckgo")
                print(f"   Using provider: {provider}")
                return 0

            elif action == "disable":
                config_manager.set("web_search.enabled", False, save=True)
                print("‚úÖ Web search disabled")
                return 0

            elif action == "set-provider":
                if not provider:
                    print("‚ùå Error: Provider name required")
                    print("Usage: aii config web-search set-provider <brave|google|duckduckgo>")
                    return 1

                valid_providers = ["brave", "google", "duckduckgo"]
                if provider not in valid_providers:
                    print(f"‚ùå Error: Invalid provider '{provider}'")
                    print(f"Valid providers: {', '.join(valid_providers)}")
                    return 1

                config_manager.set("web_search.provider", provider, save=True)
                config_manager.set("web_search.enabled", True, save=True)
                print(f"‚úÖ Web search provider set to: {provider}")

                # Remind about API key if needed
                if provider in ["brave", "google"]:
                    api_key_var = f"{provider.upper()}_SEARCH_API_KEY"
                    print(f"\nüí° Remember to set your API key:")
                    print(f"   export {api_key_var}='your-api-key'")
                return 0

        elif config_action == "oauth":
            return await handle_oauth_command(parsed_cmd, engine)

        else:
            print("Available config commands:")
            print("  init        - Initialize configuration interactively")
            print("  show        - Show current configuration")
            print("  model       - Change LLM model")
            print("  provider    - Change LLM provider")
            print("  web-search  - Configure web search")
            print("  set         - Set configuration value")
            print("  validate    - Validate configuration")
            print("  reset       - Reset to default configuration")
            print("  backup      - Create configuration backup")
            print("  oauth       - OAuth subscription authentication")
            return 1

        return 0

    except Exception as e:
        print(f"Config command failed: {e}")
        return 1


async def handle_oauth_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle OAuth authentication commands"""
    args = parsed_cmd.args
    oauth_action = args.get("oauth_action")

    try:
        from .auth.claude_oauth import ClaudeOAuthClient

        config_dir = Path.home() / ".config" / "aii"
        oauth_client = ClaudeOAuthClient(config_dir)

        if oauth_action == "login":
            # Display prominent experimental notice
            print("\n" + "="*70)
            print("üß™ EXPERIMENTAL FEATURE - SUBSCRIPTION AUTHENTICATION")
            print("="*70)
            print("‚ö†Ô∏è  WARNING: This is an EXPERIMENTAL feature that may not work reliably.")
            print("üìã NOTICE: OAuth tokens obtained through this flow are not compatible")
            print("          with Claude's programmatic API endpoints.")
            print("üîß STATUS: Successfully implemented but limited by Claude's API architecture.")
            print("üí° RECOMMEND: Use API key authentication for reliable operation.")
            print("\nüìñ For production use, set up API key authentication instead:")
            print("   export ANTHROPIC_API_KEY='sk-ant-api03-your-key-here'")
            print("="*70)

            # Ask for explicit confirmation
            try:
                confirm = input("\n‚ùì Continue with experimental OAuth authentication? (y/N): ").strip().lower()
                if confirm not in ['y', 'yes']:
                    print("üëã OAuth authentication cancelled. Use API key for reliable access.")
                    return 0
            except (KeyboardInterrupt, EOFError):
                print("\nüëã OAuth authentication cancelled.")
                return 0

            print("\nüîÑ Proceeding with experimental OAuth authentication...")
            success = await oauth_client.authenticate()
            if success:
                print("\n‚úÖ Successfully authenticated with your Claude subscription!")
                print("‚ö†Ô∏è  Note: This authentication is experimental and may not work for API calls.")

                # DO NOT update configuration to use subscription automatically
                # Keep this as experimental only
                config_manager = get_config()
                config_manager.set("llm.provider", "anthropic")
                # Do NOT set use_subscription to True - keep it experimental only
                print("‚úÖ OAuth credentials stored for experimental use.")
                print("üí° Main authentication still uses API key for reliability.")

                return 0
            else:
                print("\n‚ùå Authentication failed. Please try again.")
                return 1

        elif oauth_action == "logout":
            print("üîì Logging out and clearing experimental OAuth credentials...")
            success = await oauth_client.logout()
            if success:
                print("‚úÖ Successfully logged out. Experimental OAuth credentials cleared.")
                print("üí° Your main API key authentication remains unchanged.")

                # Ensure subscription is disabled
                config_manager = get_config()
                config_manager.set("llm.use_subscription", False)
                print("‚úÖ Configuration updated to disable subscription authentication.")

                return 0
            else:
                print("‚ùå Logout failed.")
                return 1

        elif oauth_action == "status":
            print("üìä Experimental OAuth Authentication Status:")
            print("‚ö†Ô∏è  Note: OAuth authentication is experimental and not used in main flow.")

            # Load credentials and check status
            await oauth_client.load_credentials()
            status_info = oauth_client.get_status_info()

            if status_info["authenticated"]:
                print("‚úÖ Status: Authenticated")
                print(f"üîë Token: {status_info['access_token']}")
                print(f"üÜî Client ID: {status_info['client_id']}")
                if status_info["expires_at"]:
                    from datetime import datetime
                    expires = datetime.fromisoformat(status_info["expires_at"])
                    print(f"‚è∞ Token expires: {expires.strftime('%Y-%m-%d %H:%M:%S')}")
                if status_info["user_info"]:
                    user_info = status_info["user_info"]
                    if "email" in user_info:
                        print(f"üë§ User: {user_info['email']}")
                    if "plan" in user_info:
                        print(f"üìã Plan: Claude {user_info['plan'].title()}")
            else:
                print("‚ùå Status: Not authenticated")
                print("Run 'aii config oauth login' to authenticate with your subscription.")

            # Show configuration status
            config_manager = get_config()
            use_subscription = config_manager.get("llm.use_subscription", False)
            print(f"‚öôÔ∏è  Subscription mode: {'Enabled' if use_subscription else 'Disabled'}")

            return 0

        else:
            print("Available OAuth commands:")
            print("  login  - Login with your Claude Pro/Max subscription")
            print("  logout - Logout and clear credentials")
            print("  status - Show authentication status")
            return 1

    except Exception as e:
        print(f"OAuth command failed: {e}")
        return 1


async def handle_doctor_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle doctor/health check commands"""
    from .cli.health_check import HealthCheckRunner
    from .config.manager import get_config

    try:
        # Create health check runner
        output_config = engine.output_config if hasattr(engine, 'output_config') else None
        runner = HealthCheckRunner(
            use_colors=output_config.use_colors if output_config else True,
            use_emojis=output_config.use_emojis if output_config else True,
        )

        # Register all default checks
        runner.register_default_checks()

        # Build context for health checks
        config_manager = get_config()
        context = {
            "config_manager": config_manager,
            "llm_provider": engine.llm_provider,
            "web_client": engine.web_client,
            "storage_path": engine.storage_path,
            "function_registry": engine.function_registry,
            "cost_calculator": engine.cost_calculator if hasattr(engine, 'cost_calculator') else None,
            "output_config": output_config,
        }

        # Run all health checks
        results = await runner.run_all(context)

        # Format and display results
        output = runner.format_results(results)
        print(output)

        # Return exit code based on results
        failed_count = sum(1 for r in results if r.status.value == "failed")
        return 1 if failed_count > 0 else 0

    except Exception as e:
        print(f"‚ùå Health check error: {str(e)}")
        import traceback
        traceback.print_exc()
        return 1


def cli_main() -> int:
    """CLI entry point (synchronous wrapper)"""
    return asyncio.run(main())


if __name__ == "__main__":
    sys.exit(cli_main())
