"""Main AII Beta CLI Entry Point"""

import asyncio
import sys
from pathlib import Path
from typing import Any

from .cli.command_parser import CommandParser
from .cli.interactive import InteractiveShell
from .cli.status_display import StatusDisplay
from .config.manager import get_config, init_config
from .config.output_config import OutputConfig
from .core.engine import AIIEngine
from .data.integrations.mcp_client import MCPClient, MCPServerConfig
from .data.integrations.web_search import (
    BraveSearchProvider,
    DuckDuckGoSearchProvider,
    GoogleSearchProvider,
    WebSearchClient,
    create_web_search_client_from_config,
)
from .data.providers.llm_provider import create_llm_provider
from .functions import register_all_functions
from .functions.system.system_functions import (
    ClarificationFunction,
    HelpFunction,
)

# Git commit signature - configurable footer for AI-generated commits
GIT_COMMIT_SIGNATURE = "ðŸ¤– Generated by aii - https://pypi.org/project/aiiware-cli"


async def main() -> int:
    """Main entry point for AII Beta"""
    try:
        # Parse command line arguments
        parser = CommandParser()
        parsed_cmd = parser.parse_args()

        # Initialize output configuration with CLI args and config files
        # Create a simple object from the parsed args dict to mimic argparse.Namespace
        class Args:
            def __init__(self, args_dict):
                for key, value in args_dict.items():
                    setattr(self, key, value)

        args_obj = Args(parsed_cmd.args) if parsed_cmd.args else None
        output_config = OutputConfig.load(cli_args=args_obj)

        # Initialize configuration
        config_manager = init_config(Path.home() / ".config" / "aii")
        config = config_manager.get_all_config()

        # Initialize engine with output configuration
        storage_path = Path.home() / ".config" / "aii"
        engine = AIIEngine(config=config, storage_path=storage_path, output_config=output_config)

        # Register all built-in functions (universal system)
        register_all_functions(engine.function_registry)
        engine.register_function(HelpFunction())
        engine.register_function(ClarificationFunction())

        # Configure integrations from config
        try:
            # Configure LLM provider
            llm_provider_name = config_manager.get("llm.provider")
            llm_model = config_manager.get("llm.model")

            # Try Pydantic AI first, fallback to custom providers
            use_pydantic_ai = True  # Enable Pydantic AI by default for testing

            if llm_provider_name == "gemini":
                api_key = config_manager.get_secret("gemini_api_key")
                if api_key:
                    llm_provider = create_llm_provider(
                        "gemini", api_key, llm_model, use_pydantic_ai
                    )
                    engine.configure(llm_provider=llm_provider)
            elif llm_provider_name == "openai":
                api_key = config_manager.get_secret("openai_api_key")
                if api_key:
                    llm_provider = create_llm_provider(
                        "openai", api_key, llm_model, use_pydantic_ai
                    )
                    engine.configure(llm_provider=llm_provider)
            elif llm_provider_name == "anthropic":
                # ALWAYS use API key authentication for reliable operation
                # Subscription authentication is experimental only via oauth command
                api_key = config_manager.get_secret("anthropic_api_key")
                # Using API key authentication for reliable operation

                if api_key:
                    # Use API key authentication
                    llm_provider = create_llm_provider(
                        "anthropic", api_key, llm_model, use_pydantic_ai
                    )
                    engine.configure(llm_provider=llm_provider)

            # Configure web search using factory function
            if config_manager.get("web_search.enabled"):
                try:
                    web_client = create_web_search_client_from_config(config_manager)
                    engine.configure(web_client=web_client)
                except Exception as e:
                    # Log but don't fail - web search is optional
                    print(f"Warning: Failed to initialize web search: {e}")

            # Configure MCP servers
            mcp_servers = config_manager.get("mcp.servers", [])
            if mcp_servers:
                server_configs = []
                for server_config in mcp_servers:
                    mcp_config = MCPServerConfig(
                        name=server_config["name"],
                        url=server_config["url"],
                        auth_token=server_config.get("auth_token"),
                        timeout=config_manager.get("mcp.timeout"),
                        retries=config_manager.get("mcp.retries"),
                    )
                    server_configs.append(mcp_config)

                if server_configs:
                    mcp_client = MCPClient(server_configs)
                    engine.configure(mcp_client=mcp_client)

        except Exception as e:
            print(f"Warning: Could not initialize all integrations: {e}")
            print("Some features may not be available.")

        # Handle different command modes
        if parsed_cmd.interactive or (
            not parsed_cmd.input_text and not parsed_cmd.command
        ):
            # Interactive mode
            shell = InteractiveShell(engine, engine.output_formatter)
            await shell.start(parsed_cmd.continue_chat)
            return 0

        elif parsed_cmd.command == "history":
            # Chat history commands
            return await handle_history_command(parsed_cmd, engine)

        elif parsed_cmd.command == "config":
            # Configuration commands
            return await handle_config_command(parsed_cmd, engine)

        elif parsed_cmd.command == "doctor":
            # Health check commands
            return await handle_doctor_command(parsed_cmd, engine)

        elif parsed_cmd.input_text:
            # Process single input
            try:
                context = None
                if parsed_cmd.continue_chat:
                    context = await engine.continue_chat(parsed_cmd.continue_chat)
                elif parsed_cmd.new_chat:
                    context = await engine.start_new_chat()
                else:
                    # Default: start new chat for single commands
                    context = await engine.start_new_chat()

                # Create status display for CLI mode
                status_display = StatusDisplay(
                    use_emojis=output_config.use_emojis,
                    use_animations=output_config.use_animations
                )

                # Show loading animation for CLI processing
                status_display.start_loading("Processing your request...", "spinner")

                try:
                    # Git commit requests now use proper GitCommitFunction with LLM-based generation

                    # Process input and handle confirmations
                    session_id = getattr(parsed_cmd, "session_id", None)
                    result = await engine.process_input(
                        parsed_cmd.input_text,
                        context=context,
                        offline_mode=parsed_cmd.offline,
                        session_id=session_id,
                    )

                    # Stop loading animation
                    status_display.stop_loading()

                except Exception:
                    # Make sure to stop loading on error
                    status_display.stop_loading()
                    raise

                # Check if this is a confirmation request - look for the confirmation text anywhere in segments
                has_confirmation = any(
                    (
                        "Confirm? (y/n):" in segment.content
                        or "Proceed with this commit? (y/n):" in segment.content
                        or "Execute this command? [y/N]:" in segment.content
                    )
                    for segment in result.segments
                )

                if has_confirmation:
                    # This is a confirmation request, display it and get user response
                    engine.output_formatter.display(result)
                    sys.stdout.flush()  # Ensure prompt is displayed immediately
                    try:
                        response = input().strip().lower()
                    except EOFError:
                        print("\nâŒ No input available")
                        response = "n"
                    except KeyboardInterrupt:
                        print("\nâŒ Cancelled by user")
                        response = "n"

                    if response in ("y", "yes"):
                        # User confirmed, proceed with execution
                        # Show loading animation during execution
                        status_display = StatusDisplay(
                            use_emojis=output_config.use_emojis,
                            use_animations=output_config.use_animations
                        )
                        status_display.start_loading("Executing command...", "spinner")

                        try:
                            # We need to re-process with confirmed execution
                            result = await engine.confirm_and_execute_last_recognition(
                                confirmed=True
                            )
                            status_display.stop_loading()
                            engine.output_formatter.display(result)
                        except Exception:
                            status_display.stop_loading()
                            raise
                    else:
                        # User cancelled
                        cancel_result = engine.output_formatter.format_error(
                            "Operation cancelled by user"
                        )
                        engine.output_formatter.display(cancel_result)
                else:
                    # Regular result, just display
                    engine.output_formatter.display(result)

                return 0

            except Exception as e:
                error_output = engine.output_formatter.format_error(
                    f"Processing failed: {str(e)}"
                )
                engine.output_formatter.display(error_output)
                return 1

        else:
            parser.print_help()
            return 0

    except KeyboardInterrupt:
        print("\\nInterrupted by user")
        return 130

    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        return 1

    finally:
        # Cleanup
        try:
            if "engine" in locals():
                await engine.shutdown()
        except Exception:
            pass


async def handle_history_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle chat history commands"""
    args = parsed_cmd.args
    history_action = args.get("history_action")

    try:
        if history_action == "list":
            output = await engine.list_chat_history(limit=50, archived=False)
            engine.output_formatter.display(output)

        elif history_action == "search":
            query = args.get("query", "")
            if not query:
                print("Error: Search query required")
                return 1

            output = await engine.search_chats(
                query=query,
                search_content=args.get("content", False),
                tag_filter=args.get("tag"),
            )
            engine.output_formatter.display(output)

        elif history_action == "continue":
            chat_id = args.get("chat_id")
            if not chat_id:
                print("Error: Chat ID required")
                return 1

            # Start interactive session with specific chat
            shell = InteractiveShell(engine, engine.output_formatter)
            await shell.start(chat_id)

        elif history_action == "export":
            chat_id = args.get("chat_id")
            if not chat_id:
                print("Error: Chat ID required")
                return 1

            format_type = args.get("format", "json")
            exported_data = await engine.export_chat(chat_id, format_type)

            if exported_data:
                output_file = f"{chat_id}.{format_type}"
                with open(output_file, "w", encoding="utf-8") as f:
                    f.write(exported_data)
                print(f"Chat exported to {output_file}")
            else:
                print("Export failed")
                return 1

        elif history_action == "delete":
            chat_id = args.get("chat_id")
            if not chat_id:
                print("Error: Chat ID required")
                return 1

            success = await engine.delete_chat(chat_id)
            if success:
                print(f"Chat {chat_id} deleted successfully")
            else:
                print("Delete failed")
                return 1

        else:
            print("Available history commands: list, search, continue, export, delete")
            return 1

        return 0

    except Exception as e:
        print(f"History command failed: {e}")
        return 1


async def handle_config_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle configuration commands"""
    args = parsed_cmd.args
    config_action = args.get("config_action")

    try:
        config_manager = get_config()

        if config_action == "init":
            print("ðŸš€ Initializing AII configuration...")
            config_manager.init_config(interactive=True)

            # Validate configuration
            issues = config_manager.validate_config()
            if issues:
                print("\nâš ï¸  Configuration issues found:")
                for issue in issues:
                    print(f"  - {issue}")
                print("\nYou can fix these later with 'aii config set' commands.")
            else:
                print("\nâœ… Configuration is valid and ready to use!")
                print("Run 'aii help' to see available commands.")

        elif config_action == "show":
            print("ðŸ“‹ Current AII Configuration:")
            print(f"- Config file: {config_manager.config_file}")
            print(f"- Storage path: {engine.storage_path}")

            # LLM provider
            llm_provider = config_manager.get("llm.provider")
            llm_model = config_manager.get("llm.model")
            llm_configured = bool(config_manager.get_secret(f"{llm_provider}_api_key"))
            print(
                f"- LLM provider: {llm_provider} ({llm_model}) - {'âœ“' if llm_configured else 'âœ—'}"
            )

            # Web search
            web_enabled = config_manager.get("web_search.enabled")
            web_provider = config_manager.get("web_search.provider")
            web_configured = (
                bool(config_manager.get_secret(f"{web_provider}_api_key"))
                if web_enabled
                else False
            )
            print(
                f"- Web search: {web_provider} - {'âœ“' if web_configured else 'âœ—' if web_enabled else 'disabled'}"
            )

            # Functions
            print(f"- Registered functions: {len(engine.function_registry.functions)}")

            # Validation
            issues = config_manager.validate_config()
            if issues:
                print(f"- Configuration issues: {len(issues)}")

        elif config_action == "validate":
            issues = config_manager.validate_config()
            if issues:
                print("âŒ Configuration issues found:")
                for issue in issues:
                    print(f"  - {issue}")
                return 1
            else:
                print("âœ… Configuration is valid!")

        elif config_action == "reset":
            confirm = input(
                "Are you sure you want to reset configuration to defaults? (y/N): "
            )
            if confirm.lower() in ("y", "yes"):
                config_manager.reset_to_defaults()
                print("âœ… Configuration reset to defaults")
            else:
                print("Reset cancelled")

        elif config_action == "backup":
            backup_path = config_manager.backup_config()
            print(f"âœ… Configuration backed up to: {backup_path}")

        elif config_action == "oauth":
            return await handle_oauth_command(parsed_cmd, engine)

        else:
            print("Available config commands:")
            print("  init     - Initialize configuration interactively")
            print("  show     - Show current configuration")
            print("  validate - Validate configuration")
            print("  reset    - Reset to default configuration")
            print("  backup   - Create configuration backup")
            print("  oauth    - OAuth subscription authentication")
            return 1

        return 0

    except Exception as e:
        print(f"Config command failed: {e}")
        return 1


async def handle_oauth_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle OAuth authentication commands"""
    args = parsed_cmd.args
    oauth_action = args.get("oauth_action")

    try:
        from .auth.claude_oauth import ClaudeOAuthClient

        config_dir = Path.home() / ".config" / "aii"
        oauth_client = ClaudeOAuthClient(config_dir)

        if oauth_action == "login":
            # Display prominent experimental notice
            print("\n" + "="*70)
            print("ðŸ§ª EXPERIMENTAL FEATURE - SUBSCRIPTION AUTHENTICATION")
            print("="*70)
            print("âš ï¸  WARNING: This is an EXPERIMENTAL feature that may not work reliably.")
            print("ðŸ“‹ NOTICE: OAuth tokens obtained through this flow are not compatible")
            print("          with Claude's programmatic API endpoints.")
            print("ðŸ”§ STATUS: Successfully implemented but limited by Claude's API architecture.")
            print("ðŸ’¡ RECOMMEND: Use API key authentication for reliable operation.")
            print("\nðŸ“– For production use, set up API key authentication instead:")
            print("   export ANTHROPIC_API_KEY='sk-ant-api03-your-key-here'")
            print("="*70)

            # Ask for explicit confirmation
            try:
                confirm = input("\nâ“ Continue with experimental OAuth authentication? (y/N): ").strip().lower()
                if confirm not in ['y', 'yes']:
                    print("ðŸ‘‹ OAuth authentication cancelled. Use API key for reliable access.")
                    return 0
            except (KeyboardInterrupt, EOFError):
                print("\nðŸ‘‹ OAuth authentication cancelled.")
                return 0

            print("\nðŸ”„ Proceeding with experimental OAuth authentication...")
            success = await oauth_client.authenticate()
            if success:
                print("\nâœ… Successfully authenticated with your Claude subscription!")
                print("âš ï¸  Note: This authentication is experimental and may not work for API calls.")

                # DO NOT update configuration to use subscription automatically
                # Keep this as experimental only
                config_manager = get_config()
                config_manager.set("llm.provider", "anthropic")
                # Do NOT set use_subscription to True - keep it experimental only
                print("âœ… OAuth credentials stored for experimental use.")
                print("ðŸ’¡ Main authentication still uses API key for reliability.")

                return 0
            else:
                print("\nâŒ Authentication failed. Please try again.")
                return 1

        elif oauth_action == "logout":
            print("ðŸ”“ Logging out and clearing experimental OAuth credentials...")
            success = await oauth_client.logout()
            if success:
                print("âœ… Successfully logged out. Experimental OAuth credentials cleared.")
                print("ðŸ’¡ Your main API key authentication remains unchanged.")

                # Ensure subscription is disabled
                config_manager = get_config()
                config_manager.set("llm.use_subscription", False)
                print("âœ… Configuration updated to disable subscription authentication.")

                return 0
            else:
                print("âŒ Logout failed.")
                return 1

        elif oauth_action == "status":
            print("ðŸ“Š Experimental OAuth Authentication Status:")
            print("âš ï¸  Note: OAuth authentication is experimental and not used in main flow.")

            # Load credentials and check status
            await oauth_client.load_credentials()
            status_info = oauth_client.get_status_info()

            if status_info["authenticated"]:
                print("âœ… Status: Authenticated")
                print(f"ðŸ”‘ Token: {status_info['access_token']}")
                print(f"ðŸ†” Client ID: {status_info['client_id']}")
                if status_info["expires_at"]:
                    from datetime import datetime
                    expires = datetime.fromisoformat(status_info["expires_at"])
                    print(f"â° Token expires: {expires.strftime('%Y-%m-%d %H:%M:%S')}")
                if status_info["user_info"]:
                    user_info = status_info["user_info"]
                    if "email" in user_info:
                        print(f"ðŸ‘¤ User: {user_info['email']}")
                    if "plan" in user_info:
                        print(f"ðŸ“‹ Plan: Claude {user_info['plan'].title()}")
            else:
                print("âŒ Status: Not authenticated")
                print("Run 'aii config oauth login' to authenticate with your subscription.")

            # Show configuration status
            config_manager = get_config()
            use_subscription = config_manager.get("llm.use_subscription", False)
            print(f"âš™ï¸  Subscription mode: {'Enabled' if use_subscription else 'Disabled'}")

            return 0

        else:
            print("Available OAuth commands:")
            print("  login  - Login with your Claude Pro/Max subscription")
            print("  logout - Logout and clear credentials")
            print("  status - Show authentication status")
            return 1

    except Exception as e:
        print(f"OAuth command failed: {e}")
        return 1


async def handle_doctor_command(parsed_cmd: Any, engine: AIIEngine) -> int:
    """Handle doctor/health check commands"""
    from .cli.health_check import HealthCheckRunner
    from .config.manager import get_config

    try:
        # Create health check runner
        output_config = engine.output_config if hasattr(engine, 'output_config') else None
        runner = HealthCheckRunner(
            use_colors=output_config.use_colors if output_config else True,
            use_emojis=output_config.use_emojis if output_config else True,
        )

        # Register all default checks
        runner.register_default_checks()

        # Build context for health checks
        config_manager = get_config()
        context = {
            "config_manager": config_manager,
            "llm_provider": engine.llm_provider,
            "web_client": engine.web_client,
            "storage_path": engine.storage_path,
            "function_registry": engine.function_registry,
            "cost_calculator": engine.cost_calculator if hasattr(engine, 'cost_calculator') else None,
            "output_config": output_config,
        }

        # Run all health checks
        results = await runner.run_all(context)

        # Format and display results
        output = runner.format_results(results)
        print(output)

        # Return exit code based on results
        failed_count = sum(1 for r in results if r.status.value == "failed")
        return 1 if failed_count > 0 else 0

    except Exception as e:
        print(f"âŒ Health check error: {str(e)}")
        import traceback
        traceback.print_exc()
        return 1


def cli_main() -> int:
    """CLI entry point (synchronous wrapper)"""
    return asyncio.run(main())


if __name__ == "__main__":
    sys.exit(cli_main())
