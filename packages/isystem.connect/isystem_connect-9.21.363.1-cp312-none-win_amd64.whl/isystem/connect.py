# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _connect
else:
    import _connect

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_SwigPyIterator

    def value(self):
        return _connect.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _connect.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _connect.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _connect.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _connect.SwigPyIterator_equal(self, x)

    def copy(self):
        return _connect.SwigPyIterator_copy(self)

    def next(self):
        return _connect.SwigPyIterator_next(self)

    def __next__(self):
        return _connect.SwigPyIterator___next__(self)

    def previous(self):
        return _connect.SwigPyIterator_previous(self)

    def advance(self, n):
        return _connect.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _connect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _connect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _connect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _connect.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _connect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _connect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _connect:
_connect.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _connect.SHARED_PTR_DISOWN
class ucharArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _connect.ucharArray_swiginit(self, _connect.new_ucharArray(nelements))
    __swig_destroy__ = _connect.delete_ucharArray

    def __getitem__(self, index):
        return _connect.ucharArray___getitem__(self, index)

    def __setitem__(self, index, value):
        return _connect.ucharArray___setitem__(self, index, value)

    def cast(self):
        return _connect.ucharArray_cast(self)

    @staticmethod
    def frompointer(t):
        return _connect.ucharArray_frompointer(t)

# Register ucharArray in _connect:
_connect.ucharArray_swigregister(ucharArray)
cvar = _connect.cvar
S_OK = cvar.S_OK
S_FALSE = cvar.S_FALSE

ICONNECT_E_CONNECT_FAILED = _connect.ICONNECT_E_CONNECT_FAILED
r"""The server is not reachable on the specified IP address and port"""
ICONNECT_E_VERSION_CONFLICT = _connect.ICONNECT_E_VERSION_CONFLICT
r"""The client and server versions are incompatible"""
ICONNECT_E_ALREADY_CONNECTED = _connect.ICONNECT_E_ALREADY_CONNECTED
r"""The iCONNECT object is already attached"""
ICONNECT_E_NOT_CONNECTED = _connect.ICONNECT_E_NOT_CONNECTED
r"""The iCONNECT object is not attached"""
ICONNECT_E_FILE_NOT_FOUND = _connect.ICONNECT_E_FILE_NOT_FOUND
r"""File not found"""
ICONNECT_E_CAN_NOT_ACCESS = _connect.ICONNECT_E_CAN_NOT_ACCESS
r"""Evaluation required a memory access which could not be performed"""
ICONNECT_E_BAD_ID = _connect.ICONNECT_E_BAD_ID
r"""Expression could not be evaluated"""
ICONNECT_E_NOT_SIMPLE_TYPE = _connect.ICONNECT_E_NOT_SIMPLE_TYPE
r"""Expression does not evaluate to a simple type"""
ICONNECT_E_ERROR = _connect.ICONNECT_E_ERROR
r"""Error occurred while performing the requested operation"""
ICONNECT_E_NO_BREAKPOINT = _connect.ICONNECT_E_NO_BREAKPOINT
r"""No breakpoint was found at the specified address"""
ICONNECT_E_NOT_AVAILABLE = _connect.ICONNECT_E_NOT_AVAILABLE
r"""The requested operation is not available"""
ICONNECT_E_SIZE = _connect.ICONNECT_E_SIZE
r"""Parameter size invalid"""
ICONNECT_E_ALREADY_EXISTS = _connect.ICONNECT_E_ALREADY_EXISTS
r"""Creation failed because an object with same name already exists"""
ICONNECT_E_TIMEOUT = _connect.ICONNECT_E_TIMEOUT
r"""timeout occurred in processing the operation"""
ICONNECT_E_LICENSE = _connect.ICONNECT_E_LICENSE
r"""license for the current operation is not available"""
ICONNECT_E_BUSY = _connect.ICONNECT_E_BUSY
r"""The requested operation is unavailable because the called object is busy"""
ICONNECT_E_MSG_FAIL = _connect.ICONNECT_E_MSG_FAIL
r"""Internal usage. The call failed with an error message."""
ICONNECT_E_ROUTING = _connect.ICONNECT_E_ROUTING
r"""Error occurred while routing the message from ser/des to winIDEA iConnect implementation"""
ICONNECT_E_UMI_FAIL = _connect.ICONNECT_E_UMI_FAIL
r"""UMI operation failed. LSB byte of the error code contains monitor error code"""
ICONNECT_UMI_EXC_ERR_MASK = _connect.ICONNECT_UMI_EXC_ERR_MASK
r"""these 8 bits holds UMI monitor fpcXXX operation result"""
ICONNECT_S_SIZE = _connect.ICONNECT_S_SIZE
r"""Function succeeded but could not return all the data due to output buffer size limitation"""
ICONNECT_S_MSG_FAIL = _connect.ICONNECT_S_MSG_FAIL
r"""
    Internal Usage. The call failed with an error message box.
    There is no exact return code.
    Call GetLastError() for more information.
    """
ICONNECT_S_MSG_WARN = _connect.ICONNECT_S_MSG_WARN
r"""The call passed with a warning"""
ICONNECT_S_STATUS_1 = _connect.ICONNECT_S_STATUS_1
r"""Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_2 = _connect.ICONNECT_S_STATUS_2
r"""Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_3 = _connect.ICONNECT_S_STATUS_3
r"""Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_4 = _connect.ICONNECT_S_STATUS_4
r"""Status of a document is neither idle, nor default busy"""
ICONNECT_S_STATUS_FLAGSMASK = _connect.ICONNECT_S_STATUS_FLAGSMASK
r"""
    these 8 bits can return information on the status, if dsReturnFlags is specified in the Document(daStatus call)
    the encoded values are document specific (e.g. IConnectIDE::EStatusFlagsAnalyzer)
    """
class IConnect(object):
    r"""This struct defines flags used by isystem.connect API."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eWinIDEA = _connect.IConnect_eWinIDEA
    eWinIDEAc = _connect.IConnect_eWinIDEAc
    dfCloseServerNone = _connect.IConnect_dfCloseServerNone
    r"""server will not close"""
    dfCloseServerIfLastClient = _connect.IConnect_dfCloseServerIfLastClient
    r"""server will exit if this is the last client attached"""
    dfCloseServerUnconditional = _connect.IConnect_dfCloseServerUnconditional
    r"""server will exit unconditionally. In this case (and if shared memory connection is used), Detach becomes a blocking call until server exits"""
    dfCloseServerMask = _connect.IConnect_dfCloseServerMask
    dfCloseAutoSaveDefault = _connect.IConnect_dfCloseAutoSaveDefault
    r"""upon exiting prompt by default"""
    dfCloseAutoSaveAll = _connect.IConnect_dfCloseAutoSaveAll
    r"""upon exiting save all"""
    dfCloseAutoSaveNone = _connect.IConnect_dfCloseAutoSaveNone
    r"""upon exiting discard all"""
    dfCloseAutoSaveMask = _connect.IConnect_dfCloseAutoSaveMask
    lfStartNever = _connect.IConnect_lfStartNever
    lfStartIfRequired = _connect.IConnect_lfStartIfRequired
    r"""Starts winIDEA if an instance isn't running yet"""
    lfStartAlways = _connect.IConnect_lfStartAlways
    r"""Always launch a new instance"""
    lfStartExisting = _connect.IConnect_lfStartExisting
    r"""Find an existing instance, do not launch new"""
    lfStartEnumerate = _connect.IConnect_lfStartEnumerate
    r"""When used, all instances of winIDEA with pszID on pszIPAddress will be enumerated"""
    lfStartMask = _connect.IConnect_lfStartMask
    r"""mask for **lfStart** values"""
    lfWaitDefault = _connect.IConnect_lfWaitDefault
    r"""Currently one second"""
    lfWait30ms = _connect.IConnect_lfWait30ms
    r"""30 milliseconds"""
    lfWait100ms = _connect.IConnect_lfWait100ms
    r"""100 milliseconds"""
    lfWait300ms = _connect.IConnect_lfWait300ms
    r"""300 milliseconds"""
    lfWait1s = _connect.IConnect_lfWait1s
    r"""1 second"""
    lfWait3s = _connect.IConnect_lfWait3s
    r"""3 seconds"""
    lfWait10s = _connect.IConnect_lfWait10s
    r"""10 seconds"""
    lfWait30s = _connect.IConnect_lfWait30s
    r"""30 seconds"""
    lfWaitMask = _connect.IConnect_lfWaitMask
    r"""mask for **lfWait** values"""
    lfUseIPCDiscovery = _connect.IConnect_lfUseIPCDiscovery
    r"""locally running winIDEA instances will be discovered using local IPC discovery"""
    lfShowDefault = _connect.IConnect_lfShowDefault
    r"""No special provision."""
    lfShowMinimized = _connect.IConnect_lfShowMinimized
    r"""winIDEA is started minimized"""
    lfShowMaximized = _connect.IConnect_lfShowMaximized
    r"""winIDEA is started maximized"""
    lfShowHidden = _connect.IConnect_lfShowHidden
    r"""winIDEA is started hidden"""
    lfShowMask = _connect.IConnect_lfShowMask
    r"""mask for **lfShow** values"""
    lfDiag_1 = _connect.IConnect_lfDiag_1
    r"""internal usse"""

    def __init__(self):
        _connect.IConnect_swiginit(self, _connect.new_IConnect())
    __swig_destroy__ = _connect.delete_IConnect

# Register IConnect in _connect:
_connect.IConnect_swigregister(IConnect)
class IConnectDebug(object):
    r"""This struct defines flags used by isystem.connect API."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fMonitor = _connect.IConnectDebug_fMonitor
    r"""Use regular memory access"""
    fRealTime = _connect.IConnectDebug_fRealTime
    r"""Use real time access"""
    fMemMask = _connect.IConnectDebug_fMemMask
    r"""mask for fMonitor and fRealTime values"""
    fCore = _connect.IConnectDebug_fCore
    r"""CPU core register or memory access"""
    fSFR = _connect.IConnectDebug_fSFR
    r"""
    Special function register, used only in ReadRegister()
    and WriteRegister(), ignored in other functions
    """
    fSoC = _connect.IConnectDebug_fSoC
    r"""SoC bus access, memory area is the bus index to access"""
    fModule = _connect.IConnectDebug_fModule
    r"""SoC module access, memory area is the module index to access"""
    fRegMask = _connect.IConnectDebug_fRegMask
    fCacheNever = _connect.IConnectDebug_fCacheNever
    r"""do not cache the access"""
    fCacheDefault = _connect.IConnectDebug_fCacheDefault
    r"""cache according to server settings"""
    fCacheStop = _connect.IConnectDebug_fCacheStop
    r"""cache while the CPU is stopped"""
    fCacheCode = _connect.IConnectDebug_fCacheCode
    r"""get code from cached download"""
    fCacheMask = _connect.IConnectDebug_fCacheMask
    r"""mask for **fCacheXXX** values"""
    fNoRefresh = _connect.IConnectDebug_fNoRefresh
    r"""do not refresh winIDEA GUI after write operation"""
    fDirect = _connect.IConnectDebug_fDirect
    r"""access memory directly, bypass any programmable devices"""
    fAccessFlagsMask = _connect.IConnectDebug_fAccessFlagsMask
    r"""higher bits used by individual functions specifically"""
    gafExpression = _connect.IConnectDebug_gafExpression
    r"""
    No enumeration, address of any
    L-value expression can be retrieved
    """
    gafVariables = _connect.IConnectDebug_gafVariables
    r"""enum variables (data objects)"""
    gafLabels = _connect.IConnectDebug_gafLabels
    r"""enum global code labels"""
    gafFunctions = _connect.IConnectDebug_gafFunctions
    r"""enum function objects"""
    gafEnumMask = _connect.IConnectDebug_gafEnumMask
    r"""mask for **gafXXX** values"""
    gafEnumIndexMask = _connect.IConnectDebug_gafEnumIndexMask
    r"""
    mask for enum index. Set this, if there
    is more than one symbol with the same name
    """
    gafEnumIndexOfs = _connect.IConnectDebug_gafEnumIndexOfs
    r"""
    bit offset of the enum index, can be used as
    shift count.
    """
    gafType2 = _connect.IConnectDebug_gafType2
    r"""valid only with gafExpression, if set pType is interpreted as SType2"""
    gafUseFile = _connect.IConnectDebug_gafUseFile
    r"""enum specific partition only"""
    gafFileMask = _connect.IConnectDebug_gafFileMask
    r"""which partition to use"""
    gafFileOfs = _connect.IConnectDebug_gafFileOfs
    r"""bit offset of the partition"""
    efDefaultMemAreaDisplay = _connect.IConnectDebug_efDefaultMemAreaDisplay
    r"""if set, setting in winIDEA is used for mem area display"""
    efNoMemAreaDisplay = _connect.IConnectDebug_efNoMemAreaDisplay
    r"""
    if set, memory area is not displayed with pointers and
    addresses. It changed from 0x01000000 to 0x01000100, eventually 0x00000100
    """
    efVagueFloatEqual = _connect.IConnectDebug_efVagueFloatEqual
    r"""if vague, 1e-5 tolerance is considered equal"""
    efIgnorePointerAssignType = _connect.IConnectDebug_efIgnorePointerAssignType
    r"""if set, pointer type compatibility is not checked on assignments to pointer type"""
    efType2 = _connect.IConnectDebug_efType2
    r"""if set pType is interpreted as SType2"""
    efAllowTernaryOperator = _connect.IConnectDebug_efAllowTernaryOperator
    r"""the ? and : are valid in expression"""
    sVariables = _connect.IConnectDebug_sVariables
    r"""Global variables (data objects)"""
    sLabels = _connect.IConnectDebug_sLabels
    r"""Global code labels"""
    sFunctions = _connect.IConnectDebug_sFunctions
    r"""High level functions"""
    sLines = _connect.IConnectDebug_sLines
    r"""Source lines"""
    sConstants = _connect.IConnectDebug_sConstants
    r"""Global constants"""
    sSourceCode = _connect.IConnectDebug_sSourceCode
    r"""Source line text"""
    sScopeExact = _connect.IConnectDebug_sScopeExact
    r"""return symbol whose starting address matches aAddress exactly"""
    sScopeNarrow = _connect.IConnectDebug_sScopeNarrow
    r"""return symbol which spans over aAddress. For structured types or arrays the narrow scope is returned, e.g. A.B[3].C"""
    sScopeWide = _connect.IConnectDebug_sScopeWide
    r"""return symbol which spans over aAddress. For structured types or arrays the wide scope is returned, e.g. A"""
    sScopeMask = _connect.IConnectDebug_sScopeMask
    bAddress = _connect.IConnectDebug_bAddress
    r"""Use the aAddress as breakpoint address"""
    bSymbol = _connect.IConnectDebug_bSymbol
    r"""Use the pszAddress as breakpoint address"""
    bSource = _connect.IConnectDebug_bSource
    r"""Use the pszAddress and dwLine as breakpoint address"""
    bAddrMask = _connect.IConnectDebug_bAddrMask
    r"""mask for address type values"""
    bHW = _connect.IConnectDebug_bHW
    r"""
    it's a HW BP (set/enable/disable apply)
    if bSet is used, the bHW_XXXX flags are considered
    """
    bSet = _connect.IConnectDebug_bSet
    r"""Set a breakpoint"""
    bClear = _connect.IConnectDebug_bClear
    r"""Clear a breakpoint"""
    bEnable = _connect.IConnectDebug_bEnable
    r"""Enable a breakpoint"""
    bDisable = _connect.IConnectDebug_bDisable
    r"""Disable a breakpoint"""
    bAll = _connect.IConnectDebug_bAll
    r"""
    Use in combination with bClear, bDisable, bEnable and
    bReapply. When used, it applies to all configured
    breakpoints.
    """
    bReapply = _connect.IConnectDebug_bReapply
    r"""reapplies BP if it is active currently"""
    bSetMask = _connect.IConnectDebug_bSetMask
    r"""mask for breakpoint action values"""
    bHW_accAny = _connect.IConnectDebug_bHW_accAny
    r"""any access to the symbol/address"""
    bHW_accRD = _connect.IConnectDebug_bHW_accRD
    r"""read access to the symbol/address"""
    bHW_accWR = _connect.IConnectDebug_bHW_accWR
    r"""write access to the symbol/address"""
    bHW_accRW = _connect.IConnectDebug_bHW_accRW
    r"""read or write access to the symbol/address"""
    bHW_accFetch = _connect.IConnectDebug_bHW_accFetch
    r"""instruction fetch from the symbol/address"""
    bHW_accMask = _connect.IConnectDebug_bHW_accMask
    r"""mask to extract access"""
    bHW_EntireObject = _connect.IConnectDebug_bHW_EntireObject
    r"""cover entire object specified in symbol"""
    bHW_SizeDefault = _connect.IConnectDebug_bHW_SizeDefault
    r"""default access size"""
    bHW_Size1 = _connect.IConnectDebug_bHW_Size1
    r"""access size is 1 MAU"""
    bHW_Size2 = _connect.IConnectDebug_bHW_Size2
    r"""access size is 2 MAU"""
    bHW_Size4 = _connect.IConnectDebug_bHW_Size4
    r"""access size is 4 MAU"""
    bHW_Size8 = _connect.IConnectDebug_bHW_Size8
    r"""access size is 8 MAU"""
    bHW_SizeMask = _connect.IConnectDebug_bHW_SizeMask
    r"""mask to extract access size"""
    bHW_DataMask = _connect.IConnectDebug_bHW_DataMask
    r"""data mask - the bits set determine which byte of dwLine is used for data value comparison (00 = no data, FF = all)"""
    bHW_DataLSB0 = _connect.IConnectDebug_bHW_DataLSB0
    r"""LSB0 data byte is considered"""
    bHW_DataLSB1 = _connect.IConnectDebug_bHW_DataLSB1
    r"""LSB1 data byte is considered"""
    bHW_DataLSB2 = _connect.IConnectDebug_bHW_DataLSB2
    r"""LSB2 data byte is considered"""
    bHW_DataLSB3 = _connect.IConnectDebug_bHW_DataLSB3
    r"""LSB3 data byte is considered"""
    bHW_DataLSB4 = _connect.IConnectDebug_bHW_DataLSB4
    r"""LSB4 data byte is considered"""
    bHW_DataLSB5 = _connect.IConnectDebug_bHW_DataLSB5
    r"""LSB5 data byte is considered"""
    bHW_DataLSB6 = _connect.IConnectDebug_bHW_DataLSB6
    r"""LSB6 data byte is considered"""
    bHW_DataLSB7 = _connect.IConnectDebug_bHW_DataLSB7
    r"""LSB7 data byte is considered"""
    rNothing = _connect.IConnectDebug_rNothing
    r"""do nothing"""
    rReset = _connect.IConnectDebug_rReset
    r"""Reset the CPU"""
    rResetAndRun = _connect.IConnectDebug_rResetAndRun
    r"""Reset the CPU, then runs immediately"""
    rDownload = _connect.IConnectDebug_rDownload
    r"""Download the executable"""
    rStop = _connect.IConnectDebug_rStop
    r"""Stop the CPU"""
    rRun = _connect.IConnectDebug_rRun
    r"""Run the CPU"""
    rStep = _connect.IConnectDebug_rStep
    r"""
    Execute a single step instruction or high level step
    depending on context
    """
    rStepOver = _connect.IConnectDebug_rStepOver
    r"""rStep, do not enter subroutine calls"""
    rStepInst = _connect.IConnectDebug_rStepInst
    r"""Execute a single instruction step"""
    rStepOverInst = _connect.IConnectDebug_rStepOverInst
    r"""rStepInst, do not enter subroutine calls"""
    rStepHigh = _connect.IConnectDebug_rStepHigh
    r"""Execute a high level step"""
    rStepOverHigh = _connect.IConnectDebug_rStepOverHigh
    r"""rStepHigh, do not enter function calls"""
    rRunUntil = _connect.IConnectDebug_rRunUntil
    r"""Run until aAddress"""
    rRunUntilReturn = _connect.IConnectDebug_rRunUntilReturn
    r"""Run until current function returns"""
    rGoto = _connect.IConnectDebug_rGoto
    r"""Preset execution point to aAddress"""
    rSnapshot = _connect.IConnectDebug_rSnapshot
    r"""refresh the IDE"""
    rVerify = _connect.IConnectDebug_rVerify
    r"""perform verify, S_OK/ICONNECT_E_ERROR/ICONNECT_E_NOT_AVAILABLE return"""
    rDownloadNoCode = _connect.IConnectDebug_rDownloadNoCode
    r"""Download without code - initialize target and load symbols"""
    rAttach = _connect.IConnectDebug_rAttach
    r"""hot-attach to the target"""
    rDetach = _connect.IConnectDebug_rDetach
    r"""hot-detach from the target"""
    rSlowRunOff = _connect.IConnectDebug_rSlowRunOff
    r"""switch slow run off. Return: S_OK on success, S_FALSE if already configured, E_NOTIMPL if not implemented, ICONNECT_E_NOT_AVAILABLE if changing is currently not available"""
    rSlowRunOn = _connect.IConnectDebug_rSlowRunOn
    r"""switch slow run on   Return: S_OK on success, S_FALSE if already configured, E_NOTIMPL if not implemented, ICONNECT_E_NOT_AVAILABLE if changing is currently not available"""
    rRunMask = _connect.IConnectDebug_rRunMask
    r"""mask for **rXXX** values"""
    rWaitForStop = _connect.IConnectDebug_rWaitForStop
    r"""wait for CPU to stop after the current command."""
    rWaitTimeout10s = _connect.IConnectDebug_rWaitTimeout10s
    r"""wait 10s for stop"""
    rWaitTimeout1s = _connect.IConnectDebug_rWaitTimeout1s
    r"""wait 1s for stop. [deprecated] now 3s"""
    rWaitTimeout3s = _connect.IConnectDebug_rWaitTimeout3s
    r"""wait 3s for stop"""
    rWaitTimeout100s = _connect.IConnectDebug_rWaitTimeout100s
    r"""wait 100s for stop"""
    rWaitTimeoutInf = _connect.IConnectDebug_rWaitTimeoutInf
    r"""wait infinitely for stop"""
    rWaitTimeoutMask = _connect.IConnectDebug_rWaitTimeoutMask
    r"""mask for **rWaitTimeoutXXX** values"""
    rPollingOff = _connect.IConnectDebug_rPollingOff
    r"""disable periodic polling"""
    rPollingOn = _connect.IConnectDebug_rPollingOn
    r"""enable periodic polling (default)"""
    rPollingMask = _connect.IConnectDebug_rPollingMask
    r"""mask for **rPollingXXX** values"""
    rTristateOff = _connect.IConnectDebug_rTristateOff
    r"""switch tristate mode off (connect debugger to target)"""
    rTristateOn = _connect.IConnectDebug_rTristateOn
    r"""switch tristate mode on  (disconnect debugger from target)"""
    rTristateMask = _connect.IConnectDebug_rTristateMask
    r"""mask for **rTristateXXX** values"""
    rTargetHWConnectOff = _connect.IConnectDebug_rTargetHWConnectOff
    r"""physically disconnect from target"""
    rTargetHWConnectOn = _connect.IConnectDebug_rTargetHWConnectOn
    r"""physically connect to target"""
    rTargetHWConnectMask = _connect.IConnectDebug_rTargetHWConnectMask
    r"""mask for **rTargetHWConnectXXX** values"""

    def __init__(self):
        _connect.IConnectDebug_swiginit(self, _connect.new_IConnectDebug())
    __swig_destroy__ = _connect.delete_IConnectDebug

# Register IConnectDebug in _connect:
_connect.IConnectDebug_swigregister(IConnectDebug)
class IConnectIDE(object):
    r"""This struct defines flags used by isystem.connect API."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    deFormatMask = _connect.IConnectIDE_deFormatMask
    r"""use this mask to select the export format"""
    deScopeAll = _connect.IConnectIDE_deScopeAll
    r"""export entire document"""
    deScopeSelection = _connect.IConnectIDE_deScopeSelection
    r"""export selection only"""
    deScopeMask = _connect.IConnectIDE_deScopeMask
    r"""mask to use for scope selection"""
    drContent = _connect.IConnectIDE_drContent
    r"""deletes content of analyzer documents, has no effect for text documents"""
    drItem = _connect.IConnectIDE_drItem
    r"""action applies to the aspect given in drItemMask"""
    drItemMask = _connect.IConnectIDE_drItemMask
    r"""index of the document aspect"""
    drConfigAll = _connect.IConnectIDE_drConfigAll
    r"""action applies to all configuration"""
    drConfigSelected = _connect.IConnectIDE_drConfigSelected
    r"""action applies to the selected aspect (trigger, rangeset,...)"""
    drConfigPresetInit = _connect.IConnectIDE_drConfigPresetInit
    r"""Initializes preset configuration"""
    drConfigPresetApply = _connect.IConnectIDE_drConfigPresetApply
    r"""Applies preset configuration"""
    drConfigMask = _connect.IConnectIDE_drConfigMask
    r"""config. flags selection mask"""

    def __init__(self):
        _connect.IConnectIDE_swiginit(self, _connect.new_IConnectIDE())
    __swig_destroy__ = _connect.delete_IConnectIDE

# Register IConnectIDE in _connect:
_connect.IConnectIDE_swigregister(IConnectIDE)
class IConnectProfiler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cfTimeStampCycles = _connect.IConnectProfiler_cfTimeStampCycles
    cfTimeStampTime = _connect.IConnectProfiler_cfTimeStampTime
    r"""Default time resolution."""
    cfTimeStampM0 = _connect.IConnectProfiler_cfTimeStampM0
    r"""magnitude 0 - seconds level resolution"""
    cfTimeStampM1 = _connect.IConnectProfiler_cfTimeStampM1
    r"""magnitude 1 - 100 ms  level resolution"""
    cfTimeStampM2 = _connect.IConnectProfiler_cfTimeStampM2
    r"""magnitude 2 -  10 ms  level resolution"""
    cfTimeStampM3 = _connect.IConnectProfiler_cfTimeStampM3
    r"""magnitude 3 -   1 ms  level resolution"""
    cfTimeStampM4 = _connect.IConnectProfiler_cfTimeStampM4
    r"""magnitude 4 - 100 us  level resolution"""
    cfTimeStampM5 = _connect.IConnectProfiler_cfTimeStampM5
    r"""magnitude 5 -  10 us  level resolution"""
    cfTimeStampM6 = _connect.IConnectProfiler_cfTimeStampM6
    r"""magnitude 6 -   1 us  level resolution"""
    cfTimeStampM7 = _connect.IConnectProfiler_cfTimeStampM7
    r"""magnitude 7 - 100 ns  level resolution"""
    cfTimeStampM8 = _connect.IConnectProfiler_cfTimeStampM8
    r"""magnitude 8 -  10 ns  level resolution"""
    cfTimeStampM9 = _connect.IConnectProfiler_cfTimeStampM9
    r"""magnitude 9 -   1 ns  level resolution"""
    cfTimeStampMask = _connect.IConnectProfiler_cfTimeStampMask
    r"""mask for **cfXXX** values"""
    gsfNumRecorded = _connect.IConnectProfiler_gsfNumRecorded
    r"""m_dwNumAvailable specifies the number of recorded samples"""
    gsfNumAnalyzed = _connect.IConnectProfiler_gsfNumAnalyzed
    r"""m_dwNumAvailable specifies the number of analyzed samples"""
    gsfNumMask = _connect.IConnectProfiler_gsfNumMask

    def __init__(self):
        _connect.IConnectProfiler_swiginit(self, _connect.new_IConnectProfiler())
    __swig_destroy__ = _connect.delete_IConnectProfiler

# Register IConnectProfiler in _connect:
_connect.IConnectProfiler_swigregister(IConnectProfiler)
class IConnectProject(object):
    r"""This struct defines flags used by isystem.connect API."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ofaGet = _connect.IConnectProject_ofaGet
    r"""retrieves an option value"""
    ofaEnum = _connect.IConnectProject_ofaEnum
    r"""
    enumerates project items, for example project files,
    include directories, etc. The lower 16
    bits of dwOptionFlags (ofaEnumIndexMask) should
    contain the index number of the option.
    If the index is larger than the entity size, the function
    will return S_FALSE.

    """
    ofaSet = _connect.IConnectProject_ofaSet
    r"""sets an option value"""
    ofaAdd = _connect.IConnectProject_ofaAdd
    r"""adds an option value (e.g. a project file)"""
    ofaRmv = _connect.IConnectProject_ofaRmv
    r"""removes an option (e.g. a project file)"""
    ofaMov = _connect.IConnectProject_ofaMov
    r"""
    Moves an option to a different location (e.g. move a
    project file to a different group)
    """
    ofaMask = _connect.IConnectProject_ofaMask
    r"""mask for **ofaXXX** values"""
    ofaRelativePaths = _connect.IConnectProject_ofaRelativePaths
    r"""return relative file paths"""
    ofaEnumIndexMask = _connect.IConnectProject_ofaEnumIndexMask
    r"""mask to use on index for ofaEnum"""

    def __init__(self):
        _connect.IConnectProject_swiginit(self, _connect.new_IConnectProject())
    __swig_destroy__ = _connect.delete_IConnectProject

# Register IConnectProject in _connect:
_connect.IConnectProject_swigregister(IConnectProject)
class IConnectDebug2(object):
    r"""This struct defines flags used by isystem.connect API."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ccOpRead = _connect.IConnectDebug2_ccOpRead
    r"""read from target. pICodeCache on entry specifies the regions to read"""
    ccOpWrite = _connect.IConnectDebug2_ccOpWrite
    r"""write to target"""
    ccOpLoad = _connect.IConnectDebug2_ccOpLoad
    r"""read from file"""
    ccOpSave = _connect.IConnectDebug2_ccOpSave
    r"""save to file"""
    ccOpGet = _connect.IConnectDebug2_ccOpGet
    r"""use source and return. if pszFileName is not empty, code for pszFileName is returned"""
    ccOpVerify = _connect.IConnectDebug2_ccOpVerify
    r"""perform download verify, return dif. if pszFileName is not empty, operation is performed only on it"""
    ccOpVerifySave = _connect.IConnectDebug2_ccOpVerifySave
    r"""same as ccOpVerify. The dif result is saved to file specified in pszParam"""
    ccOpMask = _connect.IConnectDebug2_ccOpMask
    r"""mask for operation"""
    ccSrcLoaded = _connect.IConnectDebug2_ccSrcLoaded
    r"""code put into target at download time"""
    ccSrcInFiles = _connect.IConnectDebug2_ccSrcInFiles
    r"""code contained in download files"""
    ccSrcFiltered = _connect.IConnectDebug2_ccSrcFiltered
    r"""code contained in download files, minus exclusions"""
    ccSrcMask = _connect.IConnectDebug2_ccSrcMask
    ccSaveFormatMotorolaS37 = _connect.IConnectDebug2_ccSaveFormatMotorolaS37
    r"""with ccOpSave operation, specifies Motorola S37 output"""
    ccSaveFormatIntelHex = _connect.IConnectDebug2_ccSaveFormatIntelHex
    r"""use Intel hex format"""
    ccSaveFormatBinary = _connect.IConnectDebug2_ccSaveFormatBinary
    r"""use binary format"""
    ccSaveFormatMask = _connect.IConnectDebug2_ccSaveFormatMask
    ccSaveBytes10 = _connect.IConnectDebug2_ccSaveBytes10
    r"""when saving save 0x10 bytes per line"""
    ccSaveBytes20 = _connect.IConnectDebug2_ccSaveBytes20
    r"""when saving save 0x20 bytes per line"""
    ccSaveBytes40 = _connect.IConnectDebug2_ccSaveBytes40
    r"""when saving save 0x40 bytes per line"""
    ccSaveBytes80 = _connect.IConnectDebug2_ccSaveBytes80
    r"""when saving save 0x80 bytes per line"""
    ccSaveBytesMask = _connect.IConnectDebug2_ccSaveBytesMask
    ccNoData = _connect.IConnectDebug2_ccNoData
    r"""for Load, GetLoaded, GetInFile operations - data is not required"""

    def __init__(self):
        _connect.IConnectDebug2_swiginit(self, _connect.new_IConnectDebug2())
    __swig_destroy__ = _connect.delete_IConnectDebug2

# Register IConnectDebug2 in _connect:
_connect.IConnectDebug2_swigregister(IConnectDebug2)
class IConnectTest(object):
    r"""This struct defines flags used by isystem.connect API."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    efVagueFloatEqual = _connect.IConnectTest_efVagueFloatEqual
    r"""
    Floating point values are compared for
    equality with precision 10e-5.
    """
    efIgnoreLocalScope = _connect.IConnectTest_efIgnoreLocalScope
    r"""Ignore variables in local scope in evaluation"""
    efUseRealTimeAccess = _connect.IConnectTest_efUseRealTimeAccess
    r"""perform access using real-time access"""
    efModifyParameter = _connect.IConnectTest_efModifyParameter
    r"""used in modify call when modifying a function parameter"""
    sfQueryTestCase = _connect.IConnectTest_sfQueryTestCase
    r"""
    On return *pdwStatus will hold the handle of
    the test case now active.
    dwHandle is ignored and should be zero.
    """
    sfQueryStub = _connect.IConnectTest_sfQueryStub
    r"""
    On return *pdwStatus will hold the handle of
    the stub now  active.
    dwHandle is ignored and should be zero.
    """
    sfTestCase = _connect.IConnectTest_sfTestCase
    r"""
    On return *pdwStatus will hold the status of
    the test case. See also IConnectTest::EState
    for possible values.
    dwHandle specifies the test case to be queried.
    """
    sfStub = _connect.IConnectTest_sfStub
    r"""
    On return *pdwStatus will hold the status of
    the stub. See also IConnectTest::EStubState
    for possible values.
    dwHandle specifies the stub to be queried.
    """
    sfException = _connect.IConnectTest_sfException
    r"""
    On return *pdwStatus will hold the status of
    the exception.
    dwHandle specifies the exception to be queried.
    """
    stateOffline = _connect.IConnectTest_stateOffline
    r"""No test case is currently active"""
    stateInitialized = _connect.IConnectTest_stateInitialized
    r"""The test case has been initialized"""
    stateRunning = _connect.IConnectTest_stateRunning
    r"""The test case is in progress"""
    stateEnded = _connect.IConnectTest_stateEnded
    r"""The test case finished execution"""
    stateStub = _connect.IConnectTest_stateStub
    r"""The test case stopped at a stub"""
    stateUnexpectedStop = _connect.IConnectTest_stateUnexpectedStop
    r"""The test case stopped at an unexpected point"""
    stateAborted = _connect.IConnectTest_stateAborted
    r"""The test case was aborted by the user"""
    statePaused = _connect.IConnectTest_statePaused
    r"""The test case was paused by the user"""
    statePersistentReady = _connect.IConnectTest_statePersistentReady
    r"""Persistent variables initialized"""
    stateSystemTest = _connect.IConnectTest_stateSystemTest
    r"""The system test is ready to run"""
    stateStop = _connect.IConnectTest_stateStop
    r"""System test is stopped"""
    stateException = _connect.IConnectTest_stateException
    r"""The test case is stopped in exception handler"""
    stateTimeOut = _connect.IConnectTest_stateTimeOut
    r"""TestCase timed out"""
    stateStubNotActive = _connect.IConnectTest_stateStubNotActive
    r"""The stub is not active"""
    stateStubActive = _connect.IConnectTest_stateStubActive
    r"""The stub is active"""
    cveRegularVariable = _connect.IConnectTest_cveRegularVariable
    r"""The function will behave as CreateVariable"""
    cvePersistentVariable = _connect.IConnectTest_cvePersistentVariable
    r"""
    The variable created will be persistent
    across test cases. To initialize persistent
    variables call the control function using the
    flag
    """
    sfeAutoBreakpoints = _connect.IConnectTest_sfeAutoBreakpoints
    r"""Breakpoints are automatically set on stubbed function"""
    sfeCustomBreakpoints = _connect.IConnectTest_sfeCustomBreakpoints
    r"""Client has to set break point on location of stubbed function manually."""

    def __init__(self):
        _connect.IConnectTest_swiginit(self, _connect.new_IConnectTest())
    __swig_destroy__ = _connect.delete_IConnectTest

# Register IConnectTest in _connect:
_connect.IConnectTest_swigregister(IConnectTest)
WINVER = _connect.WINVER
_WIN32_WINNT = _connect._WIN32_WINNT
_WIN32_WINDOWS = _connect._WIN32_WINDOWS
_WIN32_IE = _connect._WIN32_IE
class CConnectionConfig(object):
    r"""
    This class contains information for connection to winIDEA. Its methods
    return reference to self, so we can use it like this:

    CConnectionConfig config = new CConnectionConfig();
    config.udpDiscoveryPort(5534).instanceId("main");


    All parameters are optional. Set only what is required, default values are
    used for unspecified parameters.



    Python example: _sample_link{advanced,advanced_winidea_launching}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CConnectionConfig_swiginit(self, _connect.new_CConnectionConfig())

    def workspace(self, rstrWorkspace):
        r"""
        Sets winIDEA workspace.

        This value is used to
        - search for an existing instance
        - start a new winIDEA instance.
        """
        return _connect.CConnectionConfig_workspace(self, rstrWorkspace)

    def exe_dir(self, rstr_exe_dir):
        r"""
        Sets directory, where `winIDEA.exe` is located. This value is used to start a new
        winIDEA instance. It is not used to search for an existing instance.
        Set it, when you want to start specific version of winIDEA.
        """
        return _connect.CConnectionConfig_exe_dir(self, rstr_exe_dir)

    def host(self, rstr_host, w_TCP_port=0):
        r"""
        Sets PC host and port of winIDEA to connect to.

        :type rstr_host: string
        :param rstr_host: host name or IP address. If empty string is given,
            the local host is used to look for winIDEA.

        :type w_TCP_port: int, optional
        :param w_TCP_port: specifies the port to connect to.
              If it is not specified or specified with value 0, then discovery (enumeration) is
              performed and connection is made to:
              - the first discovered instance of winIDEA if winIDEA ID is not specified in this object
              - to winIDEA with the specified ID if the ID is specified in this object
              - if winIDEA ID is specified in this object and it is not found, and exception is thrown.

            If winIDEA is not responding on this port, a new instance is not launched.
            To get the port number call `ConnectionMgr::enumerateWinIDEAInstances()`
            and then use the port of winIDEA with expected ID or workspace opened.
            It is recommended to use this setting only when connecting to winIDEA on a
            remote host. For connections to winIDEAs on the local host use winIDEA ID to
            connect to the desired instance.

        Example:

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.host('', 5315)
        """
        return _connect.CConnectionConfig_host(self, rstr_host, w_TCP_port)

    def udpDiscoveryPort(self, w_UDP_discovery_port):
        r"""
        Sets UDP discovery port.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cc.udpDiscoveryPort(5315).getUdpDiscoveryPort()
            5315
        """
        return _connect.CConnectionConfig_udpDiscoveryPort(self, w_UDP_discovery_port)

    def instanceId(self, rstr_instance_ID):
        r"""
        Sets winIDEA instance ID

        This value is used to
        - search for an existing instance
        - start a new winIDEA instance

        Instance ID should not be provided in combination with launch flag
        flStartAlways to prevent launch of multiple instances with the same Id,
        will throw when launch is called.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.instanceId('sdk_example_winIDEA_instanceID')

            >>> cmgr.connect(cc)
        """
        return _connect.CConnectionConfig_instanceId(self, rstr_instance_ID)

    def cmd_line(self, rstr_cmd_line):
        r"""
        Command line parameters for winIDEA

        This value is used to
        - start a new winIDEA instance.

        (it is not used to search for an existing instance)

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.cmd_line('-DEMO')

            >>> cmgr.connect(cc)
        """
        return _connect.CConnectionConfig_cmd_line(self, rstr_cmd_line)

    def cmdLineParams(self, rstr_cmd_line):
        r"""
        _rst
        .. deprecated:: 9.21.325
           Use cmd_line() instead, which is a direct replacement.

        _rst
        """
        return _connect.CConnectionConfig_cmdLineParams(self, rstr_cmd_line)

    def discoveryTime(self, timeout_ms):
        r"""
        This method sets the timeout for winIDEA pre-launch discovery. It is
        used when launch flag `startIfRequired` is specified. The timout is used for
        the first enumeration, which tries to find out if requested winIDEA
        is already running. If it is not running, winIDEA is started, and then the
        second timeout set with `waitTime()` is used to wait for the started winIDEA
        to be actually up and running, which takes more time than discovery of
        already running winIDEAs.
        Default value of 1s should be good for most cases, so this setting rarely
        needs adjustment.

        :type timeout_ms: int
        :param timeout_ms: timeout in ms
        """
        return _connect.CConnectionConfig_discoveryTime(self, timeout_ms)

    def waitTime(self, e_wait_time):
        r"""
        Determines how long the ``isystem.connect`` should wait for newly launched
        instance to respond. Only one of ``lfWaitXXX`` flags from IConnect::ELaunchFlags
        may be specified.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.waitTime(ic.IConnect.lfWait1s)

            >>> cc.getWaitTime() & ic.IConnect.lfWaitMask
            64

            >>> cmgr.connect(cc)
        """
        return _connect.CConnectionConfig_waitTime(self, e_wait_time)

    def useIPCDiscovery(self, b_use_IPC_discovery):
        r"""
        Locally running winIDEA instances will be discovered using local
        IPC discovery.
        Change this setting only when instructed by TASKING support team.

            >>> cc = ic.CConnectionCongif()

            >>> cc.useIPCDiscovery(False).isUseIPCDiscovery()
            False
        """
        return _connect.CConnectionConfig_useIPCDiscovery(self, b_use_IPC_discovery)

    def visibility(self, e_visibility):
        r"""
        Determines how the newly launched instance will start. Only one
        of ``lfShowXXX`` flags from IConnect::ELaunchFlags
        may be specified.

        _rst
        .. note::
           Even if winIDEA is started hidden, UI elements are accessible via SDK

        _rst

        This value is used to
        - start a new winIDEA instance.

        (it is not used to search for an existing instance)

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc.visibility(ic.IConnect.lfShowHidden))

            >>> cc.getVisibility() & ic.IConnect.lfShowMask
            768
        """
        return _connect.CConnectionConfig_visibility(self, e_visibility)

    def headless(self, b_headless):
        r"""
        Determines whether winIDEA is started in headless mode.
        No UI elements are available in this mode.

        This value is used to
        - start a new winIDEA instance.

        (it is not used to search for an existing instance)

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc.headless(True))
        """
        return _connect.CConnectionConfig_headless(self, b_headless)

    def start(self, eStart):
        r"""
        Determines how to potentially start a new winIDEA instance. Only one
        of ``lfStart`` flags from IConnect::ELaunchFlags may be specified.
        If lfStartAlways is provided, instance ID must not be specified
        (exception is thrown) to prevent launch of multiple instances with
        the same ID.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc.start(ic.IConnect.lfStartExisting))

            >>> cc.get_start() & ic.IConnect.lfStartMask
            3
        """
        return _connect.CConnectionConfig_start(self, eStart)

    def start_if_required(self):
        r"""
        Start a new winIDEA instance if no existing is matching the connection criteria.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc.start_if_required())

            >>> cmgr.isConnected()
            True
        """
        return _connect.CConnectionConfig_start_if_required(self)

    def start_always(self):
        r"""
        Always start a new winIDEA instance. If this method is called, instance ID
        must not be specified (exception is thrown) to prevent launch of multiple
        instances with the same ID.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc.start_always())

            >>> cmgr.isConnected()
            True
        """
        return _connect.CConnectionConfig_start_always(self)

    def start_existing(self):
        r"""
        Connect to an existing winIDEA instance. Never start new.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc.start_if_required())

            >>> cmgr.isConnected()
            True

            >>> cmgr.disconnect_keep()

            >>> cmgr.connect(cc.start_existing())

            >>> cmgr.isConnected()
            True
        """
        return _connect.CConnectionConfig_start_existing(self)

    def processId(self, dw_PID):
        return _connect.CConnectionConfig_processId(self, dw_PID)

    def processTCPPort(self, w_TCP_port):
        return _connect.CConnectionConfig_processTCPPort(self, w_TCP_port)

    def should_use_env_vars(self):
        return _connect.CConnectionConfig_should_use_env_vars(self)

    def use_server_env_vars(self):
        return _connect.CConnectionConfig_use_server_env_vars(self)

    def getWorkspace(self):
        r"""
        Returns workspace path.

            >>> cc = ic.CConnectionConfig()

            >>> cc.workspace('path/to/the/workspace').getWorkspace()
            'path/to/the/workspace'
        """
        return _connect.CConnectionConfig_getWorkspace(self)

    def getUdpDiscoveryPort(self):
        r"""
        Returns UDP discovery port.

            >>> cc = ic.CConnectionConfig()

            >>> cc.udpDiscoveryPort(5315).getUdpDiscoveryPort()
            5315
        """
        return _connect.CConnectionConfig_getUdpDiscoveryPort(self)

    def getInstanceId(self):
        r"""
        Returns instanceId.

            >>> cc = ic.CConnectionConfig()

            >>> cc.instanceId('sdk_demo_winideaID').getInstanceId()
            'sdk_demo_winideaID'
        """
        return _connect.CConnectionConfig_getInstanceId(self)

    def getCmdLineParams(self):
        r"""
        Returns command line parameters.

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.cmd_line('-DEMO').getCmdLineParams()
            '-DEMO'
        """
        return _connect.CConnectionConfig_getCmdLineParams(self)

    def getDiscoveryTime(self):
        r"""Returns specified discovery wait time in ms."""
        return _connect.CConnectionConfig_getDiscoveryTime(self)

    def getWaitTime(self):
        r"""
        Returns startup wait time.

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.waitTime(ic.IConnect.lfWait1s)

            >>> cc.getWaitTime() & ic.IConnect.lfWaitMask
            64
        """
        return _connect.CConnectionConfig_getWaitTime(self)

    def isUseIPCDiscovery(self):
        r"""
        Returns true, if IPC discovery should be used.

            >>> cc = ic.CConnectionCongif()

            >>> cc.useIPCDiscovery(False).isUseIPCDiscovery()
            False
        """
        return _connect.CConnectionConfig_isUseIPCDiscovery(self)

    def getVisibility(self):
        r"""
        Returns winIDEA window visibility after startup.

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.visibility(ic.IConnect.lfShowHidden)

            >>> cc.getVisibility() & ic.IConnect.lfShowMask
            768
        """
        return _connect.CConnectionConfig_getVisibility(self)

    def get_start(self):
        r"""
        Returns winIDEA start policy.

            >>> cc = ic.CConnectionConfig()

            >>> cc = cc.start(ic.IConnect.lfStartExisting)

            >>> cc.get_start() & ic.IConnect.lfStartMask
            3
        """
        return _connect.CConnectionConfig_get_start(self)

    def getProcessId(self):
        r"""
        Returns process id. The id is set after call to findExistingInstance(),
        startNewInstance(), or findOrStartInstance(). It is valid only when
        different from 0.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc)

            >>> cc.getProcessId() != 0
            True
        """
        return _connect.CConnectionConfig_getProcessId(self)

    def getTCPPort(self):
        r"""
        Returns TCP port. The port is set after call to findExistingInstance(),
        startNewInstance(), or findOrStartInstance(). It is valid only when
        different from 0.

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc)

            >>> cc.getTCPPort() != 0
            True
        """
        return _connect.CConnectionConfig_getTCPPort(self)

    def get_exe_type(self):
        r"""Returns executable type (gui or command)"""
        return _connect.CConnectionConfig_get_exe_type(self)

    def toString(self):
        return _connect.CConnectionConfig_toString(self)
    __swig_destroy__ = _connect.delete_CConnectionConfig

# Register CConnectionConfig in _connect:
_connect.CConnectionConfig_swigregister(CConnectionConfig)
class WinIDEAInstanceInfo(object):
    r"""
    This class contains information about instance of winIDEA as returned
    by enumeration.


    See also: ConnectionMgr::enumerateWinIDEAInstances
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.WinIDEAInstanceInfo_swiginit(self, _connect.new_WinIDEAInstanceInfo(*args))

    def getWorkspace(self):
        r"""
        Returns workspace path.

           >>> cmgr = ic.ConnectionMgr()

           >>> cc = ic.CConnectionConfig()

           >>> instances = ic.VectorWinIDEAInstanceInfo()

           >>> cmgr.connect(cc.instanceId('sdk_example_winIDEA_ID'))

           >>> cmgr.enumerateWinIDEAInstances('', cc, instances)

           >>> type(instances[0].getWorkspace())
           <class 'str'>
        """
        return _connect.WinIDEAInstanceInfo_getWorkspace(self)

    def getInstanceId(self):
        r"""
        Returns instanceId.

           >>> cmgr = ic.ConnectionMgr()

           >>> cc = ic.CConnectionConfig()

           >>> instances = ic.VectorWinIDEAInstanceInfo()

           >>> cmgr.connect(cc.instanceId('sdk_example_winIDEA_ID'))

           >>> cmgr.enumerateWinIDEAInstances('', cc, instances)

           >>> instances[0].getInstanceId()
           'sdk_example_winIDEA_ID'
        """
        return _connect.WinIDEAInstanceInfo_getInstanceId(self)

    def getTcpPort(self):
        r"""
        Returns TCP port.

           >>> cmgr = ic.ConnectionMgr()

           >>> cc = ic.CConnectionConfig()

           >>> instances = ic.VectorWinIDEAInstanceInfo()

           >>> cmgr.connect(cc)

           >>> cmgr.enumerateWinIDEAInstances('', cc, instances)

           >>> instances[0].getTcpPort()
           5315
        """
        return _connect.WinIDEAInstanceInfo_getTcpPort(self)
    __swig_destroy__ = _connect.delete_WinIDEAInstanceInfo

# Register WinIDEAInstanceInfo in _connect:
_connect.WinIDEAInstanceInfo_swigregister(WinIDEAInstanceInfo)
class Sinstalled_winIDEA(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getMajor(self):
        r"""Returns the major winIDEA version."""
        return _connect.Sinstalled_winIDEA_getMajor(self)

    def getMinor(self):
        r"""Returns the minor winIDEA version."""
        return _connect.Sinstalled_winIDEA_getMinor(self)

    def getBuild(self):
        r"""Returns the winIDEA build number."""
        return _connect.Sinstalled_winIDEA_getBuild(self)

    def get_InstallDir(self):
        r"""Returns the installation directory"""
        return _connect.Sinstalled_winIDEA_get_InstallDir(self)

    def get_deployment(self):
        r"""Returns the deployment"""
        return _connect.Sinstalled_winIDEA_get_deployment(self)

    def get_owner(self):
        r"""Returns the deployment"""
        return _connect.Sinstalled_winIDEA_get_owner(self)

    def __init__(self):
        _connect.Sinstalled_winIDEA_swiginit(self, _connect.new_Sinstalled_winIDEA())
    __swig_destroy__ = _connect.delete_Sinstalled_winIDEA

# Register Sinstalled_winIDEA in _connect:
_connect.Sinstalled_winIDEA_swigregister(Sinstalled_winIDEA)
class ConnectionMgr(object):
    r"""
    This class manages connection to winIDEA.


    Python example: _sample_link{connection_mgr,test_connection_mgr}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EVersionIgnore = _connect.ConnectionMgr_EVersionIgnore
    r"""version is not verified"""
    EVersionWarning = _connect.ConnectionMgr_EVersionWarning
    r"""
    version is verified and warning written if winIDEA is
    different version than SDK
    """
    EVersionError = _connect.ConnectionMgr_EVersionError
    r"""
    version is verified and exception thrown if winIDEA is
    different version than SDK
    """
    __swig_destroy__ = _connect.delete_ConnectionMgr

    def initLogger(self, id, fileName, language):
        r"""
        Initializes logger, which is owned by instance of this class. Logger writes
        ``isystem.connect`` calls to log file, so that it produces valid python
        program in most cases. Only some complex calls, which require creation of
        local variables are not logged in a way to be directly executable.

        :type id: string
        :param id: used as prefix in log
                statements. The default value is empty string, which is OK if
                there is only one winIDEA instance. If we are controlling multiple
                targets or multi-core CPUs, then the ID **must** be set to distinguish
                connections in scripts produced by isystem.connect logger.
                If the id is empty, logged statements will look something like:

                    execCtrl.setBP("func1");

                If we set the id to ``main_`` , we get:

                    main_execCtrl.setBP("func1");


        :type fileName: string
        :param fileName: name of the log file
        :type language: int
        :param language: language used for log files statements. Only PYTHON
                is currently fully supported, while JAVA has limited support.

        Python example: _sample_link{connection_mgr,test_logger}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.initLogger('loggerId', 'loggerOutput.py', ic.CLogger.PYTHON)

            >>> cmgr.getId()
            'loggerId'
        """
        return _connect.ConnectionMgr_initLogger(self, id, fileName, language)

    def getId(self):
        r"""
         Returns the ID set by setLogger().
        Python example: _sample_link{connection_mgr,test_logger}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.initLogger('loggerId', 'loggerOutput.py', ic.CLogger.PYTHON)

            >>> cmgr.getId()
            'loggerId'
        """
        return _connect.ConnectionMgr_getId(self)

    def getLogger(self):
        r"""
         Returns pointer to logger set by setLogger().
        Python example: _sample_link{connection_mgr,test_logger}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.initLogger('loggerId', 'loggerOutput.py', ic.CLogger.PYTHON)

            >>> logger = cmgr.getLogger()

            >>> logger.loggingOn()

            >>> logger.isLoggingOn()
            True
        """
        return _connect.ConnectionMgr_getLogger(self)

    @staticmethod
    def get_installed_winIDEAs(bAllowOwner, bAllowDeployment):
        r"""
         Returns information on all installed winIDEAs.

        :type bAllowOwner: boolean
        :param bAllowOwner: if true, installations with an owner are included
        :type bAllowDeployment: boolean
        :param bAllowDeployment: if true, non-regular deployments are included
        :rtype: :py:class:`Vinstalled_winIDEAs`
        :return: vector of all installed winIDEAs.
        """
        return _connect.ConnectionMgr_get_installed_winIDEAs(bAllowOwner, bAllowDeployment)

    def isConnected(self, bCheckConnection=False):
        r"""
        Returns true, if connection was established. It returns true, until
        the method disconnect() (which releases connection resources) is called,
        even if winIDEA is closed after the connection is established.

        See also: isAttached()

        Python example: _sample_link{connection_mgr,test_connect}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr.isConnected()
            True
        """
        return _connect.ConnectionMgr_isConnected(self, bCheckConnection)

    def enumerateWinIDEAInstances(self, address, spConnectionConfig, instances):
        r"""
        This method enumerates instances of winIDEA running at the specified host.

        :type address: string
        :param address: The IP address of the machine where to search for
            running instance of winIDEA. This can be either dotted decimal or an URL. If
            it is empty string, the local host is considered.

        :type spConnectionConfig: :py:class:`CConnectionConfig`
        :param spConnectionConfig: configuration parameters for search domain (shared memory
                                    or UDP). See CConnectionConfig for more info.

        :type instances: :py:class:`VectorWinIDEAInstanceInfo`
        :param instances: vector to receive enumeration information. One element
            contains information for one instance found.

        Python example: _sample_link{connection_mgr,test_enumerate_winidea_instances}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect() # ensures at least one instance is alive

            >>> instances = ic.VectorWinIDEAInstanceInfo()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.enumerateWinIDEAInstances('', cc, instances)

            >>> len(instances) > 0
            True
        """
        return _connect.ConnectionMgr_enumerateWinIDEAInstances(self, address, spConnectionConfig, instances)

    def disconnect_keep(self):
        r"""
        Disconnects from winIDEA and leaves it running

            >>> conn_mgr = ConnectionMgr()

            >>> conn_mgr.connect()

            >>> conn_mgr.isConnected()
            True

            >>> conn_mgr.disconnect_keep()

            >>> conn_mgr.isConnected()
            False
        """
        return _connect.ConnectionMgr_disconnect_keep(self)

    def disconnect_close(self, bSaveAll):
        r"""
        Disconnects from winIDEA and closes it

        :type bSaveAll: boolean
        :param bSaveAll: if true, winIDA saves files and workspace, otherwise discards changes

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr.isConnected()
            True

            >>> cmgr.disconnect_close(False)

            >>> cmgr.isConnected()
            False
        """
        return _connect.ConnectionMgr_disconnect_close(self, bSaveAll)

    def inProcessDisconnect(self):
        return _connect.ConnectionMgr_inProcessDisconnect(self)

    def getWinIDEAVersion(self):
        r"""
        Returns winIDEA version. Supported only on winIDEA versions 9.9 and higher.

            >>> cmgr = ic.ConnectionMgr()

            >>> version = cmgr.getWinIDEAVersion()

            >>> version.getMajor()
            9
        """
        return _connect.ConnectionMgr_getWinIDEAVersion(self)

    def isCoreLaunched(self, coreIndex):
        r"""
        Returns true, if winIDEA for the given core is already launched,
        false otherwise.

        :type coreIndex: int
        :param coreIndex: 0 for primary core, 1 for next core, ...

        Python example: _sample_link{connection_mgr,test_launch_core1}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr.isCoreLaunched(0)
            True

           >>> cmgr.isCoreLaunched(1)
           False
        """
        return _connect.ConnectionMgr_isCoreLaunched(self, coreIndex)

    def launchCore1(self, coreIndex):
        r"""
        Opens another winIDEA instance, which is connected to core
        specified by parameter 'coreIndex'. Connection to primary core must be
        made before this method is called.

        :type coreIndex: int
        :param coreIndex: index of the core, starting with 0.
            Indices may be in range 0..(N - 1), where N is the number of cores.
            Since instance of connection manager on which this method is
            called is usually connected to core 0, this parameter is
            usually >= 1.

        :rtype: :py:class:`ConnectionMgr`
        :return: connection manager already connected to the winIDEA instance.

        Python example: _sample_link{connection_mgr,test_launch_core1}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr1 = cmgr.launchCore1(1)
        """
        return _connect.ConnectionMgr_launchCore1(self, coreIndex)

    def getIConnectDllVersion(self):
        r"""
        _rst
        .. deprecated:: 9.21.199
           use ctor with version flag.

        _rst
        """
        return _connect.ConnectionMgr_getIConnectDllVersion(self)

    def isWarning(self):
        r"""
        Returns true, if the last operation issued a warning.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr.isWarning()
            False
        """
        return _connect.ConnectionMgr_isWarning(self)

    def getLastErrorMsg(self):
        r"""
        Returns the warning or error message of the last operation. Returns empty
        string, when there was no error or warning.

        Python example: _sample_link{connection_mgr,test_get_last_error_msg}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr.getLastErrorMsg()
            '''
        """
        return _connect.ConnectionMgr_getLastErrorMsg(self)

    def isAttached(self):
        r"""
        Returns true, if connection to winIDEA is alive. When winIDEA
        is closed, this method returns false.

        See also: isConnected()

        Python example: _sample_link{connection_mgr,test_is_attached}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.isAttached()
            False

            >>> cmgr.connect()

            >>> cmgr.isAttached()
            True
        """
        return _connect.ConnectionMgr_isAttached(self)

    @staticmethod
    def isStartedFromWinIDEA():
        r"""
        Returns true, if application calling this function was started from
        winIDEA, false otherwise.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.isStartedFromWinIDEA()
            False
        """
        return _connect.ConnectionMgr_isStartedFromWinIDEA()

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructs the object, but does not connect to winIDEA.
        Use one of :cpp:func:`ConnectionMgr::connect()` methods to establish connection to winIDEA.

            >>> conn_mgr = ConnectionMgr()

            >>> print(f"Is connected: {conn_mgr.isConnected()}")
            Is connected: False

        Python example: _sample_link{connection_mgr,test_connection_mgr}

        |

        *Overload 2:*

        _rst
        .. deprecated:: 9.21.199
           Use default constructor and then call :cpp:func:`connect(SPConnectionConfig)  <void ConnectionMgr::connect(SPConnectionConfig)>`
           with :cpp:func:`CConnectionConfig::exe_dir` set to define directory where `winIDEA.exe`
           is located.

        Call :cpp:func:`connect(SPConnectionConfig)  <void ConnectionMgr::connect(SPConnectionConfig)>` instead.
        _rst

        Constructs the object, and creates IConnect client. The specified
        path is used to start new winIDEA instance on connect() call,
        if necessary.
        Use one of connection methods to establish connection to winIDEA.

        :type rstrPath: string
        :param rstrPath: Path to winIDEA.exe or directory (must be terminated
                   with \ or /) containing the winIDEA.exe.
                   You can use this parameter if multiple versions of winIDEA are
                   installed on a system and you want to control which one to use.
                   Example value: 'C:/winIDEA/2024/'

        Python example: _sample_link{connection_mgr,test_connection_mgr}

        |

        *Overload 3:*

        _rst
        .. deprecated:: 9.17.187
           version control is always strict since 9.17.187. Use the
           parameterless constructor instead of this one.

        _rst

        Constructs the object, and creates IConnect client. The most recently
        used ``isystem.connect`` DLL is used.
        Use one of connection methods to establish connection to winIDEA.

        :type versionControl: int
        :param versionControl: ignored
        """
        _connect.ConnectionMgr_swiginit(self, _connect.new_ConnectionMgr(*args))

    def connectMRU(self, *args):
        r"""
        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.
           :cpp:func:`~ConnectionMgr::connectMRU` without arguments can be replaced
           with :cpp:func:`connect() <void ConnectionMgr::connect()>`.

        _rst

        Connects to the most recently used winIDEA and opens the given
        workspace. This is a utility method, which suits most needs. For
        complex configurations with more than one winIDEA instance or remote
        instances use other methods as described in documentation of this class.

        If environment variables ICONNECT_PATH and ICONNECT_TCP_PORT
        are defined, then they define the winIDEA to connect to. Otherwise
        winIDEA's internal data is used to connect to the most recently started
        winIDEA. These two environment variables are defined when executing
        Python script interactively from winIDEA.

        _rst
        .. note::

           On Linux this method always starts executable called `winidea`,
           which is on system path. It does not check which winIDEA was started latest.

        .. note::

           If this method does not find running winIDEA instance on Linux,
           check if you have enabled firewall (discovery is made with broadcasting).

        _rst

        :type workspacePath: string, optional
        :param workspacePath: specifies a path to the workspace file. If the
                   string is empty (size == 0), and winIDEA option
                   `Tools | Options | Reload last workspace on startup` is enabled,
                   the last opened workspace is used.
                   Linux specific: Is is assumed that Wine maps drive Z: to root folder.

        :type winIDEAId: string, optional
        :param winIDEAId: if specified, connection is made to winIDEA, which was
                             started with command line option /id:<winIDEAId>. If empty
                             string, this parameter is ignored.

        :type hostIpAddress: string, optional
        :param hostIpAddress: if specified, this host is used for lookup. If empty,
                                 local host is used.

        :type isUseServerEnvVars: boolean, optional
        :param isUseServerEnvVars: if true, environment vars as set by launching
                                      application are used to connect to winIDEA.
                                      Namely, process ID and TCP port are used. For
                                      example, if Python script was started from winIDEA,
                                      and this flag is ``true``, then the script will be able to
                                      connect only to this instance of winIDEA. Set this
                                      flag to ``false`` to connect to other instances of winIDEA
                                      if required.

        :raises: IllegalStateException if already connected
        :raises: IOException if connecting to winIDEA failed
        """
        return _connect.ConnectionMgr_connectMRU(self, *args)

    def connectMRUEx(self, workspacePath, isAnyWinIDEAId, winIDEAId, hostIpAddress, isUseServerEnvVars):
        r"""
        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.

        _rst

        Connects to the most recently used winIDEA and opens the given
        workspace. Use this method only if you want to connect to winIDEA with
        no ID specified. For complex configurations with more than one winIDEA
        instance or remote
        instances use other methods as described in documentation of this class.

        If environment variables ICONNECT_PATH and ICONNECT_TCP_PORT
        are defined, then they define the winIDEA to connect to. Otherwise
        winIDEA's internal data is used to connect to the most recently started
        winIDEA. These two environment variables are defined when executing
        Python script interactively from winIDEA.


        :type workspacePath: string
        :param workspacePath: specifies a path to the workspace file. If the
                   string is empty (size == 0), and winIDEA option
                   `Tools | Options | Reload last workspace on startup` is enabled,
                   the last opened workspace is used.
                   Linux specific: Is is assumed that Wine maps drive Z: to root folder.

        :type isAnyWinIDEAId: boolean
        :param isAnyWinIDEAId: if true, value of winIDEAId parameter is ignored -
                                  connection is made to winIDEA with any ID.

        :type winIDEAId: string
        :param winIDEAId: if isAnyWinIDEAId is false, connection is made to winIDEA, which was
                             started with command line option /id:<winIDEAId>). If empty
                             string, connection is made to winIDEA, which was
                             started **without** command line option /id:<winIDEAId>.

        :type hostIpAddress: string
        :param hostIpAddress: if specified, this host is used for lookup. If empty,
                                 local host is used.

        :type isUseServerEnvVars: boolean
        :param isUseServerEnvVars: if true, environment vars as set by launching
                                      application are used to connect to winIDEA.
                                      Namely, process ID and TCP port are used. For
                                      example, if Python script was started from winIDEA,
                                      and this flag is ``true``, then the script will be able to
                                      connect only to this instance of winIDEA. Set this
                                      flag to ``false`` to connect to other instances of winIDEA
                                      if required.

        :raises: IllegalStateException if already connected
        :raises: IOException if connecting to winIDEA failed
        :raises: IllegalStateException if already connected
        :raises: IOException if connecting to winIDEA failed
        """
        return _connect.ConnectionMgr_connectMRUEx(self, workspacePath, isAnyWinIDEAId, winIDEAId, hostIpAddress, isUseServerEnvVars)

    def findExistingInstance(self, address, spConnectionConfig):
        r"""
        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.

        _rst

        Finds existing instance of winIDEA if it is running on host specified with parameter
        ``address``. Search criteria is specified with parameters ``workspace``, and
        ``instanceId`` of parameter ``spConnectionConfig``, if they are not empty strings.

        :type address: string
        :param address: The IP address of the machine where to search for
            running instance of winIDEA. This can be either dotted decimal or an URL. If
            it is an empty string, the local host is considered, and shared memory discovery
            is used on Windows. On Linux UDP discovery is always used.

        :type spConnectionConfig: :py:class:`CConnectionConfig`
        :param spConnectionConfig: configuration parameters for search algorithm.
                   Process ID of found winIDEA instance is returned in this object.
                   See CConnectionConfig for more info.

        :rtype: int
        :return: port number of the running instance which matches the search
                    criteria. If no such winIDEA instance was found, exception is thrown.

        See also: #findOrStartInstance
        See also: #startNewInstance

        :raises: IOException if winIDEA instance could not be found.

        Python example: _sample_link{advanced,advanced_winidea_launching}
        Python example: _sample_link{connection_mgr,test_find_existing_instance}
        """
        return _connect.ConnectionMgr_findExistingInstance(self, address, spConnectionConfig)

    def startNewInstance(self, spConnectionConfig):
        r"""
        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.

        _rst

        Starts new instance of winIDEA with parameters specified in ``spConnectionConfig``.
        To connect to the new winIDEA instance call method ``connect()`` with
        port number returned by this method.

        :type spConnectionConfig: :py:class:`CConnectionConfig`
        :param spConnectionConfig: configuration of the new instance of winIDEA to be started.
                   Process ID of started winIDEA instance is returned in this object.

        :rtype: int
        :return: isystem.connect port of the new winIEDA instance

        See also: #findOrStartInstance
        See also: #findExistingInstance

        Python example: _sample_link{connection_mgr,test_start_new_instance}
        """
        return _connect.ConnectionMgr_startNewInstance(self, spConnectionConfig)

    def findOrStartInstance(self, spConnectionConfig):
        r"""
        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.

        _rst

        First tries to find a winIDEA instance, with ``workspace``, and
        ``instanceId`` as specified in ``spConnectionConfig``. If any of these
        two items is empty string, it is ignored when searching. If matching
        instance of winIDEA is found, its ``isystem.connect`` port number is
        returned. If not, a new instance is started and its ``isystem.connect``
        port number is returned.

        :type spConnectionConfig: :py:class:`CConnectionConfig`
        :param spConnectionConfig: configuration parameters for search algorithm and
            creating of new winIDEA instance. Process ID of found/started winIDEA
            instance is set in this object if shared memory communication is used.
            If TCP/IP is used, then process ID of winIDEA is set only if winIDEA
            has been started.
            See CConnectionConfig for more info.

        :rtype: int
        :return: port number of winIDEA instance matching the ``workspace`` and
            ``instanceId`` in ``SPConnectionConfig``.

        See also: #startNewInstance
        See also: #findExistingInstance

        Python example: _sample_link{connection_mgr,test_find_or_start_instance}
        """
        return _connect.ConnectionMgr_findOrStartInstance(self, spConnectionConfig)

    def connect(self, *args):
        r"""
        *Overload 1:*

        Connects to local winIDEA instance with the same configuration
        (workspace, id) as set in input parameter. If it is not running,
        a new instance with the given configuration is started.
        If no instance ID is provided in the connection config,
        it is generated when calling this.

        :type spConnectionConfig: :py:class:`CConnectionConfig`
        :param spConnectionConfig: expected winIDEA configuration and startup parameters

        Python example: _sample_link{connection_mgr,test_cconnection_config}

            >>> cmgr = ic.ConnectionMgr()

            >>> cc = ic.CConnectionConfig()

            >>> cmgr.connect(cc)

            >>> cmgr.isConnected()
            True

        |

        *Overload 2:*

        Connects to most-recently started winIDEA instance
        If it is not running, a new instance is started.


        Python example: _sample_link{connection_mgr,test_cconnection_config}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> cmgr.isConnected()
            True

        |

        *Overload 3:*

        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.

        _rst

        Connects to winIDEA via TCP/IP at address specified in `address` at
        the specified port.

        :type address: string
        :param address: The IP address of the machine where winIDEA is
            running. This can be either dotted decimal or an URL. If
            it is an empty string, the local host is considered.

        :type iconnectPort: int
        :param iconnectPort: The TCP port to use. This should be the
            same value as provided by winIDEA menu `Tools |
            Options | winIDEA SDK | TCP Connection Port`. This port is allocated
            dynamically at each start of winIDEA. It is recommended to call
            `enumerateWinIDEAInstances()` to get the port number programmmatically.
            It is possible to
            specify the port in command line when starting winIDEA, but if the
            port is already used by some other application or instance of winIDEA,
            then winIDEA opens the next available port, which makes this approach
            with port specified in command line unreliable, so enumeration is
            preferred.

        Python example: _sample_link{connection_mgr,test_cconnection_config}

        |

        *Overload 4:*

        _rst
        .. deprecated:: 9.21.199
           Use :cpp:func:`connect(SPConnectionConfig) <void ConnectionMgr::connect(SPConnectionConfig)>` instead.

        .. note::
           This call does not work on Linux, because it requires communication
           over shared memory, which is currently implemented only on Windows.
        _rst

        Connects to winIDEA with the given process ID.

        :type pid: int
        :param pid: Windows process ID

        Python example: _sample_link{connection_mgr,test_cconnection_config}
        """
        return _connect.ConnectionMgr_connect(self, *args)

    def disconnect(self, *args):
        r"""
        *Overload 1:*

        _rst
        .. deprecated:: 9.21.199
           Use Use :cpp:func:`~ConnectionMgr::disconnect_keep`/ :cpp:func:`~ConnectionMgr::disconnect_close` instead.

        _rst

        Disconnects from winIDEA. This method is automatically called by destructor,
        if connection to winIDEA is still active.

        Python example: _sample_link{connection_mgr,test_start_new_instance}

        |

        *Overload 2:*

        _rst
        .. deprecated:: 9.21.199
           Use Use :cpp:func:`~ConnectionMgr::disconnect_keep`/ :cpp:func:`~ConnectionMgr::disconnect_close` instead.

        _rst

        Disconnects from winIDEA.

        :type closeServerFlags: int
        :param closeServerFlags: one of ``IConnect::EDetachFlags::dfCloseServer...`` flags
                                    or 0 if we do not want to close winIDEA.
        :type autoSaveFlags: int
        :param autoSaveFlags: one of ``IConnect::EDetachFlags::dfCloseAutoSave...`` flags
        """
        return _connect.ConnectionMgr_disconnect(self, *args)

    def launchCore(self, coreIndex, isPrimaryCoreIndexed=False):
        r"""
        _rst
        .. deprecated:: 9.21.199
           This method does not work
           reliably when you have multiple instances of winIDEA with the
           same workspace opened. Use launchCore1() instead.

        _rst

        Opens another winIDEA instance, which is connected to core
        specified by parameter 'coreIndex'.

        :type coreIndex: int
        :param coreIndex: index of the core, starting with 0. If parameter
                   ``isPrimaryCoreIndexed`` is false, then the primary core is
                   not indexed, so index ``0`` means core 1. This is deprecated
                   usage, which exists for backward compatibility. It is recommended
                   to always set flag ``isPrimaryCoreIndexed`` to ``true``, so all cores
                   can be indexed. Indices may be in range 0..(N - 1), where N is the
                   number of cores.

        :type isPrimaryCoreIndexed: boolean, optional
        :param isPrimaryCoreIndexed: see description of parameter ``coreIndex`` above.

        :rtype: string
        :return: name of the workspace file used by the newly opened instance.
            To use isystem.connect with this core, instantiate another ConnectionMgr
            and use the returned workspace name as parameter to ConnectionMgr::connectMRU().
        """
        return _connect.ConnectionMgr_launchCore(self, coreIndex, isPrimaryCoreIndexed)

    def terminate(self):
        r"""
        This method terminates pending communication. Call this from another thread,
        when winIDEA is unresponsive, to gracefully exit the blocked SDK call.
        """
        return _connect.ConnectionMgr_terminate(self)

# Register ConnectionMgr in _connect:
_connect.ConnectionMgr_swigregister(ConnectionMgr)
class CMulticoreConnectionMgr(object):
    r"""
    Deprecated: since 9.21.209. Use ConnectionMgr instead.

    This class manages connections to multicore instances of winIDEA.
    It can be used
    when we want to connect to multi-core target. Since advanced functions
    of ConnectionMgr (which is used under the hood) are not exposed, use
    ConnectionMgr directly when advanced functionality (for example starting
    winIDEAs in hidden mode) is needed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def connectPrimaryCore(self, *args):
        r"""
        *Overload 1:*

        This method starts winIDEA version, which was the last started in current
        user account. See overload for details.
        See also: connectPrimaryCore(const iconnect::StrVector &, const std::string &, bool,
        const std::string &, const std::string &, const std::string &).

        |

        *Overload 2:*

        This method creates connection to primary core. If
        connection is already established, it disconnects first,
        then reconnects. This is the first method to be called in this class.

        Note that it is highly recommended to specify either `winIDEAWorkspace`
        or `winIDEAId`, so that connection is always made to the primary core.
        Otherwise connection is made to the latest started winIDEA, which is
        usually not the one you intended to connect to, especially in multicore
        configurations.

        :type loggingParams: :py:class:`StrVector`
        :param loggingParams: used for logger configuration. If empty vector, logging of
                                 isystem.connect calls is not performed. Otherwise
                                 `loggingParams[0]` should contain log file name.
                                 If `loggingParams[1]` exists, it is used as prefix in log statements.
        :type winIDEAWorkspace: string
        :param winIDEAWorkspace: path to winIDEA workspace used for connection to winIDEA. If
                                    empty, connection to the most recently used winIDEA is made.
        :type isUseWinIDEAId: boolean
        :param isUseWinIDEAId: if true, parameter winIDEAId is used to connect to
                                  winIDEA with the given ID. If false, connection can be made to
                                  any winIDEA, regardless if it has ID specified or not.
        :type winIDEAId: string
        :param winIDEAId: used only if isUseWinIDEAId is true. If empty string, connection
                             can be made only to winIDEA, which has no ID specified.
        :type primaryCoreId: string
        :param primaryCoreId: id of primary core, may be empty string.
        :type pathToIConnectDll: string
        :param pathToIConnectDll: if not empty string, is should specify full path to
                                     iconnect.dll in winIDEA installation directory, for
                                     example ``'C:\iSYSTEM\winIDEA\iconnect.dll'``.
                                     Specify it when you want to run specific version of winIDEA,
                                     or winIDEA has never been run under current user account,
                                     so ``connect()`` can not find winIDEA. For example,
                                     when starting winIDEA with script running as a service (daemon).
        """
        return _connect.CMulticoreConnectionMgr_connectPrimaryCore(self, *args)

    def connectCore(self, coreIndex, coreId):
        r"""
        Creates connection to core with the given index and assigns
        it the given coreId. Connection to primary core must exist before
        calling this method (call connectPrimaryCore()). If winIDEA for the
        given core is already running, connection to this instance is made.

        :type coreIndex: int
        :param coreIndex: index of the core to connect to. Index 0 is used for
                             primary core (see connectPrimaryCore()), so for this
                             method coreIndex >= 1.
        :type coreId: string
        :param coreId: id, which is assigned to the core with index *coreIndex*.
                          Must *not* be empty string!

        :rtype: :py:class:`ConnectionMgr`
        :return: created connection manager
        """
        return _connect.CMulticoreConnectionMgr_connectCore(self, coreIndex, coreId)

    def getConnectionMgr(self, coreID):
        r"""
        Returns connection manager for core with the given ID.

        :type coreID: string
        :param coreID: core ID or empty string for primary core.
        """
        return _connect.CMulticoreConnectionMgr_getConnectionMgr(self, coreID)

    def isConnected(self, coreId):
        r"""
        Returns true, if connection to the given core was established and
        is still alive.
        """
        return _connect.CMulticoreConnectionMgr_isConnected(self, coreId)

    def disconnect(self, *args):
        r"""
        Disconnects connection manager with the given core ID. Parameters `closeServerFlags`
        and `autoSaveFlags` are later ORed together. Both of them are specified, because
        Java enums are not int-s, so they can not be ORed together before the call. This is
        also the reason for using IConnect::dfCloseAutoSaveDefault as value for `closeServerFlags`
        as described below in parameter description.

        :type coreId: string
        :param coreId: id of the core to be disconnected
        :type closeServerFlags: int, optional
        :param closeServerFlags: flags defining if and when winIDEA should close.
                                    Specify one of IConnect::EDetachFlags `dfCloseServer...` flags.
                                    If you do not want winIDEA to close,
                                    specify value IConnect::dfCloseAutoSaveDefault
                                    for this item.
        :type autoSaveFlags: int, optional
        :param autoSaveFlags: flags defining if winIDEA should save unsaved information.
                                       Specify one of IConnect::EDetachFlags `dfCloseAutoSave...` flags.
        """
        return _connect.CMulticoreConnectionMgr_disconnect(self, *args)

    def disconnectAll(self):
        r"""Disconnects all connection managers."""
        return _connect.CMulticoreConnectionMgr_disconnectAll(self)

    def getCDebugFacade(self, coreId):
        r"""Returns cached CDebugFacade for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCDebugFacade(self, coreId)

    def getCIDEController(self, coreId):
        r"""Returns cached CIDEController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCIDEController(self, coreId)

    def getCExecutionController(self, coreId):
        r"""Returns cached CExecutionController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCExecutionController(self, coreId)

    def getCLoaderController(self, coreId):
        r"""Returns cached CLoaderController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCLoaderController(self, coreId)

    def getCDataEController2(self, coreId):
        r"""
        Deprecated: since 2016-05-02, 9.12.179, because of typo in method name.
        Call getCDataController2() instead.
        """
        return _connect.CMulticoreConnectionMgr_getCDataEController2(self, coreId)

    def getCDataController2(self, coreId):
        r"""Returns cached CDataController2 for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCDataController2(self, coreId)

    def getCHILController(self):
        r"""Returns cached CHILController for the given core ID."""
        return _connect.CMulticoreConnectionMgr_getCHILController(self)

    def getConnectedCoreIDs(self):
        r"""Returns list of all core IDs currently connected."""
        return _connect.CMulticoreConnectionMgr_getConnectedCoreIDs(self)

    def __init__(self):
        _connect.CMulticoreConnectionMgr_swiginit(self, _connect.new_CMulticoreConnectionMgr())
    __swig_destroy__ = _connect.delete_CMulticoreConnectionMgr

# Register CMulticoreConnectionMgr in _connect:
_connect.CMulticoreConnectionMgr_swigregister(CMulticoreConnectionMgr)
class CMemAddress(object):
    r"""
    This class contains memory address including memory area.


    Note: If you are using logging (see ConnectionMgr::setLogger())
    functionality, some methods disable it if an exception is thrown.
    Call ``logger.loggingOn()`` in case of exception.

    See also: CAddressController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, memArea, address):
        _connect.CMemAddress_swiginit(self, _connect.new_CMemAddress(memArea, address))

    def getMemArea(self):
        r"""
        Returns memory area. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.

        Python example: _sample_link{address_ctrl,test_get_expression_address}
        """
        return _connect.CMemAddress_getMemArea(self)

    def getAddress(self):
        r"""
        Returns address.

        Python example: _sample_link{address_ctrl,test_get_expression_address}
        """
        return _connect.CMemAddress_getAddress(self)

    def toString(self):
        return _connect.CMemAddress_toString(self)
    __swig_destroy__ = _connect.delete_CMemAddress

# Register CMemAddress in _connect:
_connect.CMemAddress_swigregister(CMemAddress)
class CSymbolInfo(object):
    r"""This class contains information about symbol, such as address, size and type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, memArea, address, sizeMAUs, type):
        _connect.CSymbolInfo_swiginit(self, _connect.new_CSymbolInfo(memArea, address, sizeMAUs, type))

    def getMemArea(self):
        r"""
        Returns symbol's memory area. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.
        """
        return _connect.CSymbolInfo_getMemArea(self)

    def getAddress(self):
        r"""Returns symbol's address."""
        return _connect.CSymbolInfo_getAddress(self)

    def getSizeMAUs(self):
        r"""Returns symbol's size in Memory Addressable Units."""
        return _connect.CSymbolInfo_getSizeMAUs(self)

    def getMType(self):
        r"""Returns symbol's type."""
        return _connect.CSymbolInfo_getMType(self)

    def toString(self):
        return _connect.CSymbolInfo_toString(self)
    __swig_destroy__ = _connect.delete_CSymbolInfo

# Register CSymbolInfo in _connect:
_connect.CSymbolInfo_swigregister(CSymbolInfo)
class CLineLocation(object):
    r"""
    This class contains information about line location - file name and line
    number.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fileName, lineNumber):
        _connect.CLineLocation_swiginit(self, _connect.new_CLineLocation(fileName, lineNumber))

    def getFileName(self):
        r"""Returns file name."""
        return _connect.CLineLocation_getFileName(self)

    def getLineNumber(self):
        r"""Returns line number."""
        return _connect.CLineLocation_getLineNumber(self)

    def toString(self):
        r"""Returns string representation of this object."""
        return _connect.CLineLocation_toString(self)
    __swig_destroy__ = _connect.delete_CLineLocation

# Register CLineLocation in _connect:
_connect.CLineLocation_swigregister(CLineLocation)
class CLineDescription(object):
    r"""
    This adapter class contains line description based on file/line
    contents not on line number. It is used to to define source code line, which
    location may change when source file is modified.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_RESOURCE_FUNCTION = _connect.CLineDescription_E_RESOURCE_FUNCTION
    r"""lines are given relative to function"""
    E_RESOURCE_FILE = _connect.CLineDescription_E_RESOURCE_FILE
    r"""lines are given relative to file"""
    E_RESOURCE_ADDRESS = _connect.CLineDescription_E_RESOURCE_ADDRESS
    r"""
    location is defined by address as string
    in resource name.
    """
    E_SEARCH_ANY = _connect.CLineDescription_E_SEARCH_ANY
    r"""all text is searched"""
    E_SEARCH_CODE = _connect.CLineDescription_E_SEARCH_CODE
    r"""only source code is searched"""
    E_SEARCH_COMMENT = _connect.CLineDescription_E_SEARCH_COMMENT
    r"""only single line comment is searched"""
    E_MATCH_PLAIN = _connect.CLineDescription_E_MATCH_PLAIN
    r"""plain string matching is done anywhere in the line"""
    E_MATCH_REG_EX = _connect.CLineDescription_E_MATCH_REG_EX
    r"""pattern is regular expression"""
    E_MATCH_TEST_POINT_ID = _connect.CLineDescription_E_MATCH_TEST_POINT_ID
    ELocalHost = _connect.CLineDescription_ELocalHost
    r"""get source code from host, where testIDEA or script using SDK is running"""
    EWinIDEAHost = _connect.CLineDescription_EWinIDEAHost
    r"""get source code from host, where winIDEA is running"""

    def __init__(self, *args):
        r"""
        Instantiates this class.

        :type resourceType: int
        :param resourceType: defines where to look for location
        :type resourceName: string
        :param resourceName: name of file or function, depending on the first parameter
        :type line: int
        :param line: line in file or function, 0-based. If isSearch is true, this is line
                   where search is started
        :type isSearch: boolean
        :param isSearch: if true, line with the specified pattern is searched
        :type linesRange: int
        :param linesRange: how many lines to search. Set it to 0 for no limit (till the end of file)
        :type searchContext: int
        :param searchContext: see CLineDescription::ESearchContext
        :type matchingType: int
        :param matchingType: see CLineDescription::EMatchingType
        :type searchPattern: string
        :param searchPattern: text pattern to search in lines, format depends on matchingType
        :type lineOffset: int
        :param lineOffset: the number of lines to add to the found line
        :type fileLocation: int, optional
        :param fileLocation: defines where to look for source files - on local host running
                   the script, or on remote host running winIDEA. If winIDEA is running on
                   the same host as script, use the default value.
        """
        _connect.CLineDescription_swiginit(self, _connect.new_CLineDescription(*args))

    def getResourceType(self):
        r"""Returns type of resource for which location is given."""
        return _connect.CLineDescription_getResourceType(self)

    def getResourceName(self):
        r"""Returns name of resource where test point is located."""
        return _connect.CLineDescription_getResourceName(self)

    def getLine(self):
        r"""
        Returns line number, where test point is set, or where
        search range starts (if pattern is defined). Lines for file
        are 1-based, while lines for function are 0 based and can also be
        negative.
        """
        return _connect.CLineDescription_getLine(self)

    def isSearch(self):
        r"""
        Returns true, if search is to be performed. Otherwise the line
        number returned by getLine() is used to set a test point.
        """
        return _connect.CLineDescription_isSearch(self)

    def getLinesRange(self):
        r"""
        Returns the number of lines, which are searched for pattern.
        Value 0 means till the end of file.
        """
        return _connect.CLineDescription_getLinesRange(self)

    def getSearchContext(self):
        r"""Returns search context for pattern."""
        return _connect.CLineDescription_getSearchContext(self)

    def getMatchingType(self):
        r"""Returns matching type for pattern."""
        return _connect.CLineDescription_getMatchingType(self)

    def getSearchPattern(self):
        r"""
        Returns search pattern. If this item is not defined (empty
        string is returned), then test point is located in line
        returned by ``getLine()``. No search is performed. Num lines,
        search context, and matching type are ignored.
        """
        return _connect.CLineDescription_getSearchPattern(self)

    def getLineOffset(self):
        r"""
        Returns the number of lines, which are added to line found by search
        pattern above.
        """
        return _connect.CLineDescription_getLineOffset(self)

    def getFileLocation(self):
        r"""Returns source location."""
        return _connect.CLineDescription_getFileLocation(self)

    def toString(self):
        r"""
        Returns contents of object as string. Use this for logging/debugging
        purposes only.
        """
        return _connect.CLineDescription_toString(self)
    __swig_destroy__ = _connect.delete_CLineDescription

# Register CLineDescription in _connect:
_connect.CLineDescription_swigregister(CLineDescription)
class CAddressController(object):
    r"""
    This class provides information about symbols and source code -
    sizes and addresses in the memory.


    Python example for method getSymbolAtAddress(): _sample_link{address_ctrl,test_get_symbol_at_address}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: _sample_link{address_ctrl,test_get_code_area}
        """
        _connect.CAddressController_swiginit(self, _connect.new_CAddressController(connectionMgr))
    __swig_destroy__ = _connect.delete_CAddressController

    def getCodeArea(self, bPhysical):
        r"""
        Returns memory area, where the code is located.

        :type bPhysical: boolean
        :param bPhysical: used only for PowerPC, see MemoryAreas.cpp,
            CCPUInfoHelp::GetCodeArea():
             ``**return** bPhysical ? maPPhysicalPowerPC : maVirtualPowerPC;``

        Python example: _sample_link{address_ctrl,test_get_code_area}
        """
        return _connect.CAddressController_getCodeArea(self, bPhysical)

    def getFunctionAddress(self, functionName):
        r"""
        Returns address of a function. If function is located in a *default
        download file*, then its name is enough. If function is located in
        *other download file than the default one*, a fully qualified name
        should be specified in the following format:


        "<moduleName>"#<funcName>,,<downloadFileName>

        where:
        - ``moduleName`` - name of the C source file, which contains the function
        - ``funcName`` - name of the function
        - ``downloadFileName`` - name of the download file, where the function is located

        Module name is optional. It is only needed when there is more than one
        file static function with the same name.

        Example:

        "main.c"#init,,executable.elf


        :type functionName: string
        :param functionName: name of the function

        Python example: _sample_link{address_ctrl,test_get_function_address}
        """
        return _connect.CAddressController_getFunctionAddress(self, functionName)

    def getVariableAddress(self, variableName):
        r"""
        Returns address of a variable. Use this method to get address of a simple
        variable. For complex items, for example struct members, use method getExpressionAddress().

        :type variableName: string
        :param variableName: name of the variable

        Python example: _sample_link{address_ctrl,test_get_variable_addresses}
        """
        return _connect.CAddressController_getVariableAddress(self, variableName)

    def getExpressionAddress(self, expression):
        r"""
        Returns address of an expression. Expression can be any item with address,
        for example function, variable, struct member, ...

        :type expression: string
        :param expression: any expression with address, for example 'myStruct.x'

        Python example: _sample_link{address_ctrl,test_get_expression_address}
        """
        return _connect.CAddressController_getExpressionAddress(self, expression)

    def getLabelAddress(self, labelName):
        r"""
        Returns address of a label.

        :type labelName: string
        :param labelName: name of the label

        Python example: _sample_link{address_ctrl,test_get_label_address}
        """
        return _connect.CAddressController_getLabelAddress(self, labelName)

    def getSymbolInfo(self, flags, expression):
        r"""
        Returns information about the symbol. It includes:
        - memory area, where it is located (set to 0 for architectures with
          linear memory space)
        - address or the symbol
        - size of the symbol in memory allocation units
        - type

        If you need only address of the symbol, then methods getFunctionAddress(),
        getVariableAddress(), and getLabelAddress() are more convenient.

        :type flags: int
        :param flags:

            | 31       | 30-24      | 23-16      | 15-12       | 11-8         | 7-0          |
            ----------------------------------------------------------------------------------
            | Use File | File Index | Enum Index | Enum Source | Reserved SBZ | EAccessFlags |

            - __EAccessFlags__ - used if required to resolve the expression.
              See IConnectDebug::EAccessFlags.
            - __Enum Source__ - see IConnectDebug::EGetAddressFlags, flags `gafExpression`,
                                   `gafVariables`, `gafLabels`, and `gafFunctions`.
            - __Enum Index__ - Index of the enumerated symbol to return.
            - __File index__ - Index of the symbol (download) file to use. Used only
              if `Use File` flag is set.
            - __Use File__ - if this bit set, then download file specified
                             by `File Index` is used. If it is not set, the default
                             download file is used.

        :type expression: string
        :param expression: name of the symbol, for example variable or
                   function name

        Python example: _sample_link{daq_ctrl,test_create_config_item}
        """
        return _connect.CAddressController_getSymbolInfo(self, flags, expression)

    def getSymbolAtAddress(self, *args):
        r"""
        Returns the name of the symbol at the specified address, or empty
        string if there is no symbol at the given address.

        :type symbolType: int
        :param symbolType: Specifies symbol classes to consider, must be one of the following
                   ``IConnectDebug::ESymbolFlags``: ``sVariables``, ``sLabels``, ``sFunctions``,
                   ``sLine``, or ``sConstants``.
        :type memArea: uint8_t
        :param memArea: memory area of the object
        :type address: int
        :param address: address of the object
        :type scope: int, optional
        :param scope: defines how exact the symbol search should be. Should be one of
                         ``sScope*`` flags from ``IConnectDebug::ESymbolFlags``.

        Python example: _sample_link{address_ctrl,test_get_symbol_at_address}
        """
        return _connect.CAddressController_getSymbolAtAddress(self, *args)

    def getAnySymbolAtAddress(self, symbolTypes, memArea, address, scope):
        r"""
        Returns the name of the symbol at the specified address, or empty
        string if there is no symbol at the given address.

        :type symbolTypes: int
        :param symbolTypes: Specifies symbol classes to consider, must be one of the following
                   ``IConnectDebug::ESymbolFlags``: ``sVariables``, ``sLabels``, ``sFunctions``,
                   ``sLine``, ``sConstants`` or ORed value of these constants
        :type memArea: uint8_t
        :param memArea: memory area of the object
        :type address: int
        :param address: address of the object
        :type scope: int
        :param scope: defines how exact the symbol search should be. Should be one of
                         ``sScope*`` flags from ``IConnectDebug::ESymbolFlags``.

        See also: getSymbolAtAddress
        """
        return _connect.CAddressController_getAnySymbolAtAddress(self, symbolTypes, memArea, address, scope)
    EPathSource_ELF_FILE = _connect.CAddressController_EPathSource_ELF_FILE
    r"""Return path from elf file."""
    EPathSource_LOCAL = _connect.CAddressController_EPathSource_LOCAL
    r"""
    Find the file referenced in ELF file in local file system. Throw if
    the file can not be located.
    """
    EPathSource_AUTO = _connect.CAddressController_EPathSource_AUTO
    r"""
    Try to find the file referenced in ELF file in the local files system.
    If not found, return the path from ELF.
    """

    def getAddressOfSourceLineAtPathSource(self, fileName, line, path_source, isReportSize=False):
        r"""
        Returns vector of addresses used by the given line of source code. If the line
        generates no assembly code (empty lines, for example), an empty vector is returned.
        To get info about memory area, use method getCodeArea(), because executable code
        is always located in the code memory area.

        If source line compiles to a continuous block of code its start address and size
        are reported. Only when source line generates several blocks of object code
        (for example 'for' loop), more than one address item is returned.
        If local path is selected as a source,
        it throws if source line could not be found in local files.

        :type fileName: string
        :param fileName: name of the file, where the source line is located,
                              file is used as is, without performing any path conversion,
                              even with use_winepath_conversion.
        :type line: int
        :param line: line number
        :type path_source: int
        :param path_source: explicit source where address should be looked for.
        :type isReportSize: boolean, optional
        :param isReportSize: if set, for every object location both address and size are returned

        Python example: _sample_link{address_ctrl,test_get_address_of_source_line}
        """
        return _connect.CAddressController_getAddressOfSourceLineAtPathSource(self, fileName, line, path_source, isReportSize)

    def getAddressOfSourceLine(self, fileName, line, isReportSize=False):
        r"""
        Returns vector of addresses used by the given line of source code. If the line
        generates no assembly code (empty lines, for example), an empty vector is returned.
        To get info about memory area, use method getCodeArea(), because executable code
        is always located in the code memory area.

        If source line compiles to a continuous block of code its start address and size
        are reported. Only when source line generates several blocks of object code
        (for example 'for' loop), more than one address item is returned.
        If local path is selected as a source,
        it throws if source line could not be found in local files.

        Equivalent to CAddressController::getAddressOfSourceLineAtPathSource(const std::string &, int, const EPathSource&, bool)
        with ePathSource set to EPathSource::AUTO.

        :type fileName: string
        :param fileName: name of the file, where the source line is located,
                              file is used as is, without performing any path conversion,
                              even with use_winepath_conversion.
        :type line: int
        :param line: line number
        :type isReportSize: boolean, optional
        :param isReportSize: if set, for every object location both address and size are returned

        Python example: _sample_link{address_ctrl,test_get_address_of_source_line}
        """
        return _connect.CAddressController_getAddressOfSourceLine(self, fileName, line, isReportSize)

    def getSourceLineAtAddressAtPathSource(self, *args):
        r"""
        *Overload 1:*

        Returns the location of source line which generates code at the given address.
        It is equivalent of ``getSourceLineAtAddressAtPathSource(address, false, false, ePathSource)``.

        :type address: int
        :param address: memory address, where the code generated by the returned
            source line is located

        :type ePathSource: int
        :param ePathSource: explicit source where address should be looked for.

        :rtype: :py:class:`CLineLocation`
        :return: file name and line number if there exits source line for the given
            address, or empty file name and line number set to 0 if there is no such source line.
            Returned path is converted to host path only if EPathSource::LOCAL is specified.

        Python example: _sample_link{address_ctrl,test_get_source_line_at_address}

        |

        *Overload 2:*

        Returns the location of source line which generates code at the given address.

        :type address: int
        :param address: memory address, where the code generated by the returned
            source line is located

        :type isExact: boolean
        :param isExact: if true, address must be the the first address occupied by
            the source line. If it is not, empty file name and line number set to 0 are returned.

        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, file name is returned with absolute path

        :type path_source: int
        :param path_source: path source to search for source file

        :rtype: :py:class:`CLineLocation`
        :return: file name and line number if there exits source line for the given
            address, or empty file name and line number set to 0 if there is no such source line.
        """
        return _connect.CAddressController_getSourceLineAtAddressAtPathSource(self, *args)

    def getSourceLineAtAddress(self, *args):
        r"""
        *Overload 1:*

        Returns the location of source line which generates code at the given address.

        Equivalent to ``getSourceLineAtAddressAtPathSource(address, false, false, CAddressController::ePathSource::AUTO)``

        |

        *Overload 2:*

        Returns the location of source line which generates code at the given address.

        Equivalent to CAddressController::getSourceLineAtAddressAtPathSource(ADDRESS_64, bool, bool, const EPathSource &) ,
        with ePathSource parameter as EPathSource::AUTO
        """
        return _connect.CAddressController_getSourceLineAtAddress(self, *args)

    def getFunctionNames(self, addresses, names, types):
        r"""
        Returns names of functions at given addresses. If function can not be found
        for an address, empty string or hex address is returned.

        :type addresses: :py:class:`AddressVector`
        :param addresses: input list of function addresses. Address may be located
                             anywhere inside function.
        :type names: :py:class:`StrVector`
        :param names: output list of function names. On output it has the same
                   number of elements as 'addresses'.
        :type types: :py:class:`IntVector`
        :param types: output list of symbol type at address. Can be IConnectDebug.sFunctions,
                         IConnectDebug.sLabels, or IConnectDebug.sConstants if no function
                         or label is found at the given address.

        Python example: _sample_link{address_ctrl,test_get_function_names}
        """
        return _connect.CAddressController_getFunctionNames(self, addresses, names, types)

    def getSourceLocationAtPathSource(self, *args):
        r"""
        Return line location which matches the given criteria. Use this method
        when you want to set a breakpoint on a specific line in source code,
        but line number of this line changes as source code is modified. For example,
        if you always want the script to set a breakpoint at source line

           numItems = 1234;

        in function ``f()``, then use this method to get line number and the
        source file. This information can then be used to set a breakpoint.

        :type tpLocation: :py:class:`CLineDescription`
        :param tpLocation: object with source line search criteria
        :type ePathSource: int
        :param ePathSource: explicit source where address should be looked for.

        Python example: _sample_link{address_ctrl,test_get_source_location}
        """
        return _connect.CAddressController_getSourceLocationAtPathSource(self, *args)

    def getSourceLocation(self, *args):
        r"""
        Return line location which matches the given criteria. Use this method
        when you want to set a breakpoint on a specific line in source code,
        but line number of this line changes as source code is modified.

        Equivalent to CAddressController::getSourceLocationAtPathSource(isys::CLineDescriptionSPtr, const EPathSource &)  with
        EPathSource::AUTO as ePathSource parameter.
        """
        return _connect.CAddressController_getSourceLocation(self, *args)

    @staticmethod
    def getTestPointIdPrefix():
        r"""
        Returns const prefix used in search for test point location,
        when matching type is set to E_MATCH_TEST_POINT_ID.

        Python example: _sample_link{address_ctrl,test_get_test_point_id_prefix}
        """
        return _connect.CAddressController_getTestPointIdPrefix()

# Register CAddressController in _connect:
_connect.CAddressController_swigregister(CAddressController)
class CBPInstance(object):
    r"""This class contains information about a breakpoint."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def location(self):
        r"""
        :rtype: string
        :return: location of a breakpoint.
        """
        return _connect.CBPInstance_location(self)

    def __init__(self):
        _connect.CBPInstance_swiginit(self, _connect.new_CBPInstance())
    __swig_destroy__ = _connect.delete_CBPInstance

# Register CBPInstance in _connect:
_connect.CBPInstance_swigregister(CBPInstance)
class CBreakpointController(object):
    r"""
    This class controls breakpoints on target.


    Python example for method setBP(): _sample_link{breakpoint_ctrl,test_set_b}
    Python example for method setHWBP(): _sample_link{breakpoint_ctrl,test_set_hwb}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)
        """
        _connect.CBreakpointController_swiginit(self, _connect.new_CBreakpointController(connectionMgr))
    __swig_destroy__ = _connect.delete_CBreakpointController

    def setBP(self, *args):
        r"""
        *Overload 1:*

        Sets breakpoint at the given symbol.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :type conditionExpression: string, optional
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set


            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main', 0, '')
            1

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

        |

        *Overload 2:*

        Sets breakpoint at the given location in source code.

        :type lineNumber: int
        :param lineNumber: line number in source file
        :type fileName: string
        :param fileName: name of source code file
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :type conditionExpression: string, optional
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(19, 'src/main.cpp', 0, '')
            0

            >>> bp_ctrl.setBP(19, 'src/main.cpp', 0, '')
            1

        |

        *Overload 3:*

        Sets breakpoint at the given location in source code.

        :type lineNumber: int
        :param lineNumber: line number in source file
        :type fileName: string
        :param fileName: name of source code file
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(19, 'src/main.cpp', 0, '')
            0

            >>> bp_ctrl.setBP(19, 'src/main.cpp', 0, '')
            1

        |

        *Overload 4:*

        Sets breakpoint at the given location in source code.

        :type lineNumber: int
        :param lineNumber: line number in source file
        :type fileName: string
        :param fileName: name of source code file
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(19, 'src/main.cpp', 0, '')
            0

            >>> bp_ctrl.setBP(19, 'src/main.cpp', 0, '')
            1

        |

        *Overload 5:*

        Sets breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address to set the breakpoint
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :type conditionExpression: string, optional
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(0, 0x20000000, 0, '')
            0

            >>> bp_ctrl.setBP(0, 0x20000000, 0, '')
            1

        |

        *Overload 6:*

        Sets breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address to set the breakpoint
        :type conditionCount: int, optional
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(0, 0x20000000, 0, '')
            0

            >>> bp_ctrl.setBP(0, 0x20000000, 0, '')
            1

        |

        *Overload 7:*

        Sets breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address to set the breakpoint
        :param conditionCount: the number of times condition has to be met for breakpoint to trigger
        :param conditionExpression: condition that has to be met for breakpoint to trigger

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(0, 0x20000000, 0, '')
            0

            >>> bp_ctrl.setBP(0, 0x20000000, 0, '')
            1
        """
        return _connect.CBreakpointController_setBP(self, *args)

    def setHWBP(self, *args):
        r"""
        *Overload 1:*

        Sets hardware breakpoint on the given variable or symbol. This
        method can set only the most basic parameters of one hardware
        breakpoint. If you'd like to set more than one HW breakpoint,
        or options not supported by this method, please set winIDEA options.
        To find options, set some value in HW breakpoint dialog in winIDEA,
        then search for it in winIDEA `Help | Display Options ...`

        Example for PowerPC:

            import isystem.connect as ic

            cmgr = ic.ConnectionMgr()
            cmgr.connect()

            ide = ic.CIDEController(cmgr)

            #configure the breakpoint
            strRoot = '/iOPEN/Breakpoints.PPC55xx.BP.'
            strCore = '1'
            ide.setOption(strRoot + 'HW.Enabled'              , 'true')
            ide.setOption(strRoot + 'HW.e200[' + strCore + '].Enabled'      , 'true')
            ide.setOption(strRoot + 'HW.e200[' + strCore + '].DAC_Enable[0]', 'true')
            ide.setOption(strRoot + 'HW.e200[' + strCore + '].DAC_Access[0]', 'WR')
            ide.setOption(strRoot + 'e200[' + strCore + '].DAC_Address[0]'  , 'VariableName')

            #apply it to the MCU
            print (ide.serviceCall('/iOPEN/Core.Debug.ApplyInternalBPs', ''))

        :type rwAccess: int
        :param rwAccess: defines read/write access. Should be one of
                            IConnectDebug::EBreakpointFlags
                            which start with ``bHW_acc...:``
                            - IConnectDebug::bHW_accAny
                            - IConnectDebug::bHW_accRD
                            - IConnectDebug::bHW_accWR
                            - IConnectDebug::bHW_accRW
                            - IConnectDebug::bHW_accFetch

        :type accessSize: int
        :param accessSize: defines the size of access area. Should be one
                   of IConnectDebug::EBreakpointFlags which start with
                   bHW_Size...:
                   - IConnectDebug::bHW_SizeDefault
                   - IConnectDebug::bHW_Size1
                   - IConnectDebug::bHW_Size2
                   - IConnectDebug::bHW_Size4
                   - IConnectDebug::bHW_Size8

        :type usedDataBytes: int
        :param usedDataBytes: determines which byte of ``data`` is used for data value
                   comparison (00 = no data, FF = all). It can be set as ORed value of
                   IConnectDebug::EBreakpointFlags which start with ``bHW_Data...:``
                   - IConnectDebug::bHW_DataLSB0
                   - IConnectDebug::bHW_DataLSB1
                   - IConnectDebug::bHW_DataLSB2
                   - IConnectDebug::bHW_DataLSB3

        :type isEntireObject: boolean
        :param isEntireObject: if true, all addresses occupied by object will be
                   monitored, otherwise only the first address is monitored. For example,
                   if symbol is array or struct, any address occupied by the symbol
                   may trigger a breakpoint.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              variable name.

        :type data: int
        :param data: value used for comparison (access breakpoints only)

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_hwb}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    True,  # monitor all addresses of the symbol
            ...                    "main_loop_counter",
            ...                    42)  # compare value
            0


        |

        *Overload 2:*

        Sets hardware breakpoint on the given address.
        See setHWBP(DWORD, DWORD, DWORD, bool, const std::string &, DWORD)
        for limitations of this method and how to overcome them.

        :type rwAccess: int
        :param rwAccess: defines read/write access. Should be one of
                            IConnectDebug::EBreakpointFlags
                            which start with ``bHW_acc...:``
                            - IConnectDebug::bHW_accAny
                            - IConnectDebug::bHW_accRD
                            - IConnectDebug::bHW_accWR
                            - IConnectDebug::bHW_accRW
                            - IConnectDebug::bHW_accFetch

        :type accessSize: int
        :param accessSize: defines the size of access area. Should be one
                   of IConnectDebug::EBreakpointFlags which start with
                   bHW_Size...:
                   - IConnectDebug::bHW_SizeDefault
                   - IConnectDebug::bHW_Size1
                   - IConnectDebug::bHW_Size2
                   - IConnectDebug::bHW_Size4
                   - IConnectDebug::bHW_Size8

        :type usedDataBytes: int
        :param usedDataBytes: determines which byte of ``data`` is used for data value
                   comparison (00 = no data, FF = all). It can be set as ORed value of
                   IConnectDebug::EBreakpointFlags which start with ``bHW_Data...:``
                   - IConnectDebug::bHW_DataLSB0
                   - IConnectDebug::bHW_DataLSB1
                   - IConnectDebug::bHW_DataLSB2
                   - IConnectDebug::bHW_DataLSB3

        :type memArea: int
        :param memArea: memory area of address

        :type address: int
        :param address: address to be monitored

        :type data: int
        :param data: value used for comparison (access breakpoints only)

        :rtype: int
        :return: 0 if there was no breakpoint before this call, 1 if the
                    breakpoint at this location was already set

        Python example: _sample_link{breakpoint_ctrl,test_set_hwb}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    0,  # main memory space
            ...                    0x20000034,
            ...                    56)  # compare value
            0
        """
        return _connect.CBreakpointController_setHWBP(self, *args)

    def deleteBP(self, *args):
        r"""
        *Overload 1:*

        Deletes breakpoint at the given symbol name.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        :rtype: int
        :return: 0 if there was breakpoint before this call (it was deleted),
                    1 if the breakpoint at this location did not exist

        Python example: _sample_link{breakpoint_ctrl,test_delete_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.deleteBP('main')
            0

        |

        *Overload 2:*

        Deletes breakpoint at the given location in source code.

        :type fileName: string
        :param fileName: name of source code file
        :type lineNumber: int
        :param lineNumber: line number in source file

        :rtype: int
        :return: 0 if operation was successful, 1 if operation was not executed as expected,
            but the target is in the expected state. For example, if there was no breakpoint at the
            specified location, then 1 is returned, because it was not removed, but after the
            method returns there is no breakpoint, as it is expected.

        Python example: _sample_link{breakpoint_ctrl,test_delete_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(19, 'src/main.cpp')
            0

            >>> bp_ctrl.deleteBP('src/main.cpp', 19)
            0

        |

        *Overload 3:*

        Deletes breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the existing breakpoint

        :rtype: int
        :return: 0 if operation was successful, 1 if operation was not executed as expected,
            but the target is in the expected state. For example, if there was no breakpoint at the
            specified location, then 1 is returned, because it was not removed, but after the
            method returns there is no breakpoint, as it is expected.

        Python example: _sample_link{breakpoint_ctrl,test_delete_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(0, 0x20000000)
            0

            >>> bp_ctrl.deleteBP(0, 0x20000000)
            0
        """
        return _connect.CBreakpointController_deleteBP(self, *args)

    def deleteHWBP(self, *args):
        r"""
        *Overload 1:*

        Deletes hardware breakpoint at the given symbol name.

        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        :rtype: int
        :return: 0 if operation was successful, 1 if there was no
            breakpoint at the given address or it was disabled.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    True,  # monitor all addresses of the symbol
            ...                    "main_loop_counter",
            ...                    42)  # compare value
            0

            >>> bp_ctrl.deleteHWBP("main_loop_counter")
            0

        |

        *Overload 2:*

        Deletes hardware breakpoint at the given address.

        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the breakpoint

        :rtype: int
        :return: 0 if operation was successful, 1 if there was no
            breakpoint at the given address or it was disabled.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    0,  # main memory space
            ...                    0x20000034,
            ...                    56)  # compare value
            0

            >>> bp_ctrl.deleteHWBP(0, 0x20000034)
            0
        """
        return _connect.CBreakpointController_deleteHWBP(self, *args)

    def deleteAll(self):
        r"""
        Deletes all execution breakpoints.

        :rtype: int
        :return: 0 if OK

        Python example: _sample_link{breakpoint_ctrl,test_delete_all}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main_loop_counter')
            0

            >>> bp_ctrl.deleteAll()
            0
        """
        return _connect.CBreakpointController_deleteAll(self)

    def deleteAllHWBP(self):
        r"""
        Deletes all hardware breakpoints.

        :rtype: int
        :return: 0 if OK

        Python example: _sample_link{breakpoint_ctrl,test_delete_all_hwb}


            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    True,  # monitor all addresses of the symbol
            ...                    "main_loop_counter",
            ...                    42)  # compare value
            0

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    0,  # main memory space
            ...                    0x20000034,
            ...                    56)  # compare value
            0

            >>> bp_ctrl.deleteAllHWBP()
            0
        """
        return _connect.CBreakpointController_deleteAllHWBP(self)

    def setEnabled(self, *args):
        r"""
        *Overload 1:*

        Enables / disables the breakpoint at the given symbol name.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        :rtype: int
        :return: 0 if breakpoint is enabled after the call, regardless of previous state.

        Python example: _sample_link{breakpoint_ctrl,test_set_enabled}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setEnabled(False, 'main')
            0

            >>> bp_ctrl.setEnabled(True, 'main')
            0

        |

        *Overload 2:*

        Enables / disables the breakpoint at the given source line.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type fileName: string
        :param fileName: name of source code file
        :type lineNumber: int
        :param lineNumber: line number in source file

        :rtype: int
        :return: 0 if breakpoint is enabled after the call, regardless of previous state.

        Python example: _sample_link{breakpoint_ctrl,test_set_enabled}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(19, 'src/main.cpp')
            0

            >>> bp_ctrl.setEnabled(False, 'src/main.cpp', 19)
            0

            >>> bp_ctrl.setEnabled(True, 'src/main.cpp', 19)
            0

        |

        *Overload 3:*

        Enables / disables the breakpoint at the given address.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the breakpoint

        :rtype: int
        :return: 0 if breakpoint is enabled after the call, regardless of previous state.

        Python example: _sample_link{breakpoint_ctrl,test_set_enabled}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP(0, 0x20000000)
            0

            >>> bp_ctrl.setEnabled(False, 0, 0x20000000)
            0

            >>> bp_ctrl.setEnabled(True, 0, 0x20000000)
            0
        """
        return _connect.CBreakpointController_setEnabled(self, *args)

    def setHWEnabled(self, *args):
        r"""
        *Overload 1:*

        Enables / disables hardware breakpoint at the given symbol name.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type symbolName: string
        :param symbolName: name of symbol in target program, for example
                              function name.

        :rtype: int
        :return: 0 if breakpoint is enabled after the call, regardless of previous state.

        Python example: _sample_link{breakpoint_ctrl,test_set_hw_enabled}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    True,  # monitor all addresses of the symbol
            ...                    "main_loop_counter",
            ...                    42)  # compare value
            0

            >>> bp_ctrl.setHWEnabled(False, "main_loop_counter")
            1

            >>> bp_ctrl.setHWEnabled(True, "main_loop_counter")
            0

        |

        *Overload 2:*

        Enables / disables hardware breakpoint at the given address.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable the breakpoint, false to disable it
        :type memArea: int
        :param memArea: memory area of the breakpoint
        :type address: int
        :param address: address of the breakpoint

        :rtype: int
        :return: 0 if breakpoint is enabled after the call, regardless of previous state.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>>

            >>>

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    0,  # main memory space
            ...                    0x20000034,
            ...                    56)  # compare value
            0

            >>> bp_ctrl.setHWEnabled(True, 0, 0x20000034)
            0

            >>> bp_ctrl.setHWEnabled(False, 0, 0x20000034)
            1

            >>>
        """
        return _connect.CBreakpointController_setHWEnabled(self, *args)

    def setHWEnabledAll(self, isEnabled):
        r"""
        Sets enabled status of all **hardware** breakpoints.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable breakpoints, false to disable them

        Python example: _sample_link{breakpoint_ctrl,test_set_hw_enabled_all}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>>

            >>>

            >>> bp_ctrl.setHWBP(ic.IConnectDebug.bHW_accRD,
            ...                    ic.IConnectDebug.bHW_SizeDefault,
            ...                    ic.IConnectDebug.bHW_DataLSB0,
            ...                    0,  # main memory space
            ...                    0x20000034,
            ...                    56)  # compare value
            0

            >>> bp_ctrl.setHWEnabledAll(True)
            0
        """
        return _connect.CBreakpointController_setHWEnabledAll(self, isEnabled)

    def setEnabledAll(self, isEnabled):
        r"""
        Sets enabled status of all breakpoints.

        :type isEnabled: boolean
        :param isEnabled: set to true to enable breakpoints, false to disable them

        Python example: _sample_link{breakpoint_ctrl,test_set_enabled_all}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>>

            >>>

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main_loop_counter')
            0

            >>> bp_ctrl.setEnabledAll(True)
            0
        """
        return _connect.CBreakpointController_setEnabledAll(self, isEnabled)

    def reapplyAll(self):
        r"""
        Reapplies all currently active breakpoints. Use this method, if your
        application has overwritten software breakpoints, for example when
        the code in RAM is overwritten by target application after download.

        :rtype: int
        :return: 0 on success, throws Exception on error.

        Python example: _sample_link{breakpoint_ctrl,test_reapply_all}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>>

            >>>

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main_loop_counter')
            0

            >>> bp_ctrl.reapplyAll()
            0
        """
        return _connect.CBreakpointController_reapplyAll(self)

    def get_BPs(self):
        r"""
        Returns all currently configured BPs

        :rtype: :py:class:`VBPInstances`
        :return: vector of BPs

        Python example: _sample_link{breakpoint_ctrl,test_get_bps}


            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>>

            >>>

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main_loop_counter')
            0

            >>> bp_instances = bp_ctrl.get_BPs()

            >>> [bp.location() for bp in bp_instances]
            ['main', 'main_loop_counter']
        """
        return _connect.CBreakpointController_get_BPs(self)

    def set_BP_symbol(self, rstrSymbol):
        r"""
        Sets a breakpoint on the symbol

        :type rstrSymbol: string
        :param rstrSymbol: name of the symbol to set a BP to

        :rtype: :py:class:`CBPInstance`
        :return: the breakpoint handle

        Python example: _sample_link{breakpoint_ctrl,test_set_bp_symbol}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_symbol('main_loop_counter')

            >>> bp_instance.location()
            'main_loop_counter'
        """
        return _connect.CBreakpointController_set_BP_symbol(self, rstrSymbol)

    def set_BP_source(self, nLineNumber, rstrFileName):
        r"""
        Sets a breakpoint on a source line

        :type nLineNumber: int
        :param nLineNumber: line number of the breakpoint
        :type rstrFileName: string
        :param rstrFileName: file name

        :rtype: :py:class:`CBPInstance`
        :return: the breakpoint handle

        Python example: _sample_link{breakpoint_ctrl,test_set_bp_source}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_source(19, 'src/main.cpp')

            >>> bp_instance.location()
            '"src\\main.cpp"::19'
        """
        return _connect.CBreakpointController_set_BP_source(self, nLineNumber, rstrFileName)

    def remove_BP(self, rBP):
        r"""
        removes the breakpoint

        :type rBP: :py:class:`CBPInstance`
        :param rBP: the breakpoint handle

        Python example: _sample_link{breakpoint_ctrl,test_remove_b}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_source(19, 'src/main.cpp')

            >>> bp_ctrl.remove_BP(bp_instance)

            >>>
        """
        return _connect.CBreakpointController_remove_BP(self, rBP)

    def remove_BPs(self, rvBPs):
        r"""
        removes the breakpoints

        :type rvBPs: :py:class:`VBPInstances`
        :param rvBPs: BP handles to remove

        Python example: _sample_link{breakpoint_ctrl,test_remove_bps}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main_loop_counter')
            0

            >>> bp_instances = bp_ctrl.get_BPs()

            >>> [bp.location() for bp in bp_instances]
            ['main', 'main_loop_counter']

            >>> bp_ctrl.remove_BPs(bp_instances)

            >>> bp_instances = bp_ctrl.get_BPs()

            >>> [bp.location() for bp in bp_instances]
            []
        """
        return _connect.CBreakpointController_remove_BPs(self, rvBPs)

    def remove_all_BPs(self):
        r"""
        removes all breakpoints

        Python example: _sample_link{breakpoint_ctrl,test_remove_all_bps}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_ctrl.setBP('main')
            0

            >>> bp_ctrl.setBP('main_loop_counter')
            0

            >>> bp_instances = bp_ctrl.get_BPs()

            >>> [bp.location() for bp in bp_instances]
            ['main', 'main_loop_counter']

            >>> bp_ctrl.remove_all_BPs()

            >>> bp_instances = bp_ctrl.get_BPs()

            >>> [bp.location() for bp in bp_instances]
            []
        """
        return _connect.CBreakpointController_remove_all_BPs(self)

    def set_BP_condition(self, rBP, nConditionCount, rstrConditionExpression):
        r"""
        Sets condition to the breakpoint

        :type rBP: :py:class:`CBPInstance`
        :param rBP: the breakpoint handle
        :type nConditionCount: int
        :param nConditionCount: the number of times condition has to be met for breakpoint to trigger
        :type rstrConditionExpression: string
        :param rstrConditionExpression: condition that has to be met for breakpoint to trigger

        Python example: _sample_link{breakpoint_ctrl,test_set_bp_condition}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_symbol('main')
            0

            >>> bp_ctrl.set_BP_condition(bp_instance, 1, 'main_loop_counter > 10')
        """
        return _connect.CBreakpointController_set_BP_condition(self, rBP, nConditionCount, rstrConditionExpression)

    def clear_BP_condition(self, rBP):
        r"""
        removes breakpoint's condition

        :type rBP: :py:class:`CBPInstance`
        :param rBP: the breakpoint handle

        Python example: _sample_link{breakpoint_ctrl,test_clear_bp_condition}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_symbol('main')
            0

            >>> bp_ctrl.set_BP_condition(bp_instance, 1, 'main_loop_counter > 10')

            >>> bp_ctrl.clear_BP_condition(bp_instance)
        """
        return _connect.CBreakpointController_clear_BP_condition(self, rBP)

    def set_BP_process_filter(self, *args):
        r"""
        Sets process filter for a breakpoint

        :type rBP: :py:class:`CBPInstance`
        :param rBP: the breakpoint handle
        :type rstrProcessFilter: string, optional
        :param rstrProcessFilter: the process filter string

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_symbol('main')
            0

            >>> bp_ctrl.set_BP_process_filter(bp_instance, 'App/CORE0')
        """
        return _connect.CBreakpointController_set_BP_process_filter(self, *args)

    def set_BP_action(self, rBP, rstrActionScript, rstrActionScriptParams, bShow):
        r"""
        Sets action to take when BP hits

        :type rBP: :py:class:`CBPInstance`
        :param rBP: the breakpoint handle
        :type rstrActionScript: string
        :param rstrActionScript: path to the script to execute
        :type rstrActionScriptParams: string
        :param rstrActionScriptParams: parameters to pass to rstrActionScript
        :type bShow: boolean
        :param bShow: if set, the script window is shown, otherwise hidden

        Python example: _sample_link{breakpoint_ctrl,test_set_bp_action}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_symbol('main')
            0

            >>> script_dir = os.path.normpath(os.path.dirname(__file__))

            >>> bp_action_script = os.path.join(script_dir, "set_bp_symbol_action.py")

            >>> param = "process_strings"

            >>> bp_ctrl.setBP_action(bp_instance, bp_action_script, param, False)
        """
        return _connect.CBreakpointController_set_BP_action(self, rBP, rstrActionScript, rstrActionScriptParams, bShow)

    def set_BP_enabled(self, rBP, bEnable):
        r"""
        Enables / disables the breakpoint

        :type rBP: :py:class:`CBPInstance`
        :param rBP: the breakpoint handle
        :type bEnable: boolean
        :param bEnable: set to true to enable the breakpoint, false to disable it

        Python example: _sample_link{breakpoint_ctrl,test_set_bp_enabled}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> bp_ctrl = ic.CBreakpointController(cmgr)

            >>> bp_instance = bp_ctrl.set_BP_symbol('main')
            0

            >>> bp_ctrl.set_BP_enabled(bp_instance, True)

            >>> bp_ctrl.set_BP_enabled(bp_instance, False)
        """
        return _connect.CBreakpointController_set_BP_enabled(self, rBP, bEnable)

# Register CBreakpointController in _connect:
_connect.CBreakpointController_swigregister(CBreakpointController)
class CDAQSample(object):
    r"""
    Sample acquired by the DAQ system.

    Python example: _sample_link{data_recorder_with_daq}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CDAQSample_swiginit(self, _connect.new_CDAQSample())

    def getIndex(self):
        r"""index of the DAQ item"""
        return _connect.CDAQSample_getIndex(self)

    def getTime(self):
        r"""Returns time of acquisition in microseconds."""
        return _connect.CDAQSample_getTime(self)

    def getData(self):
        r"""acquisition data in flat memory layout. Use CDAQController.getDataValue to extract a well formed type"""
        return _connect.CDAQSample_getData(self)

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CDAQSample_toString(self)
    __swig_destroy__ = _connect.delete_CDAQSample

# Register CDAQSample in _connect:
_connect.CDAQSample_swigregister(CDAQSample)
class CDAQInfo(object):
    r"""
    Capabilities information about the DAQ system.

    Python example: _sample_link{data_recorder_with_daq}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CDAQInfo_swiginit(self, _connect.new_CDAQInfo())

    def getMaxItems(self):
        r"""maximum number of DAQ items configurable"""
        return _connect.CDAQInfo_getMaxItems(self)

    def getBufSize(self):
        r"""size of sample buffer"""
        return _connect.CDAQInfo_getBufSize(self)

    def getMaxItemSize(self):
        r"""
        :rtype: BYTE
        :return: maximum size of a DAQ item

        Python example: _sample_link{daq_simple}
        """
        return _connect.CDAQInfo_getMaxItemSize(self)

    def getTick_ns(self):
        r"""
        Deprecated: in 9.21.2, always returns 1000. Times returned by CDAQSample::getTime()
        are always in microseconds now, so this method is no longer needed.

        Returns duration of DAQ clock tick in ns. All times returned by methods in
        ``CDAQ`` classes are returned as the number of DAQ clock ticks. Use value
        returned by this method to calculate real time:

         realTimeInSeconds = daqTime * getTick_ns() / 1'000'000'000.0
        """
        return _connect.CDAQInfo_getTick_ns(self)

    def getNumItems(self):
        r"""
        Deprecated: in 9.21.2, always throws. Call CDAQController::getNumItems() instead.

        :rtype: int
        :return: currently configured number of DAQ items
        """
        return _connect.CDAQInfo_getNumItems(self)

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CDAQInfo_toString(self)
    __swig_destroy__ = _connect.delete_CDAQInfo

# Register CDAQInfo in _connect:
_connect.CDAQInfo_swigregister(CDAQInfo)
class CDAQStatus(object):
    r"""
    Status information about the DAQ system.

    Python example: _sample_link{data_recorder_with_daq}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, qwTime, dwLastLoopTime, dwNumSamplesAvailable, dwNumLoops, bOverflow, bGlobalEnable):
        _connect.CDAQStatus_swiginit(self, _connect.new_CDAQStatus(qwTime, dwLastLoopTime, dwNumSamplesAvailable, dwNumLoops, bOverflow, bGlobalEnable))

    def getTime(self):
        r"""
         Current time in DAQ ticks.
        Python example: _sample_link{daq_simple}
        """
        return _connect.CDAQStatus_getTime(self)

    def getLastLoopTime(self):
        r"""DAQ loop time in milliseconds since last status check."""
        return _connect.CDAQStatus_getLastLoopTime(self)

    def getNumSamplesAvailable(self):
        r"""Number of samples ready for readout."""
        return _connect.CDAQStatus_getNumSamplesAvailable(self)

    def getNumLoops(self):
        r"""Number of loops executed since configuration reset."""
        return _connect.CDAQStatus_getNumLoops(self)

    def getOverflow(self):
        r"""Indicates whether an overflow in the DAQ sample buffer has occurred since last status check."""
        return _connect.CDAQStatus_getOverflow(self)

    def getGlobalEnable(self):
        r"""Returns ``true`` if global DAQ sampling is enabled."""
        return _connect.CDAQStatus_getGlobalEnable(self)

    def getCoreEnable(self):
        r"""
        Deprecated: in 9.21.2. Always returns the same value as getGlobalEnable().

        Returns ``true`` if DAQ sampling on this core is enabled.
        """
        return _connect.CDAQStatus_getCoreEnable(self)

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CDAQStatus_toString(self)
    __swig_destroy__ = _connect.delete_CDAQStatus

# Register CDAQStatus in _connect:
_connect.CDAQStatus_swigregister(CDAQStatus)
class CDAQConfig(object):
    r"""
    This class contains DAQ configuration. Its methods
    return reference to self, so we can use it like this:

    CDAQConfig config = new CDAQConfig();
    config.acquisition(BBK_RAM).smth(2);


    All parameters are optional. Set only what is required, default values are
    used for unspecified parameters.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CDAQConfig_swiginit(self, _connect.new_CDAQConfig())
    Auto = _connect.CDAQConfig_Auto
    r"""acquisition loop runs in best possible mode"""
    SW = _connect.CDAQConfig_SW
    r"""acquisition loop runs in debugger SW"""
    HW = _connect.CDAQConfig_HW
    r"""acquisition loop runs in debugger HW"""

    def mode(self, eMode):
        return _connect.CDAQConfig_mode(self, eMode)
    __swig_destroy__ = _connect.delete_CDAQConfig

# Register CDAQConfig in _connect:
_connect.CDAQConfig_swigregister(CDAQConfig)
class CDAQController(object):
    r"""
    This class controls DAQ (Data AcQuisition) system. It enables acquisition of
    data on target in non-blocking mode, but time precision is not as exact as
    with batch access, which is a blocking call.

    Call methods in the following sequence:

        attachHW()
        info()
        configure()
        enableGlobal(True)  // starts reading vars and placing them in DAQ buffer
        [status(),] read()  // repeat
        enableGlobal(False) // stops reading vars, but DAQ buffer may contain yet unread data
        [status(),] Read,   // repeat until done
        detachHW()

    Python example: _sample_link{daq_ctrl,test_attach_detach}
    Python example: _sample_link{daq_simple}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    daqSampleMax = _connect.CDAQController_daqSampleMax
    r"""maximum sampling"""
    daqSample1ms = _connect.CDAQController_daqSample1ms
    r"""1ms   sampling resolution"""
    daqSample10ms = _connect.CDAQController_daqSample10ms
    r"""10ms  sampling resolution"""
    daqSample100ms = _connect.CDAQController_daqSample100ms
    r"""100ms sampling resolution"""
    daqSample1s = _connect.CDAQController_daqSample1s
    r"""1 s   sampling resolution"""

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: _sample_link{daq_ctrl,test_attach_detach}
        Python example: _sample_link{daq_simple}
        """
        _connect.CDAQController_swiginit(self, _connect.new_CDAQController(connectionMgr))
    __swig_destroy__ = _connect.delete_CDAQController

    def attachHW(self):
        r"""Deprecated: this call is no longer required, it does nothing."""
        return _connect.CDAQController_attachHW(self)

    def detachHW(self):
        r"""Deprecated: this call is no longer required, it does nothing."""
        return _connect.CDAQController_detachHW(self)

    def configReset(self):
        r"""
        Deprecated: in 9.21.2 and later. If you are still using
                    the deprecated `configAdd()` methods, call
                    this method to clear all added samples.

        Resets DAQ configuration.

        Python example: _sample_link{data_recorder_with_daq}
        """
        return _connect.CDAQController_configReset(self)

    def configAdd(self, *args):
        r"""
        *Overload 1:*

        Deprecated: in 9.21.2, use method `configure()`.

        Adds a DAQ item to configuration.

        :type size: BYTE
        :param size: size of the item in bytes
        :type memArea: BYTE
        :param memArea: memory area of the item
        :type address: int
        :param address: address of the item
        :type sampling: int, optional
        :param sampling: sampling policy

        :rtype: int
        :return: the handle/index of the item. This value will be reported in the acquired samples.

        Python example: _sample_link{data_recorder_with_daq}

        |

        *Overload 2:*

        Deprecated: in 9.21.2, use method `configure()`.

        Adds a DAQ item to configuration.

        :type symbol: string
        :param symbol: name of the variable to monitor
        :type sampling: int, optional
        :param sampling: sampling policy

        :rtype: int
        :return: the handle/index of the item. This value will be reported in the acquired samples.


        |

        *Overload 3:*

        Deprecated: in 9.21.2, use method `configure()`.

        Adds a DAQ item to configuration.

        :type symbol: string
        :param symbol: name of the variable to monitor
        :param sampling: sampling policy

        :rtype: int
        :return: the handle/index of the item. This value will be reported in the acquired samples.
        """
        return _connect.CDAQController_configAdd(self, *args)

    def configure(self, *args):
        r"""
        *Overload 1:*

        Configures DAQ with the given items. It is not allowed to call
        `configure()` when DAQ is enabled (after `enableGlobal(true)`
        was called and before `enableGlobal(false)` was called.)

        See also: CDAQConfigItem

        Python example: _sample_link{daq_ctrl,test_daq_configure}

        |

        *Overload 2:*

        Configures DAQ with the given items. It is not allowed to call
        `configure()` when DAQ is enabled (after `enableGlobal(true)`
        was called and before `enableGlobal(false)` was called.)

        See also: CDAQConfigItem

        Python example: _sample_link{daq_ctrl,test_daq_configure}
        """
        return _connect.CDAQController_configure(self, *args)

    def getNumItems(self):
        r"""
        :rtype: int
        :return: currently configured number of DAQ items

        Python example: _sample_link{daq_ctrl,test_daq_configure}
        """
        return _connect.CDAQController_getNumItems(self)

    def enableGlobal(self, enable):
        r"""
        Enables or disables DAQ acquisition. This has to be enabled
        so that data can be acquired through the DAQ on any core. Call
        it after `configure()` or `configAdd()` calls.

        :type enable: boolean
        :param enable: defines whether the global DAQ is enabled or not

        Python example: _sample_link{daq_ctrl,test_attach_detach}
        """
        return _connect.CDAQController_enableGlobal(self, enable)

    def enableCore(self, enable):
        r"""
        Deprecated: in 9.21.2 and later this method has no effect. You may
                    remove it from your code.

        Enables or disables DAQ acquisition on this particular core. This has to
        be enabled so that data can be acquired through the DAQ on this particular
        core.

        :type enable: boolean
        :param enable: defines whether DAQ on the controlled core is enabled or not

        Python example: _sample_link{data_recorder_with_daq}
        """
        return _connect.CDAQController_enableCore(self, enable)

    def info(self):
        r"""
        Returns the information about DAQ capabilities.

        Python example: _sample_link{daq_ctrl,test_run}
        """
        return _connect.CDAQController_info(self)

    def status(self):
        r"""
        Returns the current status of the DAQ system.

        Python example: _sample_link{daq_ctrl,test_run}
        """
        return _connect.CDAQController_status(self)

    def read(self, samples, maxSamples=0):
        r"""
        Reads acquired data.

        :type samples: std::vector< isys::CDAQSample,std::allocator< isys::CDAQSample > >
        :param samples: vector where samples will be read to
        :type maxSamples: int, optional
        :param maxSamples: defines the maximum number of samples to read. If 0
                   is specified, all current acquired samples will be loaded. Not
                   used in SDK versions 9.21.2 and later.

        Python example: _sample_link{daq_ctrl,test_run}
        """
        return _connect.CDAQController_read(self, samples, maxSamples)

    def getDataValue(self, sample):
        r"""
        Returns the value of the acquired sample in CValueType format.
        If sample configuration was given as address and size (not with
        symbol name), then unsigned integral type is assumed.

        :type sample: :py:class:`CDAQSample`
        :param sample: previously acquired sample.

        :rtype: :py:class:`CValueType`
        :return: value in CValueType format

        Python example: _sample_link{daq_ctrl,test_run}
        """
        return _connect.CDAQController_getDataValue(self, sample)

# Register CDAQController in _connect:
_connect.CDAQController_swigregister(CDAQController)
class CDAQConfigItem(object):
    r"""This class contains configuration of one DAQ item."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :type size: BYTE
        :param size: size of the item in bytes
        :type memArea: BYTE
        :param memArea: memory area of the item
        :type address: int
        :param address: address of the item
        :type sampling: int, optional
        :param sampling: sampling policy
        :type coreIndex: int, optional
        :param coreIndex: index of the core
        :type socIndex: int, optional
        :param socIndex: index of the soc

        |

        *Overload 2:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :type size: BYTE
        :param size: size of the item in bytes
        :type memArea: BYTE
        :param memArea: memory area of the item
        :type address: int
        :param address: address of the item
        :type sampling: int, optional
        :param sampling: sampling policy
        :type coreIndex: int, optional
        :param coreIndex: index of the core
        :param socIndex: index of the soc

        |

        *Overload 3:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :type size: BYTE
        :param size: size of the item in bytes
        :type memArea: BYTE
        :param memArea: memory area of the item
        :type address: int
        :param address: address of the item
        :type sampling: int, optional
        :param sampling: sampling policy
        :param coreIndex: index of the core
        :param socIndex: index of the soc

        |

        *Overload 4:*

        Creates DAQ sampling item at the given address in memory. Core and SoC
        indices are set to 0.

        :type size: BYTE
        :param size: size of the item in bytes
        :type memArea: BYTE
        :param memArea: memory area of the item
        :type address: int
        :param address: address of the item
        :param sampling: sampling policy
        :param coreIndex: index of the core
        :param socIndex: index of the soc

        |

        *Overload 5:*

        Creates DAQ sampling item for the given symbol in memory.

        :type symbolName: string
        :param symbolName: name of the variable to monitor
        :type sampling: int, optional
        :param sampling: sampling policy
        :type coreIndex: int, optional
        :param coreIndex: index of core
        :type socIndex: int, optional
        :param socIndex: index of SoC

        |

        *Overload 6:*

        Creates DAQ sampling item for the given symbol in memory.

        :type symbolName: string
        :param symbolName: name of the variable to monitor
        :type sampling: int, optional
        :param sampling: sampling policy
        :type coreIndex: int, optional
        :param coreIndex: index of core
        :param socIndex: index of SoC

        |

        *Overload 7:*

        Creates DAQ sampling item for the given symbol in memory.

        :type symbolName: string
        :param symbolName: name of the variable to monitor
        :type sampling: int, optional
        :param sampling: sampling policy
        :param coreIndex: index of core
        :param socIndex: index of SoC

        |

        *Overload 8:*

        Creates DAQ sampling item for the given symbol in memory.

        :type symbolName: string
        :param symbolName: name of the variable to monitor
        :param sampling: sampling policy
        :param coreIndex: index of core
        :param socIndex: index of SoC

        |

        *Overload 9:*

        Creates DAQ sampling item for program counter register (PC).

        :type size: BYTE
        :param size: size of the PC in bytes
        :type sampling: int, optional
        :param sampling: sampling policy
        :type coreIndex: int, optional
        :param coreIndex: index of core
        :type socIndex: int, optional
        :param socIndex: index of SoC

        |

        *Overload 10:*

        Creates DAQ sampling item for program counter register (PC).

        :type size: BYTE
        :param size: size of the PC in bytes
        :type sampling: int, optional
        :param sampling: sampling policy
        :type coreIndex: int, optional
        :param coreIndex: index of core
        :param socIndex: index of SoC

        |

        *Overload 11:*

        Creates DAQ sampling item for program counter register (PC).

        :type size: BYTE
        :param size: size of the PC in bytes
        :type sampling: int, optional
        :param sampling: sampling policy
        :param coreIndex: index of core
        :param socIndex: index of SoC

        |

        *Overload 12:*

        Creates DAQ sampling item for program counter register (PC).

        :type size: BYTE
        :param size: size of the PC in bytes
        :param sampling: sampling policy
        :param coreIndex: index of core
        :param socIndex: index of SoC
        """
        _connect.CDAQConfigItem_swiginit(self, _connect.new_CDAQConfigItem(*args))

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CDAQConfigItem_toString(self)
    __swig_destroy__ = _connect.delete_CDAQConfigItem

# Register CDAQConfigItem in _connect:
_connect.CDAQConfigItem_swigregister(CDAQConfigItem)
class CValueType(object):
    r"""
    This is a wrapper class for iConnect SType and SValue. Since some languages do
    not support unions, there are special getter methods for obtaining the value.

    **Important:** If there was an error in evaluation, this class will contain
    error description instead of the value. Method isError() should be called
    always when an instance of this class is returned from ``isystem.connect`` methods,
    for example CDataController::evaluate() or CDataController::readValue().

    This class is immutable.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EDecimal = _connect.CValueType_EDecimal
    r"""
    All integers, from 8 to 64-bit, are returned as string in decimal format.
    Has no effect for other types like floats or addresses.
    """
    EHex = _connect.CValueType_EHex
    r"""
    All integers, from 8 to 64-bit, are returned as string in hexadecimal format.
    Has no effect for other types like floats or addresses.
    """
    EChar = _connect.CValueType_EChar
    r"""8-bit integers in range 32-127 are returned as characters"""

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new object with type and value.

        |

        *Overload 2:*

        Initializes new object with type, value, and string result of
        evaluation.

        |

        *Overload 3:*

        This ctor sets 64 bit integer value.

        :type type: :py:class:`SType`
        :param type: must be set to tSigned or tUnsigned, bit size must be
                   less than 65.
        :type value: int
        :param value: the value

        |

        *Overload 4:*

        This ctor sets float value.

        :type type: :py:class:`SType`
        :param type: must be set to tFloat, bit size must be 32 or 64.
        :type value: float
        :param value: the value

        |

        *Overload 5:*

        This ctor sets double value.

        :type type: :py:class:`SType`
        :param type: must be set to tFloat, bit size must be 64.
        :type value: float
        :param value: the value

        |

        *Overload 6:*

        This ctor initializes object with signed data.

        :type bitSize: int
        :param bitSize: size of value in bits
        :type value: int
        :param value: the value

        |

        *Overload 7:*

        This ctor initializes object with signed data.

        :type bitSize: int
        :param bitSize: size of value in bits
        :type value: int
        :param value: the value

        |

        *Overload 8:*

        This ctor sets 32 bit float value as follows:

        SType.m_byType = tFloat;
        SType.m_byBitSize = 32;


        :type value: float
        :param value: the value

        |

        *Overload 9:*

        This ctor sets 64 bit float value as follows:

        SType.m_byType = tFloat;
        SType.m_byBitSize = 64;


        :type value: float
        :param value: the value

        |

        *Overload 10:*

        This ctor sets address value.

        :type type: :py:class:`SType`
        :param type: must be set to tAddress
        :type address: :py:class:`CAddress`
        :param address: the address

        |

        *Overload 11:*

        This ctor sets numeric values and string value, depending on the type
        specified. It is preferred to use this method from Java for unsigned types.

        :type type: :py:class:`SType`
        :param type: the type, no restrictions
        :type value: string
        :param value: string containing integer to be set. Example: "324".
                         Only characters up to first non-digit character are used.

        |

        *Overload 12:*

        This ctor is used to report error. Used for example wehn reading SFRs,
        since some SFRs can not be read due to access restrictions, while
        most of them are read without problems.

        :type errorMsg: string
        :param errorMsg: string containing error description
        """
        _connect.CValueType_swiginit(self, _connect.new_CValueType(*args))

    def isError(self):
        r"""
        Returns true, if the object contains error message instead of value.
        Call getResult() to get the error message.
        """
        return _connect.CValueType_isError(self)

    def getType(self):
        r"""
        Returns iConnect type. It is preferred to use one of 'isType...()'
         and 'getBitSize()' methods instead of this one.
        """
        return _connect.CValueType_getType(self)

    def getValue(self):
        r"""Returns iConnect value."""
        return _connect.CValueType_getValue(self)

    def getResult(self, *args):
        r"""
        *Overload 1:*

        Returns string value, which is either the evaluation result or error
        message if isError() returns true. This method should be used for
        logging or debugging only. Use other getters to obtain values
        for further processing. Format of the returned value depends on
        settings in winIDEA watch window.

        |

        *Overload 2:*

        Returns string value, which is either the evaluation result or error
        message if isError() returns true.
        This method should be used for logging or debugging only. Use other
        getters to obtain values for further processing.

        :type format: int
        :param format: result format has effect only for integer values.
        """
        return _connect.CValueType_getResult(self, *args)

    def isTypeUnsigned(self):
        r"""Returns true, if the value is of unsigned type."""
        return _connect.CValueType_isTypeUnsigned(self)

    def isTypeSigned(self):
        r"""Returns true, if the value is of signed type."""
        return _connect.CValueType_isTypeSigned(self)

    def isTypeFloat(self):
        r"""Returns true, if the value is of float type."""
        return _connect.CValueType_isTypeFloat(self)

    def isTypeAddress(self):
        r"""Returns true, if the value is of address type."""
        return _connect.CValueType_isTypeAddress(self)

    def isTypeCompound(self):
        r"""Returns true, if the value is of compound type, for example struct."""
        return _connect.CValueType_isTypeCompound(self)

    def getBitSize(self):
        r"""Returns size of value in bits."""
        return _connect.CValueType_getBitSize(self)

    def getInt(self):
        r"""
        Returns integer value for bit sizes 8, 16, and 32.

        :raises: IOException if bit size given in ctor does not
                     match 8, 16, or 32, or type is not tSigned or tUnsigned.
        """
        return _connect.CValueType_getInt(self)

    def getLong(self):
        r"""
        Returns long integer value for bit sizes 8, 16, 32, and 64.

        :raises: IOException if bit size given in ctor does not
                     match 8, 16, 32, or 64, or type is not tSigned or tUnsigned.
        """
        return _connect.CValueType_getLong(self)

    def getFloat(self):
        r"""
        Returns float value. If the value is of type integer it is converted to float.

        :raises: IOException if bit size is not 32, or type is not
                                tSigned, or tUnsigned, or tFloat
        """
        return _connect.CValueType_getFloat(self)

    def getDouble(self):
        r"""
        Returns double value. If the value is of type integer or float, it is
        converted to double.

        :raises: IOException if bit size is not 32, or 64, or type is not
                                tSigned, or tUnsigned, or tFloat
        """
        return _connect.CValueType_getDouble(self)

    def getAddress(self):
        r"""
        Returns address.

        :raises: IOException if type is not  tAddress.
        """
        return _connect.CValueType_getAddress(self)
    __swig_destroy__ = _connect.delete_CValueType

# Register CValueType in _connect:
_connect.CValueType_swigregister(CValueType)
class CVariable(object):
    r"""
    This immutable class contains information about variable or function
    parameter.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Instantiates object. Constructor is not intended to be used by clients.

        |

        *Overload 2:*
        Instantiates object. Constructor is not intended to be used by clients.
        """
        _connect.CVariable_swiginit(self, _connect.new_CVariable(*args))

    def getName(self):
        r"""Returns variable name."""
        return _connect.CVariable_getName(self)

    def getQualifiedName(self):
        r"""Return qualified variable name."""
        return _connect.CVariable_getQualifiedName(self)

    def getType(self):
        r"""Returns variable type as string."""
        return _connect.CVariable_getType(self)

    def getArrayDimension(self):
        r"""Returns array dimension if variable is of type array."""
        return _connect.CVariable_getArrayDimension(self)

    def getNumBytes(self):
        r"""Returns size in bytes. Deprecated, use getSize() instead."""
        return _connect.CVariable_getNumBytes(self)

    def getSize(self):
        r"""Returns size in bytes."""
        return _connect.CVariable_getSize(self)

    def getTypeAsEnum(self):
        r"""Returns variable type as enum value."""
        return _connect.CVariable_getTypeAsEnum(self)

    def getScope(self):
        r"""Returns scope, for example class name."""
        return _connect.CVariable_getScope(self)
    __swig_destroy__ = _connect.delete_CVariable

# Register CVariable in _connect:
_connect.CVariable_swigregister(CVariable)
class CFunction(object):
    r"""This immutable class contains information about function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CFunction_swiginit(self, _connect.new_CFunction(*args))

    def getName(self):
        r"""Returns function name without any qualifiers like scope or parameters."""
        return _connect.CFunction_getName(self)

    def getQualifiedName(self):
        r"""
        Returns function name. This name may not be fully qualified,
        but depends on setting in winiDEA (for example just enough decorated
        to be unique).
        """
        return _connect.CFunction_getQualifiedName(self)

    def getScope(self):
        r"""Returns function scope, for example class name."""
        return _connect.CFunction_getScope(self)

    def getReturnType(self):
        r"""Returns function's return type."""
        return _connect.CFunction_getReturnType(self)

    def getModuleIndex(self):
        r"""
        Returns index of the source file, where this function is implemented.
        The index can be used to get module from the list of modules returned
        by method CDataController::getModules().
        """
        return _connect.CFunction_getModuleIndex(self)

    def getParameters(self):
        r"""Returns function parameters."""
        return _connect.CFunction_getParameters(self)

    def getLocalVars(self):
        r"""Returns function local variables (including parameters)."""
        return _connect.CFunction_getLocalVars(self)

    def getCallsToFunction(self, functionAddresses):
        r"""
        Returns addresses, where calls to this function are located.

        See also: isys::CAddressController::getFunctionNames()

        Python example: _sample_link{call_hierarchy}
        """
        return _connect.CFunction_getCallsToFunction(self, functionAddresses)

    def getCallsFromFunction(self, functionAddresses):
        r"""
        Returns addresses of functions, which are called from this function.
        If some function is called from more than one location in this
        function, then its address appears more than once in ``functionAddresses``.

        See also: isys::CAddressController::getFunctionNames()

        Python example: _sample_link{call_hierarchy}
        """
        return _connect.CFunction_getCallsFromFunction(self, functionAddresses)
    __swig_destroy__ = _connect.delete_CFunction

# Register CFunction in _connect:
_connect.CFunction_swigregister(CFunction)
class CStackFrame(object):
    r"""This class contains information about one stack frame."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CStackFrame_swiginit(self, _connect.new_CStackFrame(*args))

    def getAddress(self):
        r"""Returns address of a stack frame."""
        return _connect.CStackFrame_getAddress(self)

    def getMemArea(self):
        r"""
        Returns memory area of a stack frame. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.
        """
        return _connect.CStackFrame_getMemArea(self)

    def getFileName(self):
        r"""Returns name of file, where the execution point is located."""
        return _connect.CStackFrame_getFileName(self)

    def getLineNumber(self):
        r"""Returns the source code line number, where the execution point is located."""
        return _connect.CStackFrame_getLineNumber(self)

    def getFunction(self):
        r"""Returns function information."""
        return _connect.CStackFrame_getFunction(self)

    def getPartition(self):
        r"""
        Returns index of download file, where this function is located.
        Use it as parameter to getSymbols() if module name is needed.
        """
        return _connect.CStackFrame_getPartition(self)
    __swig_destroy__ = _connect.delete_CStackFrame

# Register CStackFrame in _connect:
_connect.CStackFrame_swigregister(CStackFrame)
class CModule(object):
    r"""This immutable class contains information about source code file."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Instantiates object. Constructor is not intended to be used by clients.
        :type path: string
        :param path: source file name including directory relative to winIDEA workspace,
                        or abs path, if the file is not below winIDEA workspace directory.
                        Example: 'src/comomn/main.c'
        :type name: string
        :param name: source file name without directory. Example: `main.c`
        """
        _connect.CModule_swiginit(self, _connect.new_CModule(*args))

    def getPath(self):
        r"""
        Returns source file name including folder relative to winIDEA workspace, or abs path,
        if the file is not below winIDEA workspace dir. Example: `src/comomn/main.c`
        """
        return _connect.CModule_getPath(self)

    def getName(self):
        r"""Returns file name without directory. Example: `main.c`."""
        return _connect.CModule_getName(self)
    __swig_destroy__ = _connect.delete_CModule

# Register CModule in _connect:
_connect.CModule_swigregister(CModule)
class CType(object):
    r"""This immutable class contains information about data type."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CType_swiginit(self, _connect.new_CType(*args))

    def getName(self):
        r"""Returns type name."""
        return _connect.CType_getName(self)

    def getType(self):
        r"""Returns type information."""
        return _connect.CType_getType(self)
    __swig_destroy__ = _connect.delete_CType

# Register CType in _connect:
_connect.CType_swigregister(CType)
class CTypedef(object):
    r"""This immutable class contains information about typedef."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CTypedef_swiginit(self, _connect.new_CTypedef(*args))

    def getTypedefName(self):
        r"""Returns typedef name."""
        return _connect.CTypedef_getTypedefName(self)

    def getTypeName(self):
        r"""Returns type name."""
        return _connect.CTypedef_getTypeName(self)
    __swig_destroy__ = _connect.delete_CTypedef

# Register CTypedef in _connect:
_connect.CTypedef_swigregister(CTypedef)
class CMemoryAccess(object):
    r"""This class contains information about available memory access types."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, accessInfo):
        _connect.CMemoryAccess_swiginit(self, _connect.new_CMemoryAccess(accessInfo))

    def canRead(self):
        r"""Returns true, if read is available."""
        return _connect.CMemoryAccess_canRead(self)

    def canWrite(self):
        r"""Returns true, if writ is available."""
        return _connect.CMemoryAccess_canWrite(self)

    def canReadInRealtime(self):
        r"""Returns true, if read in real time is available."""
        return _connect.CMemoryAccess_canReadInRealtime(self)

    def canWriteInRealtime(self):
        r"""Returns true, if write in real time is available."""
        return _connect.CMemoryAccess_canWriteInRealtime(self)
    __swig_destroy__ = _connect.delete_CMemoryAccess

# Register CMemoryAccess in _connect:
_connect.CMemoryAccess_swigregister(CMemoryAccess)
class CSystemMemoryAreas(object):
    r"""
    This class contains information about system memory areas. This class
    is not intended to be instantiated by clients. Call
    CDataController::getSystemMemoryAreas() to get instance of this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getMemAreaCodeVirtual(self):
        r"""Returns virtual memory area of code symbols."""
        return _connect.CSystemMemoryAreas_getMemAreaCodeVirtual(self)

    def getMemAreaCodePhysical(self):
        r"""Returns physical memory area of code."""
        return _connect.CSystemMemoryAreas_getMemAreaCodePhysical(self)

    def getMemAreaDataVirtual(self):
        r"""Returns virtual memory area of data symbols."""
        return _connect.CSystemMemoryAreas_getMemAreaDataVirtual(self)

    def getMemAreaDataPhysical(self):
        r"""Returns physical memory area of data."""
        return _connect.CSystemMemoryAreas_getMemAreaDataPhysical(self)

    def getMemAreaSFR(self):
        r"""Returns memory area of SFR space."""
        return _connect.CSystemMemoryAreas_getMemAreaSFR(self)
    __swig_destroy__ = _connect.delete_CSystemMemoryAreas

# Register CSystemMemoryAreas in _connect:
_connect.CSystemMemoryAreas_swigregister(CSystemMemoryAreas)
class CStackUsage(object):
    r"""
    This class contains information about stack usage. Clients should not
    instantiate this class, call method CDataController::getStackUsage()
    to get instances of this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CStackUsage_swiginit(self, _connect.new_CStackUsage())

    def getBase(self):
        r"""Returns base address of stack."""
        return _connect.CStackUsage_getBase(self)

    def getSize(self):
        r"""Returns size of stack."""
        return _connect.CStackUsage_getSize(self)

    def getUsed(self):
        r"""Returns used size of stack."""
        return _connect.CStackUsage_getUsed(self)
    __swig_destroy__ = _connect.delete_CStackUsage

# Register CStackUsage in _connect:
_connect.CStackUsage_swigregister(CStackUsage)
class CDataController(object):
    r"""
    This class enables access to data on the target - memory, variables,
    and registers.



    **Qualified Variable Names**

    When variables are specified by name, for example in ``evaluate()`` or
    ``modify()`` methods, it may happen that more than one variables in
    different source or download files share the same name. In such case
    we have to specify the fully qualified variable name in the following
    format:

        "<moduleName>"#<varName>,,<downloadFileName>

    where:
    - ``moduleName`` - name of the C source file, which contains variable
    - ``varName`` - name of the variable
    - ``downloadFileName`` - name of the download file, where the variable is located

    Example:

    "main.c"#iCounter,,executable.elf


    The same syntax is used for function names, see also
    CAddressController::getFunctionName().


    Another type of variables are function static variables, which have to
    be prefixed with ``<functionName>##``, for example:

    myFunction##myStaticVar


    The same syntax can be used in winIDEA's Watch window.


    _sample_link{data_ctrl,test_batch_access}
    _sample_link{data_ctrl,test_get_symbols}
    _sample_link{data_ctrl,test_data_evaluate}
    _sample_link{data_ctrl,test_read_write_register}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    estFunctions = _connect.CDataController_estFunctions
    r"""get functions"""
    estGlobalVariables = _connect.CDataController_estGlobalVariables
    r"""get global variables"""
    estModules = _connect.CDataController_estModules
    r"""get modules"""
    PARTITION_DEFAULT = _connect.CDataController_PARTITION_DEFAULT
    r"""The default download file is sued."""
    PARTITION_CURRENT = _connect.CDataController_PARTITION_CURRENT
    r"""The current download file is used."""

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: _sample_link{data_ctrl,test_cpu_info}
        """
        _connect.CDataController_swiginit(self, _connect.new_CDataController(connectionMgr))
    __swig_destroy__ = _connect.delete_CDataController

    def getCPUInfo(self):
        r"""
        Returns CPU info. See definition of this struct in CCPUInfo.h for enum
        constants which describe CPU type.

        Python example: _sample_link{data_ctrl,test_cpu_info}
        """
        return _connect.CDataController_getCPUInfo(self)

    def getMemoryAreaBytesPerMAU(self, memArea):
        r"""
        Returns the number of bytes per addressable memory unit.

        :type memArea: int
        :param memArea: memory area for which to return the number

        Python example: _sample_link{data_ctrl,test_get_memory_area_bytes_per_mau}
        """
        return _connect.CDataController_getMemoryAreaBytesPerMAU(self, memArea)

    def readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU):
        r"""
        This method reads memory block and returns data and access info.
        Returned vector contains data in the first ``(aNumMAUs * bytesPerMAU)``
        bytes, and access info in ``aNumMAUs`` bytes at offset
        ``(aNumMAUs * bytesPerMAU)``.

        Access info bytes tell us, whether read for MAU succeeded or not. Each byte
        is set to ``ACCESS_OK`` or `ACCESS_FAIL`. These two constants are
        defined in globdefs.h.

        Contents of the returned vector:

            [(target memory data, size = aNumMAUs * bytesPerMAU) (access info, size = aNumMAUs)]


        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual
                           CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location
        :type aNumMAUs: int
        :param aNumMAUs: number of MAUs (memory addressable units) to read.

        :type bytesPerMAU: BYTE
        :param bytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:

              | MAU Size in bits| Bytes Required per MAU|
              -------------------------------------------
              | 1 - 8           |             1         |
              | 9 - 16          |             2         |
              | 17 - 32         |             4         |

              Almost all microprocessors supported by our tools have 1 byte of
              data stored at one address, so this value is usually set to 1.
              winIDEA will check this parameter and return ICONNECT_E_SIZE in
              case of mismatch.

        :raises: IOException in case of an error


            Python example: _sample_link{data_ctrl,test_read_write_memory}
        """
        return _connect.CDataController_readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU)

    def writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff):
        r"""
        Writes block of data to target memory, and returns access information.

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual
                           CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location
        :type aNumMAUs: int
        :param aNumMAUs: number of MAUs (memory addressable units) to write.

        :type bytesPerMAU: BYTE
        :param bytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:

              | MAU Size in bits| Bytes Required per MAU|
              -------------------------------------------
              | 1 - 8           |             1         |
              | 9 - 16          |             2         |
              | 17 - 32         |             4         |

              Almost all microprocessors supported by our tools have 1 byte of
              data stored at one address, so this value is usually set to 1.
              winIDEA will check this parameter and return ICONNECT_E_SIZE in
              case of mismatch.

        :type buff: std::vector< BYTE,std::allocator< BYTE > >
        :param buff: vector, which contains data to be written to memory on the target.
            Languages other than C++ should instantiate class ``VectorBYTE`` for this parameter.
            Examples:

            Python:
                buff = isystem.connect.VectorBYTE([0, 0, 0, 0xff])

            Java:
                VectorBYTE buff = new VectorBYTE();
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)255);


        :raises: IOException in case of an error

        :rtype: std::vector< BYTE,std::allocator< BYTE > >
        :return: accessInfo contains write status, one byte per MAU for each MAU. Byte
            at index 0 contains access info for MAU at address **aAddress**, byte at index 1
            contains access info for MAU at address **aAddress** + **1**, ...
            See ACCESS_OK and ACCESS_FAIL in globdefs.h for possible values of access info bytes.


            Python example: _sample_link{data_ctrl,test_read_write_memory}
        """
        return _connect.CDataController_writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def writeMemoryNAI(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff):
        r"""
        Writes block of data to target memory. This method is faster than
        writeMemory(), because no access information is returned.

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual
                           CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location
        :type aNumMAUs: int
        :param aNumMAUs: number of MAUs (memory addressable units) to write.

        :type bytesPerMAU: BYTE
        :param bytesPerMAU: Number of BYTE type locations required to
              fit one MAU (memory addressable unit). The number of bytes
              required for every MAU is:

              | MAU Size in bits| Bytes Required per MAU|
              -------------------------------------------
              | 1 - 8           |             1         |
              | 9 - 16          |             2         |
              | 17 - 32         |             4         |

              Almost all microprocessors supported by our tools have 1 byte of
              data stored at one address, so this value is usually set to 1.
              winIDEA will check this parameter and return ICONNECT_E_SIZE in
              case of mismatch.

        :type buff: std::vector< BYTE,std::allocator< BYTE > >
        :param buff: vector, which contains data to be written to memory on the target.
            Languages other than C++ should instantiate class ``VectorBYTE`` for this parameter.
            Examples:

            Python:
                buff = isystem.connect.VectorBYTE([0, 0, 0, 0xff])

            Java:
                VectorBYTE buff = new VectorBYTE();
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)0);
                buff.add((short)255);


        :raises: IOException in case of an error

        See also: writeMemory()

        Python example: see _sample_link{data_ctrl,test_read_write_memory}
        """
        return _connect.CDataController_writeMemoryNAI(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def readRegister(self, accessFlags, registerName):
        r"""
        Reads the specified general purpose register. For SFRs please use
        method evaluate().

        :type accessFlags: int
        :param accessFlags: see IConnectDebug::EAccessFlags for available flags, except
                               **fCacheCode**
        :type registerName: string
        :param registerName: name of the register to read

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_read_write_register}
        """
        return _connect.CDataController_readRegister(self, accessFlags, registerName)

    def writeRegister(self, accessFlags, registerName, registerInfo):
        r"""
        Writes value to the specified core register.
        Example:

            # bit size is 32, value is 1234567
            r1Value = isystem.connect.CValueType(32, 1234567)
            debug.writeRegister(IConnectDebug.fMonitor, 'R1', r1Value)

        Longer way, if we use specific data types:

            # first we should define value type
            valueType = isystem.connect.SType()
            valueType.m_byType = isystem.connect.SType.tSigned
            valueType.m_byBitSize = 32

            # create 'Value' with type and value
            r0Value = isystem.connect.CValueType(valueType, 5678)

            debug.writeRegister(0, "R0", r0Value)


        :type accessFlags: int
        :param accessFlags: see IConnectDebug::EAccessFlags for available flags, except
                               **fCacheCode**
        :type registerName: string
        :param registerName: name of the register to write to
        :type registerInfo: :py:class:`CValueType`
        :param registerInfo: a value to be written to the register

        :raises: IOException in case of an error

        __Note:__ This method can modify only core registers. To modify SFRs
        please use the modify() method.

        Python example : _sample_link{data_ctrl,test_read_write_register}
        """
        return _connect.CDataController_writeRegister(self, accessFlags, registerName, registerInfo)

    def readValue(self, accessFlags, memArea, aAddress, type):
        r"""
        Reads a value from the target system. This function resembles
        readMemory() but additionally it formats the value according to the
        type specified (including endian conversions).


        Example:

            debug = ic.CDebugFacade(cmgr)

            varType = ic.SType()
            varType.m_byBitSize = 32
            varType.m_byType = ic.SType.tSigned

            memArea = 0
            addr = 1073768999

            value = debug.readValue(ic.IConnectDebug.fMonitor, memArea, addr, varType)

            print "Result = ", value.getInt()

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags, except **fCore**, and **fSFR**
        :type memArea: BYTE
        :param memArea: memory area, definitions for individual CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location of the first access.
        :type type: :py:class:`SType`
        :param type: variable containing the type info of value to be read

        :raises: IOException in case of an error


            Python example: _sample_link{data_ctrl,test_read_write_value}
        """
        return _connect.CDataController_readValue(self, accessFlags, memArea, aAddress, type)

    def writeValue(self, *args):
        r"""
        *Overload 1:*

        Writes a value to the target system. This function resembles writeMemory()
        but additionally it formats the value according to the type
        specified (including endian conversions).

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags, except **fCore**, **fSFR**,
                               and **fCacheXXX**.
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location of the first access
        :type value: :py:class:`CValueType`
        :param value: variable containing the value to write

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_read_write_value}

        |

        *Overload 2:*

        Writes a value to the target system. This function resembles writeMemory()
        but additionally it formats the value according to the type
        specified (including endian conversions).

        :type accessFlags: int
        :param accessFlags: use IConnectDebug::EAccessFlags, except **fCore**, **fSFR**,
                               and **fCacheXXX**.
        :type isNotRefreshWinIDEAGUIAfterWrite: boolean
        :param isNotRefreshWinIDEAGUIAfterWrite: if true, winIDEA windows are not refreshed after
                                                    write operation - this speeds up operation.
        :type memArea: BYTE
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type aAddress: int
        :param aAddress: address of the memory location of the first access
        :type value: :py:class:`CValueType`
        :param value: variable containing the value to write

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_read_write_value}
        """
        return _connect.CDataController_writeValue(self, *args)

    def evaluate(self, *args):
        r"""
        *Overload 1:*

        Calls evaluate(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &expression)
        with ``evaluateFlags = IConnectDebug::efDefaultMemAreaDisplay``.


        Python example with online value graph: _sample_link{chart_sample}
        Python module for plotting of watch expressions: _sample_link{variables_chart}
        Python example with web server providing results of this method: _sample_link{web,webserver}

        Python example: _sample_link{data_ctrl,test_data_evaluate}

        |

        *Overload 2:*

        Evaluates an expression. Works only for simple types.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: IConnectDebug::EAccessFlags determine what kind of
                                 memory access is permitted if required to resolve the expression
        :type evaluateFlags: int
        :param evaluateFlags: define result format
        :type expression: string
        :param expression: any C syntax expression. CPU registers (including SFRs)
                              can be used in expression with prefix '@', for example
                              '@R0'.

        :raises: IOException if complex type is given or in case of an error
        """
        return _connect.CDataController_evaluate(self, *args)

    def modify(self, *args):
        r"""
        *Overload 1:*
         See modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .

        Python example: _sample_link{data_ctrl,test_data_modify}

        |

        *Overload 2:*
         See modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .



        Python example: _sample_link{data_ctrl,test_data_modify}

        |

        *Overload 3:*
         See modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .



        Python example: _sample_link{data_ctrl,test_data_modify}

        |

        *Overload 4:*

        Modifies expression to value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: :py:class:`CValueType`
        :param value: contains the value to write to **expression**
        :type readBack: boolean, optional
        :param readBack: set to false to skip reading back the value

        :rtype: string
        :return: result of evaluation as string or error description in case of error.
                           For example for expression 'a = 10' return value is '10'.

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_data_modify}

        |

        *Overload 5:*

        Modifies expression to value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: :py:class:`CValueType`
        :param value: contains the value to write to **expression**
        :param readBack: set to false to skip reading back the value

        :rtype: string
        :return: result of evaluation as string or error description in case of error.
                           For example for expression 'a = 10' return value is '10'.

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_data_modify}

        |

        *Overload 6:*

        Modifies expression to string value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: string
        :param value: contains the value to write to **expression**
        :type readBack: boolean, optional
        :param readBack: set to false to skip reading back the value

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_data_modify}

        |

        *Overload 7:*

        Modifies expression to string value. The expression must evaluate to
        a *lvalue*.
        See also 'Qualified Variable Names'.

        :type accessFlags: int
        :param accessFlags: determines what kind of
                                 memory access is permitted if required to resolve the expression,
        :type evaluateFlags: int
        :param evaluateFlags: define result format.
        :type expression: string
        :param expression: any C syntax expression that evaluates to a lvalue
        :type value: string
        :param value: contains the value to write to **expression**
        :param readBack: set to false to skip reading back the value

        :raises: IOException in case of an error

        Python example: _sample_link{data_ctrl,test_data_modify}
        """
        return _connect.CDataController_modify(self, *args)

    def batchAccess(self, dwBatchAccessFlags, pBatchAccessHeader, batchAccessItems, batchAccessItemResults):
        r"""
        Performs multiple memory accesses, using deterministic delays.

        :type dwBatchAccessFlags: int
        :param dwBatchAccessFlags: see enum EFlags in SBatchAccessHeader, flags that
                                      start with prefix 'fl'
        :type pBatchAccessHeader: :py:class:`SBatchAccessHeader`
        :param pBatchAccessHeader: see SBatchAccessHeader
        :type batchAccessItems: std::vector< SBatchAccessItem,std::allocator< SBatchAccessItem > >
        :param batchAccessItems:  items defining the type
                                      and time of an individual access.

        :type batchAccessItemResults: std::vector< SBatchAccessItemResult,std::allocator< SBatchAccessItemResult > >
        :param batchAccessItemResults:  objects that will
                                            receive the results of every individual
                                            access.

        :rtype: boolean
        :return: true if OK, false if the specified time restrictions could
                    not be kept

        :raises: IOException if one of the accesses failed
        :raises: FeatureNotImplementedException if batch access is not implemented for your target

        Example:

          const int NUM_ITEMS = 1;  // just one item to execute in every run
          const int NUM_RUNS  = 100;   // perform so many iterations

          SBatchAccessHeader  BAH = {0};
          SBatchAccessItem    aBAI[NUM_ITEMS];
          memset(aBAI, 0, sizeof aBAI);

          // define header
          BAH.m_dwFlags       = SBatchAccessHeader::flRealTime; // use real-time access
          BAH.m_dwFlags       |= SBatchAccessHeader::flWantTimeStamp;
          BAH.m_dwNumItems    = NUM_ITEMS;
          BAH.m_dwNumRuns     = NUM_RUNS;
          BAH.m_qwRunInterval = 500;                            // every 500 us

          // Define item(s), ``iCounter`` in this case. Call CAddressController::getSymbolInfo()
          // to get ``aSizeMAUs``, ``byMemArea``, and ``aAddress`` of ``iCounter``.

          aBAI[0].m_byFlags   = SBatchAccessItem::flRead;       // it's a read
          aBAI[0].m_bySize    = (BYTE)aSizeMAUs;                // size or iCounter
          aBAI[0].m_byMemArea = byMemArea;                      // memory area of iCounter
          aBAI[0].m_aAddress  = aAddress;                       // address of iCounter

          SBatchAccessItemResult aBAIR[NUM_ITEMS * NUM_RUNS];   // make space for results

          bool hr = batchAccess(0, &BAH, aBAI, aBAIR);


        Python example: _sample_link{data_ctrl,test_batch_access}
        """
        return _connect.CDataController_batchAccess(self, dwBatchAccessFlags, pBatchAccessHeader, batchAccessItems, batchAccessItemResults)

    def jtagScan(self, dwScanFlags, dwNumBits, tdi, isOutputRequested, tdo):
        r"""
        Deprecated: 

        Performs JTAG scan operation.

        :type dwScanFlags: int
        :param dwScanFlags: scan flags, see DebugService_JTAG::EScan.
        :type dwNumBits: int
        :param dwNumBits: the number of I/O bits
        :type tdi: std::vector< BYTE,std::allocator< BYTE > >
        :param tdi: vector of bytes containing input data. If it is empty,
                   input is ignored. If it is not empty, but its size is less than
                   ``(dwNumBits + 7) / 8``, then IndexOutOfBoundsException
                   is thrown.
        :type isOutputRequested: boolean
        :param isOutputRequested: if true, then ``tdo`` parameter is filled with
                   output data. Otherwise no output data is provided.
        :type tdo: std::vector< BYTE,std::allocator< BYTE > >
        :param tdo: vector to receive output data. May be empty on input.
        """
        return _connect.CDataController_jtagScan(self, dwScanFlags, dwNumBits, tdi, isOutputRequested, tdo)

    def setJtagLine(self, line, level):
        r"""
        Deprecated: 

        Sets JTAG line to the given value.
        Example:

        dataCtrl.setJtagLine(DebugService_JTAG::lRESET, 0);


        :type line: int
        :param line: line number, see DebugService_JTAG::ELine for possible values
        :type level: BYTE
        :param level: value to set, should be 0 or 1
        """
        return _connect.CDataController_setJtagLine(self, line, level)

    def setOcdPortTristate(self, isTristate):
        return _connect.CDataController_setOcdPortTristate(self, isTristate)

    def eraseFlash(self, nDevice=-1):
        r"""
        Deprecated: use isys::CStorageDeviceController::erase() instead.

        Erases FLASH memory.

        :type nDevice: int, optional
        :param nDevice: if -1 all FLASH devices are processed, otherwise only the specified device
        """
        return _connect.CDataController_eraseFlash(self, nDevice)

    def secureFlash(self, nDevice=-1):
        r"""
        Secures FLASH memory.

        :type nDevice: int, optional
        :param nDevice: if -1 all FLASH devices are processed, otherwise only the specified device

        Python example: _sample_link{advanced,service_functions}
        """
        return _connect.CDataController_secureFlash(self, nDevice)

    def unsecureFlash(self, nDevice=-1):
        r"""
        Unsecures FLASH memory.

        :type nDevice: int, optional
        :param nDevice: if -1 all FLASH devices are processed, otherwise only the specified device

        Python example: _sample_link{advanced,service_functions}
        """
        return _connect.CDataController_unsecureFlash(self, nDevice)

    @staticmethod
    def setByte(array, idx, value):
        r"""
        Sets array element at index ``idx`` to ``value``. This is general method, which
        can be used to set arrays, which are required as ``isystem.connect`` function
        parameters or are elements of ``isystem.connect`` structures, for example
        ``SBatchAccessItem``.

        Python example: _sample_link{data_ctrl,test_batch_access}
        """
        return _connect.CDataController_setByte(array, idx, value)

    @staticmethod
    def getByte(array, idx):
        r"""
        Gets array element at index ``idx``. This is general method, which
        can be used to read arrays, which are returned by  ``isystem.connect`` function
        parameters or are elements of ``isystem.connect`` structures, for example
        ``SBatchAccessItem``.

        Python example: _sample_link{data_ctrl,test_batch_access}
        """
        return _connect.CDataController_getByte(array, idx)

    @staticmethod
    def byteArrayToVector(array, len):
        r"""
        This method converts byte array to std::vector<BYTE>, which is supported by
        SWIG and provides better access than pure C arrays.
        """
        return _connect.CDataController_byteArrayToVector(array, len)

    @staticmethod
    def vectorToByteArray(buff, array, size):
        r"""This method converts std::vector<BYTE> to byte array."""
        return _connect.CDataController_vectorToByteArray(buff, array, size)

    def getSymbols(self, *args):
        r"""
        Gets list of all symbols of the specified type. Symbols must be downloaded
        in winIDEA before this function is called.

        :type symbolsType: int
        :param symbolsType: type of symbols to retrieve
        :type symbolNames: :py:class:`StrVector`
        :param symbolNames: after return this vector contains names of all
                               symbols of the specified type from download file.
        :type partition: int, optional
        :param partition: index of download file to get symbols from



        Python example: _sample_link{data_ctrl,test_get_symbols}
        """
        return _connect.CDataController_getSymbols(self, *args)

    def getStackFrames(self, isActiveFrameOnly, isAbsPaths, stackFrames):
        r"""
        Gets list of current stack frames on a target. The
        stack frame information depends on compiler debug info and may not
        be always available.

        :type isActiveFrameOnly: boolean
        :param isActiveFrameOnly: if true, only the active frame is returned. This
                                     can be much faster than retrieving all frames.
        :type isAbsPaths: boolean
        :param isAbsPaths: if true, absolute paths are returned

        :type stackFrames: :py:class:`StackFrameVector`
        :param stackFrames: vector to receive stack frame objects

        Python example: _sample_link{data_ctrl,test_get_stack_frames}
        """
        return _connect.CDataController_getStackFrames(self, isActiveFrameOnly, isAbsPaths, stackFrames)

    def getVariables(self, partition, variables):
        r"""
        Returns list of global variables in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type variables: :py:class:`VariableVector`
        :param variables: vector to receive result

        Python example: _sample_link{data_ctrl,test_get_variables}
        """
        return _connect.CDataController_getVariables(self, partition, variables)

    def getLabels(self, partition, labels):
        r"""
        Returns list of labels in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type labels: :py:class:`VariableVector`
        :param labels: vector to receive result

        Python example: _sample_link{data_ctrl,test_get_labels}
        """
        return _connect.CDataController_getLabels(self, partition, labels)

    def getModules(self, partition, modules):
        r"""
        Returns list of source code files which were used to generate a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type modules: :py:class:`ModuleVector`
        :param modules: vector to receive result

        Python example: _sample_link{data_ctrl,test_get_modules}
        """
        return _connect.CDataController_getModules(self, partition, modules)

    def getFunctions(self, partition, functions):
        r"""
        Returns list of functions in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type functions: :py:class:`FunctionVector`
        :param functions: vector to receive result

        Python example: _sample_link{data_ctrl,test_get_functions}
        """
        return _connect.CDataController_getFunctions(self, partition, functions)

    def getTypes(self, partition, types):
        r"""
        Returns list of types in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type types: :py:class:`TypeVector`
        :param types: vector to receive result

        Python example: _sample_link{data_ctrl,test_get_types}
        """
        return _connect.CDataController_getTypes(self, partition, types)

    def getTypedefs(self, partition, typedefs):
        r"""
        Deprecated: Use `getTypes()` instead.

        Returns list of typedefs in a download file.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type typedefs: :py:class:`TypedefVector`
        :param typedefs: vector to receive result

        Python example: _sample_link{data_ctrl,test_get_typedefs}
        """
        return _connect.CDataController_getTypedefs(self, partition, typedefs)

    def getPartitions(self, paths, fileNames):
        r"""
        Returns a list of download files.

        :type paths: :py:class:`StrVector`
        :param paths: vector to receive paths of download files
        :type fileNames: :py:class:`StrVector`
        :param fileNames: vector to receive names of download files

        Python example: _sample_link{data_ctrl,test_get_partitions}
        """
        return _connect.CDataController_getPartitions(self, paths, fileNames)

    def getMacros(self, partition, names, values):
        r"""
        Returns a list of macros in the given partition.

        :type partition: int
        :param partition: partition number, or PARTITION_CURRENT for current download file or
                             PARTITION_DEFAULT for default download file.
        :type names: :py:class:`StrVector`
        :param names: vector, which will contain names of macros on return.
        :type values: :py:class:`StrVector`
        :param values: vector, which will contain values of macros on return.

        Python example: _sample_link{data_ctrl,test_get_macros}
        """
        return _connect.CDataController_getMacros(self, partition, names, values)

    def canAccessMemory(self):
        return _connect.CDataController_canAccessMemory(self)

    def getSystemMemoryAreas(self):
        r"""
        This method returns information about memory areas available on a
        target.

        Python example: _sample_link{data_ctrl,test_get_system_memory_areas}
        """
        return _connect.CDataController_getSystemMemoryAreas(self)

    def getDefaultEndian(self):
        r"""
        Returns default CPU endian mode.

        Python example: _sample_link{data_ctrl,test_get_default_endian}
        """
        return _connect.CDataController_getDefaultEndian(self)

    def getStackUsage(self):
        r"""
        Returns information about maximum stack usage since
        seedStack() was called.

        Python example: _sample_link{data_ctrl,test_seed_get_stack_usage}
        """
        return _connect.CDataController_getStackUsage(self)

    def seedStack(self):
        r"""
        Writes the given values to stack memory area. 


        Memory locations and value are defined with
        options ``Debug.StackUsage.*`` in winIDEA, which
        can be configured with `Debug | Configure Session... | Applications`
        dialog or method configureStackUsage() in this class.

        Python example: _sample_link{data_ctrl,test_seed_get_stack_usage}
        """
        return _connect.CDataController_seedStack(self)

    def configureStackUsage(self, *args):
        r"""
        *Overload 1:*

        Deprecated: use CConfigurationController::ide_app() to control stack configuration instead.
        Python example: _sample_link{data_ctrl,test_configure_stack_usage}

        |

        *Overload 2:*

        Deprecated: use CConfigurationController::ide_app() to control stack configuration instead.
        See python example.

        Configures winIDEA options used for measuring stack usage.
        This method changes values of options ``Debug.StackUsage.*``
        in winIDEA. This method must be called **before** download, for settings to
        take effect. After download you should call seedStack() without parameters
        to seed the stack memory region.

        :type start: string
        :param start: starting address. If both ``start`` and
                         ``end`` are empty strings, then
                         stack usage monitoring is disabled.
        :type end: string
        :param end: end address - value at this address is not modified,
                       so that ``size = end - start``. If both
                       ``start`` and ``end`` are empty strings,
                       then stack usage monitoring is disabled.
        :type value: unsigned char
        :param value: value to write to the stack. Not that this value
            should not interfere with other values written to stack to get
            reliable stack usage with getStackUsage().

        Python example: _sample_link{data_ctrl,test_configure_stack_usage}
        """
        return _connect.CDataController_configureStackUsage(self, *args)

    def csCreate(self):
        r"""
        This method creates an empty code store object

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object

        Python example: _sample_link{data_ctrl,test_cs_read_memor}
        """
        return _connect.CDataController_csCreate(self)

    def csGetDownloaded(self, memArea, fileDownload, data):
        r"""
        This method retrieves all downloaded code.

        :type memArea: BYTE
        :param memArea: specifies the memory space for which the downloaded code should be retrieved
        :type fileDownload: string
        :param fileDownload: if empty, all downloaded code is retrieved, otherwise only for the specified file
        :type data: boolean
        :param data: true to retrieve the data. Otherwise only address information is retrieved.

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the downloaded code

        Python example: _sample_link{data_ctrl,test_code_store}
        """
        return _connect.CDataController_csGetDownloaded(self, memArea, fileDownload, data)

    def csReadMemory(self, memArea, rspSource):
        r"""
        This method reads memory to the given ``rspSource`` object.

        :type memArea: BYTE
        :param memArea: specifies the memory space from which to read
        :type rspSource: :py:class:`CCodeStore`
        :param rspSource: a CCodeStore object filled with items (address and size), which should be read

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the read memory

        Python example: _sample_link{data_ctrl,test_cs_read_memor}
        """
        return _connect.CDataController_csReadMemory(self, memArea, rspSource)

    def csVerifyDownloaded(self, *args):
        r"""
        This method verifies downloaded data with the given file.

        :type memArea: BYTE
        :param memArea: specifies the memory space for which the verify
                           should be performed

        :type fileDownload: string
        :param fileDownload: if empty, all downloaded code is verified,
                                otherwise only for the specified file

        :type fileReport: string
        :param fileReport: file path to which the report should be written.
                              If empty no report is generated

        :type verifyAgainst: int, optional
        :param verifyAgainst: can be one of IConnectDebug2::ccSrcLoaded,
                                 IConnectDebug2::ccSrcInFiles,
                                 or IConnectDebug2::ccSrcFiltered.

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the differences between loaded and
                         read-back code. All data values are ICodeCache::EDifType::dtDif

        Python example: _sample_link{data_ctrl,test_cs_verify_downloaded}
        """
        return _connect.CDataController_csVerifyDownloaded(self, *args)

    def csDif(self, rsp1, rsp2, flDifferent=True, flNotIn1=True, flNotIn2=True, flEqual=False):
        r"""
        This method returns differences between two SPCodeStore instances.

        :type rsp1: :py:class:`CCodeStore`
        :param rsp1: the first CCodeStore object
        :type rsp2: :py:class:`CCodeStore`
        :param rsp2: the second CCodeStore object
        :type flDifferent: boolean, optional
        :param flDifferent: report locations present in both objects, but with different contents
        :type flNotIn1: boolean, optional
        :param flNotIn1: report locations that are not in rsp1, but present int rsp2
        :type flNotIn2: boolean, optional
        :param flNotIn2: report locations that are not in rsp2, but present int rsp1
        :type flEqual: boolean, optional
        :param flEqual: report locations with equal contents

        :rtype: :py:class:`CCodeStore`
        :return: 
            - CCodeStore object containing the differences between rsp1 and rsp2. Data values use ICodeCache::EDifType encoding

        Python example: _sample_link{data_ctrl,test_code_store_diff}
        """
        return _connect.CDataController_csDif(self, rsp1, rsp2, flDifferent, flNotIn1, flNotIn2, flEqual)

# Register CDataController in _connect:
_connect.CDataController_swigregister(CDataController)
class CRegisterInfo(object):
    r"""Wrapper for register info."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, regName, type):
        _connect.CRegisterInfo_swiginit(self, _connect.new_CRegisterInfo(regName, type))

    def getRegisterName(self):
        r"""Returns register name."""
        return _connect.CRegisterInfo_getRegisterName(self)

    def getType(self):
        r"""Returns register type."""
        return _connect.CRegisterInfo_getType(self)
    __swig_destroy__ = _connect.delete_CRegisterInfo

# Register CRegisterInfo in _connect:
_connect.CRegisterInfo_swigregister(CRegisterInfo)
class SDisassemblyLine(object):
    r"""Wrapper for disassembly line."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    address = property(_connect.SDisassemblyLine_address_get, _connect.SDisassemblyLine_address_set)
    opCode = property(_connect.SDisassemblyLine_opCode_get, _connect.SDisassemblyLine_opCode_set)
    opCodeArgs = property(_connect.SDisassemblyLine_opCodeArgs_get, _connect.SDisassemblyLine_opCodeArgs_set)
    fileName = property(_connect.SDisassemblyLine_fileName_get, _connect.SDisassemblyLine_fileName_set)
    lineNumber = property(_connect.SDisassemblyLine_lineNumber_get, _connect.SDisassemblyLine_lineNumber_set)
    functionName = property(_connect.SDisassemblyLine_functionName_get, _connect.SDisassemblyLine_functionName_set)
    functionOffset = property(_connect.SDisassemblyLine_functionOffset_get, _connect.SDisassemblyLine_functionOffset_set)
    branchTarget = property(_connect.SDisassemblyLine_branchTarget_get, _connect.SDisassemblyLine_branchTarget_set)
    length = property(_connect.SDisassemblyLine_length_get, _connect.SDisassemblyLine_length_set)
    isBranch = property(_connect.SDisassemblyLine_isBranch_get, _connect.SDisassemblyLine_isBranch_set)
    isCall = property(_connect.SDisassemblyLine_isCall_get, _connect.SDisassemblyLine_isCall_set)
    isConditional = property(_connect.SDisassemblyLine_isConditional_get, _connect.SDisassemblyLine_isConditional_set)
    isIndirect = property(_connect.SDisassemblyLine_isIndirect_get, _connect.SDisassemblyLine_isIndirect_set)

    def __init__(self, *args):
        _connect.SDisassemblyLine_swiginit(self, _connect.new_SDisassemblyLine(*args))
    __swig_destroy__ = _connect.delete_SDisassemblyLine

# Register SDisassemblyLine in _connect:
_connect.SDisassemblyLine_swigregister(SDisassemblyLine)
class CDataComposite(object):
    r"""
    This class contains information about expression and its children
    (elements of structure or array).

    See also: CDataController2::evaluateComposite()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CDataComposite_swiginit(self, _connect.new_CDataComposite(*args))

    def getVariable(self):
        r"""Returns object containing name and type of an expression."""
        return _connect.CDataComposite_getVariable(self)

    def isValueSet(self):
        r"""Returns true, if value is set."""
        return _connect.CDataComposite_isValueSet(self)

    def getValue(self):
        r"""
        Returns value of an object if isValueSet() returns true, otherwise
        an exception is thrown.
        """
        return _connect.CDataComposite_getValue(self)

    def getChildren(self, children):
        r"""Returns elements of a struct or an array."""
        return _connect.CDataComposite_getChildren(self, children)
    __swig_destroy__ = _connect.delete_CDataComposite

# Register CDataComposite in _connect:
_connect.CDataComposite_swigregister(CDataComposite)
class CDataController2(CDataController):
    r"""
    This class contains advanced methods, which are needed for complex projects,
    for example Eclipse debugger plug-in.


    **IMPORTANT: Resources allocated by calls to some methods of this class
    must be explicitly released. This is true also for managed languages like Java
    and C#. Improper allocation/releasing of resources may crash application! **
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""Instantiates object associated with the given connection."""
        _connect.CDataController2_swiginit(self, _connect.new_CDataController2(connectionMgr))
    __swig_destroy__ = _connect.delete_CDataController2

    def getTargetInfo(self):
        r"""
        Obtains general info about the target, not provided with other methods.

        Python example: _sample_link{data_ctrl_2,test_get_target_info}
        """
        return _connect.CDataController2_getTargetInfo(self)

    def getRegisterInfo(self, registerIdx):
        r"""
        Provides info about a register. Only main registers can be accessed
        by this method. Use GetCPUSFR() and SFRValue() to access SFRs.

        :type registerIdx: int
        :param registerIdx: register index. Call getTargetInfo() to get the number
                   of registers on the target. Index should be in range [0 .. SInfo.m_dwNumRegisters - 1]

        Python example: _sample_link{data_ctrl_2,test_get_register_info}
        """
        return _connect.CDataController2_getRegisterInfo(self, registerIdx)

    def getDisassembly(self, *args):
        r"""
        *Overload 1:*

        This method provides disassembly of the given source code block.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: see iEclipse::IConnectEclipse::EDisassemblyFlags for possible values
        :type fileName: string
        :param fileName: name of the source code file
        :type lineNumber: int
        :param lineNumber: starting line number of the code block
        :type numLines: int
        :param numLines: number of source code lines to get disassembly for

        Python example: _sample_link{data_ctrl_2,test_get_disassembly}

        |

        *Overload 2:*

        This method provides disassembly of the given source code block.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: see iEclipse::IConnectEclipse::EDisassemblyFlags for possible values
        :type memArea: BYTE
        :param memArea: memory area of the code block
        :type startAddress: int
        :param startAddress: starting address of the code block
        :type numMAUs: int
        :param numMAUs: number of memory allocation units to get disassembly for
        """
        return _connect.CDataController2_getDisassembly(self, *args)

    def getStackFrameInfo(self, isActiveFrameOnly, isAbsolutePath):
        r"""
        Provides the current stack frames.
        The returned resource must be released with call to method
        release() after usage.

        :type isActiveFrameOnly: boolean
        :param isActiveFrameOnly: if true, only the active stack frame is
                   is retrieved. This way the method call is much faster.
        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, absolute paths are returned

        Python example: _sample_link{data_ctrl_2,test_get_stack_frame_info}
        """
        return _connect.CDataController2_getStackFrameInfo(self, isActiveFrameOnly, isAbsolutePath)

    def release(self, *args):
        r"""
        *Overload 1:*
         Releases instance of iEclipse::IStackFrameInfo.

        Python example: _sample_link{data_ctrl_2,test_get_stack_frame_info}

        |

        *Overload 2:*
         Releases instance of iEclipse::IExpressionType.

        Python example: _sample_link{data_ctrl_2,test_get_expression_type}

        |

        *Overload 3:*
         Releases instance of iEclipse::IDisassemblyBlock.

        Python example: _sample_link{data_ctrl_2,test_get_disassembly}

        |

        *Overload 4:*
         Releases instance of iEclipse::IGlobals.

        Python example: _sample_link{data_ctrl_2,test_get_globals}

        |

        *Overload 5:*
         Releases instance of iEclipse::IConfiguration.

        Python example: _sample_link{data_ctrl_2,test_get_configuration}

        |

        *Overload 6:*
         Releases instance of iEclipse::ICPUSFR.

        Python example: _sample_link{data_ctrl_2,test_get_cpusfrs}
        """
        return _connect.CDataController2_release(self, *args)

    def setStackFrameContext(self, flags, context):
        r"""
        Sets active stack frame. Variables of the selected stack frame are
        available for evaluator (see methods CDataController::evaluate() and
        CDataController::modify()).

        :type flags: int
        :param flags: reserved, should be 0
        :type context: int
        :param context: index of the stack frame to be selected

        Python example: _sample_link{data_ctrl_2,test_set_stack_frame_context}
        """
        return _connect.CDataController2_setStackFrameContext(self, flags, context)

    def getExpressionType(self, flags, expression):
        r"""
        Provides information about expression. This method can be used to get
        information about complex variables, for example members of a structure,
        elements of array, ...
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: reserved, should be 0
        :type expression: string
        :param expression: C expression, for example `myStruct.counter`,
                   or `p->a[0]`


            Python example: _sample_link{data_ctrl_2,test_get_expression_type}
        """
        return _connect.CDataController2_getExpressionType(self, flags, expression)

    def getGlobals(self, flags, partition):
        r"""
        Provides information about global items in a program. The returned object
        contains only information requested by ``flags``.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: see iEclipse::IConnectEclipse::EGetGlobalsFlags for possible values
        :type partition: int
        :param partition: partition index

        Python example: _sample_link{data_ctrl_2,test_get_globals}
        """
        return _connect.CDataController2_getGlobals(self, flags, partition)

    def getConfiguration(self, flags):
        r"""
        Returns program configuration, for example partitions.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: reserved, should be 0.

        Python example: _sample_link{data_ctrl_2,test_get_configuration}
        """
        return _connect.CDataController2_getConfiguration(self, flags)

    def getCPUSFRs(self, flags):
        r"""
        Provides information about CPU's SFRs.
        The returned resource must be released with call to method
        release() after usage.

        :type flags: int
        :param flags: one of values defined in iEclipse::IConnectEclipse::EGetCPUSFR.

        Python example: _sample_link{data_ctrl_2,test_get_cpusfrs}
        """
        return _connect.CDataController2_getCPUSFRs(self, flags)

    def readSFR(self, dwHandle, type):
        r"""
        Reads SFR.


        IMPORTANT: Always check for error on return value: retVal.isError()
        to avoid misinterpretation of results!

        :type dwHandle: int
        :param dwHandle: handle of the SFR

        :type type: :py:class:`SType`
        :param type: defines SFR type. Required to return valid CValueType object on output.

        :rtype: :py:class:`CValueType`
        :return: SFR value. The type info of return value is set to input parameter 'type'.
            If the call succeeds, but register value is not valid, CValueType.isError()
            returns true, and CValueType.getResult() returns error description.

        Python example: _sample_link{data_ctrl_2,test_read_write_sfr}
        """
        return _connect.CDataController2_readSFR(self, dwHandle, type)

    def writeSFR(self, flags, dwHandle, value):
        r"""
        Writes value to SFR, then optionally reads it, to get the actual value.
        The type part of CValueType is not used.

        :type flags: int
        :param flags: flags of type ESFRValue. Values may be ORed together. Bit
            `IConnectEclipse::svWrite` is set by this method, so flags == 0 will perform write.

        :type dwHandle: int
        :param dwHandle: handle of the SFR

        :type value: :py:class:`CValueType`
        :param value: value to be written to SFR

        :rtype: :py:class:`CValueType`
        :return: read SFR value, if ``IConnectEclipse::svWriteThenRead`` is set,
            otherwise the input value is returned. Type in return value is always the same
            as type of input value.

        Python example: _sample_link{data_ctrl_2,test_read_write_sfr}
        """
        return _connect.CDataController2_writeSFR(self, flags, dwHandle, value)

    def evaluateComposite(self, accessFlags, expression, isGetValue, maxArrayElements):
        r"""
        Evaluates expression which may refer to composed data, for example
        arrays and structures. Let's have:

        MyStruct a[10]

        Returned object will contain information about array (type of elements and size),
        and 10 elements, each of them containing also elements of ``MyStruct``.

        :type accessFlags: int
        :param accessFlags: see IConnectDebug::EAccessFlags, usually we specify
                               IConnectDebug::fMonitor or IConnectDebug::fRealTime.
        :type expression: string
        :param expression: C expression or name of variable to be evaluated.
        :type isGetValue: boolean
        :param isGetValue: if true, values of all elements are evaluated - call
                              CDataComposite::getValue() to get the value.
                              If false, only structure of composite is returned - types
                              and children of elements. Call
                              to CDataElement::getValue() will throw an exception in this case.
        :type maxArrayElements: int
        :param maxArrayElements: max number of array elements to show. Since arrays may be
                              very large, setting of this parameter can enable getting of
                              structures with large arrays.

        :rtype: :py:class:`CDataComposite`
        :return: object containing information about the given expression and its children.



        Python example: _sample_link{data_ctrl_2,test_evaluate_composite}
        """
        return _connect.CDataController2_evaluateComposite(self, accessFlags, expression, isGetValue, maxArrayElements)

    def evaluateArray(self, *args):
        r"""
        This method returns contents of array on target.

        **WARNING:** For performance reasons the elements of the underlying C++ vector
        are not stored as shared pointers. Therefore you should
        not keep references to elements from the returned array
        after the array goes out of scope. This will result in unpredictable
        behavior and crashes. For example, don't do that:

            def f():
                values = ic.CValueTypeVector()
                dimensions = ic.UInt64Vector()
                data_ctrl2.evaluateArray('myarary', values, dimensions)
                return values[0]  # ERROR: Vector 'values' will be deleted after return, so values[0] references invalid location!

        :type arrayName: string
        :param arrayName: name of the array to evaluate
        :type values: std::vector< isys::CValueType,std::allocator< isys::CValueType > >
        :param values: vector to receive values from the array
        :type dimensions: std::vector< uint64_t,std::allocator< uint64_t > >
        :param dimensions: size of the array, one value per array dimension
        :type appURL: string, optional
        :param appURL: application URL, if empty it is deduced from `arrayName`
        :type partition: int, optional
        :param partition:, if -1 it is deduced from `arrayName`

        Since: 9.21.357
        """
        return _connect.CDataController2_evaluateArray(self, *args)

# Register CDataController2 in _connect:
_connect.CDataController2_swigregister(CDataController2)
class CPUStatus(object):
    r"""
    This class contains CPU status. It is not intended to be instantiated by
    clients.

    Note: Due to hardware restrictions, the stop reason is not always reliable
    on all architectures (methods **isStopReason...()**).

    See also: IConnectDebug::GetStatus
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, isStopReasonAvailable):
        _connect.CPUStatus_swiginit(self, _connect.new_CPUStatus(isStopReasonAvailable))
    __swig_destroy__ = _connect.delete_CPUStatus

    def isMustInit(self):
        r"""
         Returns true if the debug system must initialize.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isMustInit(self)

    def isStopped(self):
        r"""
         Returns true if CPU is stopped.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isStopped(self)

    def isRunning(self):
        r"""
         Returns true if CPU is running.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isRunning(self)

    def isReset(self):
        r"""
         Returns true if CPU is held in reset.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isReset(self)

    def isHalted(self):
        r"""
         Returns true if CPU is halted by target.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isHalted(self)

    def isWaiting(self):
        r"""
         Returns true if CPU is halted by debugger.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isWaiting(self)

    def isAttach(self):
        r"""
         Returns true if debugger is initialized and waiting for hot attach on the target.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isAttach(self)

    def isIdle(self):
        r"""
         Returns true if CPU is idle.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isIdle(self)

    def isStopReasonExplicit(self):
        r"""
        Returns true if CPU is in stopped state, and was stopped explicitly by
                   the user.
                   Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isStopReasonExplicit(self)

    def isStopReasonBP(self):
        r"""
         Returns true if CPU is in stopped state, and was stopped due to execution BP hit.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isStopReasonBP(self)

    def isStopReasonStep(self):
        r"""
         Returns true if CPU is in stopped state, and was stopped CPU is stopped
          after a step/over/until/until return command.
        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isStopReasonStep(self)

    def isStopReasonHW(self):
        r"""
        Returns true if CPU is in stopped state, and was stopped after a hardware
                   breakpoint hit.

                   Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_isStopReasonHW(self)

    def getExecutionPoint(self):
        r"""
        Returns current execution address, which is value of program counter register.

        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_getExecutionPoint(self)

    def getExecutionArea(self):
        r"""
        Returns memory area of the current execution address. It is specific to each architecture.
        See MemArea.h as a reference.

        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_getExecutionArea(self)

    def getMSID(self, rsmsid):
        r"""
        Returns current execution point MSID. Valid when in stopped state.

        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CPUStatus_getMSID(self, rsmsid)

    def toString(self):
        r"""Returns human readable contents of the object."""
        return _connect.CPUStatus_toString(self)

# Register CPUStatus in _connect:
_connect.CPUStatus_swigregister(CPUStatus)
class CExecutionController(object):
    r"""
    This class can be used to control the execution of the program on a target.
    Methods which start execution have two overloads. The second overload has
    additional parameter, which specifies wait for stop timeout. Functionally
    this call is equivalent to calling the first overload and ``waitUntilStopped()``,
    but the first approach uses less CPU time, because pooling is done at lower
    levels in winIDEA.


    _sample_link{execution_ctrl,test_call}
    _sample_link{execution_ctrl,test_run_until_function}
    _sample_link{execution_ctrl,test_hot_attach_detach}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TOUT_NONE = _connect.CExecutionController_TOUT_NONE
    r"""
    does not wait for stop, returns immediately.
    The target may still be running, when
    method returns.
    """
    TOUT_1s = _connect.CExecutionController_TOUT_1s
    r"""waits at most 1 s for stop"""
    TOUT_10s = _connect.CExecutionController_TOUT_10s
    r"""waits at most 10 s for stop"""
    TOUT_100s = _connect.CExecutionController_TOUT_100s
    r"""waits at most 100 s for stop"""
    TOUT_INF = _connect.CExecutionController_TOUT_INF
    r"""
    waits forever for stop. WARNING: Since winIDEA GUI is blocked during
    wait, you may have to switch off the debugger if target never stops.
    """

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: _sample_link{execution_ctrl,test_hot_attach_detach}
        """
        _connect.CExecutionController_swiginit(self, _connect.new_CExecutionController(connectionMgr))
    __swig_destroy__ = _connect.delete_CExecutionController

    def getIConnectDebug(self):
        r"""
        Returns the **isystem.connect** Debug interface. Use this method only when
        some functionality of the IConnectDebug interface
        is not accessible from wrapper classes.
        """
        return _connect.CExecutionController_getIConnectDebug(self)

    def hotAttach(self):
        r"""
        Hot-attaches to the target.

        :rtype: int
        :return: 0 if OK, else it is warning. Exception is thrown
            in case of error.



        Python example: _sample_link{execution_ctrl,test_hot_attach_detach}
        """
        return _connect.CExecutionController_hotAttach(self)

    def hotDetach(self):
        r"""
        Hot-detaches from the target.

        :rtype: int
        :return: 0 if OK, else it is warning. Exception is thrown
            in case of error.



        Python example: _sample_link{execution_ctrl,test_hot_attach_detach}
        """
        return _connect.CExecutionController_hotDetach(self)

    def run(self, *args):
        r"""
        *Overload 1:*

        Runs the program. The function is non-blocking. When it returns, the
        program might still be running (if it didn't hit a breakpoint, for example).
        Call getStatus() to check the target state, or one of wait...() methods in this
        class to wait for non-running state.

        :rtype: int
        :return: 'S_OK'

        Python example: _sample_link{execution_ctrl,test_run_stop}

        |

        *Overload 2:*

        Runs the program.

        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns S_FALSE when timeout is specified and the target is still
                    running (timeout expired).

        |

        *Overload 3:*

        Runs the program.

        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns S_FALSE when timeout is specified and the target is still
                    running (timeout expired).
        """
        return _connect.CExecutionController_run(self, *args)

    def runUntilReturn(self, *args):
        r"""
        *Overload 1:*

        Runs the program until return. The function is non-blocking. When it returns, the
        program might still be running. Call getStatus() to check the target state.

        :rtype: int
        :return: 'S_OK'

        Python example: _sample_link{execution_ctrl,test_run_until_return}

        |

        *Overload 2:*

        Runs the program until return.

        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_run_until_function}

        |

        *Overload 3:*

        Runs the program until return.

        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_run_until_function}
        """
        return _connect.CExecutionController_runUntilReturn(self, *args)

    def runUntilAddress(self, *args):
        r"""
        *Overload 1:*

        Runs the program until the address is reached. This method is non-blocking.
        When it returns, the program might still be running. Call getStatus() or waitUntilStopped()
        to be sure that the program has stopped (note that the program can also stop
        for other reasons, for example a breakpoint, so checking an address may also
        be needed in some cases).

        :type memArea: uint8_t
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location

        :rtype: int
        :return: 'S_OK'

        Python example: _sample_link{execution_ctrl,test_run_until_address}

        |

        *Overload 2:*

        Runs the program until the address is reached.

        :type memArea: uint8_t
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location
        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).


        |

        *Overload 3:*

        Runs the program until the address is reached.

        :type memArea: uint8_t
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location
        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).
        """
        return _connect.CExecutionController_runUntilAddress(self, *args)

    def runUntilFunction(self, *args):
        r"""
        *Overload 1:*

        Runs the program until the start of the function is reached. This method is
        non-blocking. When it returns, the program might still be running. Call waitUntilStopped()
        to be sure that the program has stopped (note that the program can also stop
        for other reasons, for example a breakpoint, so checking an address may also
        be needed in some cases).

        :type functionName: string
        :param functionName: name of the function

        :rtype: int
        :return: 'S_OK'


            Python example: _sample_link{execution_ctrl,test_run_until_function}

        |

        *Overload 2:*

        Runs the program until the start of the function is reached. Note that the
        program can also stop for other reasons,
        for example a breakpoint, so checking an address may also
        be needed in some cases, or call the overload with parameter *throwOnUnexpectedStop*.

        :type functionName: string
        :param functionName: name of the function
        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_run_until_function}

        |

        *Overload 3:*

        Runs the program until the start of the function is reached. Note that the
        program can also stop for other reasons,
        for example a breakpoint, so checking an address may also
        be needed in some cases, or call the overload with parameter *throwOnUnexpectedStop*.

        :type functionName: string
        :param functionName: name of the function
        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_run_until_function}

        |

        *Overload 4:*

        Runs the program until the start of the function is reached. This method
        differs from other runUntil...() methods in verification of stop address.
        If it differs from function address, a status code is returned or IOException
        is thrown.

        :type functionName: string
        :param functionName: name of the function
        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait. Must not be CExecutionController::TOUT_NONE,
                              or results are unpredictable.

        :type throwOnTimeout: boolean
        :param throwOnTimeout: if true, exception is thrown on timeout. If false, check
                   return code to detect timeout.

        :type throwOnUnexpectedStop: boolean
        :param throwOnUnexpectedStop: if true, and the function is not reached because
                   target stopped for some other reason, an IOException is thrown.

        :rtype: int
        :return: 'S_OK' if the target is stopped at the specified function.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired). Returns 'ICONNECT_S_MSG_FAIL' when the
                    target is stopped, but not at the specified function.

        Python example: _sample_link{execution_ctrl,test_run_until_function}
        """
        return _connect.CExecutionController_runUntilFunction(self, *args)

    def setSlowRun(self, isSlowRun):
        r"""
        If ``isSlowRun`` is set to ``true``, then execution is done by stepping through
        code on the target. This mode enables usage of analyzer on targets without
        trace capabilities.

        **Note**: This method must be called BEFORE analyzer is started!

        :type isSlowRun: boolean
        :param isSlowRun: if true, slow run is enabled, if false, normal run is used

        :rtype: int
        :return: 'S_OK' if mode is changed, S_FALSE if mode was already set
        :raises: FeatureNotImplementedException if slow run is not implemented for the target
        :raises: IOException if changing of the slow run mode is not possible at that moment
        :raises: IllegalStateException in case of other errors

        Python example: _sample_link{execution_ctrl,test_set_slow_run}
        """
        return _connect.CExecutionController_setSlowRun(self, isSlowRun)

    def gotoAddress(self, memArea, address):
        r"""
        Moves execution point to the given address.

        :type memArea: uint8_t
        :param memArea: memory space. Definitions for individual CPUs are provided in MemArea.h
        :type address: int
        :param address: of the memory location

        Python example: _sample_link{execution_ctrl,test_goto_address}
        """
        return _connect.CExecutionController_gotoAddress(self, memArea, address)

    def gotoFunction(self, functionName):
        r"""
        Moves execution point to the start of the given function.

        :type functionName: string
        :param functionName: name of the function

        Python example: _sample_link{execution_ctrl,test_goto_function}
        """
        return _connect.CExecutionController_gotoFunction(self, functionName)

    def reset(self, *args):
        r"""
        Resets the target.

        Python example: _sample_link{execution_ctrl,test_run_until_address}
        """
        return _connect.CExecutionController_reset(self, *args)

    def resetAndRun(self, *args):
        r"""
        *Overload 1:*

        Resets the target.

        :rtype: int
        :return: 'S_OK' or if operation was executed, but there is a warning (for example
                    license will soon expire), `ICONNECT_S_MSG_WARN` is returned. In case of
                    error an exception is thrown.

        Python example: _sample_link{execution_ctrl,test_reset_and_run}

        |

        *Overload 2:*

        Resets the target.

        :type timeoutMode: int
        :param timeoutMode: specifies whether to wait until the target is stopped
                              and how long to wait.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_reset_and_run}
        """
        return _connect.CExecutionController_resetAndRun(self, *args)

    def stop(self):
        r"""
        Stops the execution.


        Python example: _sample_link{execution_ctrl,test_run_stop}
        """
        return _connect.CExecutionController_stop(self)

    def stepHigh(self, *args):
        r"""
        Steps one statement in the source code. Enters functions.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_step_high}
        """
        return _connect.CExecutionController_stepHigh(self, *args)

    def stepOverHigh(self, *args):
        r"""
        Steps one statement in the source code, does not enter functions.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_step_over_high}
        """
        return _connect.CExecutionController_stepOverHigh(self, *args)

    def stepInst(self, *args):
        r"""
        Executes one machine instruction. Enters subroutines.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_step_inst}
        """
        return _connect.CExecutionController_stepInst(self, *args)

    def stepOverInst(self, *args):
        r"""
        Executes one machine instruction, does not enter subroutines.

        :type timeoutMode: int, optional
        :param timeoutMode: defines how log to wait for target stop
        :type throwOnTimeout: boolean, optional
        :param throwOnTimeout: if true, exception is thrown on timeout. If false,
                                  caller should check return code to detect timeout.

        :rtype: int
        :return: 'S_OK' if timeoutMode == CExecutionController::TOUT_NONE, or when the target is stopped.
                    Returns 'ICONNECT_E_TIMEOUT' when timeout is specified and the target is still
                    running (timeout expired).

        Python example: _sample_link{execution_ctrl,test_step_over_inst}
        """
        return _connect.CExecutionController_stepOverInst(self, *args)

    def call(self, *args):
        r"""
        *Overload 1:*

        Calls function on the target. 

        Required preconditions:
        - the code must be downloaded to the target
        - target must be initialized at least to the point where stack is set up
        - target/compiler pair must be supported by isystem.connect. Most modern
          targets and compilers are supported. If this function does not work,
          check isystem web page or ask iSYSTEM support for current status of supported
          platforms.
        - all function parameters must be of primitive types (char, int, float, ...)


        :type functionName: string
        :param functionName: name of the function to call

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.
                    If function is of type ``void``, string ``'no type information'``
                    is returned.


            Python example: _sample_link{execution_ctrl,test_call}

        |

        *Overload 2:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type param1: string
        :param param1: the first function parameter. Numbers should be given as a string.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: _sample_link{execution_ctrl,test_call}

        |

        *Overload 3:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type param1: string
        :param param1: the first function parameter. Numbers should be given as a string.
        :type param2: string
        :param param2: the second function parameter. Numbers should be given as a string.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: _sample_link{execution_ctrl,test_call}

        |

        *Overload 4:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type param1: string
        :param param1: the first function parameter. Numbers should be given as a string.
        :type param2: string
        :param param2: the second function parameter. Numbers should be given as a string.
        :type param3: string
        :param param3: the third function parameter. Numbers should be given as a string.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: _sample_link{execution_ctrl,test_call}

        |

        *Overload 5:*

        Calls function on the target. 

        See #call(const std::string &) for list of preconditions.

        :type functionName: string
        :param functionName: name of the function to call
        :type params: :py:class:`StrVector`
        :param params: list of function parameters. Numbers should be given as strings.

        :rtype: string
        :return: function return value as string. Numbers are also returned as strings.


            Python example: _sample_link{execution_ctrl,test_call}
        """
        return _connect.CExecutionController_call(self, *args)

    def getCPUStatus(self, wantStopReason=True):
        r"""
        Returns execution status of the target.

        :type wantStopReason: boolean, optional
        :param wantStopReason: if true, stop reason is set in the returned object

        Python example: _sample_link{execution_ctrl,test_get_cpustatus}
        """
        return _connect.CExecutionController_getCPUStatus(self, wantStopReason)

    def setPollingEnabled(self, isEnabled):
        r"""
        Enables/disables polling of target status in winIDEA.

        :type isEnabled: boolean
        :param isEnabled: if true, polling is enabled


            Python example: _sample_link{execution_ctrl,test_set_polling_enabled}
        """
        return _connect.CExecutionController_setPollingEnabled(self, isEnabled)

    def setBlueBoxTristateStatus(self, isTristate):
        r"""
        Sets outputs of BlueBox debug connector to tristate or out mode.

        :type isTristate: boolean
        :param isTristate: if true, outputs are set to tristate

        Python example: _sample_link{execution_ctrl,test_set_blue_box_tristate_status}
        """
        return _connect.CExecutionController_setBlueBoxTristateStatus(self, isTristate)

    def setBlueBoxTargetConnection(self, isConnected):
        r"""
        Activates/deactivates BlueBox target connection.

        :type isConnected: boolean
        :param isConnected: if true, the debugger is connected to the target

        Python example: _sample_link{execution_ctrl,test_set_blue_box_target_connection}
        """
        return _connect.CExecutionController_setBlueBoxTargetConnection(self, isConnected)

    def waitUntilStopped(self, timeoutMs=0, pollingIntervalMs=100, isThrow=False):
        r"""
        This method polls CPU status with the given polling interval and
        returns when CPU is stopped or timeout expires. This method waits
        if CPU is in any other state than stopped state, for example ``running``,
        ``halted``, ``must`` ``init``, ...

        :type timeoutMs: int, optional
        :param timeoutMs: timeout in milliseconds. 0 means infinite timeout
        :type pollingIntervalMs: int, optional
        :param pollingIntervalMs: time in milliseconds between two readings of the CPU status
        :type isThrow: boolean, optional
        :param isThrow: if true and timeout occurs, an exception is thrown
        :rtype: boolean
        :return: true if CPU is in stopped state, false if timeout expired and isThrow == false


            Python example: _sample_link{test_case_ctrl,test_control}
        """
        return _connect.CExecutionController_waitUntilStopped(self, timeoutMs, pollingIntervalMs, isThrow)

    def waitWhileRunning(self, timeoutMs, pollingIntervalMs=100, isThrow=False):
        r"""
        This method polls CPU status with the given polling interval and
        returns when CPU is no longer running or timeout expires. The difference
        to waitUntilStopped() method is that waitUntilStopped() expects
        exactly ``stopped`` state to return - it won't return on ``must`` ``init`` state,
        for example. waitWhileRunning() method will wait only if the target
        is in ``running`` state - it will
        return on any other state, for example ``stopped``, ``must`` ``init``, ``halted``, ...

        :type timeoutMs: int
        :param timeoutMs: timeout in milliseconds. 0 means infinite timeout
        :type pollingIntervalMs: int, optional
        :param pollingIntervalMs: time in milliseconds between two readings of the CPU status
        :type isThrow: boolean, optional
        :param isThrow: if true and timeout occurs, an exception is thrown
        :rtype: boolean
        :return: true if CPU is not running, false if timeout expired and isThrow == false

        Python example: _sample_link{execution_ctrl,test_wait_state}
        """
        return _connect.CExecutionController_waitWhileRunning(self, timeoutMs, pollingIntervalMs, isThrow)

# Register CExecutionController in _connect:
_connect.CExecutionController_swigregister(CExecutionController)
class CHILChannel(object):
    r"""
    This immutable class contains information about HIL channel
    parameter.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""Instantiates object. Constructor is not intended to be used by clients."""
        _connect.CHILChannel_swiginit(self, _connect.new_CHILChannel(*args))

    def getName(self):
        r"""Returns channel name."""
        return _connect.CHILChannel_getName(self)

    def getQualifiedName(self):
        r"""Returns channel qualified name."""
        return _connect.CHILChannel_getQualifiedName(self)

    def isAvailable(self):
        r"""Returns true if the channel is avaialble - on the hardware module and not explicitly disabled."""
        return _connect.CHILChannel_isAvailable(self)

    def getType(self):
        r"""Returns the type of the channel. IHILChannel::mc_cit encoding is used"""
        return _connect.CHILChannel_getType(self)

    def getIndex(self):
        r"""Returns the index of the channel within its type group."""
        return _connect.CHILChannel_getIndex(self)

    def getUnit(self):
        r"""Returns the units measured by an analog channel."""
        return _connect.CHILChannel_getUnit(self)

    def getAMin(self):
        r"""Returns the minimum value an analog channel can assume."""
        return _connect.CHILChannel_getAMin(self)

    def getAMax(self):
        r"""Returns the minimum value an analog channel can assume."""
        return _connect.CHILChannel_getAMax(self)
    __swig_destroy__ = _connect.delete_CHILChannel

# Register CHILChannel in _connect:
_connect.CHILChannel_swigregister(CHILChannel)
class CHILController(object):
    r"""
    This class controls HIL (Hardware In the Loop).

    Python example: _sample_link{hil_ctrl,test_hil_read_write}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
            Python example: _sample_link{hil_ctrl,test_hil_read_write}
        """
        _connect.CHILController_swiginit(self, _connect.new_CHILController(connectionMgr))
    __swig_destroy__ = _connect.delete_CHILController

    def read(self, paths, bufferSize=4096, dwFlags=0, dwGenParam=0):
        r"""
        Reads data from HIL. Consult your hardware manual for available parameters.
        For iSYSTEM's I/O module on IC5000 you get the list of available paths to
        parameters with HIL monitor in winIDEA:
        - Open "Plugins | Options" dialog, then move "HIL Monitor" from "Available" to "Loaded", click OK
        - Select "Plugins | HIL Monitor" to open the HIL Monitor window.

        :type paths: string
        :param paths: paths to parameters to read separated by '\n'. Example for
                                    iSYSTEM IO module:

                          read("DIN.DIN0\\nDIN.DIN1");



        :type bufferSize: int, optional
        :param bufferSize: allocated buffer to receive data. If it is to small,
                              IllegalSizeException is thrown.

        :type dwFlags: int, optional
        :param dwFlags: reserved, should be zero

        :type dwGenParam: int, optional
        :param dwGenParam: reserved, should be zero

        :rtype: string
        :return: string of values for each path, separated by '\n'

        Python example: _sample_link{hil_ctrl,test_hil_read_write}
        """
        return _connect.CHILController_read(self, paths, bufferSize, dwFlags, dwGenParam)

    def write(self, values, dwFlags=0, dwGenParam=0):
        r"""
        Writes data to HIL. Consult your hardware manual for available parameters.
        For iSYSTEM's I/O module on IC5000 you get the list of available paths to
        parameters with HIL monitor in winIDEA:
        - Open "Plugins | Options" dialog, then move "HIL Monitor" from "Available" to "Loaded", click OK
        - Select "Plugins | HIL Monitor" to open the HIL Monitor window.

        :type values: string
        :param values: data to be written to HIL module given as ``path: value``
                          pairs separated by '\n'. Example for iSYSTEM IO module:

                          write("DOUT.DOUT0: LOW");


        :type dwFlags: int, optional
        :param dwFlags: reserved, should be zero

        :type dwGenParam: int, optional
        :param dwGenParam: reserved, should be zero

        Python example: _sample_link{hil_ctrl,test_hil_read_write}
        """
        return _connect.CHILController_write(self, values, dwFlags, dwGenParam)

    def getDescriptors(self):
        return _connect.CHILController_getDescriptors(self)

    def getChannels(self, channels):
        r"""
        Deprecated: does not support new hardware, currently has no replacement

        Returns list of channels in the HIL.

        :type channels: :py:class:`HILChannelVector`
        :param channels: vector to receive result

        See also: isys::CHILChannel
        """
        return _connect.CHILController_getChannels(self, channels)

# Register CHILController in _connect:
_connect.CHILController_swigregister(CHILController)
class CIDEData(object):
    r"""
    This class contains winIDEA window location and process ID. This class is
    not intended to be instantiated by clients. Use method
    CIDEController::getWinIDEAVersion() to obtain the current winIDEA version.

    See also: CIDEController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getLeft(self):
        r"""Returns coordinate of the left edge of winIDEA window."""
        return _connect.CIDEData_getLeft(self)

    def getTop(self):
        r"""Returns coordinate of the top edge of winIDEA window."""
        return _connect.CIDEData_getTop(self)

    def getRight(self):
        r"""Returns coordinate of the right edge of winIDEA window."""
        return _connect.CIDEData_getRight(self)

    def getBottom(self):
        r"""Returns coordinate of the bottom edge of winIDEA window."""
        return _connect.CIDEData_getBottom(self)

    def getPID(self):
        r"""Returns process ID of winDEA process."""
        return _connect.CIDEData_getPID(self)
    __swig_destroy__ = _connect.delete_CIDEData

# Register CIDEData in _connect:
_connect.CIDEData_swigregister(CIDEData)
POSTFIX_ENABLE_PROFILER = cvar.POSTFIX_ENABLE_PROFILER
POSTFIX_ENABLE_COVERAGE = cvar.POSTFIX_ENABLE_COVERAGE
OPT_VAL_TRUE = cvar.OPT_VAL_TRUE
OPT_VAL_FALSE = cvar.OPT_VAL_FALSE

class CIDECapabilities(object):
    r"""
    This class contains capabilities of the current hardware setup.
    This class is not intended to be instantiated by users. Call
    isys::CIDEController::getCapabilities() to get an instance.


    See also: CIDEController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, capabilities):
        _connect.CIDECapabilities_swiginit(self, _connect.new_CIDECapabilities(capabilities))

    def isDebugAvailable(self):
        r"""Returns true if debugging is supported."""
        return _connect.CIDECapabilities_isDebugAvailable(self)

    def isTraceAvailable(self):
        r"""Returns true if trace is supported."""
        return _connect.CIDECapabilities_isTraceAvailable(self)

    def isCoverageAvailable(self):
        r"""Returns true if coverage is supported."""
        return _connect.CIDECapabilities_isCoverageAvailable(self)

    def isProfilerAvailable(self):
        r"""Returns true if profiler is supported."""
        return _connect.CIDECapabilities_isProfilerAvailable(self)
    __swig_destroy__ = _connect.delete_CIDECapabilities

# Register CIDECapabilities in _connect:
_connect.CIDECapabilities_swigregister(CIDECapabilities)
class COptionValue(object):
    r"""
    This class wraps structure SOptionValue defined in i_Options.h

    See also: CIDEController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes the object. Uses default separators,
        and does not allocate output buffer. Use this ctor when
        you want to GET option value (EOptionValue::ofGet).

        |

        *Overload 2:*

        Initializes input string with the given value. Uses default separators,
        and does not allocate output buffer.

        |

        *Overload 3:*

        Initializes input integer with the given value. Uses default separators,
        and does not allocate output buffer.

        |

        *Overload 4:*

        Initializes input float with the given value. Uses default separators,
        and does not allocate output buffer.
        """
        _connect.COptionValue_swiginit(self, _connect.new_COptionValue(*args))
    __swig_destroy__ = _connect.delete_COptionValue

    def setSeparators(self, pathSeparator=0, valueSeparator=0, optionSeparator=0):
        r"""Sets separators for multiple options."""
        return _connect.COptionValue_setSeparators(self, pathSeparator, valueSeparator, optionSeparator)

    def getOutputBuffer(self):
        r"""Returns contents of the output buffer."""
        return _connect.COptionValue_getOutputBuffer(self)

# Register COptionValue in _connect:
_connect.COptionValue_swigregister(COptionValue)
class CIDEController(object):
    r"""
    This class can be used to control winIDEA IDE behavior.


    Python example for method setOption(): _sample_link{ide_ctrl,test_dynamic_option}
    Python example for method getOptionStr(): _sample_link{ide_ctrl,test_get_option}
    Python example for method getCapabilities(): _sample_link{ide_ctrl,test_get_capabilities}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ViewType_Project = _connect.CIDEController_ViewType_Project
    r"""Project view"""
    ViewType_Symbols = _connect.CIDEController_ViewType_Symbols
    r"""Symbols view"""
    ViewType_Callstack = _connect.CIDEController_ViewType_Callstack
    r"""Callstack view"""
    ViewType_Locals = _connect.CIDEController_ViewType_Locals
    r"""Locals view"""
    ViewType_This = _connect.CIDEController_ViewType_This
    r"""This view"""
    ViewType_Disassembly = _connect.CIDEController_ViewType_Disassembly
    r"""Disassembly view"""
    ViewType_CoreRegisters = _connect.CIDEController_ViewType_CoreRegisters
    r"""Core Registers view"""
    ViewType_Terminal = _connect.CIDEController_ViewType_Terminal
    r"""Terminal view"""
    ViewType_Tasks = _connect.CIDEController_ViewType_Tasks
    r"""Tasks view"""
    ViewType_SFRs = _connect.CIDEController_ViewType_SFRs
    r"""SFRs view"""
    ViewType_Output = _connect.CIDEController_ViewType_Output
    r"""Output view"""
    ViewType_Build = _connect.CIDEController_ViewType_Build
    r"""Build view"""
    ViewType_FindInFiles = _connect.CIDEController_ViewType_FindInFiles
    r"""Find In Files view"""
    ViewType_Tools = _connect.CIDEController_ViewType_Tools
    r"""Tools view"""
    ViewType_Script = _connect.CIDEController_ViewType_Script
    r"""Scripts view"""
    ViewType_Progress = _connect.CIDEController_ViewType_Progress
    r"""Progress view"""
    ViewType_Watch = _connect.CIDEController_ViewType_Watch
    r"""Watch view"""
    ViewType_Memory = _connect.CIDEController_ViewType_Memory
    r"""Memory view"""
    ViewType_SFR = _connect.CIDEController_ViewType_SFR
    r"""SFR view"""
    ViewType_FrameworkPlugin = _connect.CIDEController_ViewType_FrameworkPlugin
    r"""Framework Plugin view"""
    ViewType_Document = _connect.CIDEController_ViewType_Document
    r"""Document view"""
    ViewType_NoneView = _connect.CIDEController_ViewType_NoneView
    ViewState_Opened = _connect.CIDEController_ViewState_Opened
    r"""view opened"""
    ViewState_Closed = _connect.CIDEController_ViewState_Closed
    r"""view closed"""
    ViewState_Undefined = _connect.CIDEController_ViewState_Undefined
    DEFAULT_OPTION_BUFFER_SIZE = _connect.CIDEController_DEFAULT_OPTION_BUFFER_SIZE
    r"""
    Buffer size for data received from winIDEA. If this buffer size is too small,
    use method 'option()' instead of specialized 'getOptionStr()'.
    """
    HOOK_NONE = _connect.CIDEController_HOOK_NONE
    HOOK_ICONNECT_CALL = _connect.CIDEController_HOOK_ICONNECT_CALL
    HOOK_ALL = _connect.CIDEController_HOOK_ALL
    WINIDEA_EXE_DIR = _connect.CIDEController_WINIDEA_EXE_DIR
    r"""directory of winIDEA executable"""
    WORKSPACE_DIR = _connect.CIDEController_WORKSPACE_DIR
    r"""directory of winIDEA workspace file"""
    WORKSPACE_FILE_NAME = _connect.CIDEController_WORKSPACE_FILE_NAME
    r"""path and name of winIDEA workspace file"""
    EDebugAPI = _connect.CIDEController_EDebugAPI
    r"""debug API"""
    EAnalyzerAPI = _connect.CIDEController_EAnalyzerAPI
    r"""analyzer API"""
    EiTestAPI = _connect.CIDEController_EiTestAPI
    r"""isystem.test API"""

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
            Python example: _sample_link{ide_ctrl,test_get_capabilities}
        """
        _connect.CIDEController_swiginit(self, _connect.new_CIDEController(connectionMgr))
    __swig_destroy__ = _connect.delete_CIDEController

    def getWinIDEAVersion(self):
        r"""
        Returns winIDEA version. Supported only on winIDEA versions 9.9 and higher.
        On versions lower than that, it always returns 0.0.0.

        Python example: _sample_link{ide_ctrl,test_get_winidea_version}
        """
        return _connect.CIDEController_getWinIDEAVersion(self)

    def isWinIDEAOpenVersion(self):
        r"""
        Returns true, if winIDEA is open version, false for
        professional version.

        Python example: _sample_link{ide_ctrl,test_is_winidea_open_version}
        """
        return _connect.CIDEController_isWinIDEAOpenVersion(self)

    def isAPICompatible(self, apiCategory):
        r"""
        Returns true, if the given API category is compatible between
        the client and winIDEA of different versions. Client version is
        determined by SDK automatically and winIDEA version is taken from
        connected winIDEA. Connection to winIDEA must be established
        before calling this method.

        :type apiCategory: int
        :param apiCategory: API category to get compatibility info for.

        Python example: _sample_link{ide_ctrl,test_is_api_compatible}
        """
        return _connect.CIDEController_isAPICompatible(self, apiCategory)

    def getPath(self, pathType):
        r"""
        Returns path or file name of winIDEA item, for example name of
        the workspace file currently opened in winIDEA.

        :type pathType: int
        :param pathType: specifies which path or file name the function should return.

        Python example: _sample_link{ide_ctrl,test_get_path}
        """
        return _connect.CIDEController_getPath(self, pathType)

    def getOpenDocuments(self, documents):
        r"""Returns the list of all open documents"""
        return _connect.CIDEController_getOpenDocuments(self, documents)

    def closeAllDocuments(self):
        r"""
        Closes all documents opened in winIDEA. It has the same functionality as
        CDocumentController::closeAll(), but can be used even if we have no document
        opened via *isystem.connect*.

        Python example: _sample_link{ide_ctrl,test_document_manipulation}
        """
        return _connect.CIDEController_closeAllDocuments(self)

    def saveAllDocuments(self):
        r"""
        Saves all documents opened in winIDEA.

        Python example: _sample_link{ide_ctrl,test_document_manipulation}
        """
        return _connect.CIDEController_saveAllDocuments(self)

    def activate(self):
        r"""
         Activates the winIDEA window - it gets focus.
        Python example: _sample_link{ide_ctrl,test_activate}
        """
        return _connect.CIDEController_activate(self)

    def minimize(self):
        r"""
        Minimizes winIDEA window.

        Python example: _sample_link{ide_ctrl,test_window_manipulation}
        """
        return _connect.CIDEController_minimize(self)

    def maximize(self):
        r"""
        Maximizes winIDEA window.

        Python example: _sample_link{ide_ctrl,test_window_manipulation}
        """
        return _connect.CIDEController_maximize(self)

    def restore(self):
        r"""
        Restores winIDEA window to previous position and size.

        Python example: _sample_link{ide_ctrl,test_window_manipulation}
        """
        return _connect.CIDEController_restore(self)

    def getPID(self):
        r"""
        Returns object containing process ID of winIDEA instance. To obtain
        the process ID call CIDEData::getPID() on returned object, for example:

           ideData = ideCtrl.getPID()
           pid = ideData.getPID()


        Python example: _sample_link{ide_ctrl,test_activate}
        """
        return _connect.CIDEController_getPID(self)

    def move(self, left, top, right, bottom):
        r"""
        Moves and resizes winIDEA window to the given rectangle.

        :type left: int
        :param left: position of the left window edge in screen coordinates
        :type top: int
        :param top: position of the top window edge in screen coordinates
        :type right: int
        :param right: position of the right window edge in screen coordinates
        :type bottom: int
        :param bottom: position of the bottom window edge in screen coordinates

        Python example: _sample_link{ide_ctrl,test_window_manipulation}
        """
        return _connect.CIDEController_move(self, left, top, right, bottom)

    def refreshUI(self):
        r"""
        Refreshes winIDEA UI. Call this method, when previous calls to isystem.connect
        methods disabled UI refresh (usually for speed reasons).

        See also: CDataController::writeValue(IConnectDebug::EAccessFlags, bool, BYTE, DWORD, const CValueType &)
        """
        return _connect.CIDEController_refreshUI(self)

    def bringWinIDEAToTop(self):
        r"""
        Makes winIDEA window the top window. Works only on winIDEA 9.9 and later.
        Does nothing on winIDEA 9.7 and earlier versions.

        Python example: _sample_link{ide_ctrl,test_window_manipulation}
        """
        return _connect.CIDEController_bringWinIDEAToTop(self)

    def getNumClients(self):
        r"""
        Deprecated: Since this method does not count clients connected via
        shared memory, there is no good use case for it.

        Returns the number of iConnect clients connected via TCP/IP, including the
        calling one.

        On winIDEA 9.7 and earlier always returns -1.
        """
        return _connect.CIDEController_getNumClients(self)

    def getCapabilities(self):
        r"""
        Returns capabilities of the current hardware setup.

        Python example: _sample_link{ide_ctrl,test_get_capabilities}
        """
        return _connect.CIDEController_getCapabilities(self)

    def setMsgBoxHook(self, isHookOn):
        r"""
        Deprecated! Use ``setMsgBoxHook(EHookMode`` ``hookMode)`` instead!
        This method behaves like setMsgBoxHook(EHookMode::ICONNECT_CALL).

        Controls displaying of message boxes in winIDEA, when errors
        occur during isystem.connect calls. An isystem.connect call can cause an error
        condition in winIDEA which under normal circumstances brings up a
        modal message box. Such message boxes require user intervention which is
        not desired during isystem.connect operation. winIDEA can therefore hook
        such messages, taking default decisions when they occur.

        :type isHookOn: boolean
        :param isHookOn: if true, message box is NOT displayed

        :raises: IOException in case of an error
        """
        return _connect.CIDEController_setMsgBoxHook(self, isHookOn)

    def setMsgBoxHookMode(self, hookMode):
        r"""
        Deprecated: This internal winIDEA state is not useful for clients. Message
                    boxes are now automatically disabled for iconnect calls.

        Controls displaying of message boxes in winIDEA. An ``isystem.connect`` call can cause an error
        condition in winIDEA which under normal circumstances brings up a
        modal message box. Such message boxes require user intervention which is
        not desired during ``isystem.connect`` operation. This method can be used
        to suppress such messages.

        :type hookMode: int
        :param hookMode: specifies which message boxes are hooked
                   - EHookMode::HOOK_NONE - no hooking, all message boxes are shown
                   - EHookMode::HOOK_ICONNECT_CALL - only message boxes which occur during
                                                ``isystem.connect`` call are not shown. This
                                                mode is sufficient in most cases, and keeps
                                                normal behavior in manual usage of winIDEA.
                   - EHookMode::HOOK_ALL - all message boxes are hooked. This means also message boxes
                                      in manual mode. For example, if we start download from winIDEA,
                                      but target is not connected, there will be no error message box!
                                      The reason for this mode is that some errors do not occur
                                      immediately during ``isystem.connect`` call, but only when
                                      the operation completes in another thread. An example of such
                                      case is profiler, where we start the profiler, but error
                                      occurs later during recording. Use this mode only when really
                                      necessary.
        """
        return _connect.CIDEController_setMsgBoxHookMode(self, hookMode)

    def isMsgBoxHookOn(self):
        r"""
        Deprecated: This internal winIDEA state is not useful for clients.

        Returns true, if message boxes are disabled either by EHookMode::HOOK_ICONNECT_CALL
        or EHookMode::HOOK_ALL.

        See also: #setMsgBoxHookMode(EHookMode)
        """
        return _connect.CIDEController_isMsgBoxHookOn(self)

    def iOpenDisconnect(self):
        r"""
        Disconnect winIDEA from debugger. This method is equivalent to
        winIDEA menu command 'Tools | Disconnect from Debugger'.

        Python example: _sample_link{ide_ctrl,test_iopen_disconnect}
        """
        return _connect.CIDEController_iOpenDisconnect(self)

    def getDefaultDownloadFile(self):
        r"""
        Returns default download file path relative to winIDEA workspace.
        Throws FileNotFoundException if there is no download file with symbols or
        `Load Symbols` check box is not selected in winIDEA.

        Python example: _sample_link{ide_ctrl,test_get_default_download_file}
        """
        return _connect.CIDEController_getDefaultDownloadFile(self)

    def option(self, *args):
        r"""
        *Overload 1:*

        This is general method for setting winIDEA options. Use
        ``set/getOption()`` methods for simple cases.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example in Python:

        import isystem.connect as ic

        ide = ic.CIDEController(conMgr)
        optVal = isystem.connect.COptionValue("myString")
        flags = ic.ofValBuffer | ic.ofSet
        ide.option(flags, "myscope", "myoption", optVal)



        :type flags: int
        :param flags: see EOptionFlags in i_Option.h and EOptionFlags in IConnectIDE.

        :type scope: string
        :param scope: defines the destination. It may be file name in
                         case of documents or CLSID in case of plugins.

        :type option: string
        :param option: option to set, depends also on ``flags`` used

        :type optValue: :py:class:`COptionValue`
        :param optValue: data for option manipulation, see isys::COptionValue

        Python example: _sample_link{ide_ctrl,test_option}

        |

        *Overload 2:*

        This is general method for setting winIDEA options. Destination and
        scope (document name) are encoded in optionURL.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type flags: int
        :param flags: see EOptionFlags in IConnectIDE.

        :type optionURL: string
        :param optionURL: URL of option to set.

        :type optValue: :py:class:`COptionValue`
        :param optValue: data for option manipulation, see isys::COptionValue

        Python example: _sample_link{ide_ctrl,test_option}
        """
        return _connect.CIDEController_option(self, *args)

    def setOptionsMap(self, moduleTypeId, assignmentsMap):
        r"""
        Sets multiple options with one call.

        :type moduleTypeId: string
        :param moduleTypeId: defines module type and ID combined. See constants beginning with
                                        ``OPT_DEST_...`` defined in this file for available
                                        module types, for example CIDEController::OPT_DEST_IDE.

                                        If moduleType is OPT_DEST_DOCUMENT, append document name.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if moduleID must be specified.


        :type assignmentsMap: string
        :param assignmentsMap: defines key/value pair delimited by colon character

        Examples:


           setOptionsMap("/IDE/", "Debug.DownloadFiles.File[0].Path: prog.elf")
           setOptionsMap("/Document/sample_profiler.trd", "SessionTrigger.Item.Profiler.ExecArea[1].Name: func1")


        Python example: _sample_link{ide_ctrl,test_get_set_options_map}
        """
        return _connect.CIDEController_setOptionsMap(self, moduleTypeId, assignmentsMap)

    def getOptionsMap(self, moduleTypeId, options, bufferSize):
        r"""
        Returns values of multiple options separated by '\n'.

        :type moduleTypeId: string
        :param moduleTypeId: defines module type and ID combined. See constants beginning with
                                        ``OPT_DEST_...`` defined in this file for available
                                        module types, for example CIDEController::OPT_DEST_IDE.

                                        If moduleType is OPT_DEST_DOCUMENT, append document name.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if moduleID must be specified.


                             <optionPath> path defining the option. 


        :type options: string
        :param options: Options.
        :type bufferSize: int
        :param bufferSize: Size of buffer.
                             Examples:

               getOptionsMap("/IDE/", "Debug.DownloadFiles.File[0].Path\nDebug.DownloadFiles.File[1].Path", 1000);
               getOptionsMap("/Document/sample_profiler.trd/", "SessionTrigger.Item.Profiler.ExecArea[0].Name\nSessionTrigger.Item.Profiler.ExecArea[1].Name", 1000);


        Python example: _sample_link{ide_ctrl,test_get_set_options_map}
        """
        return _connect.CIDEController_getOptionsMap(self, moduleTypeId, options, bufferSize)

    def setOptionJSON(self, optionUrl, valueJSON):
        r"""
        Sets winIDEA options of an object from a JSON formatted string
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Options.Terminal.Session", '{"Session": {"BaudRate": 4800, "DataBits": 7}}')


        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 



        :type valueJSON: string
        :param valueJSON: value to be assigned to the object

        :raises: IOException in case of failure.

        Python example: _sample_link{ide_ctrl,test_get_set_option_json}
        """
        return _connect.CIDEController_setOptionJSON(self, optionUrl, valueJSON)

    def setOption_str(self, optionUrl, value):
        r"""
        This method should be used in languages, where oveloading makes
        problems, for example Tcl.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        See also: setOption(const std::string &, const std::string &);
        """
        return _connect.CIDEController_setOption_str(self, optionUrl, value)

    def setOption_u32(self, optionUrl, value):
        r"""
        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Debug.Symbols.Format.MaxParseUpload", 256)


        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart



        :type value: int
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string);

        This method should be used in languages, where oveloading makes
        problems.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        See also: setOption(const std::string &, DWORD);
        """
        return _connect.CIDEController_setOption_u32(self, optionUrl, value)

    def setOption_f64(self, optionUrl, value):
        r"""
        This method should be used in languages, where oveloading makes
        problems, for example Tcl.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        See also: setOption(const std::string &, double);
        """
        return _connect.CIDEController_setOption_f64(self, optionUrl, value)

    def setOption(self, *args):
        r"""
        *Overload 1:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption(ofDestIOPEN, "", "Hardware.Emulator", "iC5000")


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        :type value: string
        :param value: value of option

        :raises: IOException in case of failure.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 2:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        :type value: int
        :param value: value of option

        :raises: IOException in case of failure.

        See also: #setOption (DWORD, std::string, std::string, std::string)

        |

        *Overload 3:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        :type value: float
        :param value: value of option

        :raises: IOException in case of failure.

        See also: #setOption (DWORD, std::string, std::string, std::string)

        |

        *Overload 4:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IOPEN/Hardware.Emulator", "iC3000")


        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: string
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 5:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Debug.Symbols.Format.VagueFloatPrecision", 1e-005)



        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: float
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string);

        |

        *Overload 6:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/Document/traceTest.trd/TraceExport.TimeFrom", 5000000000)



        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: int
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string);

        |

        *Overload 7:*

        Sets winIDEA option.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        Example:

          ide.setOption("/IDE/Debug.DownloadFiles.File[0].Load", true)



        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        :type value: boolean
        :param value: value to be assigned to the option

        :raises: IOException in case of failure.

        See also: setOption(std::string, std::string);
        """
        return _connect.CIDEController_setOption(self, *args)

    def optionExists(self, option):
        r"""
        Returns true, if the given option exists, false otherwise.

        :type option: string
        :param option: url of the option with value, not just part of option path.
                          Format: /<moduleType>/<moduleId>/<optionPath>

                          where: 

                          <moduleType> defines module type, see constants beginning with
                                       ``OPT_DEST_...`` defined in this file for available
                                       module types, for example CIDEController::OPT_DEST_IDE.


                          <moduleId> defines module ID, used only by some module types.
                                     See CIDEController::OPT_DEST_IDE and other module type constants
                                     to see if this value must be specified.


                          <optionPath> path defining the option. 


                          Examples:

                             /HIL/outputVoltage.1
                             /IOPEN/Communication.Mode
                             /Document/myFile.ccv/Code.AutoStart


        Python example: _sample_link{ide_ctrl,test_option_exists}
        """
        return _connect.CIDEController_optionExists(self, option)

    def getOptionStr(self, *args):
        r"""
        *Overload 1:*

        Returns winIDEA option of type string.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type options: string
        :param options: paths to option

        Python example: _sample_link{ide_ctrl,test_get_option}

        |

        *Overload 2:*

        Returns winIDEA option of type string.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        Python example: _sample_link{ide_ctrl,test_get_option}
        """
        return _connect.CIDEController_getOptionStr(self, *args)

    def getOptionJSON(self, optionUrl):
        r"""
        Returns winIDEA options of an object as JSON formatted string
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>;

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code


        Python example: _sample_link{ide_ctrl,test_get_set_option_json}
        """
        return _connect.CIDEController_getOptionJSON(self, optionUrl)

    def getOptionInt(self, *args):
        r"""
        *Overload 1:*

        Returns winIDEA option of type integer.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: paths to option

        Python example: _sample_link{ide_ctrl,test_get_option}

        |

        *Overload 2:*

        Returns winIDEA option of type integer.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        Python example: _sample_link{ide_ctrl,test_get_option}
        """
        return _connect.CIDEController_getOptionInt(self, *args)

    def getOptionFloat(self, *args):
        r"""
        *Overload 1:*

        Returns winIDEA option of type float.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plug-ins.

        :type option: string
        :param option: paths to option

        Python example: _sample_link{ide_ctrl,test_get_option}

        |

        *Overload 2:*

        Returns winIDEA option of type float.
        Paths and values of options can be found in winIDEA, menu ``Help | Display Option ...``.

        :type optionUrl: string
        :param optionUrl: url of the option. Format: /<moduleType>/<moduleId>/<optionPath>

                             where: 

                             <moduleType> defines module type, see constants beginning with
                                          ``OPT_DEST_...`` defined in this file for available
                                          module types, for example CIDEController::OPT_DEST_IDE.


                             <moduleId> defines module ID, used only by some module types.
                                        See CIDEController::OPT_DEST_IDE and other module type constants
                                        to see if this value must be specified.


                             <optionPath> path defining the option. 


                             Examples:

                                /HIL/outputVoltage.1
                                /IOPEN/Communication.Mode
                                /Document/myFile.ccv/Code.AutoStart


        Python example: _sample_link{ide_ctrl,test_get_option}
        """
        return _connect.CIDEController_getOptionFloat(self, *args)

    def getEnumElements(self, optionUrl, elements):
        return _connect.CIDEController_getEnumElements(self, optionUrl, elements)

    def getOptionDataDescriptor(self, optionUrl):
        return _connect.CIDEController_getOptionDataDescriptor(self, optionUrl)

    def getMenuStructure(self, optionUrl):
        return _connect.CIDEController_getMenuStructure(self, optionUrl)

    def release(self, *args):
        return _connect.CIDEController_release(self, *args)

    def getDynamicOptionSize(self, *args):
        r"""
        *Overload 1:*

        Returns current number of items in dynamic option.

        **Dynamic** **options** are arrays of
        options, which size is not fixed. They may have 0..N items. Example of dynamic
        option are breakpoints. There may be any number of breakpoints in the program, and
        each of them contains several attributes, for example location and enabled status.
        See 'Help | Display Option...' in winIDEA. Make sure that ``Values`` check-box is not
        checked and click the ``Display`` button. All options with '[]' are dynamic. If there
        is a number, for example '[32]', the option has fixed size.

        Example:

        ide.getDynamicOptionSize(ofDestIDE, "", "ExecBPs.BP");


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type option: string
        :param option: path to option

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 2:*

        Returns current number of items in dynamic option.

        Example:

        ide.getDynamicOptionSize("/IDE/ExecBPs.BP");


        See also: getDynamicOptionSize() for description of ``dynamic`` options
        """
        return _connect.CIDEController_getDynamicOptionSize(self, *args)

    def findDynamicOption(self, urlBase, elementName, strToFind):
        r"""
        This method returns index of option with the given value. For example,
        if we have an array of options


        "/a/b.c[idx].d" = x


        and we specify:

        urlBase = "/a/b.c"
        elementName = "d"
        strToFind = "e"


        then this method will return the first ``idx``, for which ``x == "e"``.
        If the item is not found, -1 is returned.

        :type urlBase: string
        :param urlBase: url of the dynamic option, without index
        :type elementName: string
        :param elementName: name of the element in the array of dynamic options
        :type strToFind: string
        :param strToFind: value of the dynamic option to look for

        Python example: _sample_link{ide_ctrl,test_dynamic_option}
        """
        return _connect.CIDEController_findDynamicOption(self, urlBase, elementName, strToFind)

    def getDynamicOptions(self, urlBase, elementName, optionValues):
        r"""
        Returns all values of dynamic options for the given urlBase
        and element.
        Example:

        Get all function names in profiler for current trigger. URL for the first
        name is
        ``/Document/sample_profiler.trd/SessionTrigger.Item.Profiler.ExecArea[0].Name``

        Specify parameters as:

         urlBase = "/Document/sample_profiler.trd/SessionTrigger.Item.Profiler.ExecArea"
         elementName = "Name"


        :type urlBase: string
        :param urlBase: part of url up to index
        :type elementName: string
        :param elementName: part of url after index
        :type optionValues: :py:class:`StrVector`
        :param optionValues: vector to contain option values on return

        Python example: _sample_link{ide_ctrl,test_dynamic_option}
        """
        return _connect.CIDEController_getDynamicOptions(self, urlBase, elementName, optionValues)

    def addDynamicOption(self, *args):
        r"""
        *Overload 1:*

        Adds item at the specified index in dynamic option. Default values are used for
        all members of the item. Use method setOption() to define the values.

        Example:

        ide.addDynamicOption(ofDestIDE, "", "System.Network.Networks");  // add empty breakpoint


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type options: string
        :param options: path to option

        :type index: int, optional
        :param index: item index. If set to -1, item is appended to the end of the list.

        :rtype: int
        :return: index of the added element. Useful when input ``index`` was set to -1.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 2:*

        Adds item at the specified index in dynamic option. Default values are used for
        all members of the item. Use method setOption() to define the values.

        Example:

        ide.addDynamicOption("/IDE/System.Network.Networks");  // appends an empty breakpoint


        :type optionUrl: string
        :param optionUrl: option.

        :type index: int, optional
        :param index: item index. If set to -1, item is appended to the end of the list.

        :rtype: int
        :return: index of the added element. Useful when input ``index`` was set to -1.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 3:*

        Adds item at the specified index in dynamic option. Default values are used for
        all members of the item. Use method setOption() to define the values.

        Example:

        ide.addDynamicOption("/IDE/System.Network.Networks");  // appends an empty breakpoint


        :type optionUrl: string
        :param optionUrl: option.

        :param index: item index. If set to -1, item is appended to the end of the list.

        :rtype: int
        :return: index of the added element. Useful when input ``index`` was set to -1.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}
        """
        return _connect.CIDEController_addDynamicOption(self, *args)

    def addDynamicOptionUrl(self, optionUrl, index=-1):
        r"""
        This is a helper method, which performs the same operation as addDynamicOption(const std::string &, int),
        but returns URL of the added option instead of its index.

        :type optionUrl: string
        :param optionUrl: option.

        :type index: int, optional
        :param index: item index. If set to -1, item is appended to the end of the list.

        See also: addDynamicOption(const std::string &, int)

        Python example: _sample_link{ide_ctrl,test_dynamic_option}
        """
        return _connect.CIDEController_addDynamicOptionUrl(self, optionUrl, index)

    def removeDynamicOption(self, *args):
        r"""
        *Overload 1:*

        Removes item at the specified index in dynamic option.

        Example:

        ide.removeDynamicOption(ofDestIDE, "", "ExecBPs.BP", 2);


        :type moduleType: int
        :param moduleType: module type, one of ``ofDest...`` flags from EOptionFlags in i_Option.h.

        :type moduleId: string
        :param moduleId: module ID, for example file name in
                            case of documents or CLSID in case of plugins.

        :type options: string
        :param options: path to option

        :type index: int, optional
        :param index: item index. If set to -1, all items are removed.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 2:*

        Removes item at the specified index in dynamic option.

        Example:

        ide.removeDynamicOption("/IDE/ExecBPs.BP");

        :type optionUrl: string
        :param optionUrl: Option.
        :type index: int, optional
        :param index: item index. If set to -1, all items are removed.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}

        |

        *Overload 3:*

        Removes item at the specified index in dynamic option.

        Example:

        ide.removeDynamicOption("/IDE/ExecBPs.BP");

        :type optionUrl: string
        :param optionUrl: Option.
        :param index: item index. If set to -1, all items are removed.

        Python example: _sample_link{ide_ctrl,test_dynamic_option}
        """
        return _connect.CIDEController_removeDynamicOption(self, *args)

    def commitOptions(self, *args):
        r"""
        *Overload 1:*

        Deprecated: This method terminates debugging session in most cases.
        Since all options are applied at start of debugging session, this
        method is no longer needed. For options applied during debugging session,
        use service call. For example, to apply hardware breakpoints, call

            serviceCall('/iOPEN/Core.Debug.ApplyInternalBPs', '')

        Contact iSYSTEM support if you need other options to be applied during debug session.

        ---

        Commits options previously set by option() and setOption() methods.

        :type optionUrl: string
        :param optionUrl: url of the option to commit. Can also be module type
                             only, for example "/IOPEN/" or "/IDE/". Both '/' must be
                             present, as they are in the examples.


        |

        *Overload 2:*

        Deprecated: This method terminates debugging session in most cases.
        Since all options are applied at start of debugging session, this
        method is no longer needed. For options applied during debugging session,
        use service call. For example, to apply hardware breakpoints, call

            serviceCall('/iOPEN/Core.Debug.ApplyInternalBPs', '')

        Contact iSYSTEM support if you need other options to be applied during debug session.

        ---

        Commits options previously set by option() and setOption() methods.
        Note that document and plugin destinations cannot use this function as they require
        the path to the document or plugin. Use commitOptions('/Document/<path>') function instead

        :type destFlags: int
        :param destFlags: one of ``ofDest...`` flags from ::EOptionFlags.
        """
        return _connect.CIDEController_commitOptions(self, *args)

    def serviceCall(self, *args):
        r"""
        *Overload 1:*

        Deprecated: call method `invoke()` instead.
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSYSTEM support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type params: string
        :param params: function parameters as comma separated ``key: value`` pairs,
                                   for example: ``'Dividend: 10, Divisor: 3'``
        :type bufferSize: int, optional
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                                   for example: ``'Quotient: 5, Remainder: 0'``

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use parseServiceCallMap() for parsing, then retrieve values from
                      mapping.**


        |

        *Overload 2:*

        Deprecated: call method ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSYSTEM support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping
        :type outParams: :py:class:`StrStrMap`
        :param outParams: output parameters as mapping
        :type bufferSize: int, optional
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                             for example: ``'Quotient: 5, Remainder: 0'``
                             This information is the same as returned in ``outParams``.

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use returned ``outParams`` mapping.**


        |

        *Overload 3:*

        Deprecated: call method ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSYSTEM support.

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call, for
                           example: ``'/IDE/Divide'``
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping
        :type outParams: :py:class:`StrStrMap`
        :param outParams: output parameters as mapping
        :param bufferSize: buffer size for data received from winIDEA. Usually there is no need
                              to set this value.

        :rtype: string
        :return: function result as comma separated ``key: value`` pairs,
                             for example: ``'Quotient: 5, Remainder: 0'``
                             This information is the same as returned in ``outParams``.

        **IMPORTANT: Never parse returned string with your code, because format may change in the future.
                      Always use returned ``outParams`` mapping.**
        """
        return _connect.CIDEController_serviceCall(self, *args)

    def invoke(self, funcUrl, inParams):
        r"""
        This method invokes functions within winIDEA process.
        Example:

            result = ide.invoke('/IDE/Divide', {'Dividend': '10', 'Divisor': '2'})

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping

        :rtype: :py:class:`StrStrMap`
        :return: mapping of output values.
        :raises: Exception Exception is thrown only if there is an error in routing
                    (accessing winIDEA, ...). If there is an error
                    in the function called, there is no exception thrown - caller has to check
                    the returned mapping. Value `true` for the key `ResultB` means success,
                    `false` means failure with error description in `ResultS`.
                    Example for error checking:

                    outParams = invoke(myFunc, ...)
                    if outParams['ResultB'].lower() == "false":
                        raise Exception(f"'{myFunc}' failed: {outParams['ResultS']}")

        Note: Python and Java support Python mapping and Java Map as input/output
        types in addition to `isystem.connect.StrStrMap`. Example for Java:

            ideCtrl.invoke("/IDE/Divide", Map.of("Dividend", "10", "Divisor", "2"));

        Python example: _sample_link{ide_ctrl,test_invoke}
        """


        if isinstance(inParams, dict):
            inParams = StrStrMap(inParams)


        val = _connect.CIDEController_invoke(self, funcUrl, inParams)

                # return Python dict instead of StrStrMap.
        val = dict(val)


        return val


    def invoke_T(self, funcUrl, inParams):
        r"""
        Same as invoke(), but throws also if the called function
        fails - when `outParams["ResultB"].lower() == "false"`, so no special error checking
        on the client side is required.
        """
        return _connect.CIDEController_invoke_T(self, funcUrl, inParams)

    @staticmethod
    def parseServiceCallMap(str, outParams):
        r"""
        Deprecated: due to serviceCall() methods deprecation this one is not needed anymore,
        call ``'invoke(std::string, iconnect::StrStrMap, iconnect::StrStrMap)'``
        Parses the given string and returns mapping of strings. The string should be
        obtained as return value from service call.

        :type str: string
        :param str: string returned by method serviceCall(const std::string &, const std::string &, int)
        :type outParams: :py:class:`StrStrMap`
        :param outParams: mapping to receive parsed key/value pairs.
        """
        return _connect.CIDEController_parseServiceCallMap(str, outParams)

    @staticmethod
    def mapToServiceCallString(inParams):
        return _connect.CIDEController_mapToServiceCallString(inParams)

    def setInterruptsDisable(self, interruptFlags=65535):
        r"""
        This method is a convenient shortcut to disable target interrupts during
        some winIDEA operations, and to restore the previous state.

        If called with the default argument value, all interrupts are disabled.
        Returns current setting, which can be used on next call to restore the
        the interrupt enabled/disabled setting.
        The returned value can only be used as parameter to this method
        to restore previous state. The meaning of bits is internal to this
        method. If you would like to have finer control over interrupts,
        then set options ``/IDE/Debug.Debugging.DisableIRQ_...`` manually.

        Python example: _sample_link{ide_ctrl,test_set_interrupts_disable}
        """
        return _connect.CIDEController_setInterruptsDisable(self, interruptFlags)

    def cdToWinIDEAWorkspaceDir(self):
        r"""
        Changes working directory to winIDEA workspace directory.

        :rtype: string
        :return: working directory before this function was called

        Python example: _sample_link{ide_ctrl,test_cd_to_winidea_workspace_dir}
        """
        return _connect.CIDEController_cdToWinIDEAWorkspaceDir(self)

    def getLicenseDescription(self):
        r"""
         Returns license description.

        Python example: _sample_link{ide_ctrl,test_get_license_description}
        """
        return _connect.CIDEController_getLicenseDescription(self)

    def openView(self, *args):
        r"""
        Opens specified winIDEA view, for example Symbols, Callstack, etc.

        :type type: int
        :param type: type of the view, must be one of `CIDEController::ViewType`. This parameter is sufficient for opening singleton views.
        :type name: string, optional
        :param name: name of the view. This is required for opening specified non-singleton view, but only if once opened via GUI (manually).
            Memory view is an example of such view.

        Python example: _sample_link{ide_ctrl,test_layout_manipulation}
        """
        return _connect.CIDEController_openView(self, *args)

    def closeView(self, *args):
        r"""
        Closes specified winIDEA view, for example Symbols, Callstack, etc.

        :type type: int
        :param type: type of the view, must be one of `CIDEController::ViewType`. This parameter is sufficient for closing singleton views
            or all non-singleton views of certain type.
        :type name: string, optional
        :param name: name of the view. This is required for closing non-singleton view with a certain name, but only if once opened via GUI (manually).
            Memory view is an example of such view.
        """
        return _connect.CIDEController_closeView(self, *args)

    def closeAllViews(self):
        r"""
        Closes all documents and views.

        Python example: _sample_link{ide_ctrl,test_layout_manipulation}
        """
        return _connect.CIDEController_closeAllViews(self)

    def enumerateViewTypes(self, data):
        r"""
        Enumerates complete view types (singleton and non-singleton), providing data for each type.
        :type data: std::vector< isys::ViewTypeData,std::allocator< isys::ViewTypeData > >
        :param data: vector of `CIDEController::ViewTypeData` elements
        """
        return _connect.CIDEController_enumerateViewTypes(self, data)

    def enumerateAllViews(self, data):
        r"""
        Enumerates complete views (singleton and existing non-singleton), providing data for each of it.
        :type data: std::vector< isys::ViewData,std::allocator< isys::ViewData > >
        :param data: vector of `CIDEController::ViewData` elements

        Python example: _sample_link{ide_ctrl,test_layout_manipulation}
        """
        return _connect.CIDEController_enumerateAllViews(self, data)

    def enumerateView(self, type, data, bAbsolutePaths=False):
        r"""
        Enumerates all views of specified type.
        :type type: int
        :param type: view type
        :type data: std::vector< isys::ViewData,std::allocator< isys::ViewData > >
        :param data: vector of `CIDEController::ViewData` elements
        :type bAbsolutePaths: boolean, optional
        :param bAbsolutePaths: set to true to get absolute instead of relative paths of documents

        Python example: _sample_link{ide_ctrl,test_document_manipulation}
        """
        return _connect.CIDEController_enumerateView(self, type, data, bAbsolutePaths)

    def exportViewLayout(self, filePath):
        r"""
        Exports layout as workspace template.
        :type filePath: string
        :param filePath: path to the file with *.jswt extension (Json Workspace Template). Can be an absolute path or relative to the workspace.

        Python example: _sample_link{ide_ctrl,test_export_import_layout}
        """
        return _connect.CIDEController_exportViewLayout(self, filePath)

    def importViewLayout(self, filePath):
        r"""
        Imports layout from workspace template.
        :type filePath: string
        :param filePath: path to the file with *.jswt extension (Json Workspace Template). Can be an absolute path or relative to the workspace.

        Python example: _sample_link{ide_ctrl,test_export_import_layout}
        """
        return _connect.CIDEController_importViewLayout(self, filePath)

    def getLValue(self, key):
        return _connect.CIDEController_getLValue(self, key)

# Register CIDEController in _connect:
_connect.CIDEController_swigregister(CIDEController)
CIDEController.ADVANCED_KEY_0 = _connect.cvar.CIDEController_ADVANCED_KEY_0
CIDEController.EVALUATION_LICENSE_STR = _connect.cvar.CIDEController_EVALUATION_LICENSE_STR
CIDEController.LICENSE_DESCRIPTION = _connect.cvar.CIDEController_LICENSE_DESCRIPTION
CIDEController.OPT_DEST_IDE = _connect.cvar.CIDEController_OPT_DEST_IDE
CIDEController.OPT_DEST_DOCUMENT = _connect.cvar.CIDEController_OPT_DEST_DOCUMENT
CIDEController.OPT_DEST_IOPEN = _connect.cvar.CIDEController_OPT_DEST_IOPEN
CIDEController.OPT_DEST_PLUGIN = _connect.cvar.CIDEController_OPT_DEST_PLUGIN

class ViewTypeData(object):
    r"""View type data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_connect.ViewTypeData_type_get, _connect.ViewTypeData_type_set, doc=r"""view type""")
    name = property(_connect.ViewTypeData_name_get, _connect.ViewTypeData_name_set, doc=r"""view type name""")
    isSingleton = property(_connect.ViewTypeData_isSingleton_get, _connect.ViewTypeData_isSingleton_set, doc=r"""singleton status""")

    def __init__(self):
        _connect.ViewTypeData_swiginit(self, _connect.new_ViewTypeData())
    __swig_destroy__ = _connect.delete_ViewTypeData

# Register ViewTypeData in _connect:
_connect.ViewTypeData_swigregister(ViewTypeData)
class ViewData(object):
    r"""View data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_connect.ViewData_type_get, _connect.ViewData_type_set, doc=r"""view type""")
    state = property(_connect.ViewData_state_get, _connect.ViewData_state_set, doc=r"""view state""")
    name = property(_connect.ViewData_name_get, _connect.ViewData_name_set, doc=r"""view name""")
    typeName = property(_connect.ViewData_typeName_get, _connect.ViewData_typeName_set, doc=r"""view type name""")

    def __init__(self):
        _connect.ViewData_swiginit(self, _connect.new_ViewData())
    __swig_destroy__ = _connect.delete_ViewData

# Register ViewData in _connect:
_connect.ViewData_swigregister(ViewData)
class DownloadListMember(object):
    r"""Description of file in winIDEA download list."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fileName = property(_connect.DownloadListMember_fileName_get, _connect.DownloadListMember_fileName_set, doc=r"""Name of the file.""")
    options = property(_connect.DownloadListMember_options_get, _connect.DownloadListMember_options_set, doc=r"""Advanced download options from winIDEA dialog""")

    def __init__(self):
        _connect.DownloadListMember_swiginit(self, _connect.new_DownloadListMember())
    __swig_destroy__ = _connect.delete_DownloadListMember

# Register DownloadListMember in _connect:
_connect.DownloadListMember_swigregister(DownloadListMember)
class CDownloadConfiguration(object):
    r"""
    This class contains data used for download to target. At least one of methods
    setCodeOffset() or setSymbolsOffset() should be called to define which
    data should be downloaded.

    This class is intended to be used with methods CLoaderController::targetDownload() and
    CLoaderController::addToDownloadList().

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ftBinary = _connect.CDownloadConfiguration_ftBinary
    r"""binary format"""
    ftIntelHex = _connect.CDownloadConfiguration_ftIntelHex
    r"""Intel hex format"""
    ftMotorolaS = _connect.CDownloadConfiguration_ftMotorolaS
    r"""MotorolaS format"""
    ftTektronix = _connect.CDownloadConfiguration_ftTektronix
    r"""Tektronix format"""
    ftExtendedTektronix = _connect.CDownloadConfiguration_ftExtendedTektronix
    r"""ExtendedTektronix format"""
    ftUBROF = _connect.CDownloadConfiguration_ftUBROF
    r"""UBROF format"""
    ftOMF166 = _connect.CDownloadConfiguration_ftOMF166
    r"""OMF166 format"""
    ftICFOFF = _connect.CDownloadConfiguration_ftICFOFF
    r"""ICFOFF format"""
    ftOMF51 = _connect.CDownloadConfiguration_ftOMF51
    r"""OMF51 format"""
    ftSLOText = _connect.CDownloadConfiguration_ftSLOText
    r"""SLOText format"""
    ftMicrotek = _connect.CDownloadConfiguration_ftMicrotek
    r"""Microtek format"""
    ftIEEE695 = _connect.CDownloadConfiguration_ftIEEE695
    r"""IEEE695 format"""
    ftAD2500 = _connect.CDownloadConfiguration_ftAD2500
    r"""AD2500 format"""
    ftAXE = _connect.CDownloadConfiguration_ftAXE
    r"""AXE format"""
    ftByteCraftCOD = _connect.CDownloadConfiguration_ftByteCraftCOD
    r"""ByteCraftCOD format"""
    ftMotorolaSymbolic = _connect.CDownloadConfiguration_ftMotorolaSymbolic
    r"""MotorolaSymbolic format"""
    ftHiTech = _connect.CDownloadConfiguration_ftHiTech
    r"""HiTech format"""
    ftOMF86 = _connect.CDownloadConfiguration_ftOMF86
    r"""OMF86 format"""
    ftOMF96 = _connect.CDownloadConfiguration_ftOMF96
    r"""OMF96 format"""
    ftOMF251 = _connect.CDownloadConfiguration_ftOMF251
    r"""OMF251 format"""
    ftProspero = _connect.CDownloadConfiguration_ftProspero
    r"""Prospero format"""
    ftLogitechModula2 = _connect.CDownloadConfiguration_ftLogitechModula2
    r"""LogitechModula2 format"""
    ftELF = _connect.CDownloadConfiguration_ftELF
    r"""ELF format"""
    ftMARC4 = _connect.CDownloadConfiguration_ftMARC4
    r"""MARC4 format"""
    ftCR16COFF = _connect.CDownloadConfiguration_ftCR16COFF
    r"""CR16COFF format"""
    ftTMSCOFF = _connect.CDownloadConfiguration_ftTMSCOFF
    r"""TMSCOFF format"""
    ftStabs = _connect.CDownloadConfiguration_ftStabs
    r"""Stabs format"""
    ftZardoz = _connect.CDownloadConfiguration_ftZardoz
    r"""Zardoz format"""

    def __init__(self):
        r"""Constructor initializes fields to default values."""
        _connect.CDownloadConfiguration_swiginit(self, _connect.new_CDownloadConfiguration())

    def setCodeOffset(self, offset):
        r"""Sets code offset. If this method is not called, code is not downloaded."""
        return _connect.CDownloadConfiguration_setCodeOffset(self, offset)

    def setSymbolsOffset(self, offset):
        r"""Sets symbols offset. If this method is not called, symbols are not downloaded."""
        return _connect.CDownloadConfiguration_setSymbolsOffset(self, offset)

    def setMemoryArea(self, *args):
        r"""
        *Overload 1:*
        Legacy method - does nothing. Use setMemoryArea(const std::string &memoryArea).

        |

        *Overload 2:*
        Sets memory area. If this method is not called, default memory area is used.
        """
        return _connect.CDownloadConfiguration_setMemoryArea(self, *args)

    def getMemoryArea(self):
        r"""Gets memory area."""
        return _connect.CDownloadConfiguration_getMemoryArea(self)

    def setUsedInFullDownload(self, isUsedInFullDownload):
        r"""
         If ``isUsedInFullDownload`` is true, then the file is used when full download is performed.
        Set to ``false`` by default.
        """
        return _connect.CDownloadConfiguration_setUsedInFullDownload(self, isUsedInFullDownload)

    def setIsProjectOutputFile(self, isProjectOutputFile):
        return _connect.CDownloadConfiguration_setIsProjectOutputFile(self, isProjectOutputFile)

    def setInProjectTargetDir(self, isInProjectTargetDir):
        r"""
         If ``isInProjectTargetDir`` is true, the file is taken from the project target directory.
        Set to ``false`` by default.
        """
        return _connect.CDownloadConfiguration_setInProjectTargetDir(self, isInProjectTargetDir)

    def setTypeEqualByName(self, isTypeEqualByName):
        r"""
         If ``isTypeEqualByName`` is set to true, types with the same name are
        assumed to be equal. Set to ``false`` by default.
        """
        return _connect.CDownloadConfiguration_setTypeEqualByName(self, isTypeEqualByName)

    def setDownloadFileFormat(self, format):
        r"""Sets the download file format. Binary format is set by default."""
        return _connect.CDownloadConfiguration_setDownloadFileFormat(self, format)

    def setRealTimeAccess(self, isRealTimeAccess):
        r"""Sets real-time access. Off by default."""
        return _connect.CDownloadConfiguration_setRealTimeAccess(self, isRealTimeAccess)

    def setForceConvert(self, isForceConvert):
        r"""
        If ``isForceConvert`` is true, it forces conversion of elf file to
        winIDEA download format. This is
        important if you want to download symbols/code only. False
        by default.
        """
        return _connect.CDownloadConfiguration_setForceConvert(self, isForceConvert)

    def setUseAbsolutePath(self, isUseAbsolutePath):
        r"""
         If set to true,
        the specified path is not converted into workspace
        relative path. Has effect only with ``addToDownloadList()``.
        """
        return _connect.CDownloadConfiguration_setUseAbsolutePath(self, isUseAbsolutePath)

    def isForceConvert(self):
        r"""
         Returns force download setting.

        See also: setForceConvert()
        """
        return _connect.CDownloadConfiguration_isForceConvert(self)

    def isRealTimeAccess(self):
        r"""Returns true, if real-time access is set."""
        return _connect.CDownloadConfiguration_isRealTimeAccess(self)

    def isUseAbsolutePath(self):
        r"""
         Returns the ``use`` ``absolute`` ``path`` setting

        See also: setUseAbsolutePath()
        """
        return _connect.CDownloadConfiguration_isUseAbsolutePath(self)
    __swig_destroy__ = _connect.delete_CDownloadConfiguration

# Register CDownloadConfiguration in _connect:
_connect.CDownloadConfiguration_swigregister(CDownloadConfiguration)
class CLoaderController(object):
    r"""
    Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                instead.

    This class can be used for downloading executables to the target.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DLIST_PRIMARY = _connect.CLoaderController_DLIST_PRIMARY
    r"""use the Program Files download list"""
    DLIST_TARGET = _connect.CLoaderController_DLIST_TARGET
    r"""use the Target Files download list"""

    def __init__(self, connectionMgr):
        r"""
        Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                    instead.

        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CLoaderController_swiginit(self, _connect.new_CLoaderController(connectionMgr))
    __swig_destroy__ = _connect.delete_CLoaderController

    def download(self):
        r"""
        Deprecated: Use CSessionCtrl::begin_program instead. See examples in Session Control section
                    of the documentation.

        Downloads executables to the target. The download files are defined in winIDEA,
        *Debug / Configure Session / SoCs / Edit / Program Files*. This method resets the target.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        Note: this method is superseded by CSessionCtrl::begin_program
        """
        return _connect.CLoaderController_download(self)

    def downloadWithoutCode(self):
        r"""
        Deprecated: Use CSessionCtrl::begin_reset instead. See examples in Session Control section
                    of the documentation.

        Download without code - initialize target and load symbols. The download
        files are defined in winIDEA,
        *Debug / Configure Session / SoCs / Edit / Program Files*.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        Note: this method is superseded by CSessionCtrl::begin_reset
        """
        return _connect.CLoaderController_downloadWithoutCode(self)

    def targetDownload(self, *args):
        r"""
        *Overload 1:*

        This method downloads a file in winIDEA's target file list
        (see *Debug / Configure Session / SoCs / Edit / Target Files*) without resetting the target and
        initializing emulation.

        :type downloadConfig: :py:class:`CDownloadConfiguration`
        :param downloadConfig: download configuration
        :type fileName: string
        :param fileName: the file to be downloaded
        :type cmdLineOptions: string
        :param cmdLineOptions: command line options for download. These options contain
                   settings from the winIDEA advanced download options dialog
                   (*Debug / Configure Session / SoCs / Edit / Target Files / Edit / Advanced*).
                   To see how to format this string, set the options manually
                   in winIDEA, and then call getDownloadList() and print the ``options``
                   attribute of the returned items.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        |

        *Overload 2:*

        This is a specialized version of the more general
        method targetDownload(CDownloadConfigurationSPtr , const std::string &, const std::string &).
        It downloads code and symbols, memory area is not used, no real-time access.
        It is equivalent to the following code snippet:

        CDownloadConfiguration downloadConfig;
        downloadConfig.setCodeOffset(0).setSymbolsOffset(0).setDownloadFileFormat(format);

        loader.targetDownload(downloadConfig, fileName, "");


        :type format: int
        :param format: format of the download file
        :type fileName: string
        :param fileName: the file to be downloaded

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error
        """
        return _connect.CLoaderController_targetDownload(self, *args)

    def downloadFromList(self, *args):
        r"""
        *Overload 1:*

        Deprecated: Will not be replaced.

        Downloads a file from winIDEA's download list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*)
        :type fileName: string
        :param fileName: name of the file to download
        :type isRealTime: boolean
        :param isRealTime: if true, real-time access is performed.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error

        |

        *Overload 2:*

        Deprecated: Will not be replaced.

        Downloads a file from winIDEA's download list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*)
        :type fileIndex: int
        :param fileIndex: index of the file in the list
        :type isRealTime: boolean
        :param isRealTime: if true, real-time access is performed.

        :rtype: int
        :return: S_OK in case of success, S_FALSE in case of warning (but successful download).
        :raises: IOException in case of an error
        """
        return _connect.CLoaderController_downloadFromList(self, *args)

    def addToDownloadList(self, *args):
        r"""
        *Overload 1:*

        Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                    instead. See python example.

        Adds a file to download list in winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*).

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*)
        :type fileName: string
        :param fileName: name of the file to add
        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, the specified path is not converted into a
                                  workspace relative path
        :type options: string
        :param options: command line options for download. These options contain
                   settings from the winIDEA advanced download options dialog
                   (*Debug / Configure Session / SoCs / Edit / Target Files / Edit / Advanced*).
                   To see how to format this string, set the options manually
                   in winIDEA, and then call getDownloadList() and print the ``options``
                   attribute of the returned items.


        |

        *Overload 2:*

        Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                    instead. See python example.

        Adds a file to download list in winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*).

        :type downloadConfig: :py:class:`CDownloadConfiguration`
        :param downloadConfig: download configuration
        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA
        :type fileName: string
        :param fileName: the file to be downloaded
        :type cmdLineOptions: string
        :param cmdLineOptions: command line options for download. These options contain
                   settings from the winIDEA advanced download options dialog
                   (*Debug / Configure Session / SoCs / Edit / Target Files / Edit / Advanced*).
                   To see how to format this string, set the options manually
                   in winIDEA, and then call getDownloadList() and print the ``options``
                   attribute of the returned items.
        """
        return _connect.CLoaderController_addToDownloadList(self, *args)

    def removeFromDownloadList(self, listType, fileIndex):
        r"""
        Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                    instead. See python example.

        Removes the file at the given index from the list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*)
        :type fileIndex: int
        :param fileIndex: index of file to be removed from the list.

        :rtype: int
        :return: S_FALSE if there is no file at the given index.

        Python example: _sample_link{opt_ctrl,test_remove_from_download_list}
        """
        return _connect.CLoaderController_removeFromDownloadList(self, listType, fileIndex)

    def clearDownloadList(self, listType):
        r"""
        Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                    instead. See python example.

        Removes all files from the specified download list.

        :type listType: int
        :param listType: selects main or target download list in
                            winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*)

        Python example: _sample_link{opt_ctrl,test_clear_download_list}
        """
        return _connect.CLoaderController_clearDownloadList(self, listType)

    def verifyDownload(self):
        r"""
        Verifies download.

        :raises: IOException if verification can not be performed
        :raises: IllegalStateException if verification detects error in download
        """
        return _connect.CLoaderController_verifyDownload(self)

    def getDownloadList(self, listType, isAbsolutePath):
        r"""
        Deprecated: Use CConfigurationController/COptionController and CSessionCtrl
                    instead. See python example.

        Gets list of files to be downloaded from winIDEA.

        :type listType: int
        :param listType: selects main or target download
                            list in winIDEA (see dialog *Debug / Configure Session / SoCs / Edit*)
        :type isAbsolutePath: boolean
        :param isAbsolutePath: if true, absolute paths are returned

        :raises: IOException in case of an error

        Python example: _sample_link{opt_ctrl,test_get_download_list}
        """
        return _connect.CLoaderController_getDownloadList(self, listType, isAbsolutePath)

# Register CLoaderController in _connect:
_connect.CLoaderController_swigregister(CLoaderController)
class CCfg_debug_basic(object):
    r"""
    This class provides methods to manage winIDEA configuration in Basic mode.

    Once the instance is configured, it can be used in CWorkspaceController's create, get_cfg_debug and set_cfg_debug functions.


    Python example: _sample_link{workspace_ctrl,test_close_open}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCfg_debug_basic_swiginit(self, _connect.new_CCfg_debug_basic())
    __swig_destroy__ = _connect.delete_CCfg_debug_basic

    def get_Device(self):
        r"""
        gets the device(SoC) to use

        :rtype: string
        :return: manufacturer name of the device
        """
        return _connect.CCfg_debug_basic_get_Device(self)

    def set_Device(self, val):
        r"""
        Sets the device(SoC) to use. This parameter is required.

        :type val: string
        :param val: manufacturer name of the device
        """
        return _connect.CCfg_debug_basic_set_Device(self, val)

    def get_DeviceName(self):
        r"""
        gets the user name of the device(SoC)

        :rtype: string
        :return: user name of the device
        """
        return _connect.CCfg_debug_basic_get_DeviceName(self)

    def set_DeviceName(self, val):
        r"""
        Sets the user name of the device(SoC). If this parameter is not set, the manufacturer name will be used

        :type val: string
        :param val: user name of the device
        """
        return _connect.CCfg_debug_basic_set_DeviceName(self, val)

    def get_Probe(self):
        r"""
        gets the probe name to use

        :rtype: string
        :return: probe name
        """
        return _connect.CCfg_debug_basic_get_Probe(self)

    def set_Probe(self, val):
        r"""
        Sets the probe name. This parameter is required when multiple connections from the debugger to the SoC are possible. Available probes are displayed in winIDEA. Typically this needs to be specified only if multiple Active Probes are used.

        :type val: string
        :param val: probe name
        """
        return _connect.CCfg_debug_basic_set_Probe(self, val)

    def get_CreateSMP(self):
        r"""
        gets the SMP configuration

        :rtype: boolean
        :return: true if device cores are configured for SMP operation
        """
        return _connect.CCfg_debug_basic_get_CreateSMP(self)

    def set_CreateSMP(self, val):
        r"""
        sets the SMP configuration

        :type val: boolean
        :param val: true if applicable cores (those with identical core types) should be bound into SMP
        """
        return _connect.CCfg_debug_basic_set_CreateSMP(self, val)

    def get_AppName(self):
        r"""
        gets the application name

        :rtype: string
        :return: name of the application
        """
        return _connect.CCfg_debug_basic_get_AppName(self)

    def set_AppName(self, val):
        r"""
        Sets the application name. If this is not set, the default 'App' will be used. Setting a distinctive name is necessary when multiple applications are defined (in Full configuration mode)

        :type val: string
        :param val: application name
        """
        return _connect.CCfg_debug_basic_set_AppName(self, val)

    def get_SymPath(self):
        r"""
        gets the path to the application's symbol file

        :rtype: string
        :return: path to the application's symbol file
        """
        return _connect.CCfg_debug_basic_get_SymPath(self)

    def set_SymPath(self, val):
        r"""
        Sets the application's symbol file. This is typically the Elf file containing symbolic informatin. If more than one symbols file is required, use CConfigurationController::ide_app_files

        :type val: string
        :param val: path to the application's symbol file
        """
        return _connect.CCfg_debug_basic_set_SymPath(self, val)

    def get_UseSymForPgm(self):
        r"""
        gets the program file = symbol file setting

        :rtype: boolean
        :return: true if same file should be used for both symbolic information as well as FLASH/RAM programming
        """
        return _connect.CCfg_debug_basic_get_UseSymForPgm(self)

    def set_UseSymForPgm(self, val):
        r"""
        specifies whether same file should be used for both symbolic information as well as FLASH/RAM programming

        :type val: boolean
        :param val: true if same file should be used. In such case the path set with set_PgmPath is ignored
        """
        return _connect.CCfg_debug_basic_set_UseSymForPgm(self, val)

    def get_PgmPath(self):
        r"""
        gets the path to the program file

        :rtype: string
        :return: path to the program file
        """
        return _connect.CCfg_debug_basic_get_PgmPath(self)

    def set_PgmPath(self, val):
        r"""
        Sets the program file. This is typically a hex or an Elf file containing target program image. If more than one program file is required, use CConfigurationController::ide_SoC_files

        :type val: string
        :param val: path to the program file
        """
        return _connect.CCfg_debug_basic_set_PgmPath(self, val)

    def get_ReplaceDir(self):
        r"""
        gets the source file path remapping

        :rtype: string
        :return: source file path remapping rules string
        """
        return _connect.CCfg_debug_basic_get_ReplaceDir(self)

    def set_ReplaceDir(self, val):
        r"""
        Sets the source file path remapping rules. Remapping is required when the Application was built on a different PC than the debug PC. ELF file then references files on the build PC and these cannot be found on the debug PC.

        :type val: string
        :param val: source file path remapping rules string.
                "Syntax:   [path old 1]=[path new 1];[path old 2]=[path new 2];...
                "Example: /usr/src/kernel/=../kernel-source/
            "
        """
        return _connect.CCfg_debug_basic_set_ReplaceDir(self, val)
    EPresetPC_none = _connect.CCfg_debug_basic_EPresetPC_none
    r"""PC is not preset. default SoC behaviour is used"""
    EPresetPC_EntryPoint = _connect.CCfg_debug_basic_EPresetPC_EntryPoint
    r"""PC for primary core is preset to the application's symbols file's entry point"""
    EPresetPC_Address = _connect.CCfg_debug_basic_EPresetPC_Address
    r"""PC for primary core is preset to strPresetPC"""

    def set_PresetPC(self, preset_mode, symbol):
        r"""
        Sets the PC preset for primary core.

        :type preset_mode: int
        :param preset_mode: how to preset the PC
        :type symbol: string
        :param symbol: the symbol or numeric value to which the PC should be preset. used then ePresetPC is 'Symbol'
        """
        return _connect.CCfg_debug_basic_set_PresetPC(self, preset_mode, symbol)

    def get_PresetPC(self):
        r"""
        gets the PC preset mode

        :rtype: int
        :return: EPresetPC the preset mode
        """
        return _connect.CCfg_debug_basic_get_PresetPC(self)

    def get_PresetPC_symbol(self):
        r"""
        gets the PC preset symbol

        :rtype: string
        :return: the preset symbol. used when preset mode is 'Symbol'
        """
        return _connect.CCfg_debug_basic_get_PresetPC_symbol(self)

# Register CCfg_debug_basic in _connect:
_connect.CCfg_debug_basic_swigregister(CCfg_debug_basic)
class CWorkspaceController(object):
    r"""
    This class provides methods for handling current workspace in winIDEA.


    Python example: _sample_link{workspace_ctrl,test_close_open}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
            Python example: _sample_link{workspace_ctrl,test_workspace_save}
        """
        _connect.CWorkspaceController_swiginit(self, _connect.new_CWorkspaceController(connectionMgr))
    __swig_destroy__ = _connect.delete_CWorkspaceController

    def newWS(self, *args):
        r"""
        Deprecated: Use CWorkspaceController::create instead

        Creates a new workspace.

        :type rstrWorkspaceFileName: string
        :param rstrWorkspaceFileName: file name of the workspace
        :type rstrIOPEN: string, optional
        :param rstrIOPEN: name of iOPEN server to use; if empty, the default BlueBox server is used

        :raises: IOException in case of an error
        """
        return _connect.CWorkspaceController_newWS(self, *args)

    def create(self, rstrWorkspaceFileName, rstrIOPEN, rCfg):
        r"""
        Creates a new workspace.

        :type rstrWorkspaceFileName: string
        :param rstrWorkspaceFileName: file path/name of the workspace
        :type rstrIOPEN: string
        :param rstrIOPEN: name of iOPEN server to use; if empty, the default BlueBox server is used
        :type rCfg: :py:class:`CCfg_debug_basic`
        :param rCfg: initial debug session configuration

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_create}
        """
        return _connect.CWorkspaceController_create(self, rstrWorkspaceFileName, rstrIOPEN, rCfg)

    def open(self, workspaceFileName):
        r"""
        Opens workspace in winIDEA.

        :type workspaceFileName: string
        :param workspaceFileName: file path/name of the workspace

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_workspace_save}
        """
        return _connect.CWorkspaceController_open(self, workspaceFileName)

    def save(self):
        r"""
        Saves workspace.

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_workspace_save}
        """
        return _connect.CWorkspaceController_save(self)

    def saveAs(self, workspaceFileName):
        r"""
        Saves workspace to a new file.

        :type workspaceFileName: string
        :param workspaceFileName: file name of the workspace

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_workspace_save}
        """
        return _connect.CWorkspaceController_saveAs(self, workspaceFileName)

    def path(self):
        r"""
        returns path of currently opened workspace

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_workspace_save}
        """
        return _connect.CWorkspaceController_path(self)

    def close(self):
        r"""
        Closes workspace. If there are some changes, winIDEA prompts user to
        save the changes.

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_close_open}
        """
        return _connect.CWorkspaceController_close(self)

    def closeDiscard(self):
        r"""
        Closes workspace and discards all changes.

        :raises: IOException in case of an error

        Python example: _sample_link{workspace_ctrl,test_close_open}
        """
        return _connect.CWorkspaceController_closeDiscard(self)

    def get_cfg_debug(self):
        r"""
        Returns current debug configuration

        :rtype: :py:class:`CCfg_debug_basic`
        :return: Basic Debug configuration

        :raises: IOException in case of an error, or if winIDEA is using Full Debug configuration which cannot be converted to Basic configuration

        Python example: _sample_link{workspace_ctrl,test_get_set_basic_debug_cfg}
        """
        return _connect.CWorkspaceController_get_cfg_debug(self)

    def set_cfg_debug(self, rCfg):
        r"""
        Sets debug configuration

        :type rCfg: :py:class:`CCfg_debug_basic`
        :param rCfg: Basic Debug configuration

        :raises: IOException in case of an error, or the configuration is invalid (unsupported device etc.)

        Python example: _sample_link{workspace_ctrl,test_get_set_basic_debug_cfg}
        """
        return _connect.CWorkspaceController_set_cfg_debug(self, rCfg)

    def invoke(self, funcUrl, inParams):
        r"""
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSYSTEM support. Example:

            result = wsCtrl.invoke('/IDE/Divide', {'Dividend': '10', 'Divisor': '2'})

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping

        :rtype: :py:class:`StrStrMap`
        :return: mapping of output values.

        Note: Python and Java support Python mapping and Java Map as input/output
        types in addition to `isystem.connect.StrStrMap`. Example for Java:

            wsCtrl.invoke("/IDE/Divide", Map.of("Dividend", "10", "Divisor", "2"));

        Python example: _sample_link{ide_ctrl,test_invoke}

        Note: This method is equivalent to `CIDEController::invoke()`.
        """


        if isinstance(inParams, dict):
            inParams = StrStrMap(inParams)


        val = _connect.CWorkspaceController_invoke(self, funcUrl, inParams)

                # return Python dict instead of StrStrMap.
        val = dict(val)


        return val


    def invoke_T(self, funcUrl, inParams):
        r"""
        This method invokes functions within winIDEA process, but throws on failure.
        Use this method only when instructed by iSYSTEM support. Example:

            result = wsCtrl.invoke('/IDE/Divide', {'Dividend': '10', 'Divisor': '2'})

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call
        :type inParams: :py:class:`StrStrMap`
        :param inParams: input parameters as mapping

        :rtype: :py:class:`StrStrMap`
        :return: mapping of output values.

        Note: Python and Java support Python mapping and Java Map as input/output
        types in addition to `isystem.connect.StrStrMap`. Example for Java:

            wsCtrl.invoke("/IDE/Divide", Map.of("Dividend", "10", "Divisor", "2"));

        Python example: _sample_link{ide_ctrl,test_invoke}

        Note: This method is equivalent to `CIDEController::invoke_T()`.
        """
        return _connect.CWorkspaceController_invoke_T(self, funcUrl, inParams)

    def invokej(self, funcUrl, inParams):
        r"""
        This method invokes functions within winIDEA process. Use this
        method only when instructed by iSYSTEM support. Example:

            result = wsCtrl.invoke('/IDE/Divide', '{"Dividend": 10, "Divisor": 2}')

        :type funcUrl: string
        :param funcUrl: name of the winIDEA service function to call
        :type inParams: string
        :param inParams: input parameters as JSON string

        :rtype: string
        :return: string with JSON encoded output values

        Python example: _sample_link{workspace_ctrl,test_invokej}
        """
        return _connect.CWorkspaceController_invokej(self, funcUrl, inParams)

# Register CWorkspaceController in _connect:
_connect.CWorkspaceController_swigregister(CWorkspaceController)
class CBuildStatus(object):
    r"""
    This class contains status of the build manager. It is not intended to be
    instantiated by clients. Returned by CProjectController::getStatus().

    See also: CProjectController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def isIdle(self):
        r"""Returns true, if winIDEA build manager is in idle state."""
        return _connect.CBuildStatus_isIdle(self)

    def isIdleWError(self):
        r"""
         Returns true, if winIDEA build manager is in idle state, and there were
        errors in the last build.

        See also: #getNumErrors
        See also: #getNumWarnings
        """
        return _connect.CBuildStatus_isIdleWError(self)

    def isConfigError(self):
        r"""Returns true, if winIDEA build manager is not properly configured."""
        return _connect.CBuildStatus_isConfigError(self)

    def isActive(self):
        r"""Returns true, if winIDEA build manager is building."""
        return _connect.CBuildStatus_isActive(self)

    def getNumErrors(self):
        r"""Not implemented yet - will return the number of errors in the last build."""
        return _connect.CBuildStatus_getNumErrors(self)

    def getNumWarnings(self):
        r"""Not implemented yet - will return the number of warnings in the last build."""
        return _connect.CBuildStatus_getNumWarnings(self)
    __swig_destroy__ = _connect.delete_CBuildStatus

# Register CBuildStatus in _connect:
_connect.CBuildStatus_swigregister(CBuildStatus)
class CBuildOptions(object):
    r"""
    This class provides access to build manager options. Do not instantiate
    this class directly, but use CProjectController::options() instead.

    File is defined either by `>proj>file` or by `>proj>groups...>file`

    Available options:

      |  Scope                        | Option            |
      |-------------------------------|-------------------|
      |  >proj>                 |  OutputFile       |
      |  >proj>                 |  ExternalMakePath |
      |  >proj>:Compile         |  ExtInput         |
      |  >proj>:Compile         |  ExtOutput
      |  >proj>:Assemble        |  ExtInput
      |  >proj>:Assemble        |  ExtOutput
      |  >proj>:Link            |  ExtInput
      |  >proj>:Compile         |  ExtInclude
      |  >proj>:Link            |  RunAfterPath
      |  >proj>:Link            |  RunAfterParam
      |  >proj>                 |  ToolsetDir
      |  >proj>:Compile         |  Path
      |  >proj>:Assemble        |  Path
      |  >proj>:Link            |  Path
      |  >proj>:Assemble        |  RunAfterPath
      |  >proj>:Assemble        |  RunAfterParam
      |  >proj>:Compile         |  RunAfterPath
      |  >proj>:Compile         |  RunAfterParam
      |  >proj>                 |  RootDir
      |  >proj>                 |  ExternalMakeParam
      |  >proj>:Assemble        |  ExtAdditional
      |  >proj>:Compile         |  ExtAdditional
      |  >proj>:Link            |  ExtAdditional
      |  >proj>:Link            |  PathSeparator
      |  >proj>:Assemble        |  ExtInclude
      |  >proj>:Make            |  RunBeforePath
      |  >proj>:Make            |  RunBeforeParam
      |  >proj>:Compile         |  DefinesPrefix
      |  >proj>:Compile         |  DefinesPostfix
      |                          ||
      |  >proj>                 |  ExternalMakeOn
      |  >proj>                 |  RunWithRelativePaths
      |  >proj>                 |  CopyToTargetDir
      |                          ||
      |  >proj>                 |  ChangeWorkingDir
      |  >proj>                 |  DisplayParam
      |  >proj>:Compile         |  CaptureOutput
      |  >proj>:Assemble        |  CaptureOutput
      |  >proj>:Link            |  CaptureOutput
      |  >proj>:Compile         |  UseCMD
      |  >proj>:Assemble        |  UseCMD
      |  >proj>:Link            |  UseCMD
      |  >proj>                 |  ShowTool
      |                               |  BeepWhenDone
      |  >proj>                 |  WarnIncludeNotFound
      |                          ||
      |  >proj>::target         |  OutputDir
      |  >proj>file             |  ExcludeFromMake
      |                          ||
      |  >proj>:Link:target     |  CmdLine
      |  >proj>:Link:target     |  IndirectionPath
      |  >proj>:Make:target     |  CmdLine
      |  >proj>:Build:target    |  CmdLine
      |  >proj>:Link:target     |  CRLF
      |  >proj>:Link:target     |  TranslateChar
      |                          ||
      |  >proj>:Compile:target  |  RunAssembler
      |  >proj>:Compile:target  |  CmdLine
      |  >proj>`file`:Compile:target |  CmdLine
      |  >proj>:Assemble:target    |  CmdLine
      |  >proj>`file`:Assemble:target|   CmdLine
      |  >proj>:Compile:target     |  Defines
      |  >proj>`file`:Compile:target |  Defines
      |                          ||
      |  >proj>:Make            |  Mode
      |  >proj>:Make            |  Path
      |                          ||
      |  >proj>:Build           |  Mode
      |  >proj>:Build           |  Path
      |                          ||
      |  >proj>                 |  Environment
      |                          ||
      |  >proj>:Assemble        |  DepScan
      |  >proj>:Assemble        |  DepReqBlanksFront
      |  >proj>:Assemble        |  DepAllowBlanksFront
      |  >proj>:Assemble        |  DepKeyword
      |  >proj>:Assemble        |  DepStartPath
      |  >proj>:Assemble        |  DepEndPath
      |                          ||
      |  >proj>                 |  IncludePath       // ofaEnum
      |  >proj>                 |  IncludePath>path  // ofaAdd, ofaRmv,
      |  >proj>                 |  IncludePath>path   0/1  // ofaSet, ofaGet subdir
      |                          ||
      |  >proj>                 |  Name
      |  >proj>                 |  Target         // ofaEnum
      |  >proj>::target         |  Target         // ofaRmv, ofaAdd (the value defines the target from which to copy settings)
      |  >proj>::target         |  Target         // ofaSet, ofaGet
      |  >proj>                 |  Group          // ofaEnum
      |  >proj>group>        |  Group          // ofaRmv, ofaAdd
      |  >proj>                 |  Filter
      |                          ||
      |  set to TRUE if the below is not empty||
      |  >proj>:Compile         |  CustomFilter
      |                          ||
      |  >proj>:Assemble        |  CustomFilter
      |                          ||
      |  >proj>:Link            |  CustomFilter
      |                          ||
      |  >proj>                 |  CustomFilter
      |                          ||
      |  >proj>::target         |  Name
      |                          ||
      |  >proj>group>        |  Name
      |  >proj>group>        |  File           // enum only

    See also: CProjectController
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get(self, *args):
        r"""
        *Overload 1:*

        Returns option at the given index.

        See class description for available scope and options.

        :raises: IllegalStateException if index is out of range.
        :raises: IOException if any other error occurred

        |

        *Overload 2:*

        Returns the requested option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_get(self, *args)

    def set(self, scope, option, value):
        r"""
        Sets the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_set(self, scope, option, value)

    def add(self, scope, option, value):
        r"""
        Adds the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_add(self, scope, option, value)

    def remove(self, scope, option):
        r"""
        Removes the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_remove(self, scope, option)

    def move(self, scope, option, value):
        r"""
        Moves the build manager option.

        See class description for available scope and options.

        :raises: IOException if error occurred
        """
        return _connect.CBuildOptions_move(self, scope, option, value)
    __swig_destroy__ = _connect.delete_CBuildOptions

# Register CBuildOptions in _connect:
_connect.CBuildOptions_swigregister(CBuildOptions)
class CProjectController(object):
    r"""
    This class provides access to winIDEA project manager. Do not use it to build
    projects with CMake. For this use case run CMake directly from Python or other
    SDK language.

    Python example: _sample_link{proj_ctrl,test_proj_get_status}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
         Constructs the object.

        Python example: _sample_link{proj_ctrl,test_proj_get_status}
        """
        _connect.CProjectController_swiginit(self, _connect.new_CProjectController(connectionMgr))
    __swig_destroy__ = _connect.delete_CProjectController

    def getIConnectProject(self):
        r"""
        Returns the **isystem.connect** Project interface. Use this method only when
        some functionality of the IConnectProject interface regarding project handling
        is not accessible from this wrapper.
        """
        return _connect.CProjectController_getIConnectProject(self)

    def compile(self, fileName):
        r"""
        Compiles the specified file with winIDEA build manager. If you are using CMake
        for build, run CMake directly, do not use this class.

        :type fileName: string
        :param fileName: the file to compile. The file must be included in the active project.
            Python example: _sample_link{proj_ctrl,test_build_actions}
        """
        return _connect.CProjectController_compile(self, fileName)

    def link(self, suppressPostLinkActions=False):
        r"""
        Links the active project with winIDEA build manager. If you are using CMake
        for build, run CMake directly, do not use this class.

        :type suppressPostLinkActions: boolean, optional
        :param suppressPostLinkActions: if true, automatic post-link actions are not performed
            Python example: _sample_link{proj_ctrl,test_build_actions}
        """
        return _connect.CProjectController_link(self, suppressPostLinkActions)

    def make(self, suppressPostLinkActions=False):
        r"""
        Makes the active project with winIDEA build manager. If you are using CMake
        for build, run CMake directly, do not use this class.

        :type suppressPostLinkActions: boolean, optional
        :param suppressPostLinkActions: if true, automatic post-link actions are not performed
            Python example: _sample_link{proj_ctrl,test_build_actions}
        """
        return _connect.CProjectController_make(self, suppressPostLinkActions)

    def build(self, suppressPostLinkActions=False):
        r"""
        Builds the active project with winIDEA build manager. If you are using CMake
        for build, run CMake directly, do not use this class.

        :type suppressPostLinkActions: boolean, optional
        :param suppressPostLinkActions: if true, automatic post-link actions are not performed

        Python example: _sample_link{proj_ctrl,test_build_actions}
        """
        return _connect.CProjectController_build(self, suppressPostLinkActions)

    def isUpToDate(self):
        r"""
         Returns ``true`` if project is up to date, or ``false`` if sources are newer than
        executable.

        Python example: _sample_link{proj_ctrl,test_build_actions}
        """
        return _connect.CProjectController_isUpToDate(self)

    def setTarget(self, makeTargetName):
        r"""
        Sets make target for winIDEA build manager. If you are using CMake
        for build, run CMake directly, do not use this class.

        See also winIDEA menu option ``Project`` | ``Targets``.
        Python example: _sample_link{proj_ctrl,test_set_target}
        """
        return _connect.CProjectController_setTarget(self, makeTargetName)

    def importProject(self, xmlFileName):
        return _connect.CProjectController_importProject(self, xmlFileName)

    def exportProject(self, xmlFileName):
        return _connect.CProjectController_exportProject(self, xmlFileName)

    def dependencies(self):
        r"""
        Updates dependencies.
        Python example: _sample_link{proj_ctrl,test_dependencies}
        """
        return _connect.CProjectController_dependencies(self)

    def stop(self):
        r"""
        Stops the current operation of winIDEA build manager.

        Python example: _sample_link{proj_ctrl,test_build_actions}
        """
        return _connect.CProjectController_stop(self)

    def customOperation(self, operation, parameters):
        r"""
        Runs custom operation.

        :type operation: string
        :param operation: operation to run
        :type parameters: string
        :param parameters: parameters of the operation

        Python example: _sample_link{proj_ctrl,test_custom_operation}
        """
        return _connect.CProjectController_customOperation(self, operation, parameters)

    def getStatus(self):
        r"""
        Returns the object with information about the current build manager
        status.

        Python example: _sample_link{proj_ctrl,test_proj_get_status}
        """
        return _connect.CProjectController_getStatus(self)

    def options(self):
        r"""
         Returns reference to build options associated with this build manager.
        Use this reference to get/set build options.
        """
        return _connect.CProjectController_options(self)

    def enumerateProjectOption(self, scope, option, index, isReturnRelativePath):
        r"""
        This method can enumerate build targets, groups, and files in project.

        :type scope: string
        :param scope: scope should be of format: ">project>group>file name|translator|target"
                         If project or target are blank, the current project/active target is assumed.
                         Examples:


            |Scope Format    |  Option     |Returns|
            ----------------------------------------
            |">"             | "Group"     |project group|
            |">"             | "File"      |project file|


        :type option: string
        :param option: name of the option to get
        :type index: int
        :param index: index of item to retrieve. When end of list is reached, empty string is returned.
        :type isReturnRelativePath: boolean
        :param isReturnRelativePath: if true, relative paths are returned

        See also: CBuildOptions for list of scopes and options.

        Python example: _sample_link{proj_ctrl,test_options}
        """
        return _connect.CProjectController_enumerateProjectOption(self, scope, option, index, isReturnRelativePath)

    def modifyProjectOption(self, cmd, cmdFlags, scope, option, value):
        r"""
        This is a general method for configuration of project manager in winIDEA.

        :type cmd: int
        :param cmd: command. If you need command *ofaEnum*, use more convenient method
                       enumerateProjectOption().
        :type cmdFlags: int
        :param cmdFlags: this parameter may contain the second part of cmd, for example *ofaRelativePaths*,
                            or-ed with index when needed
        :type scope: string
        :param scope: scope should be of format: ">project>group>file name|translator|target"
                         If project or target are blank, the current project/active target is assumed.
                         Examples:


            |Scope Format              |Location |Scope example               |  Option          | Value|
            ---------------------------------------------------------------------------------------------
            |""                        |Global   |""                          | "BeepWhenDone"   |"1"|
            |">project>"               |Project  |">Files>"                   | "ToolsetDir"     | "$(EXEDIR)\gcc"|
            |">project>group>"         |Group    |">Files>Source Files>"      | "Name"           | "Sources"|
            |">project>group>file name"|File     |">Files>Source Files>main.c"| "ExcludeFromMake"| "0"|
            |">project>file path"      |File     |">Files>c:\test\main.c"     | "ExcludeFromMake"| "0"|


        :type option: string
        :param option: name of the option to get or set.
        :type value: string
        :param value: new option value when set or add is used. Should be empty string on get.

        See also: CBuildOptions for list of scopes and options.

        Python example: _sample_link{proj_ctrl,test_modify_project_option}
        """
        return _connect.CProjectController_modifyProjectOption(self, cmd, cmdFlags, scope, option, value)

    def getWarningMessage(self):
        r"""
        Returns warning message for methods in this class, which have returned
        warning error code, for example when importProject() or exportProject()
        return -1.

        Python example: _sample_link{proj_ctrl,test_export_import_project}
        """
        return _connect.CProjectController_getWarningMessage(self)

# Register CProjectController in _connect:
_connect.CProjectController_swigregister(CProjectController)
EXPORT_TrcAsText = _connect.EXPORT_TrcAsText
EXPORT_TrcAsCSV = _connect.EXPORT_TrcAsCSV
EXPORT_TrcAsXML = _connect.EXPORT_TrcAsXML
EXPORT_TrcAsBinary = _connect.EXPORT_TrcAsBinary
EXPORT_ProfilerAsText = _connect.EXPORT_ProfilerAsText
EXPORT_ProfilerAsCSV = _connect.EXPORT_ProfilerAsCSV
EXPORT_ProfilerAsXML = _connect.EXPORT_ProfilerAsXML
EXPORT_ProfilerAsBinary = _connect.EXPORT_ProfilerAsBinary
EXPORT_ProfilerAsText1 = _connect.EXPORT_ProfilerAsText1
EXPORT_ProfilerAsXMLBinaryTimeline = _connect.EXPORT_ProfilerAsXMLBinaryTimeline
EXPORT_ProfilerAsBTF = _connect.EXPORT_ProfilerAsBTF
EXPORT_ProfilerAsMDF = _connect.EXPORT_ProfilerAsMDF
EXPORT_ProfilerAsHTML = _connect.EXPORT_ProfilerAsHTML
EXPORT_CCAsHTML = _connect.EXPORT_CCAsHTML
EXPORT_CCAsText = _connect.EXPORT_CCAsText
EXPORT_CCAsCSV = _connect.EXPORT_CCAsCSV
EXPORT_CCAsXML = _connect.EXPORT_CCAsXML
EXPORT_CCAsReviewHTML = _connect.EXPORT_CCAsReviewHTML
EXPORT_CCAsReviewText = _connect.EXPORT_CCAsReviewText
EXPORT_CCAsXML2 = _connect.EXPORT_CCAsXML2
EXPORT_CCAsGCOV = _connect.EXPORT_CCAsGCOV
class CAnalyzerStatus(object):
    r"""
    Deprecated: Call getAnalyzerStatus() or getDocumentStatus() to obtain
                CAnalyzerSessionStatus() or CDocumentSattus() instead.

    This class contains analyzer status. It should not be instantiated by
    clients. Call CAnalyzerDocController::getStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hResult):
        _connect.CAnalyzerStatus_swiginit(self, _connect.new_CAnalyzerStatus(hResult))

    def isErrorInBuffer(self):
        return _connect.CAnalyzerStatus_isErrorInBuffer(self)

    def isBufferOverrun(self):
        return _connect.CAnalyzerStatus_isBufferOverrun(self)

    def isRecordingError(self):
        return _connect.CAnalyzerStatus_isRecordingError(self)

    def isError(self):
        return _connect.CAnalyzerStatus_isError(self)

    def isLoading(self):
        return _connect.CAnalyzerStatus_isLoading(self)

    def isWaiting(self):
        return _connect.CAnalyzerStatus_isWaiting(self)

    def isOpening(self):
        return _connect.CAnalyzerStatus_isOpening(self)

    def isDocumentEmpty(self):
        return _connect.CAnalyzerStatus_isDocumentEmpty(self)

    def isActive(self):
        return _connect.CAnalyzerStatus_isActive(self)

    def isBusy(self):
        return _connect.CAnalyzerStatus_isBusy(self)

    def getReturnCode(self):
        return _connect.CAnalyzerStatus_getReturnCode(self)

    def toString(self):
        return _connect.CAnalyzerStatus_toString(self)
    __swig_destroy__ = _connect.delete_CAnalyzerStatus

# Register CAnalyzerStatus in _connect:
_connect.CAnalyzerStatus_swigregister(CAnalyzerStatus)
class CAnalyzerSessionStatus(object):
    r"""
    This class contains analyzer status. It should not be instantiated by
    clients. Call CAnalyzerDocController::getAnalyzerStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hResult):
        r"""
        This object should not be instantiated by clients - call method
        getStatus() to get the current analyzer status.
        """
        _connect.CAnalyzerSessionStatus_swiginit(self, _connect.new_CAnalyzerSessionStatus(hResult))

    def isRecorderIdle(self):
        r"""Returns true, if analyzer is idle."""
        return _connect.CAnalyzerSessionStatus_isRecorderIdle(self)

    def isRecorderWaiting(self):
        r"""Returns true, if analyzer is waiting for the trigger to occur."""
        return _connect.CAnalyzerSessionStatus_isRecorderWaiting(self)

    def isRecorderSampling(self):
        r"""Returns true, if analyzer is sampling data."""
        return _connect.CAnalyzerSessionStatus_isRecorderSampling(self)

    def isUploading(self):
        r"""Returns true, if analyzer is loading data from debugger to PC."""
        return _connect.CAnalyzerSessionStatus_isUploading(self)

    def isAnalyzing(self):
        r"""Returns true, if analyzer is analyzing recorded data."""
        return _connect.CAnalyzerSessionStatus_isAnalyzing(self)

    def isErrorInTraceStream(self):
        r"""
        Returns true, if error in trace stream was detected.
        Possible sources are: OCT bottleneck, stream decoder error.
        """
        return _connect.CAnalyzerSessionStatus_isErrorInTraceStream(self)

    def isBufferOverrun(self):
        r"""Returns true, if session was terminated automatically when buffer was full."""
        return _connect.CAnalyzerSessionStatus_isBufferOverrun(self)

    def isError(self):
        r"""Returns true if any of the above errors occurs."""
        return _connect.CAnalyzerSessionStatus_isError(self)

    def toString(self):
        r"""Returns object data as YAML string."""
        return _connect.CAnalyzerSessionStatus_toString(self)
    __swig_destroy__ = _connect.delete_CAnalyzerSessionStatus

# Register CAnalyzerSessionStatus in _connect:
_connect.CAnalyzerSessionStatus_swigregister(CAnalyzerSessionStatus)
class CDocumentStatus(object):
    r"""
    This class contains document status. It should not be instantiated by
    clients. Call CAnalyzerDocController::getDocumentStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, hResult):
        r"""
        This object should not be instantiated by clients - call method
        getDocumentStatus() to get the current analyzer status.
        """
        _connect.CDocumentStatus_swiginit(self, _connect.new_CDocumentStatus(hResult))

    def isSerializing(self):
        r"""
        Returns true, if analyzer document is in file opening or saving phase. For large
        .trd files the process of reading/writing the file can take
        some time.
        """
        return _connect.CDocumentStatus_isSerializing(self)

    def isEmpty(self):
        r"""Returns true, if analyzer document is empty (nothing was recorded)."""
        return _connect.CDocumentStatus_isEmpty(self)

    def isDirty(self):
        r"""Returns true, if analyzer document is dirty (changed but not saved)."""
        return _connect.CDocumentStatus_isDirty(self)

    def isCanStart(self):
        r"""Returns true, if document action start is available."""
        return _connect.CDocumentStatus_isCanStart(self)

    def toString(self):
        r"""
        Returns object data as string. This should be used for logging or debugging
        purposes only as format may change in future versions.
        """
        return _connect.CDocumentStatus_toString(self)
    __swig_destroy__ = _connect.delete_CDocumentStatus

# Register CDocumentStatus in _connect:
_connect.CDocumentStatus_swigregister(CDocumentStatus)
class CDocumentController(object):
    r"""
    This class can be used to handle documents in winIDEA.


    Python example: _sample_link{document_ctrl,test_doc_close}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, fileName, mode):
        r"""
        Creates a new document or opens an existing one.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes contents,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.
        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_close}
        """
        _connect.CDocumentController_swiginit(self, _connect.new_CDocumentController(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CDocumentController

    def getIConnectIDE(self):
        r"""
        Returns the **isystem.connect** IDE interface. Use this method only when
        some functionality of the IConnectIDE interface regarding workspace handling
        is not accessible from this wrapper.
        """
        return _connect.CDocumentController_getIConnectIDE(self)

    def start(self):
        r"""
        Starts default document action. Starts recording if
        the document type is coverage, profiler or trace, or executes the script
        if it is a script document. Existing contents of analyzer document is always
        deleted when this method is called. It is possible to preserve existing
        coverage information by calling method resume(), instead of this method.

        Note: If analyzer is started, then option 'Reactivate session after CPU stop'
              has no effect. Analyzer will *not* be automatically started.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_control}
        """
        return _connect.CDocumentController_start(self)

    def start1(self):
        r"""
        Starts alternate document action. Repeats analysis on a previously recorded data
        if the document type is analyzer. Usage example: if document is recorded as
        trace (trace trigger is used), but we want to perform profiler analysis later
        (with profiler trigger).

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_control}
        """
        return _connect.CDocumentController_start1(self)

    def stop(self):
        r"""
        Stops document action. For analyzer documents this action is deprecated. Use one of
        stop...() methods of CAnalyzerController instead.


        This method triggers the following state transitions on analyzer document:
        - **waiting for trigger:** forces trigger, sampling starts
        - **sampling:** stops sampling, enters loading state and waits until loading is finished
        - **loading (data from debugger to PC):** waits until loading finishes, does NOT stop it!
        - **analyzing:** stops analysis. If coverage and profiler analysis are running, call this
                     method twice to stop both.
        - **idle:** does nothing

        For script document this method terminates the script.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_control}
        """
        return _connect.CDocumentController_stop(self)

    def resume(self):
        r"""
        Starts recording but keeps existing coverage data.
        Works on coverage analyzer documents only.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_control}
        """
        return _connect.CDocumentController_resume(self)

    def close(self):
        r"""
        Closes the document. If the document is changed but not saved, winIDEA
        prompts user if he would like to save the file.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_close}
        """
        return _connect.CDocumentController_close(self)

    def closeDiscard(self):
        r"""
        Closes the document and discards any unsaved changes.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_close}
        """
        return _connect.CDocumentController_closeDiscard(self)

    def closeAll(self):
        r"""
        Closes all documents. If there are no documents opened via *isystem.connect*,
        CIDEController::closeAllDocuments() can also be used.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_doc_close}
        """
        return _connect.CDocumentController_closeAll(self)

    def reset(self, resetScope):
        r"""
        Resets contents of the document.

        :type resetScope: int
        :param resetScope: defines which part of the document to reset.

        Python example: _sample_link{document_ctrl,test_reset}
        """
        return _connect.CDocumentController_reset(self, resetScope)

    def save(self):
        r"""
         Saves the document.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_save}
        """
        return _connect.CDocumentController_save(self)

    def saveAs(self, fileName, isForceOverwrite=False):
        r"""
        Saves the document with a new name.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_save}
        """
        return _connect.CDocumentController_saveAs(self, fileName, isForceOverwrite)

    def saveCopy(self, newFileName):
        r"""
        Saves copy of the document under a given file name. The name of the
        opened document does not change. If the destination file already exists,
        it is overwritten. Use this method to save intermediate results, for
        example coverage between several runs.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_save}
        """
        return _connect.CDocumentController_saveCopy(self, newFileName)

    def saveAsPrompt(self):
        r"""
         Saves the document, winIDEA prompts the user for a new name.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_save}
        """
        return _connect.CDocumentController_saveAsPrompt(self)

    def setMarker(self, lineNumber):
        r"""
         Sets marker at the given line - implemented only for text documents.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_marker}
        """
        return _connect.CDocumentController_setMarker(self, lineNumber)

    def clearMarker(self):
        r"""
         Clears the existing marker - implemented only for text documents.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_marker}
        """
        return _connect.CDocumentController_clearMarker(self)

    def setFocus(self, lineNumber):
        r"""
        Sets focus to the view containing the document.

        :type lineNumber: int
        :param lineNumber: line number in text document to be displayed.

        :raises: IOException in case of an error.

        Python example: _sample_link{document_ctrl,test_focus}
        """
        return _connect.CDocumentController_setFocus(self, lineNumber)

# Register CDocumentController in _connect:
_connect.CDocumentController_swigregister(CDocumentController)
class CAnalyzerDocController(CDocumentController):
    r"""
    This class is a base class for analyzer documents (trace, coverage and profiler).
    Clients should not instantiate this class directly, but should use one of
    derived classes instead (CTraceController, CCoverageController2, or
    CProfilerController2).



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ANALYZER = _connect.CAnalyzerDocController_ANALYZER
    r"""trace document"""
    CODE_COVERAGE = _connect.CAnalyzerDocController_CODE_COVERAGE
    r"""
    code coverage document. For internal use only,
    instantiate class CCoverageController instead.
    """
    PROFILER = _connect.CAnalyzerDocController_PROFILER
    r"""
    profiler document. For internal use only,
    instantiate class CProfilerController2 instead.
    """
    ETraceOnly = _connect.CAnalyzerDocController_ETraceOnly
    r"""trace is recorded, but no profiler or coverage analysis is performed"""
    ECoverage = _connect.CAnalyzerDocController_ECoverage
    r"""coverage only"""
    EProfiler = _connect.CAnalyzerDocController_EProfiler
    r"""profiler only"""
    EBoth = _connect.CAnalyzerDocController_EBoth
    r"""profiler and coverage"""

    def __init__(self, connectionMgr, type, fileName, mode, createObjectOnly=False):
        r"""
        Creates a new document or opens an existing one. If existing document
        is opened for writing, (mode = 'w'), then document contents is
        erased, but other data, for example triggers, is not cleared.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type type: int
        :param type: defines the type of document to open. Usage of
                   CODE_COVERAGE for this parameter is deprecated. Instantiate class
                   CCodeCoverage instead.

        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA. It is highly recommended to use
                   extension ``*.trd`` for trace documents and ``*.ccv`` for
                   coverage documents.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes recordings,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :type createObjectOnly: boolean, optional
        :param createObjectOnly: bool

        :raises: IOException in case of an error.
        """
        _connect.CAnalyzerDocController_swiginit(self, _connect.new_CAnalyzerDocController(connectionMgr, type, fileName, mode, createObjectOnly))
    __swig_destroy__ = _connect.delete_CAnalyzerDocController

    def isActive(self):
        r"""
        Returns ``true`` if the document start action is still running,
        ``false`` otherwise. When recording stops, this method returns false,
        even if loading and analysis of data is still in progress.

        See also: isBusy
        :raises: IOException in case of an error.

        Python example: _sample_link{coverage_ctrl,test_coverage_get_status}
        """
        return _connect.CAnalyzerDocController_isActive(self)

    def isBusy(self):
        r"""
        Returns ``true`` if the document is still changing, either because
        recording or loading/analysis is still running. Returns
        ``false`` otherwise.

        See also: isActive
        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_isBusy(self)

    def setDirty(self, isDirty):
        r"""
        Sets dirty status of the document. Normally this method is used when
        dirty flag is not set after configuring the document via API, but we
        want to save the document.
        """
        return _connect.CAnalyzerDocController_setDirty(self, isDirty)

    def abort(self):
        r"""
        Aborts loading of document contents from a file. Use this method only
        when opening a really large documents and contents is not needed,
        otherwise call waitUntilLoaded() and wait until document contents is
        loaded. Has no effect when analyzer is running.
        """
        return _connect.CAnalyzerDocController_abort(self)

    def stopSampling(self):
        r"""
        Stops sampling (recording) operation. After this action
        loading of data starts. Does nothing if sampling has already finished.

        :raises: IOException in case of an error.

        Python example: _sample_link{coverage_ctrl,test_coverage_all_code}
        """
        return _connect.CAnalyzerDocController_stopSampling(self)

    def stopUploading(self):
        r"""
        Stops transfer of data to PC. Continues with analysis of data already transferred
        to PC. To completely stop analyzer, call stopAnalyzing() after this call.
        """
        return _connect.CAnalyzerDocController_stopUploading(self)

    def stopAnalyzing(self):
        r"""
        Stops analysis of analyzer data. To unconditionally stop analyzer immediately, call
        stopUploading() before this call.
        """
        return _connect.CAnalyzerDocController_stopAnalyzing(self)

    def stopLoadingOrSaving(self):
        r"""Stops load or save operation."""
        return _connect.CAnalyzerDocController_stopLoadingOrSaving(self)

    def getStatus(self):
        r"""
        Deprecated: Call getAnalyzerSessionStatus() or getDocumentStatus() instead.

        Returns analyzer status. Use this method to check for
        analyzer status and recording errors.
        """
        return _connect.CAnalyzerDocController_getStatus(self)

    def getAnalyzerSessionStatus(self):
        r"""
        Returns analyzer session status. Use this method to check for
        analyzer status and recording errors.
        """
        return _connect.CAnalyzerDocController_getAnalyzerSessionStatus(self)

    def getDocumentStatus(self):
        r"""Returns analyzer document status."""
        return _connect.CAnalyzerDocController_getDocumentStatus(self)

    def getActiveTriggerIndex(self):
        r"""
        Returns index of the currently active trigger. If you want to get
        the active trigger name, call method:


        triggerName = getTriggerOption(index, "Name").


        See also: getTriggerOption
        """
        return _connect.CAnalyzerDocController_getActiveTriggerIndex(self)

    def createTrigger(self, triggerName):
        r"""
        Creates trigger with the given name. Call method setAnalysisType() to
        define analysis type.
        """
        return _connect.CAnalyzerDocController_createTrigger(self, triggerName)

    def setAnalysisType(self, triggerIndex, analysisType):
        r"""
        This method sets analysis type on the given trigger. If trigger is
        created with CProfilerController2, it is set to profiler only analysis
        by default. Similar is true for coverage. To perform both types of analysis
        on the same recording, call this method with analysisType set to
        EBoth.
        """
        return _connect.CAnalyzerDocController_setAnalysisType(self, triggerIndex, analysisType)

    def removeTrigger(self, triggerName):
        r"""
        Removes profiler or trace trigger.

        :type triggerName: string
        :param triggerName: name of the trigger to remove

        :rtype: int
        :return: -1 if trigger with the given name did not exist, otherwise non-negative
                    value is returned

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CAnalyzerDocController_removeTrigger(self, triggerName)

    def getTriggerIndex(self, triggerName, isThrowException=True):
        r"""
        Returns the index of the trigger with the given name.

        :type triggerName: string
        :param triggerName: name of analyzer trigger as specified in
                               'Analyzer Configuration' toolbar drop down list
                               in ``winIDEA`` analyzer window (the one with a
                               settings icon). It is also accessible
                               as winIDEA option path
                               ``/Document/<fileName>/Trigger.Items[<index>].Name``.
                               where ``<index>`` is the value returned by
                               this method.

        :type isThrowException: boolean, optional
        :param isThrowException: if trigger with the given name is not found, and:
                                    - this parameter is set to ``true``, then an
                                      ``IllegalArgumentException`` is thrown.
                                    - this parameter is set to ``false``, then -1 is
                                      returned.

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CAnalyzerDocController_getTriggerIndex(self, triggerName, isThrowException)

    def select(self, *args):
        r"""
        *Overload 1:*

        Selects trigger from 'Analyzer Configuration'
        toolbar drop down list in ``winIDEA`` (the one with a
        hammer and text)

        :type triggerName: string
        :param triggerName: name of the trigger in the list

        Python example: _sample_link{profiler_controller}

        |

        *Overload 2:*

        Selects trigger from 'Analyzer Configuration'
        toolbar drop down list in ``winIDEA`` (the one with a
        hammer and text)

        :type index: int
        :param index: index of the trigger in the list
        See also: getTriggerIndex

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CAnalyzerDocController_select(self, *args)

    def waitUntilLoaded(self, timeoutMs=0, pollingIntervalMs=100, isThrow=False):
        r"""
        This method polls analyzer status with the given polling interval and
        returns when analyzer stops loading samples from the hardware, or
        timeout expires.

        :type timeoutMs: int, optional
        :param timeoutMs: timeout in milliseconds. 0 means infinite timeout
        :type pollingIntervalMs: int, optional
        :param pollingIntervalMs: time in milliseconds between two readings of the analyzer status
        :type isThrow: boolean, optional
        :param isThrow: if true and timeout occurs, an exception is thrown
        :rtype: boolean
        :return: true if CPU is in stopped state, false if timeout expired and isThrow == false

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CAnalyzerDocController_waitUntilLoaded(self, timeoutMs, pollingIntervalMs, isThrow)

    def getNumberOfTriggers(self):
        r"""
        Returns the number of triggers defined in the opened document.

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CAnalyzerDocController_getNumberOfTriggers(self)

    def getDocumentOptionURL(self, postfix):
        r"""
        This utility method returns path of analyzer document option.
        The returned path is composed as
        ``'/Document/' + fileName + '/' + postfix``. Use this method
        when you have to set some option, which is not accessible with methods of
        this class or derived classes.

        Python example: _sample_link{profiler_ctrl_2,test_set_profiling_sections}
        """
        return _connect.CAnalyzerDocController_getDocumentOptionURL(self, postfix)

    def getTriggerOption(self, index, triggerOption):
        r"""
        Returns value of trigger option, for example
        trigger name, buffer size, trigger position, ...

        :type triggerOption: string
        :param triggerOption: part of the winIDEA option path, which is following the
                                 ``Items[]`` part. For example, name of the trigger
                                 at index 0
                                 for analyzer file ``Sample5554_profiler.trd`` is specified
                                 with winIDEA option path
                                 ``/Document/Sample5554_profiler.trd/Trigger.Items[0].Name``.
                                 To get it by this method, we define ``index`` as 0 and
                                 ``triggerOption`` as 'Name'.

                                 Another example - to get sampling starting point, we
                                 call this method as: ``getTriggerOption(0, "HW.Recorder.Start");``

        :type index: int
        :param index: trigger index, see methods getTriggerIndex() and getNumberOfTriggers()

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CAnalyzerDocController_getTriggerOption(self, index, triggerOption)

    def setTriggerOption(self, *args):
        r"""
        *Overload 1:*

        Sets value of the trigger option, for example trigger name, buffer size,
        trigger position, ...

        :type index: int
        :param index: trigger index, see methods getTriggerIndex() and getNumberOfTriggers()

        :type triggerOption: string
        :param triggerOption: part of the winIDEA option path, which is following the
                                 ``Items[]`` part. For example, the **name**
                                 of the trigger at index 0
                                 for analyzer file ``Sample5554_profiler.trd`` is specified
                                 with winIDEA option path:



                                 ``/Document/Sample5554_profiler.trd/Trigger.Items[0].Name``



                                 To set the trigger name we call this method as:



                                 ``setTriggerOption(0, "Name", "myTrig"); ``



                                 Another example - to set sampling starting point, we
                                 call this method as:


        ``setTriggerOption(0, "HW.Recorder.Start", "Immediately");``

        :type newValue: string
        :param newValue: new value of the config. property, see the ``Options`` dialog in winIDEA
                            for the list of options and possible values of each option.

        Python example: _sample_link{profiler_controller}

        |

        *Overload 2:*

        Sets value of the trigger option, for example trigger name, buffer size,
        trigger position, ...

        :type triggerOption: string
        :param triggerOption: part of the winIDEA option path, which is following the
                                 ``Items[]`` part. For example, the **name**
                                 of the trigger at index 0
                                 for analyzer file ``Sample5554_profiler.trd`` is specified
                                 with winIDEA option path:



                                 ``/Document/Sample5554_profiler.trd/Trigger.Items[0].Name``.



                                 To set the trigger name we call this method as:



                                 ``setTriggerOption(0, "Name", "myTrig"); ``



                                 Another example - to set sampling starting point, we
                                 call this method as:


        ``setTriggerOption(0, "HW.Recorder.Start", "Immediately");``

        :type index: int
        :param index: trigger index, see methods getTriggerIndex() and getNumberOfTriggers()

        :type newValue: int
        :param newValue: new value of the config. property, see the ``Options`` dialog in winIDEA
                            for the list of options and possible values of each option.
        """
        return _connect.CAnalyzerDocController_setTriggerOption(self, *args)

    def setExportFormat(self, exportFormat):
        r"""
        Deprecated: use method exportData() in derived classes.

        Sets export format for trace and coverage documents.

        :type exportFormat: string
        :param exportFormat: name of the export format as written in combo box
            in the winIDEA's export dialog. Supported values are also available as
            static members of this class. See CAnalyzerDocController::exportCCAsHTML,
            CAnalyzerDocController::exportCCAsText, ...

        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_setExportFormat(self, exportFormat)

    def exportAs(self, *args):
        r"""
        *Overload 1:*

        Deprecated: use method exportData() in derived classes.

        Exports data to the given file and in the given format.

        :type scope: int
        :param scope: export all or selection only, see IConnectIDE::EDocumentExportParameter
        :type fileName: string
        :param fileName: name of the file to export the document to
        :type format: int
        :param format: index of the format in combo box in the winIDEA's export dialog. If
            it is set to 0xFFFFFFFF, the currently selected export format is used.
            See setExportFormat(). For analyzer documents the method
            ``CProfilerController2::exportData()`` should be used.

        :raises: IOException in case of an error.

        |

        *Overload 2:*

        Deprecated: use method exportData() in derived classes.

        Exports data to the given file and in the given format.

        :type scope: int
        :param scope: export all or selection only, see IConnectIDE::EDocumentExportParameter
        :type fileName: string
        :param fileName: name of the file to export the document to
        :type format: string
        :param format: name of the export format as written in combo box
            in the winIDEA's export dialog. Supported values are also available as
            static members of this class. See CAnalyzerDocController::exportCCAsHTML,
            CAnalyzerDocController::exportCCAsText, ...
            For analyzer documents the method ``CProfilerController2::exportData()``
            should be used.

        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_exportAs(self, *args)

    def exportAsAndLaunchViewer(self, scope, fileName, format):
        r"""
        Deprecated: use method exportData() in derived classes.

        Exports the document and launches the system default viewer for the specified
        document type, for example web browser for HTML documents.

        :type scope: int
        :param scope: export all or selection only, see IConnectIDE::EDocumentExportParameter
        :type fileName: string
        :param fileName: name of the file to export the document to
        :type format: int
        :param format: index of the format in combo box in the winIDEA's export dialog. If
            it is set to 0xFFFFFFFF, the currently selected export format is used.
            See setExportFormat(). For analyzer documents the method
            ``CProfilerController2::exportData()`` should be used.

        :raises: IOException in case of an error.
        """
        return _connect.CAnalyzerDocController_exportAsAndLaunchViewer(self, scope, fileName, format)

    def setMarker(self):
        r"""Not available for analyzer documents - does nothing."""
        return _connect.CAnalyzerDocController_setMarker(self)

# Register CAnalyzerDocController in _connect:
_connect.CAnalyzerDocController_swigregister(CAnalyzerDocController)
CAnalyzerDocController.exportCCAsHTML = _connect.cvar.CAnalyzerDocController_exportCCAsHTML
CAnalyzerDocController.exportCCAsText = _connect.cvar.CAnalyzerDocController_exportCCAsText
CAnalyzerDocController.exportCCAsCSV = _connect.cvar.CAnalyzerDocController_exportCCAsCSV
CAnalyzerDocController.exportCCAsXML = _connect.cvar.CAnalyzerDocController_exportCCAsXML
CAnalyzerDocController.exportCCAsXML2 = _connect.cvar.CAnalyzerDocController_exportCCAsXML2
CAnalyzerDocController.exportCCAsGCOV = _connect.cvar.CAnalyzerDocController_exportCCAsGCOV
CAnalyzerDocController.exportCCAsReviewHTML = _connect.cvar.CAnalyzerDocController_exportCCAsReviewHTML
CAnalyzerDocController.exportCCAsReviewText = _connect.cvar.CAnalyzerDocController_exportCCAsReviewText
CAnalyzerDocController.exportTrcAsText = _connect.cvar.CAnalyzerDocController_exportTrcAsText
CAnalyzerDocController.exportTrcAsCSV = _connect.cvar.CAnalyzerDocController_exportTrcAsCSV
CAnalyzerDocController.exportTrcAsBinary = _connect.cvar.CAnalyzerDocController_exportTrcAsBinary
CAnalyzerDocController.exportTrcAsXML = _connect.cvar.CAnalyzerDocController_exportTrcAsXML
CAnalyzerDocController.exportProfilerAsXML = _connect.cvar.CAnalyzerDocController_exportProfilerAsXML
CAnalyzerDocController.exportProfilerAsText1 = _connect.cvar.CAnalyzerDocController_exportProfilerAsText1
CAnalyzerDocController.exportProfilerAsBTF = _connect.cvar.CAnalyzerDocController_exportProfilerAsBTF
CAnalyzerDocController.exportProfilerAsMDF = _connect.cvar.CAnalyzerDocController_exportProfilerAsMDF
CAnalyzerDocController.exportProfilerAsHTML = _connect.cvar.CAnalyzerDocController_exportProfilerAsHTML

class CTerminalDocController(object):
    r"""This class handles terminal window as a document."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Opens a terminal window.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :raises: IOException in case of an error.
        """
        _connect.CTerminalDocController_swiginit(self, _connect.new_CTerminalDocController(connectionMgr))
    __swig_destroy__ = _connect.delete_CTerminalDocController

    def close(self):
        r"""
         Closes the terminal window.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_close(self)

    def start(self):
        r"""
        Starts communication in the terminal window.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_start(self)

    def stop(self):
        r"""
        Stops communication in the terminal window.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_stop(self)

    def saveAs(self, fileName):
        r"""
        Saves contents of the terminal window to file.

        :type fileName: string
        :param fileName: name of the destination file

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_saveAs(self, fileName)

    def reset(self):
        r"""
        Clears history buffer.

        :raises: IOException in case of an error.
        """
        return _connect.CTerminalDocController_reset(self)

# Register CTerminalDocController in _connect:
_connect.CTerminalDocController_swigregister(CTerminalDocController)
class CMPC5xxxController(object):
    r"""
    This class controls MPC5xxx specific features.

    Python example: _sample_link{mpc5xxx_tlb_read_write}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CMPC5xxxController_swiginit(self, _connect.new_CMPC5xxxController(connectionMgr))
    __swig_destroy__ = _connect.delete_CMPC5xxxController

    def getTLB(self, dwEntry):
        r"""
        Gets a TLB entry.

        :type dwEntry: int
        :param dwEntry: index of the entry to be read

        :rtype: :py:class:`STLBEntry`
        :return: TLB entry contents in MAS format
        """
        return _connect.CMPC5xxxController_getTLB(self, dwEntry)

    def setTLB(self, dwEntry, rTLBEntry):
        r"""
        Sets a TLB entry.

        :type dwEntry: int
        :param dwEntry: index of the entry to be read

        :type rTLBEntry: :py:class:`STLBEntry`
        :param rTLBEntry: TLB entry in MAS format
        """
        return _connect.CMPC5xxxController_setTLB(self, dwEntry, rTLBEntry)

# Register CMPC5xxxController in _connect:
_connect.CMPC5xxxController_swigregister(CMPC5xxxController)
class CCoverageFormatBase(object):
    r"""
    This is abstract base class for coverage export format containers.
    Clients should not instantiate this class directly, they should
    instantiate one of its derived classes.
    See inheritance diagram for list of available formats.

    See also: CCoverageExportConfig::setFormatter()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CCoverageFormatBase
    EFmtHTML = _connect.CCoverageFormatBase_EFmtHTML
    r"""export as HTML"""
    EFmtText = _connect.CCoverageFormatBase_EFmtText
    r"""export as text"""
    EFmtXML = _connect.CCoverageFormatBase_EFmtXML
    r"""
    export as XML. This format should be used
    if parsing data with CCoverageData2 is needed
    """
    EFmtCSV = _connect.CCoverageFormatBase_EFmtCSV
    r"""export as Comma Separated Values format"""
    EFmtGCOV = _connect.CCoverageFormatBase_EFmtGCOV
    r"""export in gcov (GNU coverage) format"""

    def __init__(self, exportFormat):
        _connect.CCoverageFormatBase_swiginit(self, _connect.new_CCoverageFormatBase(exportFormat))

    def getExportFormat(self):
        r"""Returns coverage export format."""
        return _connect.CCoverageFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self):
        r"""
        Returns string containing export format, which can be used for
        setting of option
        ``/Document/<file name>/Coverage.Export.Format``

        See also: getExportFormat()
        """
        return _connect.CCoverageFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide, docFileName):
        return _connect.CCoverageFormatBase_setOptions(self, ide, docFileName)

# Register CCoverageFormatBase in _connect:
_connect.CCoverageFormatBase_swigregister(CCoverageFormatBase)
class CCoverageHTMLExportFormat(CCoverageFormatBase):
    r"""This class configures format of HTML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CCoverageHTMLExportFormat_swiginit(self, _connect.new_CCoverageHTMLExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageHTMLExportFormat

# Register CCoverageHTMLExportFormat in _connect:
_connect.CCoverageHTMLExportFormat_swigregister(CCoverageHTMLExportFormat)
class CCoverageTextExportFormat(CCoverageFormatBase):
    r"""This class configures format of Text export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CCoverageTextExportFormat_swiginit(self, _connect.new_CCoverageTextExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageTextExportFormat

# Register CCoverageTextExportFormat in _connect:
_connect.CCoverageTextExportFormat_swigregister(CCoverageTextExportFormat)
class CCoverageCSVExportFormat(CCoverageFormatBase):
    r"""This class configures format of CSV export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CCoverageCSVExportFormat_swiginit(self, _connect.new_CCoverageCSVExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageCSVExportFormat

# Register CCoverageCSVExportFormat in _connect:
_connect.CCoverageCSVExportFormat_swigregister(CCoverageCSVExportFormat)
class CCoverageXMLExportFormat(CCoverageFormatBase):
    r"""This class configures format of XML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CCoverageXMLExportFormat_swiginit(self, _connect.new_CCoverageXMLExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageXMLExportFormat

# Register CCoverageXMLExportFormat in _connect:
_connect.CCoverageXMLExportFormat_swigregister(CCoverageXMLExportFormat)
class CCoverageGCOVExportFormat(CCoverageFormatBase):
    r"""This class configures format of GNU Coverage export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CCoverageGCOVExportFormat_swiginit(self, _connect.new_CCoverageGCOVExportFormat())
    __swig_destroy__ = _connect.delete_CCoverageGCOVExportFormat

# Register CCoverageGCOVExportFormat in _connect:
_connect.CCoverageGCOVExportFormat_swigregister(CCoverageGCOVExportFormat)
class CCoverageExportConfig(object):
    r"""
    This class contains information about type of contents and format of
    the file, which will contain exported coverage data.

    See also: CCoverageController2::exportData()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EScopeAll = _connect.CCoverageExportConfig_EScopeAll
    EScopeVisible = _connect.CCoverageExportConfig_EScopeVisible
    EScopeConfigured = _connect.CCoverageExportConfig_EScopeConfigured

    def __init__(self):
        r"""
        Constructs object with default settings, as described with each method.

        Python example: _sample_link{coverage_ctrl,test_coverage_all_code}
        """
        _connect.CCoverageExportConfig_swiginit(self, _connect.new_CCoverageExportConfig())

    def setFileName(self, fileName):
        r"""
        Sets the name of the exported file or folder name for HTML export.
        If this method is not called, or
        ``fileName`` is empty string, then the existing export file name in
        winIDEA is used.
        """
        return _connect.CCoverageExportConfig_setFileName(self, fileName)

    def setFormatter(self, formatter):
        r"""
        Sets formatter object, which configures export file format. If this
        method is not called, XML formatter with default settings is used.

        Example:


            formatter = ic.CCoverageXMLExportFormat()
            exportCfg.setFormatter(formatter)


        See also: CCoverageFormatBase
        """
        return _connect.CCoverageExportConfig_setFormatter(self, formatter)

    def setFormatVariant(self, formatVariant):
        r"""
        Sets variant of the export format. Usually there is only one variant, which
        can be selected with string 'default'. See coverage _Export_ dialog if
        other variants exist.
        """
        return _connect.CCoverageExportConfig_setFormatVariant(self, formatVariant)

    def setLaunchViewer(self, isLaunchViewer):
        r"""
        If set to ``true``, launches the system default
        viewer for the specified document type after export, for example
        notepad for text documents (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setExportModules(self, isExportModules):
        r"""
        If set to ``true``, coverage of modules (source files) is exported (default:
        ``true)``.
        """
        return _connect.CCoverageExportConfig_setExportModules(self, isExportModules)

    def setExportModuleLines(self, isExportModuleLines):
        r"""
        If set to ``true``, coverage lines info in modules (source files)
        is exported (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setExportModuleLines(self, isExportModuleLines)

    def setExportSources(self, isExportSources):
        r"""
        If set to ``true``, complete source files with coverage info are
        exported (including lines without generated object code)
        (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setExportSources(self, isExportSources)

    def setExportFunctions(self, isExportFunctions):
        r"""If set to ``true``, function coverage is exported (default: ``true)``."""
        return _connect.CCoverageExportConfig_setExportFunctions(self, isExportFunctions)

    def setExportFunctionLines(self, isExportFunctionLines):
        r"""
         If set to ``true``, coverage of lines in functions is exported
        (default: ``false)``.
        """
        return _connect.CCoverageExportConfig_setExportFunctionLines(self, isExportFunctionLines)

    def setExportFunctionAsm(self, isExportFunctionAsm):
        r"""
        If set to ``true``, assembler coverage information for function is exported (default: ``false)``.
        Assembler information is given in address order.
        """
        return _connect.CCoverageExportConfig_setExportFunctionAsm(self, isExportFunctionAsm)

    def setExportAsm(self, isExportAsm):
        r"""
         If set to ``true``, assembler coverage information is exported (default: ``false)``.
        Assembler information is given in source line order (some source lines may generate code
        at several address blocks ('for' loop, for example).
        """
        return _connect.CCoverageExportConfig_setExportAsm(self, isExportAsm)

    def setExportRanges(self, isExportRanges):
        r"""If set to ``true``, range coverage information is exported (default: ``false)``."""
        return _connect.CCoverageExportConfig_setExportRanges(self, isExportRanges)

    def setModulesFilter(self, modulesFilter):
        r"""Defines wildcard expression for modules to be exported, for example: eval*.c"""
        return _connect.CCoverageExportConfig_setModulesFilter(self, modulesFilter)

    def setFunctionsFilter(self, functionsFilter):
        r"""Defines wildcard expression for functions to be exported, for example: init_*"""
        return _connect.CCoverageExportConfig_setFunctionsFilter(self, functionsFilter)

    def setTestId(self, testId):
        r"""
         Sets test ID. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setTestId(self, testId)

    def setDescription(self, desc):
        r"""
         Sets human description of measurement. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setDescription(self, desc)

    def setComment(self, comment):
        r"""
         Sets comment. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setComment(self, comment)

    def setSoftware(self, sw):
        r"""
         Sets description of software used for measurement. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setSoftware(self, sw)

    def setHardware(self, hw):
        r"""
         Sets description of hardware used for measurement. This information is written to exported file.
        If this method is not called, existing value in the document is preserved.
        """
        return _connect.CCoverageExportConfig_setHardware(self, hw)

    def getFileName(self):
        r"""Returns coverage file name."""
        return _connect.CCoverageExportConfig_getFileName(self)

    def getFormatVariant(self):
        r"""Returns variant of the selected format to use for export."""
        return _connect.CCoverageExportConfig_getFormatVariant(self)

    def isLaunchViewer(self):
        r"""Returns true, if viewer should be launched after export."""
        return _connect.CCoverageExportConfig_isLaunchViewer(self)

    def isExportModules(self):
        r"""Returns true, if modules (source files) should be exported."""
        return _connect.CCoverageExportConfig_isExportModules(self)

    def isExportModuleLines(self):
        r"""Returns true, if lines in modules (source files) should be exported."""
        return _connect.CCoverageExportConfig_isExportModuleLines(self)

    def isExportSources(self):
        r"""Returns true, if complete source files should be exported."""
        return _connect.CCoverageExportConfig_isExportSources(self)

    def isExportFunctions(self):
        r"""Returns true, if functions should be exported."""
        return _connect.CCoverageExportConfig_isExportFunctions(self)

    def isExportFunctionLines(self):
        r"""Returns true, if function lines should be exported."""
        return _connect.CCoverageExportConfig_isExportFunctionLines(self)

    def isExportFunctionAsm(self):
        r"""
         Returns true, if assembler info in address order should be exported.
        See also: setExportFunctionAsm()
        """
        return _connect.CCoverageExportConfig_isExportFunctionAsm(self)

    def isExportAsm(self):
        r"""
         Returns true, if assembler info in source line order should be exported.
        See also: setExportAsm()
        """
        return _connect.CCoverageExportConfig_isExportAsm(self)

    def isExportRange(self):
        r"""Returns true, if range info should be exported."""
        return _connect.CCoverageExportConfig_isExportRange(self)

    def getModulesFilter(self):
        r"""Returns filter for modules."""
        return _connect.CCoverageExportConfig_getModulesFilter(self)

    def getFunctionsFilter(self):
        r"""Returns filter for functions."""
        return _connect.CCoverageExportConfig_getFunctionsFilter(self)

    def getTestId(self):
        r"""
        Returns test ID. This method returns empty string or string set
        by setTestId(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getTestId(self)

    def getDescription(self):
        r"""
         Returns human description of measurement. This method returns empty string or string set
        by setDescription(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getDescription(self)

    def getComment(self):
        r"""
         Returns comment. This method returns empty string or string set
        by setComment(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getComment(self)

    def getSoftware(self):
        r"""
         Returns description of software used for measurement. This method returns empty
        string or string set
        by setSoftware(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getSoftware(self)

    def getHardware(self):
        r"""
         Returns description of hardware used for measurement. This method returns empty
        string or string set
        by setHardware(), not value from the document.
        """
        return _connect.CCoverageExportConfig_getHardware(self)

    def setOptions(self, ide, docFileName):
        return _connect.CCoverageExportConfig_setOptions(self, ide, docFileName)

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CCoverageExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CCoverageExportConfig

# Register CCoverageExportConfig in _connect:
_connect.CCoverageExportConfig_swigregister(CCoverageExportConfig)
class CCoverageController2(CAnalyzerDocController):
    r"""
    This class implements coverage functionality with a document
    oriented interface. It replaces the old CCoverageController,
    which is deprecated now. If you need some functionality from the
    old class, which is missing in this one, please contact iSYSTEM
    support, rather than using the old class. If you use the
    old class, your code will no longer work once the deprecated
    class will be removed in the future versions of ``isystem.connect``.


    Portability list

    CCoverageController()  -->  CCoverageController2()
                                File name and open mode are required.

    isCoverageAvailable ()        -->  not implemented in CCoverageController2
    isBranchCoverageAvailable ()  -->  not implemented in CCoverageController2
    isHWCoverageAvailable ()      -->  not implemented in CCoverageController2
    isOfflineCoverageAvailable () -->  not implemented in CCoverageController2

    setConfiguration()   --> use createTrigger(), setProvideAssemblerInfo()

    all ``range`` methods --> use ``area`` handling methods (addArea(), removeArea(), ...)

    getCoverageBitmap()      --> no longer available, use class CCoverageData2
    getCoverageStatistics()  --> use class CCoverageData2
    getStatisticsForSymbol() --> use class CCoverageData2



    This class can be used to configure coverage, run recording, and export
    the recorded data. However, it has no methods to get recorded information.
    For this purpose a separate class called CCoverageData2 should be used.


    Use only methods documented for this class. If a method from the base class is
    not documented here, do not use it. 




    Python example with recording and simple data reading: _sample_link{coverage_ctrl,test_area}

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EAreaFolder = _connect.CCoverageController2_EAreaFolder
    r"""folder with sources"""
    EAreaModule = _connect.CCoverageController2_EAreaModule
    r"""source file"""
    EAreaFunction = _connect.CCoverageController2_EAreaFunction
    r"""function"""
    EAreaRange = _connect.CCoverageController2_EAreaRange
    r"""address range"""
    EAreaImage = _connect.CCoverageController2_EAreaImage
    r"""download file"""
    EScopeAllDownloadedCode = _connect.CCoverageController2_EScopeAllDownloadedCode
    r"""
    All downloaded code is measured,
    adding or removing areas with methods
    in this class has no effect.
    """
    EScopeEntireMemory = _connect.CCoverageController2_EScopeEntireMemory
    r"""
    All memory is measured,
    adding or removing areas with methods
    in this class has no effect.
    """
    EScopeCustom = _connect.CCoverageController2_EScopeCustom
    r"""
    only coverage of areas added
    with ``addArea()`` method
    in this class is measured
    """

    def __init__(self, connectionMgr, fileName, mode):
        r"""
        Instantiates object and opens or creates coverage document in
        ``winIDEA``.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes recordings,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        Python example: _sample_link{coverage_ctrl,test_configure}
        """
        _connect.CCoverageController2_swiginit(self, _connect.new_CCoverageController2(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CCoverageController2

    def createTrigger(self, triggerName):
        r"""
        Creates a new coverage trigger. Trigger contains information about
        what coverage should record (which functions, modules, ...)
        and how to record it (when to start, buffer size, ...).

        :type triggerName: string
        :param triggerName: name of the trigger

        :rtype: int
        :return: index of the created trigger

        :raises: IllegalArgumentException if the trigger already exists

        Python example: _sample_link{coverage_ctrl,test_trigger}
        """
        return _connect.CCoverageController2_createTrigger(self, triggerName)

    def setScope(self, triggerIndex, scope):
        r"""
        Sets scope to be included in coverage measurement. If ``EScopeCustom``
        is set, use method ``addArea()`` to define areas to be included in coverage
        measurements.

        :type triggerIndex: int
        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type scope: int
        :param scope: defines which part of memory to include in coverage
                         measurements

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_setScope(self, triggerIndex, scope)

    def getScope(self, triggerIdx):
        r"""
        Returns scope to be included in coverage measurement.

        :type triggerIdx: int
        :param triggerIdx: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        See also: setScope

        Python example: _sample_link{coverage_ctrl,test_scope}
        """
        return _connect.CCoverageController2_getScope(self, triggerIdx)

    def setProvideAssemblerInfo(self, triggerIdx, isProvideAssemblerInfo):
        r"""
        Sets option to include assembler instructions in measured coverage.

        :type triggerIdx: int
        :param triggerIdx: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type isProvideAssemblerInfo: boolean
        :param isProvideAssemblerInfo: if set to ``true``, assembler information
                                          is provided with coverage.

        Python example: _sample_link{coverage_ctrl,test_configure}
        """
        return _connect.CCoverageController2_setProvideAssemblerInfo(self, triggerIdx, isProvideAssemblerInfo)

    def isProvideAssemblerInfo(self, triggerIdx):
        r"""
        Returns true if assembler info should be provided with coverage.

        :type triggerIdx: int
        :param triggerIdx: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        Python example: _sample_link{coverage_ctrl,test_configure}
        """
        return _connect.CCoverageController2_isProvideAssemblerInfo(self, triggerIdx)

    def setIgnoreUnreachableCode(self, isIgnoreUnreachableCode):
        r"""
        If set to true, then the code inside the function which is not reachable by
        sequential or (conditional)direct branch flow is not considered for coverage
        statistics.
        Set it to true, when compiler generates data between instructions (for example
        branch addresses) and you want to get 100% coverage.

        Python example: _sample_link{coverage_ctrl,test_configure}
        """
        return _connect.CCoverageController2_setIgnoreUnreachableCode(self, isIgnoreUnreachableCode)

    def isIgnoreUnreachableCode(self):
        r"""See also: setIgnoreUnreachableCode()"""
        return _connect.CCoverageController2_isIgnoreUnreachableCode(self)

    def addArea(self, triggerIndex, areaType, areaName):
        r"""
        Adds area (module, function, ...) to be included in coverage measurement. This
        method has effect only if method ``setScope()`` was called with ``EScopeCustom``
        as scope value.

        :type triggerIndex: int
        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type areaType: int
        :param areaType: type of area

        :type areaName: string
        :param areaName: name of image file, module, function, ... Modules must be
                   specified with relative path if they are not in winIDEA workspace folder.

        :rtype: int
        :return: index of the added area.

        See also: getAreas

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_addArea(self, triggerIndex, areaType, areaName)

    def removeArea(self, triggerIndex, areaType, areaName):
        r"""
        Removes area, which has been previously added with addArea(), from
        coverage measurement.

        :type triggerIndex: int
        :param triggerIndex: index of analyzer trigger as returned by ``createTrigger()``,
                   ``getActiveTriggerIndex()`` or ``getTriggerIndex()``

        :type areaType: int
        :param areaType: type of area

        :type areaName: string
        :param areaName: name of image file, module, function, ... Modules must be
                   specified with relative path if they are not in winIDEA workspace folder.

        :rtype: int
        :return: -1 if area with the give name was not found (not removed), 0 if area
                    with the given name exists, but is not of the specified type (not removed),
                    1 if area was found and removed

        See also: addArea

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_removeArea(self, triggerIndex, areaType, areaName)

    def removeAllAreas(self, triggerIndex):
        r"""
        Removes all areas of the given type from coverage measurement.

        See also: addArea

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_removeAllAreas(self, triggerIndex)

    def getAreas(self, triggerIndex, areaType, areas):
        r"""
        Returns list of currently configured areas.

        See also: addArea
        See also: removeArea

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_getAreas(self, triggerIndex, areaType, areas)

    def exportData(self, exportConfig):
        r"""
        Exports coverage data according to the given configuration.
        Example:


        coverage = CCoverageController2(connectionMgr, "coverage.trd", "w")

        ...

        cfg = CCoverageExportConfig().setFileName('coverageResult.xml') \
                                     .setExportSources(True) \
                                     .setExportFunctionLines(True)
        coverage.exportData(cfg)


        :type exportConfig: :py:class:`CCoverageExportConfig`
        :param exportConfig: object with parameters for export - defines which
                                items to export and their format

        See also: CCoverageExportConfig

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_exportData(self, exportConfig)

    def merge(self, files):
        r"""
        This method merges coverage information from the given list of
        analyzer files to this document.

        **Note:**
        If this document is configured
        to show only certain areas (functions), then only those areas will
        be visible after merging. It is recommended to create a new document
        before merging, because it has all areas visible by default.

        **Limitations:**
        You can only merge results, if all analyzer documents were
        obtained with the same target code.

        :raises: IOException if one of source files is not found or in
            case of merging error.

        Python example: _sample_link{coverage_ctrl,test_merge}
        """
        return _connect.CCoverageController2_merge(self, files)

    def areaType2Str(self, areaType):
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Coverage.Include[<idx2>].Type``.

        :type areaType: int
        :param areaType: type of area

        Python example: _sample_link{coverage_ctrl,test_area}
        """
        return _connect.CCoverageController2_areaType2Str(self, areaType)

    def scope2Str(self, scope):
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Coverage.Scope``.

        :type scope: int
        :param scope: coverage scope

        Python example: _sample_link{coverage_ctrl,test_scope}
        """
        return _connect.CCoverageController2_scope2Str(self, scope)

    def scope2Enum(self, scope):
        r"""
        Returns enum value for the given scope string.

        :type scope: string
        :param scope: one of strings specified for option
            ``/Document/<fileName>/Trigger.Items[<idx1>].Coverage.Scope``
            See winIDEA, ``Help | Display Option``, select ``Document`` and
            analyzer document with coverage trigger defined.

        Python example: _sample_link{coverage_ctrl,test_scope}
        """
        return _connect.CCoverageController2_scope2Enum(self, scope)

# Register CCoverageController2 in _connect:
_connect.CCoverageController2_swigregister(CCoverageController2)
class CCoverageMetaInfo(object):
    r"""
    This class contains information from coverage info node
    as entered in the 'Set Information' dialog in winIDEA.
    This node appears at the start of coverage XML export, and
    there is only one instance per document. Call method
    CCoverageData2::getCoverageMetaInfo() to get instance of this class.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getName(self):
        r"""Returns tester's name as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getName(self)

    def getId(self):
        r"""Returns coverage ID as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getId(self)

    def getDate(self):
        r"""Returns recording date."""
        return _connect.CCoverageMetaInfo_getDate(self)

    def getTime(self):
        r"""Returns recording time."""
        return _connect.CCoverageMetaInfo_getTime(self)

    def getSoftware(self):
        r"""Returns covered software info as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getSoftware(self)

    def getHardware(self):
        r"""Returns hardware info as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getHardware(self)

    def getDescription(self):
        r"""Returns description as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getDescription(self)

    def getComment(self):
        r"""Returns comment as entered in 'Set Information' dialog."""
        return _connect.CCoverageMetaInfo_getComment(self)

    def __init__(self):
        _connect.CCoverageMetaInfo_swiginit(self, _connect.new_CCoverageMetaInfo())
    __swig_destroy__ = _connect.delete_CCoverageMetaInfo

# Register CCoverageMetaInfo in _connect:
_connect.CCoverageMetaInfo_swigregister(CCoverageMetaInfo)
class CCoverageSource(object):
    r"""
    This class contains information about coverage of a source line in the
    same way as it is shown on the left edge of winIDEA source code editor.
    It contains data from <src>, and <src><al> nodes.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EAreaExecuted = _connect.CCoverageSource_EAreaExecuted
    r"""All instructions in the line were executed (xml text: '0e')"""
    EAreaNotExecuted = _connect.CCoverageSource_EAreaNotExecuted
    r"""No instructions in the line were executed (xml text: '0n')"""
    EAreaPartiallyExecuted = _connect.CCoverageSource_EAreaPartiallyExecuted
    r"""
    Some instructions in the line were
    executed (xml text: '0m' (mixed))
    """
    EConditionBoth = _connect.CCoverageSource_EConditionBoth
    r"""
    Line contains a condition, which was executed both
    ways (xml text: '1b')
    """
    EMixedStateOfMultipleConditions = _connect.CCoverageSource_EMixedStateOfMultipleConditions
    r"""
    Line contains multiple conditions, not all of
    them were executed both ways (xml text: '1m')
    """
    EConditionNotExecuted = _connect.CCoverageSource_EConditionNotExecuted
    r"""
    Line contains a condition, which was not executed
    (xml text: '1n')
    """
    EConditionWasNeverTrue = _connect.CCoverageSource_EConditionWasNeverTrue
    r"""
    Line contains condition, which was never executed
    as ``true`` (xml text: '1nt')
    """
    EConditionWasAlwaysTrue = _connect.CCoverageSource_EConditionWasAlwaysTrue
    r"""
    Line contains condition, which was never executed
    as ``false`` (xml text: '1t')
    """
    EOutOfange = _connect.CCoverageSource_EOutOfange
    r"""
    Debug info is there for this source line but it was
    not configured for coverage (xml text: 'r')
    """
    EEmpty = _connect.CCoverageSource_EEmpty
    r"""There is no debug info for this source line. (xml text: 'e')"""

    def getSourceLineText(self):
        r"""Returns source code text in the line."""
        return _connect.CCoverageSource_getSourceLineText(self)

    def getSourceLineNumber(self):
        r"""Returns the line number."""
        return _connect.CCoverageSource_getSourceLineNumber(self)

    def getAddress(self):
        r"""Returns address as text."""
        return _connect.CCoverageSource_getAddress(self)

    def getNumAsmOpCodes(self):
        r"""Returns the number of assembler op codes for source line."""
        return _connect.CCoverageSource_getNumAsmOpCodes(self)

    def getAsmOpCodeInfo(self, idx):
        r"""This method returns assembler op code coverage info."""
        return _connect.CCoverageSource_getAsmOpCodeInfo(self, idx)

    def getCoverageMarker(self):
        r"""
        Returns source code coverage marker. See
        CCoverageSource::ESrcLineCoverageMarkers for details.
        """
        return _connect.CCoverageSource_getCoverageMarker(self)

    def __init__(self):
        _connect.CCoverageSource_swiginit(self, _connect.new_CCoverageSource())
    __swig_destroy__ = _connect.delete_CCoverageSource

# Register CCoverageSource in _connect:
_connect.CCoverageSource_swigregister(CCoverageSource)
class CCoverageStatistic2(object):
    r"""
    This class contains information about coverage area (function or
    data), which coverage has been measured.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EAnyArea = _connect.CCoverageStatistic2_EAnyArea
    r"""Matches any other area when retrieving data."""
    EImages = _connect.CCoverageStatistic2_EImages
    r"""This area contains statistic for all download files."""
    EImage = _connect.CCoverageStatistic2_EImage
    r"""This area contains statistic for one download file."""
    EFolder = _connect.CCoverageStatistic2_EFolder
    r"""This area contains statistic for source files in one folder."""
    EModule = _connect.CCoverageStatistic2_EModule
    r"""This area contains statistic for one source file."""
    EFunction = _connect.CCoverageStatistic2_EFunction
    r"""This area contains statistic for one function."""
    ESrcLine = _connect.CCoverageStatistic2_ESrcLine
    r"""This area contains statistic for one source line."""
    EAsm = _connect.CCoverageStatistic2_EAsm
    r"""This area contains statistic for one assembler instruction."""
    ERange = _connect.CCoverageStatistic2_ERange
    r"""
    This area contains statistic for one memory range, usually
    this is one assembler instruction.
    """
    ERanges = _connect.CCoverageStatistic2_ERanges
    r"""
    This area contains statistic for memory ranges which
    were not found in debug information.
    """
    __swig_destroy__ = _connect.delete_CCoverageStatistic2

    def __init__(self, areaType):
        _connect.CCoverageStatistic2_swiginit(self, _connect.new_CCoverageStatistic2(areaType))

    def getParent(self):
        r"""
        Returns parent of this statistic. Hierarchy ``parentArea -> childrenAreas`` is
        defined as:
        ``images -> image -> folder -> module -> function -> line -> asm -> range``


        Parent information is available only when complete file is loaded into memory.
        If CCoverageData2::createInstance() was called with ``isLoadDataInMemory = false``,
        then this method always returns null reference.
        """
        return _connect.CCoverageStatistic2_getParent(self)

    def getNumChildren(self):
        r"""
        Returns the number of children areas, for example the number of source files
        in a folder (use only when complete
        file is loaded to memory (method createInstance() was called
        with ``isLoadDataInMemory`` = ``true))``.


        Python example: _sample_link{coverage_data,test_get_iterator}
        """
        return _connect.CCoverageStatistic2_getNumChildren(self)

    def getChild(self, idx):
        r"""
        Returns child area for the given index (available only when complete
        file is loaded to memory (method createInstance() was called
        with ``isLoadDataInMemory`` = ``true))``.


        Python example: _sample_link{coverage_data,test_get_iterator}
        """
        return _connect.CCoverageStatistic2_getChild(self, idx)

    def getAreaType(self):
        r"""
        Returns coverage area type.


        Python example: _sample_link{coverage_data,test_get_iterator}
        """
        return _connect.CCoverageStatistic2_getAreaType(self)

    def getAreaName(self):
        r"""Returns area name, for example source file name, function name, source line text, ..."""
        return _connect.CCoverageStatistic2_getAreaName(self)

    def getLinesAll(self):
        r"""Returns the number of all source code lines in area."""
        return _connect.CCoverageStatistic2_getLinesAll(self)

    def getLinesExecuted(self):
        r"""Returns the number of executed source code lines in area."""
        return _connect.CCoverageStatistic2_getLinesExecuted(self)

    def getBytesAll(self):
        r"""Returns the number of object code bytes in area."""
        return _connect.CCoverageStatistic2_getBytesAll(self)

    def getBytesExecuted(self):
        r"""Returns the number of executed object code bytes in area."""
        return _connect.CCoverageStatistic2_getBytesExecuted(self)

    def getConditionsAll(self):
        r"""Returns the number of object code conditions in area."""
        return _connect.CCoverageStatistic2_getConditionsAll(self)

    def getConditionsExecuted(self):
        r"""Returns the number of object code conditions which executed as ``true``."""
        return _connect.CCoverageStatistic2_getConditionsExecuted(self)

    def getConditionsTrue(self):
        r"""Returns the number of object code conditions which executed as ``true``."""
        return _connect.CCoverageStatistic2_getConditionsTrue(self)

    def getConditionsFalse(self):
        r"""Returns the number of object code conditions which executed as ``false``."""
        return _connect.CCoverageStatistic2_getConditionsFalse(self)

    def getConditionsBoth(self):
        r"""Returns the number of object code conditions which executed both ways."""
        return _connect.CCoverageStatistic2_getConditionsBoth(self)

    def getExecutionCount(self):
        r"""
        Returns execution count. For example, if this is coverage statistics for a module,
        this method returns number of functions in module called at least once.
        For function this is number of calls of a function, for lines this
        is number of executions of a line.
        See also: #getItemsCount
        """
        return _connect.CCoverageStatistic2_getExecutionCount(self)

    def getItemsCount(self):
        r"""
        Returns items count. For example, if this is coverage statistics for a module,
        this method returns number of all functions in a module. For functions
        this is number of lines in a function.
        See also: #getExecutionCount
        """
        return _connect.CCoverageStatistic2_getItemsCount(self)

    def getCallCount(self):
        r"""Returns the number of all calls in a range, function, module, ..."""
        return _connect.CCoverageStatistic2_getCallCount(self)

    def getExecutedCallCount(self):
        r"""Returns the number of executed calls in a range, function, module, ..."""
        return _connect.CCoverageStatistic2_getExecutedCallCount(self)

    def getTextOrAbsPath(self):
        r"""
        Returns source line text for CCoverageStatistic2::ESrcLine areas, and
        absolute path for CCoverageStatistic2::EFolder and
        CCoverageStatistic2::EModule areas. This method is not available for
        areas of other type.

        :raises: IllegalStateException if this is not line, folder or module area.

        """
        return _connect.CCoverageStatistic2_getTextOrAbsPath(self)

    def getRelPath(self):
        r"""
        Returns relative path. This method is available only for folder and
        module areas.

        :raises: IllegalStateException if this is not folder or module area.

        """
        return _connect.CCoverageStatistic2_getRelPath(self)

    def getLineNumber(self):
        r"""
        Returns source line number (this method is available only for areas
        of type CCoverageStatistic2::ESrcLine).

        :raises: IllegalStateException if this is not line area.

        """
        return _connect.CCoverageStatistic2_getLineNumber(self)

    def getNumSourceLines(self):
        r"""
        This method returns the number of source lines in area of type
        CCoverageStatistic2::EModule.

        :raises: IllegalStateException if this is not module area.

        """
        return _connect.CCoverageStatistic2_getNumSourceLines(self)

    def getSourceLineInfo(self, idx):
        r"""
        This method returns source line coverage info (available
        only for areas of type CCoverageStatistic2::EModule).

        :raises: IllegalStateException if this is not module area.

        """
        return _connect.CCoverageStatistic2_getSourceLineInfo(self, idx)

    def getNumAsmLines(self):
        r"""Returns the number of lines with ASM info for this node."""
        return _connect.CCoverageStatistic2_getNumAsmLines(self)

    def getAsmLine(self, idx):
        r"""Returns ASM info aththe given index for this node."""
        return _connect.CCoverageStatistic2_getAsmLine(self, idx)

    def addStatItems(self, src):
        return _connect.CCoverageStatistic2_addStatItems(self, src)

    @staticmethod
    def areaType2Str(areaType):
        r"""Returns string representation of the given enum."""
        return _connect.CCoverageStatistic2_areaType2Str(areaType)

# Register CCoverageStatistic2 in _connect:
_connect.CCoverageStatistic2_swigregister(CCoverageStatistic2)
class CCoverageStatistic2Asm(object):
    r"""
    This class contains disassembly coverage information for function - op
    codes are sorted by addresses.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCoverageStatistic2Asm_swiginit(self, _connect.new_CCoverageStatistic2Asm())

    def getLineType(self):
        r"""Returns line type (source or assembly)."""
        return _connect.CCoverageStatistic2Asm_getLineType(self)

    def getCoverageMarker(self):
        r"""Returns coverage marker for assembly line."""
        return _connect.CCoverageStatistic2Asm_getCoverageMarker(self)

    def getAddress(self):
        r"""Returns line address."""
        return _connect.CCoverageStatistic2Asm_getAddress(self)

    def getLineText(self):
        r"""Returns text in line."""
        return _connect.CCoverageStatistic2Asm_getLineText(self)

    def getLineNumber(self):
        r"""Returns source line number. Available for source line type only."""
        return _connect.CCoverageStatistic2Asm_getLineNumber(self)

    def getModuleName(self):
        r"""Returns source module name. Available for source line type only."""
        return _connect.CCoverageStatistic2Asm_getModuleName(self)
    __swig_destroy__ = _connect.delete_CCoverageStatistic2Asm

# Register CCoverageStatistic2Asm in _connect:
_connect.CCoverageStatistic2Asm_swigregister(CCoverageStatistic2Asm)
class CCoverageStatIterator(object):
    r"""
    This class iterates through statistic nodes. Depth-first iteration
    is used. 

    Clients should use CCoverageData2::getIterator() to obtain instances
    of this class.

    See also: CCoverageData2::getIterator()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, coverageData, areaType, firstStat):
        _connect.CCoverageStatIterator_swiginit(self, _connect.new_CCoverageStatIterator(coverageData, areaType, firstStat))
    __swig_destroy__ = _connect.delete_CCoverageStatIterator

    def hasNext(self):
        r"""
        Returns true, if there is at least one more statistic available.

        """
        return _connect.CCoverageStatIterator_hasNext(self)

    def next(self):
        r"""
        Returns the next statistic.

        """
        return _connect.CCoverageStatIterator_next(self)

# Register CCoverageStatIterator in _connect:
_connect.CCoverageStatIterator_swigregister(CCoverageStatIterator)
class CCoverageData2(object):
    r"""
    This class provides convenient access to coverage data exported to XML file,
    so that writing XML parser is not required. Use class CCoverageController2
    to record and export the data.


    Instances of this class should be obtained with one of createInstance()
    static methods.

    Two ways of parsing are provided (see parameter ``isLoadDataInMemory`` in
    methods createInstance()):
    - parse complete coverage file to memory. Use this approach when coverage
      files are small relative to available computer memory. Method getRoot()
      returns root node, which contains children. Iterators are also available.
      Recommended usage:

        createInstance()
        getParserWarnings()
        closeParser()
        use getter methods as needed


    - parse coverage file statistic node by node. Information is available only
      through iterator, nodes do not have children or parents assigned.
      Recommended usage:

        createInstance()
        getParserWarnings()
        then either:
          call getStatistic() if you are interested in coverage
                              statistic of one area only
          call getIterator()  to obtain information about all areas.
                              Once iterator's method hasNext() returns ``false``,
                              this object can no longer be used.
        finally call method closeParser()



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def createInstance(*args):
        r"""
        *Overload 1:*

        This factory method exports data to file,
        and returns initialized object.
        Use it, when you've just recorded data (have CCoverageController2 object
        available), and have not exported it yet. Note also that this method is not
        as flexible as direct export and
        method createInstance(fileName, isLoadDataInMemory).


        **Note**: if ``exportFileName`` is relative, it is saved relative to
        winIDEA working directory, not the script working directory. This method
        tries to do its best to open the saved file, but if winIDEA is on remote
        host, it will fail. In such cases try to export the coverage data with
        CCoverageController2::exportData() and use
        the overloaded method ``createInstance(fileName)`` instead.

        **Important:** To release memory and file, always call closeParser()
                          when done using parser!

        :type coverageCtrl: :py:class:`CCoverageController2`
        :param coverageCtrl: coverage document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :type isLoadDataInMemory: boolean
        :param isLoadDataInMemory: if ``true``, the exported file is immediately parsed
                                      and all data is
                                      loaded into memory.  This provides
                                      faster browsing, but may not be
                                      appropriate for large coverage files. 

                                      If ``false``, use iterator (see getIterator()) to
                                      parse statistic node by node. This approach
                                      is not as flexible as the frst one, but it is very
                                      memory efficient.

        Python example: _sample_link{coverage_data,test_coverage_create_instance}

        |

        *Overload 2:*

        This factory method parses statistic information from coverage XML
        export file and returns initialized object.

        **Important:** To release memory and file, always call closeParser()
                          when done using parser!

        :type fileName: string
        :param fileName: name of the file with coverage XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :type isLoadDataInMemory: boolean
        :param isLoadDataInMemory: if ``true``, the exported file is immediately parsed
                                      and all data is loaded into memory. This provides
                                      faster browsing, but may not be
                                      appropriate for large coverage files. 

                                      If ``false``, use iterator (see getIterator()) to
                                      parse statistic node by node. This approach
                                      is not as flexible as the first one, but it is very
                                      memory efficient.

        Python example: _sample_link{coverage_data,test_coverage_create_instance}
        """
        return _connect.CCoverageData2_createInstance(*args)

    def getParserWarnings(self):
        r"""
        This method returns warnings related to input XML document. If there
        were no warnings, an empty string is returned. Always call this method
        after createInstance(). If XML document is made with newer version of winIDEA
        than SDK, it will warn you about possible missing info.

        Python example: _sample_link{coverage_data,test_get_root}
        """
        return _connect.CCoverageData2_getParserWarnings(self)

    def closeParser(self):
        r"""
        This method releases parser resources and closes XML file. If this method
        is not called, the XML file remains opened and can not be overwritten or
        deleted until the application exits. Furthermore, memory allocated by
        by this object is not released until this method is called!

        Python example: _sample_link{coverage_data,test_get_root}
        """
        return _connect.CCoverageData2_closeParser(self)

    def getCoverageMetaInfo(self):
        r"""
        Returns coverage meta-data as specified by the user in winIDEA
        coverage 'Set information' dialog.


        Python example: _sample_link{coverage_data,test_get_coverage_meta_info}
        """
        return _connect.CCoverageData2_getCoverageMetaInfo(self)

    def getRoot(self):
        r"""
        Returns root node of type CCoverageStatistic2, which contains
        all other nodes. This method may be called only if all data is
        loaded into memory (see the second parameter of createInstance()).

        :raises: IllegalStateException if coverage data is not loaded
                   into memory (see the second parameter in
                   createInstance()).


            Python example: _sample_link{coverage_data,test_get_root}
        """
        return _connect.CCoverageData2_getRoot(self)

    def getStatistic(self, *args):
        r"""
        *Overload 1:*

        Returns statistic for the given function. This works only when data is
        loaded into memory.

        :type partition: string
        :param partition: name of download file, for example `sample.elf`
        :type folder: string
        :param folder: folder where source file is located, may be given relative to winIDEA
                          workspace (xjrf file).
        :type module: string
        :param module: name of a source file, which contains the function, for example `main.c`
        :type qualFuncName: string
        :param qualFuncName: name of the function for which we want to get coverage statistics,
                                for example `main`

        Python example: _sample_link{coverage_data,test_get_statistic}

        |

        *Overload 2:*

        This method searches the coverage data tree and returns the first
        node with the given type and name found. 


        Although this method works also
        when data is not loaded into memory (createInstance() was called with
        parameter ``isLoadDataInMemory`` = ``false)``, the parser has to be closed
        after each call and this class instantiated again, which makes it very
        inefficient. Also, if iterator was used before this method was called,
        results are unpredictable, and calling getIterator() after calling this
        method is forbidden.


        Python example: _sample_link{coverage_data,test_get_statistic}
        """
        return _connect.CCoverageData2_getStatistic(self, *args)

    def getIterator(self, areaType):
        r"""
        Returns iterator, which iterates all nodes in coverage file sequentially,
        and returns only nodes of the given type. Specify ``areaType`` = ``EAnyArea``
        to get all nodes.


        Python example: _sample_link{coverage_data,test_get_iterator}
        """
        return _connect.CCoverageData2_getIterator(self, areaType)
    __swig_destroy__ = _connect.delete_CCoverageData2

# Register CCoverageData2 in _connect:
_connect.CCoverageData2_swigregister(CCoverageData2)
class CProfilerContext(object):
    r"""
    Deprecated: this method will be removed or changed in one of
                future releases.
    This class contains information about profiler context (task, ISR,
    thread, ...). Context IDs are specified in timeline events.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getName(self):
        return _connect.CProfilerContext_getName(self)

    def getHandle(self):
        return _connect.CProfilerContext_getHandle(self)

    def __init__(self):
        _connect.CProfilerContext_swiginit(self, _connect.new_CProfilerContext())
    __swig_destroy__ = _connect.delete_CProfilerContext

# Register CProfilerContext in _connect:
_connect.CProfilerContext_swigregister(CProfilerContext)
class CProfilerArea2(object):
    r"""
    This class contains information about profiler area (function or
    data), which has been profiled. Areas are identified by 64-bit IDs, which
    are composed of area handle and area value.
    Function areas and non-state variable areas have value always set to 0.


    Python example: _sample_link{profiler_data}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EFunctions = _connect.CProfilerArea2_EFunctions
    r"""function (code) areas"""
    EFunctionLines = _connect.CProfilerArea2_EFunctionLines
    r"""deprecated since 9.17.36, Jan. 2018"""
    EVariables = _connect.CProfilerArea2_EVariables
    r"""
    variable areas for regular (non-state) variables.
    No statistics is recorded for values.
    """
    EStateVariables = _connect.CProfilerArea2_EStateVariables
    r"""
    state variables, which have at most 256 values.
    Statistics (see CProfilerStatistics2) is
    recorded for each value. Examples
    of such variables are task Id and states in
    state machines.
    """
    EAUX = _connect.CProfilerArea2_EAUX
    r"""IO lines as value"""
    EStateAUX = _connect.CProfilerArea2_EStateAUX
    r"""IO lines as state"""
    EInspector = _connect.CProfilerArea2_EInspector
    r"""inspector area, implemented as state machine with other areas as inputs"""
    EStateInspector = _connect.CProfilerArea2_EStateInspector
    r"""state inspector area, implemented as state machine with other areas as inputs"""

    def getAreaType(self):
        r"""Returns area type."""
        return _connect.CProfilerArea2_getAreaType(self)

    def getHandle(self):
        r"""Returns area handle."""
        return _connect.CProfilerArea2_getHandle(self)

    def getAreaName(self):
        r"""
        Returns area name. For function, variable and AUX areas this method
        returns function, variable, or AUX name. For function lines the source
        code of the line is returned. For state variables an empty string is
        returned, unless the variable was added to profiler with
        method CProfilerController2::addStateVariable(). Definition name
        (for example enum constant) is returned in this case.
        """
        return _connect.CProfilerArea2_getAreaName(self)

    def getFileName(self):
        r"""Returns file name. Available only for function line areas."""
        return _connect.CProfilerArea2_getFileName(self)

    def getPath(self):
        r"""Returns path from root node. Path consists of node names separated with '/'."""
        return _connect.CProfilerArea2_getPath(self)

    def getAreaId(self):
        r"""Returns unique Id for area."""
        return _connect.CProfilerArea2_getAreaId(self)

    def getValue(self):
        r"""
        Returns area value for state variables. For functions, function lines,
        and non-state variable areas it returns 0.
        """
        return _connect.CProfilerArea2_getValue(self)

    def getLineNumber(self):
        r"""Returns line number for function lines. For other areas it returns 0."""
        return _connect.CProfilerArea2_getLineNumber(self)

    def getParentHandle(self):
        r"""
        For state variable areas this method returns handle of variable,
        which was recorded, for function lines function handle is returned.
        For example, if state
        variable 'counter' was recorded with value '3',
        this method returns handle of variable 'counter'.

        Returns 0 for other ares.
        """
        return _connect.CProfilerArea2_getParentHandle(self)

    def getParentAreaName(self):
        r"""
        For state variable areas this method returns the name of variable,
        which was recorded with this value, for function lines function
        name is returned. For example, if state
        variable 'counter' was recorded with value '3', than state area
        has empty name (method getName() returns empty string), but
        this method returns 'counter' and getValue() returns '3'.
        Returns empty string for other ares.
        """
        return _connect.CProfilerArea2_getParentAreaName(self)

    def getValueUnit(self):
        r"""Returns physical unit of value, for example V for Volts, A, for Amperes, ..."""
        return _connect.CProfilerArea2_getValueUnit(self)

    def getValueType(self):
        r"""
        Returns type of value, 'I32' for 32-bit unsigned integers,
        'S32' for 32-bit signed integers, or 'F32' for 32-bit floats.
        """
        return _connect.CProfilerArea2_getValueType(self)

    def hasStates(self):
        r"""
        Returns true, if state areas exist for variable area.

        See also: getStateAreaId()
        """
        return _connect.CProfilerArea2_hasStates(self)

    def getStateAreaId(self, value):
        r"""
        Returns ID for state areas if they exist for the variable,
        0 otherwise. For example,
        if variable `mysStateVar` has states `S_ENTER`, and `S_EXIT`,
        method `getStateAreaID()` on area of `myStateVar` will return the
        same ID as `getParentHandle()` method on areas `S_ENTER` and `S_EXIT`. This way
        we can connect state variables and their states.

        :type value: int
        :param value: ignored, no longer used after 9.12.274.
        See also: hasStates()
        """
        return _connect.CProfilerArea2_getStateAreaId(self, value)

    @staticmethod
    def handle2AreaId(handle, value=0):
        r"""Utility method, which returns area type for the given handle."""
        return _connect.CProfilerArea2_handle2AreaId(handle, value)

    def __init__(self):
        _connect.CProfilerArea2_swiginit(self, _connect.new_CProfilerArea2())
    __swig_destroy__ = _connect.delete_CProfilerArea2

# Register CProfilerArea2 in _connect:
_connect.CProfilerArea2_swigregister(CProfilerArea2)
class CProfilerContextIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profilerData):
        _connect.CProfilerContextIterator_swiginit(self, _connect.new_CProfilerContextIterator(profilerData))

    def hasNext(self):
        r"""Returns true, if there is at least one more area available."""
        return _connect.CProfilerContextIterator_hasNext(self)

    def next(self):
        r"""Returns the next context."""
        return _connect.CProfilerContextIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerContextIterator

# Register CProfilerContextIterator in _connect:
_connect.CProfilerContextIterator_swigregister(CProfilerContextIterator)
class CProfilerAreaIterator(object):
    r"""
    This class provides access to profiler areas. Do not
    instantiate this class directly but call
    CProfilerData2::getAreaIterator() to get an instance.


    Python example: _sample_link{profiler_data}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profilerData, areaType):
        _connect.CProfilerAreaIterator_swiginit(self, _connect.new_CProfilerAreaIterator(profilerData, areaType))

    def hasNext(self):
        r"""
         Returns true, if there is at least one more area available.


        Python example: _sample_link{profiler_data}
        """
        return _connect.CProfilerAreaIterator_hasNext(self)

    def next(self):
        r"""
         Returns the next area.


        Python example: _sample_link{profiler_data}
        """
        return _connect.CProfilerAreaIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerAreaIterator

# Register CProfilerAreaIterator in _connect:
_connect.CProfilerAreaIterator_swigregister(CProfilerAreaIterator)
class CProfilerStatistics2(object):
    r"""
    This class contains profiler statistics information.


    Python example: _sample_link{profiler_data}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ENetTimes = _connect.CProfilerStatistics2_ENetTimes
    r"""
    Identifies net times for function execution.
    Net time is time spent for code inside function body, without
    sub-functions called from this function.
    """
    EGrossTimes = _connect.CProfilerStatistics2_EGrossTimes
    r"""
    Identifies gross times for function execution.
    Gross time is time spent for code inside function body, AND
    sub-functions called from this function.
    """
    ECallTimes = _connect.CProfilerStatistics2_ECallTimes
    r"""
    Identifies call times for function execution.
    Call time is gross time plus time spent in other contexts
    (tasks, interrupts) between entry/exit of this function.
    """
    EPeriodTimes = _connect.CProfilerStatistics2_EPeriodTimes
    r"""
    Identifies times between function invocation. Total time
    is not defined for this type of time.
    """
    EOutsideTimes = _connect.CProfilerStatistics2_EOutsideTimes
    r"""Deprecated: use EInactiveTimes instead"""
    EInactiveTimes = _connect.CProfilerStatistics2_EInactiveTimes
    r"""
    Identifies inactive time for function execution
    or state variable - the time spent outside the body of
    the function or a state.
    """
    EUnknown = _connect.CProfilerStatistics2_EUnknown

    def getAreaId(self):
        r"""
        Returns ID of the profiler area (function, variable, AUX, ...), for which
        this statistics was measured.
        """
        return _connect.CProfilerStatistics2_getAreaId(self)

    def getHandle(self):
        r"""
        Deprecated: use getAreaId instead

        Returns handle of the profiler area (function, variable, AUX, ...), for which
        this statistics was measured.
        """
        return _connect.CProfilerStatistics2_getHandle(self)

    def getAreaName(self):
        r"""
        Returns name of the profiler area (function or variable), for which
        this statistics was measured.
        """
        return _connect.CProfilerStatistics2_getAreaName(self)

    def getParentAreaName(self):
        r"""
        For state variables areas returns name of parent area (variable).
        Empty for other areas.
        """
        return _connect.CProfilerStatistics2_getParentAreaName(self)

    def getAreaValue(self):
        r"""
        Returns value of the state area, for which
        this statistics was measured. If it is not state area, this method
        always returns 0.
        """
        return _connect.CProfilerStatistics2_getAreaValue(self)

    def getNumHits(self):
        r"""Returns the number of hits."""
        return _connect.CProfilerStatistics2_getNumHits(self)

    def getTotalTime(self, timeType):
        r"""Returns total time for the given time type."""
        return _connect.CProfilerStatistics2_getTotalTime(self, timeType)

    def getMinTime(self, timeType):
        r"""Returns min time for the given time type."""
        return _connect.CProfilerStatistics2_getMinTime(self, timeType)

    def getMinStartTime(self, timeType):
        r"""Returns min start time for the given time type."""
        return _connect.CProfilerStatistics2_getMinStartTime(self, timeType)

    def getMinEndTime(self, timeType):
        r"""Returns min end time for the given time type."""
        return _connect.CProfilerStatistics2_getMinEndTime(self, timeType)

    def getMaxTime(self, timeType):
        r"""Returns max time for the given time type."""
        return _connect.CProfilerStatistics2_getMaxTime(self, timeType)

    def getMaxStartTime(self, timeType):
        r"""Returns max start time for the given time type."""
        return _connect.CProfilerStatistics2_getMaxStartTime(self, timeType)

    def getMaxEndTime(self, timeType):
        r"""Returns max end time for the given time type."""
        return _connect.CProfilerStatistics2_getMaxEndTime(self, timeType)

    def getAverageTime(self, timeType):
        r"""Returns average time for the given time type."""
        return _connect.CProfilerStatistics2_getAverageTime(self, timeType)

    def getValueAverage(self):
        r"""Returns average value if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueAverage(self)

    def getValueMin(self):
        r"""Returns min value if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueMin(self)

    def getValueMax(self):
        r"""Returns max value if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueMax(self)

    def getValueTimeOfMin(self):
        r"""Returns time when min value appeared for the first time, if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueTimeOfMin(self)

    def getValueTimeOfMax(self):
        r"""Returns time when max value appeared for the first time, if area is regular variable."""
        return _connect.CProfilerStatistics2_getValueTimeOfMax(self)

    def getNetTotalTime(self):
        r"""
        Deprecated: use getTotalTime(ETimeType) instead.

        Returns the total net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetTotalTime(self)

    def getNetMinTime(self):
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetMinTime(self)

    def getNetMaxTime(self):
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetMaxTime(self)

    def getNetAverageTime(self):
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average net time for function execution.
        Net time is time spent for code inside function body, without
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getNetAverageTime(self)

    def getGrossTotalTime(self):
        r"""
         Deprecated: use getTotalTime(ETimeType) instead.
        Returns the total gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossTotalTime(self)

    def getGrossMinTime(self):
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossMinTime(self)

    def getGrossMaxTime(self):
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossMaxTime(self)

    def getGrossAverageTime(self):
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average gross time for function execution.
        Gross time is time spent for code inside function body, AND
        sub-functions called from this function.
        """
        return _connect.CProfilerStatistics2_getGrossAverageTime(self)

    def getCallTotalTime(self):
        r"""
         Deprecated: use getTotalTime(ETimeType) instead.
        Returns the total call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallTotalTime(self)

    def getCallMinTime(self):
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallMinTime(self)

    def getCallMaxTime(self):
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallMaxTime(self)

    def getCallAverageTime(self):
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average call time for function execution.
        Call time is gross time plus time spent in other contexts
        (tasks, interrupts) between entry/exit of this function.
        """
        return _connect.CProfilerStatistics2_getCallAverageTime(self)

    def getPeriodMinTime(self):
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the minimum time between function invocation.
        """
        return _connect.CProfilerStatistics2_getPeriodMinTime(self)

    def getPeriodMaxTime(self):
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the maximum time between function invocation.
        """
        return _connect.CProfilerStatistics2_getPeriodMaxTime(self)

    def getPeriodAverageTime(self):
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average time between function invocation.
        """
        return _connect.CProfilerStatistics2_getPeriodAverageTime(self)

    def getOutsideTotalTime(self):
        r"""
         Deprecated: use getTotalTime(ETimeType) instead.
        Returns the total outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideTotalTime(self)

    def getOutsideMinTime(self):
        r"""
         Deprecated: use getMinTime(ETimeType) instead.
        Returns the min outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideMinTime(self)

    def getOutsideMaxTime(self):
        r"""
         Deprecated: use getMaxTime(ETimeType) instead.
        Returns the max outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideMaxTime(self)

    def getOutsideAverageTime(self):
        r"""
         Deprecated: use getAverageTime(ETimeType) instead.
        Returns the average outside time for function execution.
        Outside Time indicates the time spent outside the body of
        the function or a state - where the function state is Inactive.
        """
        return _connect.CProfilerStatistics2_getOutsideAverageTime(self)

    def toString(self):
        r"""Returns string representation of this object."""
        return _connect.CProfilerStatistics2_toString(self)

    def __init__(self):
        _connect.CProfilerStatistics2_swiginit(self, _connect.new_CProfilerStatistics2())
    __swig_destroy__ = _connect.delete_CProfilerStatistics2

# Register CProfilerStatistics2 in _connect:
_connect.CProfilerStatistics2_swigregister(CProfilerStatistics2)
UNDEF_EVENT_SOURCE = _connect.UNDEF_EVENT_SOURCE
class CProfilerTimeEvent(object):
    r"""
    This class contains information of one profiler time-line event.


    Python example: _sample_link{profiler_data}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EEvAny = _connect.CProfilerTimeEvent_EEvAny
    r"""any event, this value can be used by iterator to return all events"""
    EEvWrite = _connect.CProfilerTimeEvent_EEvWrite
    r"""variable write events"""
    EEvSuspend = _connect.CProfilerTimeEvent_EEvSuspend
    r"""function/task/interrupt/... execution was suspended, for example function called another function"""
    EEvResume = _connect.CProfilerTimeEvent_EEvResume
    r"""function/task/interrupt/... execution was resumed, for example function call returned to the function which called it"""
    EEvEnter = _connect.CProfilerTimeEvent_EEvEnter
    r"""function/task/interrupt/... execution started"""
    EEvExit = _connect.CProfilerTimeEvent_EEvExit
    r"""function/task/interrupt/... execution ended"""

    def getAreaId(self):
        r"""Returns ID of the area, for which event was recorded."""
        return _connect.CProfilerTimeEvent_getAreaId(self)

    def getHandle(self):
        r"""
        Deprecated: since 9.12.295 (dec 2016). Use getAreaId()
        Returns ID of the area, for which event was recorded.
        """
        return _connect.CProfilerTimeEvent_getHandle(self)

    def getEventType(self):
        r"""Returns event type."""
        return _connect.CProfilerTimeEvent_getEventType(self)

    def getValue(self):
        r"""
        Returns value of integer variable or digital AUX port.
        Always check value type of area, to interpret the number correctly, for
        example:


          area = profiler_data.getArea(event.getHandle())
          valueType = area.getValueType()[0]
          if valueType == 'I':    # unsigned integer type
              print(timelineEvents[2].getValue() & 0xffffFFFFffffFFFF)
          elif valueType == 'S':  # signed integer type
              print(timelineEvents[2].getValue())
          elif valueType == 'F':  # floating point (double) type
              print(timelineEvents[2].getFloatValue())
        """
        return _connect.CProfilerTimeEvent_getValue(self)

    def getSignedValue(self):
        r"""
        Deprecated: use getValue().

        Returns value of integer variable or digital AUX port, 0 for functions.
        """
        return _connect.CProfilerTimeEvent_getSignedValue(self)

    def getFloatValue(self):
        r"""
        Returns float value of float variables and analog AUX ports,
        0 for functions.
        """
        return _connect.CProfilerTimeEvent_getFloatValue(self)

    def getUnit(self):
        r"""Returns unit of analog AUX port, empty string for all other areas."""
        return _connect.CProfilerTimeEvent_getUnit(self)

    def getTime(self):
        r"""Returns time of event."""
        return _connect.CProfilerTimeEvent_getTime(self)

    def getEventSource(self):
        r"""Returns source of event or -1 if it does not exist for an event."""
        return _connect.CProfilerTimeEvent_getEventSource(self)

    def toString(self):
        r"""Returns string representation of this object."""
        return _connect.CProfilerTimeEvent_toString(self)

    def __init__(self):
        _connect.CProfilerTimeEvent_swiginit(self, _connect.new_CProfilerTimeEvent())
    __swig_destroy__ = _connect.delete_CProfilerTimeEvent

# Register CProfilerTimeEvent in _connect:
_connect.CProfilerTimeEvent_swigregister(CProfilerTimeEvent)
class CProfilerTimelineIterator(object):
    r"""
    This class implements iterator for profiler time-line events. Only one
    iterator may iterate the events at a time, because the events are
    not stored in memory, but are sequentially parsed from a file.


    Python example: _sample_link{profiler_data}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hasNext(self):
        r"""
         Returns true, if there is at least one more time-line item available.


        Python example: _sample_link{profiler_data}
        """
        return _connect.CProfilerTimelineIterator_hasNext(self)

    def next(self):
        r"""
        Returns the next time-line item. Do not call this method if hasNext()
        returned ``false!``


        Python example: _sample_link{profiler_data}
        """
        return _connect.CProfilerTimelineIterator_next(self)
    __swig_destroy__ = _connect.delete_CProfilerTimelineIterator

# Register CProfilerTimelineIterator in _connect:
_connect.CProfilerTimelineIterator_swigregister(CProfilerTimelineIterator)
class CProfilerData2(object):
    r"""
    This class provides access to profiler measurements. It parses XML export
    file and returns the parsed data through method calls. Since profiler export
    files may be very large - hundreds of megabytes or even gigabytes, this
    class parses one time-line item per iterator function call.

    To get instance of this class call one of createInstance() factory methods.


    Profiler data consists of three groups:
    - areas contain information about item, which was profiled:
            function name, variable name, variable value,
            source line, ... Each area also has an identifier value called **handle**.
            Information for area is stored in class CProfilerArea2.
    - statistics group contains statistics (min, max, average) of measurements for areas.
                 In general each area has its statistics item. If there are more
                 execution contexts, statistics is measured for each of them.
                 Information for statistics is stored in class CProfilerStatistics2.
    - time-line group contains events for areas as they have happened during recording.
               Each time-line event contains time stamp and handle, among other data.
               The handle identifies the area, for which the event was recorded.
               Information for time-line events is stored in class CProfilerTimeEvent.

    Items in all groups are identified by handles.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def createInstance(*args):
        r"""
        *Overload 1:*

        This factory method exports data to file, then parses statistics information,
        and returns initialized object.
        Use it, when you've just recorded data (have CProfilerController2 object
        available), and have not exported it yet. Note also that this method is not
        as flexible as direct export and
        method createInstance(fileName, isBinaryTimeline).


        **Note**: if ``exportFileName`` is relative, it is saved relative to
        the workspace directory, not the script working directory. This method
        tries to do its best to open the saved file, but if winIDEA is on remote
        host, it will fail. In such cases try to export the profiler data with
        CProfilerController2::exportData() and use
        the overloaded method ``createInstance(fileName)`` instead.

        :type profilerCtrl: :py:class:`CProfilerController2`
        :param profilerCtrl: profiler document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :type isTimeline: boolean
        :param isTimeline: if true, time-line is also exported. Note that this may
                              produce very large files in terms of gigabytes, so use it only
                              when needed.

        :type funcAreaNames: string
        :param funcAreaNames: contains function areas separated by spaces to be
                                 exported. If '*' is specified, all function areas are
                                 exported. If empty, no function areas are exported.

        :type dataAreaNames: string
        :param dataAreaNames: contains data areas separated by spaces to be
                                 exported. If '*' is specified, all data areas are exported.
                                 If empty, no data areas are exported.

        Python example: _sample_link{profiler_data_2,test_has_area}

        |

        *Overload 2:*

        See also: createInstance(isys::CProfilerController2SPtr, const std::string &, bool,
                            const std::string &, const std::string &) for description.

        :type profilerCtrl: :py:class:`CProfilerController2`
        :param profilerCtrl: profiler document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :type isTimeline: boolean
        :param isTimeline: if true, time-line is also exported. Note that this may
                              produce very large files in terms of gigabytes, so use it only
                              when needed.

        :type funcAreaNames: string
        :param funcAreaNames: contains function areas separated by spaces to be
                                 exported. If '*' is specified, all function areas are
                                 exported. If empty, no function areas are exported.

        :type dataAreaNames: string
        :param dataAreaNames: contains data areas separated by spaces to be
                                 exported. If '*' is specified, all data areas are exported.
                                 If empty, no data areas are exported.

        :type exportPNameMode: int
        :param exportPNameMode: defines if download file name is appended to area names or not

        |

        *Overload 3:*

        This factory method parses statistic information from profiler XML
        export file and returns initialized object.

        :type fileName: string
        :param fileName: name of the file with profiler XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :type isBinaryTimeline: boolean, optional
        :param isBinaryTimeline: if true, time-line data is read from binary file.
                                    Set this parameter to true when export file
                                    was created with
                                    CProfilerXMLExportFormat::setTimelineBinary(true).

        Python example: _sample_link{profiler_data_2,test_has_area}

        |

        *Overload 4:*

        This factory method parses statistic information from profiler XML
        export file and returns initialized object.

        :type fileName: string
        :param fileName: name of the file with profiler XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :param isBinaryTimeline: if true, time-line data is read from binary file.
                                    Set this parameter to true when export file
                                    was created with
                                    CProfilerXMLExportFormat::setTimelineBinary(true).

        Python example: _sample_link{profiler_data_2,test_has_area}
        """
        return _connect.CProfilerData2_createInstance(*args)

    def getParserWarnings(self):
        r"""
        This method returns warnings related to input XML document. If there
        were no warnings, an empty string is returned. Always call this method
        after createInstance(). If XML document is made with newer version of winIDEA
        than SDK, it will warn you about possible missing info.

        Python example: _sample_link{profiler_data_2,test_get_parser_warnings}
        """
        return _connect.CProfilerData2_getParserWarnings(self)

    def closeParser(self):
        r"""
        This method releases parser resources and closes XML file. It is
        recommended to call this method always after CProfilerTimelineIterator
        is no longer used. It must be called always when there is time-line data
        available, but we didn't fetch all time-line items
        (CProfilerTimelineIterator.hasNext() did not return false). Otherwise the
        XML file remains opened and can not be ovewritten or deleted until the
        application exits.

        Python example: _sample_link{profiler_data_2,test_create_close_instance}
        """
        return _connect.CProfilerData2_closeParser(self)

    def getBinTimelineEventSize(self):
        r"""
        Returns number of bytes for one event in profiler binary timeline.
        This value can be used to get the number of events in timeline, if
        you know the size of binary timeline file.
        Python example: _sample_link{profiler_data_2,test_bin_timeline}
        """
        return _connect.CProfilerData2_getBinTimelineEventSize(self)

    def getBinTimelineFileSize(self):
        r"""
        Returns size of file containing binary timeline. If timeline
        is defined in XML, not in binary file, IllegalStateException is
        thrown.
        Python example: _sample_link{profiler_data_2,test_bin_timeline}
        """
        return _connect.CProfilerData2_getBinTimelineFileSize(self)

    def getTotalSessionTimeNs(self):
        r"""
        Returns total session time in nanoseconds.
        Python example: _sample_link{profiler_data_2,test_get_total_session_time_ns}
        """
        return _connect.CProfilerData2_getTotalSessionTimeNs(self)

    def getContextIterator(self):
        r"""
        Deprecated: this method will be removed or changed in one of
                    future releases

        Returns iterator for contexts. Use this method to get all recorded
        contexts (tasks, threads, ISRs, ...).
        """
        return _connect.CProfilerData2_getContextIterator(self)

    def getAreaIterator(self, areaType):
        r"""
        Returns iterator for areas. Use this method to get all recorded areas.

        Python example: _sample_link{profiler_data_2,test_get_area_iterator}
        """
        return _connect.CProfilerData2_getAreaIterator(self, areaType)

    def hasArea(self, *args):
        r"""
        *Overload 1:*

        Returns true, if the given area exists in profiler recording.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: _sample_link{profiler_data_2,test_has_area}

        |

        *Overload 2:*

        Deprecated: Use hasArea(string areaQName) instead.

        Returns true, if the given area exists in profiler recording.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: function, variable or AUX name with full path.
                            If area type
                            is EStateVariables, or EStateAUX, then areaName
                            is taken from type definition in recording. If
                            the definition is not set, name of state var
                            is empty and we can not search for it.
                            Use getArea(EAreaType, std::string, DWORD)
                            in such case. See also
                            CProfilerController2::addStateVariable().
        """
        return _connect.CProfilerData2_hasArea(self, *args)

    def getArea(self, *args):
        r"""
        *Overload 1:*

        Returns profiler area for the given id.

        Python example: _sample_link{profiler_data_2,test_get_area}

        |

        *Overload 2:*

        Returns profiler area for the given qualified area name.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: _sample_link{profiler_data_2,test_get_area}

        |

        *Overload 3:*

        Deprecated: if there is more than one area with the same name, this
        method returns the first one only. Use getArea(string areaQName) instead.

        Returns area of the given type and with the given name. If
        ``areaType`` is
        ``EStateVariables`` or ``EStateAUX``, then
        area of the first value detected is returned.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: function, variable or AUX name with full path.
                            If area type
                            is EStateVariables, or EStateAUX, then areaName
                            is taken from type definition in recording. If
                            the definition is not set, name of state var
                            is empty and we can not search for it.
                            Use getArea(EAreaType, std::string, DWORD)
                            in such case. See also
                            CProfilerController2::addStateVariable().


        |

        *Overload 4:*

        Returns profiler state area for the given type, parent
        name and state value.

        :type areaType: int
        :param areaType: may be EStateVariables, or EStateAUX

        :type areaPath: string
        :param areaPath: path to area without area name, for example
                            name of the state variable or function.

        :type valueOrLineNumber: int
        :param valueOrLineNumber: value of the state variable or function line number

        Python example: _sample_link{profiler_data_2,test_get_area}

        |

        *Overload 5:*

        Deprecated: if there is more than one area with the same name, this
        method returns the first one only. Use getArea(string areaQName) instead.

        Returns profiler state area for the given type, parent name and state name.

        :type areaType: int
        :param areaType: may be EStateVariables, or EStateAUX

        :type areaPath: string
        :param areaPath: path to area without area name, for example
                            name of the state variable or function.

        :type stateAreaName: string
        :param stateAreaName: name of enum state value or function line number source code


        |

        *Overload 6:*

        Returns state area for the given value.

        :type areaPath: string
        :param areaPath: path to area without area name, for example
                            name of the state variable or function.
        :type valueOrLineNumber: int
        :param valueOrLineNumber: value for state variables, line number for lines

        Python example: _sample_link{profiler_data_2,test_get_area}
        """
        return _connect.CProfilerData2_getArea(self, *args)

    def hasStatisticsForArea(self, *args):
        r"""
        *Overload 1:*

        Returns true, if statistics for the given area exists.

        Python example: _sample_link{profiler_data_2,test_has_statistics_for_area}

        |

        *Overload 2:*

        Returns true, if statistics for the given area exists.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: _sample_link{profiler_data_2,test_has_statistics_for_area}

        |

        *Overload 3:*

        Deprecated: Use hasStatisticsForArea(string areaQName) instead.

        Returns true, if statistics for the given area exists.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: qualified area name, which includes path
                            and area name (for example name of function or variable).
        """
        return _connect.CProfilerData2_hasStatisticsForArea(self, *args)

    def hasStatisticsForStateArea(self, *args):
        r"""
        *Overload 1:*

        Deprecated: use hasStatisticsForStateArea(const std::string &areaPath,
                                                  int64_t value)

        Returns true, if statistics for the given state area exists.

        :type areaType: int
        :param areaType: type of area
        :type parentAreaName: string
        :param parentAreaName: name of parent area
        :type value: int
        :param value: state value


        |

        *Overload 2:*

        Returns true, if statistics for the given state area exists.

        :type areaPath: string
        :param areaPath: path to area, without area name
        :type value: int
        :param value: state value

        Python example: _sample_link{profiler_data_2,test_has_statistics_for_state_area}
        """
        return _connect.CProfilerData2_hasStatisticsForStateArea(self, *args)

    def getStatistics(self, *args):
        r"""
        *Overload 1:*

        Returns statistics for the specified area Id. If it is function
        area, then this method returns statistics for context 'Neutral',
        if it exists. If it does not exist, an exception is thrown.
        For other contexts use method getStatistics(id, contextName).

        :type id: int
        :param id: area ID. Use ``getArea(type, funcOrVarName).getAreaId()``
                      to get the ID.

        Python example: _sample_link{profiler_data_2,test_get_statistics}

        |

        *Overload 2:*

        Returns statistics for the specified qualified area name.

        :type areaQName: string
        :param areaQName: qualified area name consisting of path and name.

        Python example: _sample_link{profiler_data_2,test_get_statistics}

        |

        *Overload 3:*

        Deprecated: if there is more than one area with the same name, this
        method returns stats for the first one only.
        Use getStatistics(string areaQName) instead.

        Returns statistics for the specified function or variable area.
        This is a convenience method - for
        best performance use ``getStatistics(id)``.

        :type areaType: int
        :param areaType: area type
        :type areaName: string
        :param areaName: qualified area name, which includes path
                            and area name (for example name of function or variable).

        Python example: _sample_link{profiler_data_2,test_get_statistics}

        |

        *Overload 4:*

        Deprecated: use getStatistics(const std::string &areaPath, int64_t value);
                    instead.
        Returns statistics for the specified state area. This is a
        convenience method - for best performance use
        ``getStatistics(id)``.

        :type areaType: int
        :param areaType: are type may be EStateVariables, or EStateAUX
        :type parentAreaName: string
        :param parentAreaName: path to area without area name
        :type value: int
        :param value: value of the state variable to get statistics for


        |

        *Overload 5:*

        Returns statistics for the specified state area. This is a
        convenience method - for best performance use
        ``getStatistics(id)``.

        :type areaPath: string
        :param areaPath: path to area without area name
        :type value: int
        :param value: value of the state variable to get statistics for

        Python example: _sample_link{profiler_data_2,test_get_statistics}
        """
        return _connect.CProfilerData2_getStatistics(self, *args)

    def hasStatisticsForFunction(self, *args):
        r"""
        *Overload 1:*

        Returns true, if the specified area was recorded in
        the specified context.

        :type id: int
        :param id: area ID. Use ``getArea(type, funcOrVarName).getAreaId()``
                      to get the ID.
        :type contextName: string
        :param contextName: name of the context.

        :raises: IllegalArgumentException if area with the given ID does not exist.

        Python example: _sample_link{profiler_data_2,test_has_statistics_for_function}

        |

        *Overload 2:*

        Returns true, if the specified area was recorded in the specified
        context.

        :type areaType: int
        :param areaType: area type must be EFunctions. EFunctionLines is
                            deprecated since 9.17.36.
        :type areaName: string
        :param areaName: name of function
        :type contextName: string
        :param contextName: name of the context.

        :raises: IllegalArgumentException if area with the given type and name
                                            does not exist.

        Python example: _sample_link{profiler_data_2,test_has_statistics_for_function}
        """
        return _connect.CProfilerData2_hasStatisticsForFunction(self, *args)

    def getStatisticsForFunction(self, *args):
        r"""
        *Overload 1:*

        Returns statistics for the specified function area Id and context.
        Use this method when profiler data was exported with context set
        to 'All' or 'Current' (see CProfilerExportConfig::setContextScope()).
        If profiler data was exported with context 'Neutral', then specify
        'Neutral' as context name or use method getStatistics(id).

        :type id: int
        :param id: area ID. Use ``getArea(type, funcOrVarName).getAreaId()``
                      to get the ID.
        :type contextName: string
        :param contextName: name of the context.

        Python example: _sample_link{profiler_data_2,test_get_statistics_for_function}

        |

        *Overload 2:*

        Returns statistics for the specified function area and context.
        Use this method when profiler data was exported with context set
        to 'All' or 'Current' (see CProfilerExportConfig::setContextScope()).
        If profiler data was exported with context 'Neutral', then specify
        'Neutral' as context name or use method getStatistics(id).

        :type areaType: int
        :param areaType: area type must be EFunctions. EFunctionLines is
                            deprecated since 9.17.36.
        :type areaName: string
        :param areaName: name of function
        :type contextName: string
        :param contextName: name of the context.

        Python example: _sample_link{profiler_data_2,test_get_statistics_for_function}
        """
        return _connect.CProfilerData2_getStatisticsForFunction(self, *args)

    def getContexts(self, contexts):
        r"""
        Fills the given list with all contexts found in profiler results.

        :type contexts: :py:class:`StrVector`
        :param contexts: vector of strings to receive contexts.

        Python example: _sample_link{profiler_data_2,test_get_contexts}
        """
        return _connect.CProfilerData2_getContexts(self, contexts)

    def getTimelineIterator(self, *args):
        r"""
        *Overload 1:*

        Returns iterator, which will iterate all time-line events of the given type.
        The iterator maintains reference to this object, so multiple
        iterators will modify the same time-line parser state. When data is exhausted,
        create new instance of CProfilerData2 class to iterate again.

        Python example: _sample_link{profiler_data_2,test_get_timeline_iterator}

        |

        *Overload 2:*

        Returns iterator, which will iterate time-line events for area with the given handle.
        The iterator maintains reference to this object, so multiple
        iterators will modify the same time-line parser state. When data is exhausted,
        create new instance of CProfilerData2 class to iterate again.

        Python example: _sample_link{profiler_data_2,test_get_timeline_iterator}

        |

        *Overload 3:*

        Returns iterator, which will iterate time-line events for state
        area with the given handle and value.
        The iterator maintains reference to this object, so multiple
        iterators will modify the same time-line parser state. When data is exhausted,
        create new instance of CProfilerData2 class to iterate again.

        Python example: _sample_link{profiler_data_2,test_get_timeline_iterator}
        """
        return _connect.CProfilerData2_getTimelineIterator(self, *args)

    def getCallStackStatistics(self, *args):
        return _connect.CProfilerData2_getCallStackStatistics(self, *args)

    def getCallStackStatisticsForFunction(self, handle, contextName, callStack):
        return _connect.CProfilerData2_getCallStackStatisticsForFunction(self, handle, contextName, callStack)

    def getCallStackStatisticsIter(self, *args):
        return _connect.CProfilerData2_getCallStackStatisticsIter(self, *args)

    def getCallStackStatisticsIterForFunction(self, handle, contextName):
        return _connect.CProfilerData2_getCallStackStatisticsIterForFunction(self, handle, contextName)
    __swig_destroy__ = _connect.delete_CProfilerData2

# Register CProfilerData2 in _connect:
_connect.CProfilerData2_swigregister(CProfilerData2)
class CProfilerFormatBase(object):
    r"""
    This is abstract base class for profiler export format containers.
    Expand inheritance diagram below and click derived classes to see
    formatting options for each of available formats.

    See also: CProfilerExportConfig::setFormatter()
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EFmtXML = _connect.CProfilerFormatBase_EFmtXML
    r"""export as XML"""
    EFmtText1 = _connect.CProfilerFormatBase_EFmtText1
    r"""
    export as formatted text, see options with
    'ProfilerExport.Export.Text1.*' in URL
    """
    EFmtBTF = _connect.CProfilerFormatBase_EFmtBTF
    r"""export as BTF"""
    EFmtMDF = _connect.CProfilerFormatBase_EFmtMDF
    r"""export as MDF"""
    EFmtHTML = _connect.CProfilerFormatBase_EFmtHTML
    r"""export as HTML"""

    def __init__(self, exportFormat):
        _connect.CProfilerFormatBase_swiginit(self, _connect.new_CProfilerFormatBase(exportFormat))
    __swig_destroy__ = _connect.delete_CProfilerFormatBase

    def getExportFormat(self):
        r"""Returns profiler export format."""
        return _connect.CProfilerFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self):
        r"""
        Returns string containing export format, which can be used for
        setting of option
        '/Document/<file name>/ProfilerExport.Scope.Type'

        See also: setAreaScope()
        """
        return _connect.CProfilerFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide, docFileName):
        r"""Sets export configuration options in winIDEA."""
        return _connect.CProfilerFormatBase_setOptions(self, ide, docFileName)

# Register CProfilerFormatBase in _connect:
_connect.CProfilerFormatBase_swigregister(CProfilerFormatBase)
class CProfilerTextExportFormat(CProfilerFormatBase):
    r"""This class configures format of Text export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerTextExportFormat_swiginit(self, _connect.new_CProfilerTextExportFormat())
    __swig_destroy__ = _connect.delete_CProfilerTextExportFormat

# Register CProfilerTextExportFormat in _connect:
_connect.CProfilerTextExportFormat_swigregister(CProfilerTextExportFormat)
class CProfilerText1ExportFormat(CProfilerFormatBase):
    r"""
    This class configures format of Text1 export. It does not have
    methods for setting specific options, but two generic methods,
    which can be used to set/get ant option at URL
    ``/Document/``<docName>/ProfilerExport.Export.Text1.*

    See winIDEA menu ``Help | Display Option ...``
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerText1ExportFormat_swiginit(self, _connect.new_CProfilerText1ExportFormat())

    def setOption(self, profiler, option, value):
        r"""
        Sets option specific to this export format. Option is set
        immediately in this method - there is no need to call method
        setOptions().

        :type profiler: :py:class:`CProfilerController2`
        :param profiler: opened profiler document controller

        :type option: string
        :param option: option URL identifying Text1 export option,
                          for example: 'FileHeader'. The URL prefix is
                          automatically prepended by this method. See
                          winIDEA Help | Display Option ..., document options.

        :type value: string
        :param value: value to set.
        """
        return _connect.CProfilerText1ExportFormat_setOption(self, profiler, option, value)

    def getOption(self, profiler, option):
        r"""Returns value of the given option from winIDEA settings."""
        return _connect.CProfilerText1ExportFormat_getOption(self, profiler, option)
    __swig_destroy__ = _connect.delete_CProfilerText1ExportFormat

# Register CProfilerText1ExportFormat in _connect:
_connect.CProfilerText1ExportFormat_swigregister(CProfilerText1ExportFormat)
class CProfilerCSVExportFormat(CProfilerFormatBase):
    r"""This class configures format of CSV export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerCSVExportFormat_swiginit(self, _connect.new_CProfilerCSVExportFormat())

    def setDelimiter(self, delimiter):
        r"""Sets CSV field delimiter. Default: ','."""
        return _connect.CProfilerCSVExportFormat_setDelimiter(self, delimiter)

    def getDelimiter(self):
        r"""Returns CSV field delimiter."""
        return _connect.CProfilerCSVExportFormat_getDelimiter(self)

    def setOptions(self, ide, docFileName):
        r"""Writes options to winIDEA."""
        return _connect.CProfilerCSVExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerCSVExportFormat

# Register CProfilerCSVExportFormat in _connect:
_connect.CProfilerCSVExportFormat_swigregister(CProfilerCSVExportFormat)
class CProfilerXMLExportFormat(CProfilerFormatBase):
    r"""This class configures format of XML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerXMLExportFormat_swiginit(self, _connect.new_CProfilerXMLExportFormat())

    def setTimelineBinary(self, isTimelineBinary):
        r"""
        If set to ``true``, and time-line export is enabled (see setSaveTimeline()),
        profiler areas and statistics are exported in
        XML format, while time-line is exported in separate file in
        binary format. For small amounts of data, and when human
        readability or printing is desired, leave this at default
        value (``false)``. For long recordings the binary export is
        much faster and files are much smaller.
        Binary file name is
        <origFileName>.BIN, for example ``myExport.xml.BIN``.
        Default: false.

        :type isTimelineBinary: boolean
        :param isTimelineBinary: timeline setting
        """
        return _connect.CProfilerXMLExportFormat_setTimelineBinary(self, isTimelineBinary)

    def setUseIndent(self, isUseIndent):
        r"""
        If set to true, XML file is produced with indented elements.
        This improves readability, but produces about 20% larger files.
        If files will be processed by tools, leave this setting at the
        default value.
        Default: false.
        """
        return _connect.CProfilerXMLExportFormat_setUseIndent(self, isUseIndent)

    def isTimelineBinary(self):
        r"""
        Returns true, if time-line will be exported in binary format.
        See also: setTimelineBinary()
        """
        return _connect.CProfilerXMLExportFormat_isTimelineBinary(self)

    def isUseIndent(self):
        r"""
        Returns true, if indentation will be used in XML export.
        See also: setUseIndent()
        """
        return _connect.CProfilerXMLExportFormat_isUseIndent(self)

    def setOptions(self, ide, docFileName):
        r"""Writes options to winIDEA."""
        return _connect.CProfilerXMLExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CProfilerXMLExportFormat

# Register CProfilerXMLExportFormat in _connect:
_connect.CProfilerXMLExportFormat_swigregister(CProfilerXMLExportFormat)
class CProfilerBTFExportFormat(CProfilerFormatBase):
    r"""This class configures format of BTF export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerBTFExportFormat_swiginit(self, _connect.new_CProfilerBTFExportFormat())
    __swig_destroy__ = _connect.delete_CProfilerBTFExportFormat

# Register CProfilerBTFExportFormat in _connect:
_connect.CProfilerBTFExportFormat_swigregister(CProfilerBTFExportFormat)
class CProfilerMDFExportFormat(CProfilerFormatBase):
    r"""This class configures format of MDF export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerMDFExportFormat_swiginit(self, _connect.new_CProfilerMDFExportFormat())
    __swig_destroy__ = _connect.delete_CProfilerMDFExportFormat

# Register CProfilerMDFExportFormat in _connect:
_connect.CProfilerMDFExportFormat_swigregister(CProfilerMDFExportFormat)
class CProfilerHTMLExportFormat(CProfilerFormatBase):
    r"""This class configures format of HTML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CProfilerHTMLExportFormat_swiginit(self, _connect.new_CProfilerHTMLExportFormat())
    __swig_destroy__ = _connect.delete_CProfilerHTMLExportFormat

# Register CProfilerHTMLExportFormat in _connect:
_connect.CProfilerHTMLExportFormat_swigregister(CProfilerHTMLExportFormat)
class CProfilerExportConfig(object):
    r"""
    This class contains configuration for export of profiler
    measurements. All setters return reference to ``this``, so
    we can chain calls to set values, for example:


    cfg = CProfilerExportFormat().setFileName('profilerResult.xml')
                                 .setTimeScope(CProfilerExportFormat::ETimeAll)
                                 .setAreaScope(CProfilerExportFormat::EAreaAll);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EContextAll = _connect.CProfilerExportConfig_EContextAll
    r"""
    functions are exported for all contexts.
    Statistics contains information about time spent
    in each context (IRQ, task).
    """
    EContextNeutral = _connect.CProfilerExportConfig_EContextNeutral
    r"""
    functions are exported without context info,
    times in statistics are sumed for all contexts
    """
    EContextCurrent = _connect.CProfilerExportConfig_EContextCurrent
    r"""
    export only context specified with
    call setContextFilter().
    """
    EAreaAll = _connect.CProfilerExportConfig_EAreaAll
    r"""all areas are exported"""
    EAreaFilter = _connect.CProfilerExportConfig_EAreaFilter
    r"""
    export only areas specified with calls
    to setFunctionsFilter(), setVariablesFilter(),
    and setAUXFilter().
    """
    ETimeAll = _connect.CProfilerExportConfig_ETimeAll
    r"""export recorded samples regardless of timestamp"""
    ETimeBetweenMarkers = _connect.CProfilerExportConfig_ETimeBetweenMarkers
    r"""
    export only samples between times specified
    with call to setTimeFilter()
    """
    EPNameAuto = _connect.CProfilerExportConfig_EPNameAuto
    r"""
    partition name is appended only if there is more than
    one download file (partition) in the project
    """
    EPNameAlways = _connect.CProfilerExportConfig_EPNameAlways
    r"""partition name is appended always"""
    EPNameNever = _connect.CProfilerExportConfig_EPNameNever
    r"""partition name is never appended"""
    EPNameConfigName = _connect.CProfilerExportConfig_EPNameConfigName

    def __init__(self):
        r"""
        Constructs object with default settings, as described with each method.

        Python example: _sample_link{profiler_controller}
        """
        _connect.CProfilerExportConfig_swiginit(self, _connect.new_CProfilerExportConfig())

    def setFileName(self, fileName):
        r"""
        Sets the name of the exported file. If this method is not called, or
        ``fileName`` is empty string, then the existing export file name in
        winIDEA is used.

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CProfilerExportConfig_setFileName(self, fileName)

    def setFormatter(self, formatter):
        r"""
        Sets formatter object, which configures export file format. If this
        method is not called, XML formatter with default settings is used.
        Example:


            formatter = ic.CProfilerXMLExportFormat()
            formatter.setUseIndent(False).setTimelineBinary(False)
            exportCfg.setFormatter(formatter)


        See also: CProfilerFormatBase
        """
        return _connect.CProfilerExportConfig_setFormatter(self, formatter)

    def setAreaScope(self, areaScope):
        r"""
        Sets the area scope (default: EAreaAll).

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CProfilerExportConfig_setAreaScope(self, areaScope)

    def setExportActiveAreasOnly(self, isExportActiveAreasOnly):
        r"""
        Sets areas to export.

        :type isExportActiveAreasOnly: boolean
        :param isExportActiveAreasOnly: if true, only areas with recorded activity are exported,
                                           otherwise all configured areas are exported.
        """
        return _connect.CProfilerExportConfig_setExportActiveAreasOnly(self, isExportActiveAreasOnly)

    def setAreaExportSections(self, *args):
        r"""
        *Overload 1:*

        If area scope is set to ``EAreaAll`` (see method setAreaScope()),
        then this method defines better granularity, so that some
        types of areas are not exported. If this method is not called,
        all flags are set to ``true`` by default.

        :type isExportFunctions: boolean
        :param isExportFunctions: if true, function areas are exported.
        :type isExportData: boolean
        :param isExportData: if true, data areas are exported
        :type isExportAUX: boolean
        :param isExportAUX: if true, AUX data is exported

        |

        *Overload 2:*

        Deprecated: since winIDEA 9.12.36 line information is no longer available. If
        'isExportLines' is set to true, an exception is thrown. Use overload
        setAreaExportSections(bool, bool, bool) instead.
        """
        return _connect.CProfilerExportConfig_setAreaExportSections(self, *args)

    def setTimeScope(self, timeScope):
        r"""Sets the time scope (default: ETimeAll)."""
        return _connect.CProfilerExportConfig_setTimeScope(self, timeScope)

    def setFunctionsFilter(self, namesOfFunctions):
        r"""
        Sets names of functions for which profiler measurements should be
        exported (default: empty). This setting is used only if
        ara scope is set to EAreaFilter (see setAreaScope()).

        :type namesOfFunctions: string
        :param namesOfFunctions: names of functions for which profiler measurements should be
                                    exported to file. Functions names should be separated by spaces,
                                    for example ``'func1 func2 func3'``

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CProfilerExportConfig_setFunctionsFilter(self, namesOfFunctions)

    def setVariablesFilter(self, namesOfVariables):
        r"""
        Sets names of variables for which profiler measurements should be
        exported  (default: empty). This setting is used only if
        ara scope is set to EAreaFilter (see setAreaScope()).

        :type namesOfVariables: string
        :param namesOfVariables: names of variables for which
                                    profiler measurements should be
                                    exported to file. Names of
                                    variables should be separated by
                                    spaces, for example ``'var1
                                    var2 var3'``
        """
        return _connect.CProfilerExportConfig_setVariablesFilter(self, namesOfVariables)

    def setAUXFilter(self, namesOfIOPorts):
        r"""
        Sets names of IO ports for which profiler measurements should be
        exported (default: empty). This setting is used only if
        ara scope is set to EAreaFilter (see setAreaScope()).

        :type namesOfIOPorts: string
        :param namesOfIOPorts: names of IO ports from IO module for which
                                  profiler measurements should be
                                  exported to file. Names of
                                  the ports should be separated by
                                  spaces, for example ``'port1
                                  port2 port3'``
        """
        return _connect.CProfilerExportConfig_setAUXFilter(self, namesOfIOPorts)

    def setTimeFilter(self, startTime, endTime):
        r"""
        Sets time-frame for which profiler measurements should be exported
        (default: both times are set to 0, but are not used if
        setTimeScope(ETimeBetweenMarkers) is not called). 

        To export measurements before trigger, times must be negative. Trigger
        has timestamp 0.

        :type startTime: int
        :param startTime: start of measurements to export relative to trigger

        :type endTime: int
        :param endTime: end of measurements to export. If greater than the timestamp
                           of the last sample, all samples from ``startTime`` to the end
                           are exported.
        """
        return _connect.CProfilerExportConfig_setTimeFilter(self, startTime, endTime)

    def setContextFilter(self, contextToExport):
        r"""
        Sets context for which profiler measurements should be exported
        (default: empty). Only one context may be specified at a time. 


        :type contextToExport: string
        :param contextToExport: name of the context to export, for example
            ``'TSK: InitTask'``, or ``'IRQ: Timer'``. Prefix
            ``TSK`` should be used for tasks, ``IRQ`` for interrupts.
        """
        return _connect.CProfilerExportConfig_setContextFilter(self, contextToExport)

    def setLaunchViewer(self, isLaunchViewer):
        r"""
        If set to ``true``, launches the system default
        viewer for the specified document type after export, for example
        notepad for text documents (default: false).
        """
        return _connect.CProfilerExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setSaveStatistics(self, isSaveStatistics):
        r"""If set to ``true``, statistics data is exported to file (default: true)."""
        return _connect.CProfilerExportConfig_setSaveStatistics(self, isSaveStatistics)

    def setSaveInfo(self, isSaveInfo):
        r"""Deprecated: 9.17.81, Sept. 2018. Had no effect in the past, so there is no replacement."""
        return _connect.CProfilerExportConfig_setSaveInfo(self, isSaveInfo)

    def setSaveTimeline(self, isSaveTimeline):
        r"""
        If set to ``true``, time-line data is exported (default: false).

        Python example: _sample_link{profiler_controller}
        """
        return _connect.CProfilerExportConfig_setSaveTimeline(self, isSaveTimeline)

    def setContextScope(self, saveContext):
        r"""Sets context to be exported to file (default: EContextNeutral)."""
        return _connect.CProfilerExportConfig_setContextScope(self, saveContext)

    def setExportPartitionNameMode(self, exportPartNameMode):
        r"""Sets when download file name should be appended to exported area names."""
        return _connect.CProfilerExportConfig_setExportPartitionNameMode(self, exportPartNameMode)

    def getFileName(self):
        r"""Returns profiler file name."""
        return _connect.CProfilerExportConfig_getFileName(self)

    def getAreaScope(self):
        r"""Returns profiler area scope."""
        return _connect.CProfilerExportConfig_getAreaScope(self)

    def isExportFunctions(self):
        r"""
        Returns export flag for functions area.

        See also: setAreaExportSections()
        """
        return _connect.CProfilerExportConfig_isExportFunctions(self)

    def isExportLines(self):
        r"""
        Deprecated: since 9.12.36 profiler function lines are no longer supported.
        Always returns false.
        """
        return _connect.CProfilerExportConfig_isExportLines(self)

    def isExportData(self):
        r"""
        Returns export flag for data area.

        See also: setAreaExportSections()
        """
        return _connect.CProfilerExportConfig_isExportData(self)

    def isExportAUX(self):
        r"""
        Returns export flag for AUX area.

        See also: setAreaExportSections()
        """
        return _connect.CProfilerExportConfig_isExportAUX(self)

    def isExportActiveAreasOnly(self):
        r"""
        Returns true, if only areas with recorded activity will be exported.
        Returns false, if all configured areas will be exported.

        See also: setExportActiveAreasOnly()
        """
        return _connect.CProfilerExportConfig_isExportActiveAreasOnly(self)

    def getTimeScope(self):
        r"""Returns profiler time scope."""
        return _connect.CProfilerExportConfig_getTimeScope(self)

    def getFunctionsFilter(self):
        r"""
        Returns a list of functions to be exported. Function names are
        separated by spaces.
        """
        return _connect.CProfilerExportConfig_getFunctionsFilter(self)

    def getVariablesFilter(self):
        r"""
        Returns a list of variables to be exported. Names of variables are
        separated by spaces.
        """
        return _connect.CProfilerExportConfig_getVariablesFilter(self)

    def getAUXFilter(self):
        r"""
        Returns a list of IO ports to be exported. Names of ports are
        separated by spaces.
        """
        return _connect.CProfilerExportConfig_getAUXFilter(self)

    def getStartTime(self):
        r"""Returns export start time."""
        return _connect.CProfilerExportConfig_getStartTime(self)

    def getEndTime(self):
        r"""Returns export and time."""
        return _connect.CProfilerExportConfig_getEndTime(self)

    def getContextFilter(self):
        r"""
        Returns context filter.

        See also: setContextFilter(), setContextScope()
        """
        return _connect.CProfilerExportConfig_getContextFilter(self)

    def isLaunchViewer(self):
        r"""Returns true, if viewer will be launched after export."""
        return _connect.CProfilerExportConfig_isLaunchViewer(self)

    def isSaveStatistics(self):
        r"""Returns true, if profiler statistics should be exported."""
        return _connect.CProfilerExportConfig_isSaveStatistics(self)

    def isSaveTimeline(self):
        r"""Returns true, if profiler time-line should be exported."""
        return _connect.CProfilerExportConfig_isSaveTimeline(self)

    def isSaveInfo(self):
        r"""
        Deprecated: 9.17.81, Sept. 2018. Had no effect in the past,
        so there is no replacement. Always returns true.
        """
        return _connect.CProfilerExportConfig_isSaveInfo(self)

    def getContextScope(self):
        r"""Returns profiler context to be exported."""
        return _connect.CProfilerExportConfig_getContextScope(self)

    def getExportPartitionNameMode(self):
        r"""Returns setting, which defines when download file name should be appended to exported area names."""
        return _connect.CProfilerExportConfig_getExportPartitionNameMode(self)

    def getFormatter(self):
        r"""Returns formatter object, which configures export file format."""
        return _connect.CProfilerExportConfig_getFormatter(self)

    def getContextScopeAsStr(self):
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Export.ContextScope'

        See also: setContextScope()
        """
        return _connect.CProfilerExportConfig_getContextScopeAsStr(self)

    def getExportPartitionNameModeAsStr(self):
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Export.ExportPartitionName'

        See also: setExportPartitionNameMode()
        """
        return _connect.CProfilerExportConfig_getExportPartitionNameModeAsStr(self)

    def getAreaScopeAsStr(self):
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Scope.AreaScope'

        See also: setAreaScope()
        """
        return _connect.CProfilerExportConfig_getAreaScopeAsStr(self)

    def getTimeScopeAsStr(self):
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/ProfilerExport.Scope.TimeScope'

        See also: setTimeScope()
        """
        return _connect.CProfilerExportConfig_getTimeScopeAsStr(self)

    def setOptions(self, ide, docFileName):
        r"""Writes options to winIDEA."""
        return _connect.CProfilerExportConfig_setOptions(self, ide, docFileName)

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CProfilerExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerExportConfig

# Register CProfilerExportConfig in _connect:
_connect.CProfilerExportConfig_swigregister(CProfilerExportConfig)
class CProfilerController2(CAnalyzerDocController):
    r"""
    This class implements profiler functionality with a document
    oriented interface. It replaces the old CProfilerController,
    which is deprecated now. If you need some functionality from the
    old class, which is missing in this one, please contact iSYSTEM
    support, rather than using the old class. If you use the
    old class, your code will no longer work once the deprecated
    class will be removed in the future versions of ``isystem.connect``.


    Portability list

    CProfilerController()  -->  CProfilerController2()
                                File name and open mode are required.

    getCapabilities()      -->  not implemented in CProfilerController2

    startConfiguration()   -->  use setFunctionTrigger()

    All ``get...()`` methods are implemented in **isys::CProfilerData2** class.


    This class can be used to configure profiler, run recording, and export
    the recorded data. However, it has no methods to get recorded information.
    For this purpose a separate class called CProfilerData2 should be used.


    Use only methods documented for this class. If a method from the base class is
    not documented here, do not use it. 

    **Advanced profiler configuration**

    Most settings for profiler are implemented by setting of winIDEA options.
    Since there are many options, and most of them are target dependent,
    this class provides methods for accessing only the most often used options.
    To see all profiler options, open profiler document in winIDEA, then select
    ``Help | Display Option...``. In the opened dialog select all
    check-boxes, and radio button 'Document'. Then select profiler document in
    the combo box next to the radio button. Click the ``Display'`` button to
    see all profiler options as shown in the image below:

    Image: displayOptionsDialog.png
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ERWRead = _connect.CProfilerController2_ERWRead
    ERWWrite = _connect.CProfilerController2_ERWWrite
    ERWReadOrWrite = _connect.CProfilerController2_ERWReadOrWrite
    EDATState = _connect.CProfilerController2_EDATState
    r"""
    Data area is a state variable. It is supposed to
    have only few values, at most 256. Task ID or state
    in state machine are examples of state variables.
    Statistics will be recoded for each value.
    """
    EDATLsbExitEntry = _connect.CProfilerController2_EDATLsbExitEntry
    EDATZeroExitEntry = _connect.CProfilerController2_EDATZeroExitEntry
    EDATRegular = _connect.CProfilerController2_EDATRegular
    r"""
    Regular variable, can have any number of values,
    but no statistics will be available for each value.
    """
    EStateDefNone = _connect.CProfilerController2_EStateDefNone
    r"""no definition, there will be empty name for state variables"""
    EStateDefDefine = _connect.CProfilerController2_EStateDefDefine
    r"""variable state names will be taken from defines"""
    EStateDefEnum = _connect.CProfilerController2_EStateDefEnum
    r"""variable state names will be taken from enum type"""
    ESingleData = _connect.CProfilerController2_ESingleData
    r"""messages without parameters, for example OTM on PowerPC"""
    ESingleData1 = _connect.CProfilerController2_ESingleData1
    r"""
    messages with parameter, for example ITM on ARM, where
    parameter is channel number.
    """

    def __init__(self, connectionMgr, fileName, mode):
        r"""
        Instantiates object and opens or creates profiler document in
        ``winIDEA``.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type fileName: string
        :param fileName: if not an empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes recordings,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        Python example: _sample_link{profiler_data_2,test_create_close_instance}
        """
        _connect.CProfilerController2_swiginit(self, _connect.new_CProfilerController2(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CProfilerController2

    def createTrigger(self, triggerName):
        r"""
        Creates a new profiler trigger. Trigger contains information about
        what profiler should record (which functions, variables, ...)
        and how to record it (when to start, buffer size, ...).

        :type triggerName: string
        :param triggerName: name of the trigger

        :rtype: int
        :return: index of the created trigger

        :raises: IllegalArgumentException if the trigger already exists

        Python example: _sample_link{profiler_ctrl_2,test_profiler_create_trigger}
        """
        return _connect.CProfilerController2_createTrigger(self, triggerName)

    def setProfilingSections(self, triggerIndex, isProfileCode, isProfileData, isProfileOSObjects, isProfileAUX):
        r"""
        Defines, which sections (code, data, AUX) should be recorded by profiler.
        Please note, that the meaning of flags is different for each section.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()

        :type isProfileCode: boolean
        :param isProfileCode: if ``true``, code execution is recorded. If function list
                                 is empty, (method addFunction() was not called or functions
                                 were removed with one of remove() methods), all functions
                                 will be recorded. If the function list is not empty, only
                                 functions in the list will be recorded.
                                 If ``false``, no functions will be recorded.
        :type isProfileData: boolean
        :param isProfileData: if ``true``, variables added with addVariable() or
                                 addStateVariable() will be recorded. If ``false``,
                                 no variables will be recorded.
        :type isProfileOSObjects: boolean
        :param isProfileOSObjects: if ``true``, OS objects will be recorded. If ``false``
                                 OS objects won't be recorded.
        :type isProfileAUX: boolean
        :param isProfileAUX:  if ``true``, AUX ports will be recorded. If ``false``,
                                 AUX ports won't be recorded.

        Python example: _sample_link{profiler_ctrl_2,test_set_profiling_sections}
        """
        return _connect.CProfilerController2_setProfilingSections(self, triggerIndex, isProfileCode, isProfileData, isProfileOSObjects, isProfileAUX)

    def setFunctionTrigger(self, triggerIndex, functionName):
        r"""
        Sets a function, which will start profiling, when its execution
        starts.
        If trigger is not set, profiling starts immediately when ``start()`` is
        called and target is running.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functionName: string
        :param functionName: name of the function to use as a profiler trigger. If
                                empty string, trigger start is set to ``Anything``.

        Python example: _sample_link{profiler_ctrl_2,test_set_function_trigger}
        """
        return _connect.CProfilerController2_setFunctionTrigger(self, triggerIndex, functionName)

    def addFunction(self, triggerIndex, functionName, isIncludeFunctionLines=False):
        r"""
        Adds function to the list of functions to profile. If the function is
        already in the list, it is not added again.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functionName: string
        :param functionName: name of the function to profile
        :type isIncludeFunctionLines: boolean, optional
        :param isIncludeFunctionLines: since version 9.12.36 this parameter must always be false,
                                          because profiling function lines is no longer supported.

        :rtype: int
        :return: index of profiler option ``ExecArea``, which contains the added function

        Python example: _sample_link{profiler_ctrl_2,test_add_items}
        """
        return _connect.CProfilerController2_addFunction(self, triggerIndex, functionName, isIncludeFunctionLines)

    def addFunctions(self, triggerIndex, functions):
        r"""
        Adds functions to the list of functions to profile. If a function is
        already in the list, it is not added.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functions: :py:class:`StrVector`
        :param functions: list of functions to add
        """
        return _connect.CProfilerController2_addFunctions(self, triggerIndex, functions)

    def addVariable(self, triggerIndex, variableName, dataAreaType):
        r"""
        Adds variable to the list of variables to profile. If the variable is
        already in the list, it is not added, only ``dataAreaType`` of the existing
        entry is set. If it is a state variable, and names of states are known,
        consider using addStateVariable().

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the variable to profile
        :type dataAreaType: int
        :param dataAreaType: type of variable, see CProfilerController2::EDataAreaType

        :rtype: int
        :return: index of DataArea with the added function

        Python example: _sample_link{profiler_ctrl_2,test_add_items}
        """
        return _connect.CProfilerController2_addVariable(self, triggerIndex, variableName, dataAreaType)

    def addTraceMessage(self, triggerIndex, traceMessage, dataAreaType, messageType):
        r"""
        Adds trace message to the list of variables to profile. If the message is
        already in the list, it is not added, only ``dataAreaType`` of the existing
        entry is set.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type traceMessage: string
        :param traceMessage: name of the message to record. For PowerPC this should be
                                empty string, for ARM this should be channel number of ITM
                                messages.
        :type dataAreaType: int
        :param dataAreaType: defines the way to analyze the recorded data,
                                see CProfilerController2::EDataAreaType

        :type messageType: int
        :param messageType: type of messages, see CProfilerController2::ETraceMessageType

        :rtype: int
        :return: index of DataArea with the added function

        Python example: _sample_link{profiler_ctrl_2,test_add_items}
        """
        return _connect.CProfilerController2_addTraceMessage(self, triggerIndex, traceMessage, dataAreaType, messageType)

    def addStateVariable(self, triggerIndex, variableName, stateVarDef, definitionName):
        r"""
        Adds state variable to the list of variables to profile. If the
        variable is already in the list, it is not added, only
        ``stateVarDef`` and ``definitonName`` of the existing entry are set.
        If ``definitonName`` is not available, use addVariable(.., EDATState)
        instead of this function.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the variable to profile
        :type stateVarDef: int
        :param stateVarDef: how variable states are defined,
                   see CProfilerController2::EStateVarDefinition
        :type definitionName: string
        :param definitionName: name of state definition, for example name of
                   enum type

        :rtype: int
        :return: index of DataArea with the added function

        Python example: _sample_link{profiler_ctrl_2,test_add_items}
        """
        return _connect.CProfilerController2_addStateVariable(self, triggerIndex, variableName, stateVarDef, definitionName)

    def addAuxVariable(self, triggerIndex, variableName, dataAreaType):
        r"""
        Adds AUX input to the list of variables to profile. If the input is
        already in the list, it is not added, only ``dataAreaType`` of the existing
        entry is set.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the AUX input to profile
        :type dataAreaType: int
        :param dataAreaType: type of variable, see CProfilerController2::EDataAreaType

        :rtype: int
        :return: index of DataArea with the added function
            Python example: _sample_link{profiler_ctrl_2,test_add_items}
        """
        return _connect.CProfilerController2_addAuxVariable(self, triggerIndex, variableName, dataAreaType)

    def removeFunction(self, triggerIndex, functionName):
        r"""
        Removes function from the list of functions to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type functionName: string
        :param functionName: name of the function to remove

        :rtype: int
        :return: -1 if no function with the given name was found, 0 if
                    the function was found and removed

        Python example: _sample_link{profiler_ctrl_2,test_remove_items}
        """
        return _connect.CProfilerController2_removeFunction(self, triggerIndex, functionName)

    def removeVariable(self, triggerIndex, variableName):
        r"""
        Removes variable from the list of variables to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type variableName: string
        :param variableName: name of the variable to remove

        :rtype: int
        :return: -1 if no variable with the given name was found, 0 if
                    the variable was found and removed

        Python example: _sample_link{profiler_ctrl_2,test_remove_items}
        """
        return _connect.CProfilerController2_removeVariable(self, triggerIndex, variableName)

    def removeAllFunctions(self, triggerIndex):
        r"""
        Removes all functions from the list of functions to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
            Python example: _sample_link{profiler_ctrl_2,test_remove_items}
        """
        return _connect.CProfilerController2_removeAllFunctions(self, triggerIndex)

    def removeAllVariables(self, triggerIndex):
        r"""
        Removes all variables from the list of variables to profile.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
            Python example: _sample_link{profiler_ctrl_2,test_remove_items}
        """
        return _connect.CProfilerController2_removeAllVariables(self, triggerIndex)

    def getSessionDuration(self, triggerIndex):
        r"""
        Returns how long should profiler recording last on next run.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()

        :rtype: int
        :return: session duration in milliseconds if limit is enabled,
                    negative value of session duration if limit is disabled.

        Python example: _sample_link{profiler_ctrl_2,test_get_set_session_duration}
        """
        return _connect.CProfilerController2_getSessionDuration(self, triggerIndex)

    def setSessionDuration(self, triggerIndex, sessionDurationInMilliseconds):
        r"""
        Sets how long should profiler recording last on next run. Profiler
        will stop after the specified number of milliseconds. If target
        is stopped earlier, profiler session is shorter.

        :type triggerIndex: int
        :param triggerIndex: index of trigger, see getTriggerIndex()
        :type sessionDurationInMilliseconds: int
        :param sessionDurationInMilliseconds: max duration of next profiler session.
                                                 If greater than 0, session duration limit
                                                 is enabled and set to the specified value,
                                                 otherwise session duration limit is disabled
                                                 and the time is not changed.

        Python example: _sample_link{profiler_ctrl_2,test_get_set_session_duration}
        """
        return _connect.CProfilerController2_setSessionDuration(self, triggerIndex, sessionDurationInMilliseconds)

    def exportData(self, exportConfig):
        r"""
        Exports profiler data according to the given configuration.
        Example:


        profiler = CProfilerController2(connectionMgr, "profiler.trd", "w");

        ...

        cfg = CProfilerExportConfig().setFileName('profilerResult.xml')
                                     .setExportFormat(CProfilerExportFormat::EXML)
                                     .setAreaScpe(CProfilerExportConfig::EAll);
        profiler.exportData(cfg);


        Python example: _sample_link{profiler_ctrl_2,test_exports}
        """
        return _connect.CProfilerController2_exportData(self, exportConfig)

    def dataAreaType2Str(self, dataAreaType):
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Profiler.DataArea[<idx2>].Type``.

        Python example: _sample_link{profiler_ctrl_2,test_data_areatype2str}
        """
        return _connect.CProfilerController2_dataAreaType2Str(self, dataAreaType)

    def stateVarDef2Str(self, stateVarDef):
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Profiler.DataArea[<idx2>].Definition``.

        Python example: _sample_link{profiler_ctrl_2,test_state_vardef2str}
        """
        return _connect.CProfilerController2_stateVarDef2Str(self, stateVarDef)

    def traceMsgDef2Str(self, traceMsgType):
        r"""
        Returns string, which can be used to set option
        ``/Document/<fileName>/Trigger.Items[<idx1>].Profiler.DataArea[<idx2>].DataType``.

        Python example: _sample_link{profiler_ctrl_2,test_trace_msgdef2str}
        """
        return _connect.CProfilerController2_traceMsgDef2Str(self, traceMsgType)

# Register CProfilerController2 in _connect:
_connect.CProfilerController2_swigregister(CProfilerController2)
class CTraceFormatBase(object):
    r"""
    This is base class for trace export format containers. Expand
    **inheritance diagram** below to see all derived formatter classes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EFmtText = _connect.CTraceFormatBase_EFmtText
    r"""text export"""
    EFmtCSV = _connect.CTraceFormatBase_EFmtCSV
    r"""CSV export"""
    EFmtBinary = _connect.CTraceFormatBase_EFmtBinary
    r"""binary export"""
    EFmtXML = _connect.CTraceFormatBase_EFmtXML
    r"""XMl export"""
    __swig_destroy__ = _connect.delete_CTraceFormatBase

    def getExportFormat(self):
        r"""Returns value used for option /TraceExport.Type."""
        return _connect.CTraceFormatBase_getExportFormat(self)

    def getExportFormatAsStr(self):
        r"""
        Returns string with export format, suitable for setting winIDEA
        trace export format option.
        """
        return _connect.CTraceFormatBase_getExportFormatAsStr(self)

    def setOptions(self, ide, docFileName):
        r"""Sets option in winIDEA."""
        return _connect.CTraceFormatBase_setOptions(self, ide, docFileName)

# Register CTraceFormatBase in _connect:
_connect.CTraceFormatBase_swigregister(CTraceFormatBase)
class CTraceTextExportFormat(CTraceFormatBase):
    r"""This class configures format of Text export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CTraceTextExportFormat_swiginit(self, _connect.new_CTraceTextExportFormat())

    def setContentLen(self, contentLen):
        r"""
         Sets content length. Default: 30.

        :type contentLen: int
        :param contentLen: number of characters
        """
        return _connect.CTraceTextExportFormat_setContentLen(self, contentLen)

    def getContentLen(self):
        r"""Returns content length - number of characters"""
        return _connect.CTraceTextExportFormat_getContentLen(self)

    def setOptions(self, ide, docFileName):
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for Text format, but does not set trace export format to Text (modifies
        only options '/Document/<fname>/TraceExport.Text.*').

        :type ide: :py:class:`CIDEController`
        :param ide: ide controller

        :type docFileName: string
        :param docFileName: document file name relative to winIDEA workspace location
        """
        return _connect.CTraceTextExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceTextExportFormat

# Register CTraceTextExportFormat in _connect:
_connect.CTraceTextExportFormat_swigregister(CTraceTextExportFormat)
class CTraceCSVExportFormat(CTraceFormatBase):
    r"""This class configures format of CSV export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CTraceCSVExportFormat_swiginit(self, _connect.new_CTraceCSVExportFormat())

    def setSeparator(self, separator):
        r"""Sets CSV field separator. Default: ','."""
        return _connect.CTraceCSVExportFormat_setSeparator(self, separator)

    def setColumnHeaders(self, isColumnHeaders):
        r"""Defines if column headers should be written to file. Default: true."""
        return _connect.CTraceCSVExportFormat_setColumnHeaders(self, isColumnHeaders)

    def setFunctionTree(self, isFunctionTree):
        r"""
        Deprecated: This option has been removed from trace exports, do not
        call this method, it will be removed in future release
        """
        return _connect.CTraceCSVExportFormat_setFunctionTree(self, isFunctionTree)

    def getSeparator(self):
        r"""Returns CSV field separator."""
        return _connect.CTraceCSVExportFormat_getSeparator(self)

    def isColumnHeaders(self):
        r"""Returns true, if column headers will be present in export file."""
        return _connect.CTraceCSVExportFormat_isColumnHeaders(self)

    def isFunctionTree(self):
        r"""
        Deprecated: Always returns `false`. This option has been removed from trace
                    exports, do not call this method, it will be removed in future release.
        """
        return _connect.CTraceCSVExportFormat_isFunctionTree(self)

    def setOptions(self, ide, docFileName):
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for Text format, but does not set trace export format to Text (modifies
        only options '/Document/<fname>/TraceExport.Text.*').

        :type ide: :py:class:`CIDEController`
        :param ide: ide controller

        :type docFileName: string
        :param docFileName: document file name relative to winIDEA workspace location
        """
        return _connect.CTraceCSVExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceCSVExportFormat

# Register CTraceCSVExportFormat in _connect:
_connect.CTraceCSVExportFormat_swigregister(CTraceCSVExportFormat)
class CTraceXMLExportFormat(CTraceFormatBase):
    r"""This class configures contents of XML export."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CTraceXMLExportFormat_swiginit(self, _connect.new_CTraceXMLExportFormat())

    def setIndex(self, isIndex):
        r"""Export sample index. XML Property = IDX, default: true."""
        return _connect.CTraceXMLExportFormat_setIndex(self, isIndex)

    def setTime(self, isTime):
        r"""Export sample time. XML Property = T, default: true."""
        return _connect.CTraceXMLExportFormat_setTime(self, isTime)

    def setTraceSourceId(self, isTraceSourceId):
        r"""Export trace source ID. XML Property = ID, default: false."""
        return _connect.CTraceXMLExportFormat_setTraceSourceId(self, isTraceSourceId)

    def setAddress(self, isAddress):
        r"""Export address. XML Property = ADR, default: true."""
        return _connect.CTraceXMLExportFormat_setAddress(self, isAddress)

    def setMemArea(self, isMemArea):
        r"""Export memory area. XML Property = AREA, default: false."""
        return _connect.CTraceXMLExportFormat_setMemArea(self, isMemArea)

    def setData(self, isData):
        r"""Export data. XML Property = DATA, default: true."""
        return _connect.CTraceXMLExportFormat_setData(self, isData)

    def setDasm(self, isDasm):
        r"""Export disassembly. XML Property = DASM, default: true."""
        return _connect.CTraceXMLExportFormat_setDasm(self, isDasm)

    def setDasmData(self, isDasmData):
        r"""Includes op-code data in the Disassembly. default: false."""
        return _connect.CTraceXMLExportFormat_setDasmData(self, isDasmData)

    def setDasmAddress(self, isDasmAddress):
        r"""Includes op-code address in the Disassembly. default: false."""
        return _connect.CTraceXMLExportFormat_setDasmAddress(self, isDasmAddress)

    def setFunction(self, isFunction):
        r"""Export function. XML Property = FUNC, default: false."""
        return _connect.CTraceXMLExportFormat_setFunction(self, isFunction)

    def setLabel(self, isLabel):
        r"""Export label. XML Property = LABEL, default: false."""
        return _connect.CTraceXMLExportFormat_setLabel(self, isLabel)

    def setSourceLine(self, isSourceLine):
        r"""Export source line. XML Property = SRC, default: true."""
        return _connect.CTraceXMLExportFormat_setSourceLine(self, isSourceLine)

    def setActivity(self, isActivity):
        r"""Export activity information. XML Property = ACT, default: false."""
        return _connect.CTraceXMLExportFormat_setActivity(self, isActivity)

    def setBusStatus(self, isBusStatus):
        r"""Export bus status. XML Property = BS, default: false."""
        return _connect.CTraceXMLExportFormat_setBusStatus(self, isBusStatus)

    def setAUX(self, isAUX):
        r"""Export AUX signals. XML Property prefix = X, default: false."""
        return _connect.CTraceXMLExportFormat_setAUX(self, isAUX)

    def setOCT(self, isOCT):
        r"""Export OCT data. XML Property prefix = OCT, default: false."""
        return _connect.CTraceXMLExportFormat_setOCT(self, isOCT)

    def setUseIndent(self, isUseIndent):
        r"""
        Use indenting in XML export file. Default: false.
        Set this property to true, if humans will read the exported file.
        If indenting is not used, the file is about 20% smaller.
        """
        return _connect.CTraceXMLExportFormat_setUseIndent(self, isUseIndent)

    def isIndex(self):
        r"""Returns true, if sample index will be exported."""
        return _connect.CTraceXMLExportFormat_isIndex(self)

    def isTime(self):
        r"""Returns true, if time stamp will be exported."""
        return _connect.CTraceXMLExportFormat_isTime(self)

    def isTraceSourceId(self):
        r"""Returns true, if trace source ID will be exported."""
        return _connect.CTraceXMLExportFormat_isTraceSourceId(self)

    def isAddress(self):
        r"""Returns true, if address will be exported."""
        return _connect.CTraceXMLExportFormat_isAddress(self)

    def isMemArea(self):
        r"""Returns true, if memory area will be exported."""
        return _connect.CTraceXMLExportFormat_isMemArea(self)

    def isData(self):
        r"""Returns true, if data will be exported."""
        return _connect.CTraceXMLExportFormat_isData(self)

    def isDasm(self):
        r"""Returns true, if disassembly will be exported."""
        return _connect.CTraceXMLExportFormat_isDasm(self)

    def isDasmData(self):
        r"""Returns true, if disassembly op-code will be exported."""
        return _connect.CTraceXMLExportFormat_isDasmData(self)

    def isDasmAddress(self):
        r"""Returns true, if disassembly op-code address will be exported."""
        return _connect.CTraceXMLExportFormat_isDasmAddress(self)

    def isFunction(self):
        r"""Returns true, if function name will be exported."""
        return _connect.CTraceXMLExportFormat_isFunction(self)

    def isLabel(self):
        r"""Returns true, if label will be exported."""
        return _connect.CTraceXMLExportFormat_isLabel(self)

    def isSourceLine(self):
        r"""Returns true, if source line will be exported."""
        return _connect.CTraceXMLExportFormat_isSourceLine(self)

    def isActivity(self):
        r"""Returns true, if activity will be exported."""
        return _connect.CTraceXMLExportFormat_isActivity(self)

    def isBusStatus(self):
        r"""Returns true, if bus status will be exported."""
        return _connect.CTraceXMLExportFormat_isBusStatus(self)

    def isAUX(self):
        r"""Returns true, if AUX signals will be exported."""
        return _connect.CTraceXMLExportFormat_isAUX(self)

    def isOCT(self):
        r"""Returns true, if OCT signals will be exported."""
        return _connect.CTraceXMLExportFormat_isOCT(self)

    def isUseIndent(self):
        r"""Returns true, if exported XML will be indented."""
        return _connect.CTraceXMLExportFormat_isUseIndent(self)

    def setOptions(self, ide, docFileName):
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for XML format, but does not set trace export format to XML (modifies
        only options '/Document/<fname>/TraceExport.XML.*').

        :type ide: :py:class:`CIDEController`
        :param ide: ide controller

        :type docFileName: string
        :param docFileName: document file name relative to winIDEA workspace location
        """
        return _connect.CTraceXMLExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceXMLExportFormat

# Register CTraceXMLExportFormat in _connect:
_connect.CTraceXMLExportFormat_swigregister(CTraceXMLExportFormat)
class CTraceBinExportFormat(CTraceFormatBase):
    r"""
    This class configures contents of Binary export. It is _highly_ recommended to
    set format to header version 2 (EHeaderVer2), and to export also the presence
    flags. This way the file format is self descriptive and can be parsed anytime
    later. In all other cases we have to store the file format separately, but
    even then the file may not be parseable - for example, if addresses and OCD are
    exported, than samples with OCD may not have data for addresses, and there
    is no way to find this out from the information in file. Use
    export without presence flags only when file size is really critical, and
    you know that all exported data is present in each sample.

    winIDEA 9.12.x note: If parsing binary data without header or with header
    version 1, always call `setNumBusStatusBytes(4)` on this object, because
    it is set to 8 by default.

    _sample_link{trace_ctrl,test_ctrace_bin_export_format}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EHeaderVer1 = _connect.CTraceBinExportFormat_EHeaderVer1
    r"""the old header, without information about file format"""
    EHeaderVer2 = _connect.CTraceBinExportFormat_EHeaderVer2
    r"""the new header, which contains file format info"""
    EDataItem = _connect.CTraceBinExportFormat_EDataItem
    r"""data is present"""
    EAddressItem = _connect.CTraceBinExportFormat_EAddressItem
    r"""address is present"""
    EMemAreaItem = _connect.CTraceBinExportFormat_EMemAreaItem
    r"""memory area is present"""
    ETimeStampItem = _connect.CTraceBinExportFormat_ETimeStampItem
    r"""timestamp is present"""
    EBusStatusItem = _connect.CTraceBinExportFormat_EBusStatusItem
    r"""bus status is present"""
    ESampleIndexItem = _connect.CTraceBinExportFormat_ESampleIndexItem
    r"""sample and subsample indices are present"""
    EOCDItem = _connect.CTraceBinExportFormat_EOCDItem
    r"""On Chip Data is present"""
    EAUXItem = _connect.CTraceBinExportFormat_EAUXItem
    r"""AUX is present"""
    EPresenceFlagsItem = _connect.CTraceBinExportFormat_EPresenceFlagsItem
    r"""
    presence flags are saved in the file,
    this flag is set only in file header
    """
    ETraceSourceIdItem = _connect.CTraceBinExportFormat_ETraceSourceIdItem
    r"""trace source ID is present"""

    def __init__(self):
        r"""
        Creates object with default values. Most important, header version 2
        and presence flags are saved to file. Change these two settings only
        if the export file size really matters.
        """
        _connect.CTraceBinExportFormat_swiginit(self, _connect.new_CTraceBinExportFormat())

    def setHeader(self, isHeader):
        r"""If true, header is saved to binary export. Default: true."""
        return _connect.CTraceBinExportFormat_setHeader(self, isHeader)

    def setHeaderVersion(self, headerVersion):
        r"""Sets header version. Default: EHeaderVer2."""
        return _connect.CTraceBinExportFormat_setHeaderVersion(self, headerVersion)

    def setNumOfCpuBuses(self, numberOfCpuBusses):
        r"""
        Sets the number of CPU buses. This value is not used during export -
        all buses are always exported, but only during parsing.
        Default: 1.
        """
        return _connect.CTraceBinExportFormat_setNumOfCpuBuses(self, numberOfCpuBusses)

    def setNumMAUs(self, numMAUs):
        r"""
        Sets the number of valid MAUs in the data item.
        Default: 4. Should be set to 4 for winIDEA 9.12.x, and 8 for
        winIDEA 9.17 and newer, if trace header version 2 is not available.
        """
        return _connect.CTraceBinExportFormat_setNumMAUs(self, numMAUs)

    def setNumBusStatusBytes(self, numBusStatusBytes):
        r"""
        Sets the number of valid bus status bytes in the bus status item.
        Default: 4.
        """
        return _connect.CTraceBinExportFormat_setNumBusStatusBytes(self, numBusStatusBytes)

    def setTraceItemFlags(self, presenceFlags):
        r"""
        Sets flags, where each bit defines, which trace items should be
        exported.

        See also: EPresenceFlags
        """
        return _connect.CTraceBinExportFormat_setTraceItemFlags(self, presenceFlags)

    def addTraceItem(self, presenceFlag):
        r"""Adds the given trace item to export."""
        return _connect.CTraceBinExportFormat_addTraceItem(self, presenceFlag)

    def removeTraceItem(self, presenceFlag):
        r"""Removes the given trace item from export."""
        return _connect.CTraceBinExportFormat_removeTraceItem(self, presenceFlag)

    def isHeader(self):
        r"""Returns true, if header will be exported."""
        return _connect.CTraceBinExportFormat_isHeader(self)

    def getHeaderVersion(self):
        r"""Returns export header version."""
        return _connect.CTraceBinExportFormat_getHeaderVersion(self)

    def getHeaderVersionAsStr(self):
        r"""Returns export header version as string."""
        return _connect.CTraceBinExportFormat_getHeaderVersionAsStr(self)

    def getNumOfCpuBuses(self):
        r"""Returns the number of CPU buses as set by setNumOfCpuBuses()"""
        return _connect.CTraceBinExportFormat_getNumOfCpuBuses(self)

    def getNumMAUs(self):
        r"""Returns the number of MAUs as set by setNumMAUs()"""
        return _connect.CTraceBinExportFormat_getNumMAUs(self)

    def getNumBusStatusBytes(self):
        r"""Returns the number of valid bus status bytes as set by setNumBusStatusBytes()"""
        return _connect.CTraceBinExportFormat_getNumBusStatusBytes(self)

    def getPresenceFlags(self):
        r"""
        Returns presence flags, which indicate which trace items should
        be exported.

        See also: EPresenceFlags
        See also: setPresenceFlags()
        """
        return _connect.CTraceBinExportFormat_getPresenceFlags(self)

    def isTraceItem(self, itemMask):
        r"""
        Returns ``true``, if trace item specified in ``itemMask`` is
        available.
        """
        return _connect.CTraceBinExportFormat_isTraceItem(self, itemMask)

    def setOptions(self, ide, docFileName):
        r"""
        Writes options to winIDEA. This method is automatically called
        by CTraceController::exportData(). This method sets only configuration
        for binary  format, but does not set trace export format to binary (modifies
        only options '/Document/<fname>/TraceExport.Bin.*').

        :type ide: :py:class:`CIDEController`
        :param ide: ide controller

        :type docFileName: string
        :param docFileName: document file name relative to winIDEA workspace location
        """
        return _connect.CTraceBinExportFormat_setOptions(self, ide, docFileName)
    __swig_destroy__ = _connect.delete_CTraceBinExportFormat

# Register CTraceBinExportFormat in _connect:
_connect.CTraceBinExportFormat_swigregister(CTraceBinExportFormat)
class CTraceExportConfig(object):
    r"""
    This class contains configuration for export of trace
    recording. All setters return reference to ``this``, so we can
    chain calls to set values, for example:


    cfg = CTraceExportConfig().setFileName('traceResult.xml')
                              .setTimeScope(CTraceExportConfig::ETimeAll)
                              .setTimeFilter(0, 1000000);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ETimeAll = _connect.CTraceExportConfig_ETimeAll
    r"""export recorded samples regardless of timestamp"""
    ETimeBetweenMarkers = _connect.CTraceExportConfig_ETimeBetweenMarkers
    r"""
    export only samples between times specified
    with call to setTimeFilter()
    """

    def __init__(self):
        r"""Creates object with default values."""
        _connect.CTraceExportConfig_swiginit(self, _connect.new_CTraceExportConfig())

    def setFileName(self, fileName):
        r"""
        Sets the name of the exported file. If this method is not called, or
        ``fileName`` is empty string, then the existing export file name in
        winIDEA is used.

        Python example: _sample_link{trace_controller}
        """
        return _connect.CTraceExportConfig_setFileName(self, fileName)

    def setLaunchViewer(self, isLaunchViewer):
        r"""
        If set to true, launches the system default
        viewer for the specified document type after export, for example
        notepad for text documents. Default: false.
        """
        return _connect.CTraceExportConfig_setLaunchViewer(self, isLaunchViewer)

    def setTimeScope(self, timeScope):
        r"""Sets the time scope Default: ETimeAll."""
        return _connect.CTraceExportConfig_setTimeScope(self, timeScope)

    def setTimeFilter(self, startTime, endTime):
        r"""
        Sets time-frame for which trace should be exported
        Default: both times are set to 0, but are not used if
        setTimeScope(ETimeBetweenMarkers) is not called.


         To export measurements before trigger, times must be
        negative. Trigger has timestamp 0.

        :type startTime: int
        :param startTime: start of measurements to export relative
                             to trigger.

        :type endTime: int
        :param endTime: end of measurements to export. If greater
                           than the timestamp of the last sample, all
                           samples from ``startTime`` to the end are
                           exported.
        """
        return _connect.CTraceExportConfig_setTimeFilter(self, startTime, endTime)

    def setFormatter(self, formatter):
        r"""
        Sets formatter object, which configures export file format. If this
        method is not called, XML formatter with default settings is used.
        """
        return _connect.CTraceExportConfig_setFormatter(self, formatter)

    def getFileName(self):
        r"""Returns trace export file name."""
        return _connect.CTraceExportConfig_getFileName(self)

    def isLaunchViewer(self):
        r"""Returns true, if viewer will be launched after export."""
        return _connect.CTraceExportConfig_isLaunchViewer(self)

    def getTimeScope(self):
        r"""Returns trace export time scope."""
        return _connect.CTraceExportConfig_getTimeScope(self)

    def getTimeScopeAsStr(self):
        r"""
        Returns string, which can be used for setting of option
        '/Document/<file name>/TraceExport.SampleRange'
        """
        return _connect.CTraceExportConfig_getTimeScopeAsStr(self)

    def getStartTime(self):
        r"""Returns export start time."""
        return _connect.CTraceExportConfig_getStartTime(self)

    def getEndTime(self):
        r"""Returns export and time."""
        return _connect.CTraceExportConfig_getEndTime(self)

    def getFormatter(self):
        r"""Returns formatter object, which configures export file format."""
        return _connect.CTraceExportConfig_getFormatter(self)

    def setOptions(self, ide, docFileName):
        r"""
        Writes configured options to winIDEA. Only after this call
        the configured options are made active. This method is
        automatically called when CTraceController::exportData() is
        called.

        :type ide: :py:class:`CIDEController`
        :param ide: ide controller

        :type docFileName: string
        :param docFileName: document file name relative to winIDEA workspace location
        """
        return _connect.CTraceExportConfig_setOptions(self, ide, docFileName)

    def toString(self):
        r"""Returns contents of this object in human readable form."""
        return _connect.CTraceExportConfig_toString(self)
    __swig_destroy__ = _connect.delete_CTraceExportConfig

# Register CTraceExportConfig in _connect:
_connect.CTraceExportConfig_swigregister(CTraceExportConfig)
class CTraceController(CAnalyzerDocController):
    r"""
    This class enables recording and export of program trace. It
    extends the existing class CAnalyzerDocController.

    This class can be used to configure trace trigger, run recording, and export
    the recorded data. However, it has no methods for retrieving recorded information.
    For this purpose a separate class called CTraceData should be used.


    **Advanced trace configuration**

    Most settings for trace are implemented by setting of winIDEA options.
    Since there are many options, and most of them are target dependent,
    this class provides methods for accessing only the most often used options.
    To see all trace options, open trace document in winIDEA, then select
    ``Help | Display Option...``. In the opened dialog select all
    check-boxes, and radio button 'Document'. Then select trace document in
    the combo box next to the radio button. Click the ``Display'`` button to
    see all trace options as shown in the image below:

    Image: displayOptionsDialog.png

    These options can be set with method CIDEController::setOption(). This
    approach should be used for advanced configurations, which are
    target dependent. Another possibility is to create and configure a trace
    document manually in winIDEA, and use it as a template in scripts.



    Python example with recording and simple data reading: _sample_link{trace_controller}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, fileName, mode):
        r"""
        Instantiates object and opens or creates analyzer document in
        ``winIDEA``.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        :type mode: string
        :param mode: document open mode. 'u' opens existing file for update (file
                        must exist), 'w' opens existing file and deletes recordings,
                        or creates a new file, 'a' opens existing file and keeps
                        contents, or creates a new file if it does not exist.

        :type fileName: string
        :param fileName: Absolute or relative path to trd file. If not an
                   empty string, it is used, otherwise
                   the user is prompted for fileName by winIDEA. In the later
                   case this object can not be used, because the file name
                   is known only in winIDEA.

        Python example: _sample_link{trace_data,test_create_instance}
        """
        _connect.CTraceController_swiginit(self, _connect.new_CTraceController(connectionMgr, fileName, mode))
    __swig_destroy__ = _connect.delete_CTraceController

    def createTrigger(self, triggerName):
        r"""
        Creates a new trace trigger. Trigger contains parameters for
        trace recording (when to start, buffer size, ...). See
        CTraceConfigWizard for simplified trigger configuration.

        :type triggerName: string
        :param triggerName: name of the trigger

        :rtype: int
        :return: index of the created trigger

        :raises: IllegalArgumentException if the trigger already exists

        Python example: _sample_link{trace_ctrl,test_create_trigger}
        """
        return _connect.CTraceController_createTrigger(self, triggerName)

    def applyTriggerWizard(self, traceWizardConfig, triggerIdx):
        r"""
        This method applies the given trace trigger configuration to
        the actual trigger of this document.

        :type traceWizardConfig: :py:class:`CTraceConfigWizard`
        :param traceWizardConfig: trigger configuration.

        :type triggerIdx: int
        :param triggerIdx: index of trigger configuration will be applied to.

        Python example: _sample_link{trace_ctrl,test_apply_trigger_wizard}
        """
        return _connect.CTraceController_applyTriggerWizard(self, traceWizardConfig, triggerIdx)

    def exportData(self, exportConfig):
        r"""
        Exports trace data according to the given configuration.
        Example:


        trace = CTraceController(connectionMgr, "trace.trd", "w");

        ...

        cfg = CTraceExportConfig().setFileName('traceResult.xml')
                                  .setExportFormat(CTraceExportConfig::EFmtXML);
        trace.exportData(cfg);


        Python example: _sample_link{trace_ctrl,test_export_data}
        """
        return _connect.CTraceController_exportData(self, exportConfig)

# Register CTraceController in _connect:
_connect.CTraceController_swigregister(CTraceController)
class CTraceTimeEvent(object):
    r"""This class contains information of one trace time-line event."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def isTraceItem(self, itemMask):
        return _connect.CTraceTimeEvent_isTraceItem(self, itemMask)

    def getSampleIndex(self):
        r"""Returns sample index."""
        return _connect.CTraceTimeEvent_getSampleIndex(self)

    def getSubSampleIndex(self):
        r"""Returns sub-sample index."""
        return _connect.CTraceTimeEvent_getSubSampleIndex(self)

    def getTime(self):
        r"""Returns time of event."""
        return _connect.CTraceTimeEvent_getTime(self)

    def getTraceSourceId(self):
        return _connect.CTraceTimeEvent_getTraceSourceId(self)

    def getAddress(self, busIndex):
        r"""
        Returns address.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getAddress(self, busIndex)

    def getMemArea(self, busIndex):
        r"""
        Returns memory area. See MemArea.h for meaning of values
        returned by this function - make sure to see enum for your
        target architecture.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getMemArea(self, busIndex)

    def getData(self, busIndex):
        r"""
        Returns data.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getData(self, busIndex)

    def getData64(self, busIndex):
        r"""
        Returns 64 bit data.

        :type busIndex: int
        :param busIndex: index of the target bus, 0 based.
        """
        return _connect.CTraceTimeEvent_getData64(self, busIndex)

    def getBusStatus(self, status):
        r"""
        Returns bus status for the trace binary export.
        Check the winIDEA's Export Binary Options dialog for the byte encoding rules.

        :type status: :py:class:`ByteVector`
        :param status: vector of values
        """
        return _connect.CTraceTimeEvent_getBusStatus(self, status)

    def getDasm(self):
        r"""Returns disassembly (available only in XML export)."""
        return _connect.CTraceTimeEvent_getDasm(self)

    def getFunc(self):
        r"""Returns function data (available only in XML export)."""
        return _connect.CTraceTimeEvent_getFunc(self)

    def getLabel(self):
        r"""Returns label (available only in XML export)."""
        return _connect.CTraceTimeEvent_getLabel(self)

    def getSrc(self):
        r"""Returns source code (available only in XML export)."""
        return _connect.CTraceTimeEvent_getSrc(self)

    def getBusActivity(self):
        r"""Returns bus activity (available only in XML export)."""
        return _connect.CTraceTimeEvent_getBusActivity(self)

    def getOnChipData(self, data):
        r"""
         Returns the recorded on chip data.
        :type data: :py:class:`DWordVector`
        :param data: vector of on-chip data, for the python use ic.VectorOnChipData
        """
        return _connect.CTraceTimeEvent_getOnChipData(self, data)

    def getAuxData(self, channelName):
        r"""
        Returns value on the given AUX channel. Channel names have prefix 'X',
        followed by 'A' for analog channel, 'D' for digital channel, followed
        by 'I' for input, 'O' for output and channel number. 

        Example: ``XAI2`` is value on Analog Input channel 2.


        Values for digital channels are float values 0 or 1.
        """
        return _connect.CTraceTimeEvent_getAuxData(self, channelName)

    def getAuxChannels(self, channels):
        r"""
        This method returns the list of channels recorded in the current sample.

        :type channels: :py:class:`StrVector`
        :param channels: list of channel names, cleared before new values are inserted
        """
        return _connect.CTraceTimeEvent_getAuxChannels(self, channels)

    def toString(self):
        r"""Returns string representation of this object."""
        return _connect.CTraceTimeEvent_toString(self)

    def __init__(self):
        _connect.CTraceTimeEvent_swiginit(self, _connect.new_CTraceTimeEvent())
    __swig_destroy__ = _connect.delete_CTraceTimeEvent

# Register CTraceTimeEvent in _connect:
_connect.CTraceTimeEvent_swigregister(CTraceTimeEvent)
class CTraceTimelineIterator(object):
    r"""
    This class implements iterator for trace time-line events. Only one
    iterator may iterate the events at a time, because the events are
    not stored in memory, but are sequentially parsed from a file.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def hasNext(self):
        r"""Returns true, if there is at least one more time-line item available."""
        return _connect.CTraceTimelineIterator_hasNext(self)

    def next(self):
        r"""
        Returns the next time-line item by value. This method is much slower than
        calling nextAsPtr().

        Do not call this method if hasNext() returned ``false!``
        """
        return _connect.CTraceTimelineIterator_next(self)

    def nextAsSPtr(self):
        r"""
        Returns the next time-line item. Each call to this method returns the same
        object, but filled with new data. It is faster than calling next().

        Do not call this method if hasNext() returned ``false!``
        """
        return _connect.CTraceTimelineIterator_nextAsSPtr(self)
    __swig_destroy__ = _connect.delete_CTraceTimelineIterator

# Register CTraceTimelineIterator in _connect:
_connect.CTraceTimelineIterator_swigregister(CTraceTimelineIterator)
class CTraceData(object):
    r"""
    This class provides access to trace measurements. It parses XML or binary export
    files, and returns the parsed data through method calls. Since trace export
    files may be very large - hundreds of megabytes or even gigabytes, this
    class parses one sample per iterator function call.

    To get instance of this class call one of createInstance() factory methods.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def createInstance(*args):
        r"""
        *Overload 1:*

        This factory method exports data to file, and returns initialized object
        for parsing of trace files.
        Use it, when you've just recorded data (have CTraceController2 object
        available), and have not exported it yet. Note also that this method is not
        as flexible as direct export and
        method createInstance(fileName) or createInstance(fileName, exportConfig).


        **Note**: if ``exportFileName`` is relative, it is saved relative to
        winIDEA working directory, not the script working directory. This method
        tries to do its best to open the saved file, but if winIDEA is on remote
        host, it will fail. In such cases try to export the trace data with
        CTraceController2::exportData() and use
        the overloaded method ``createInstance(fileName, isBinaryTimeline)`` instead.

        :type traceCtrl: :py:class:`CTraceController`
        :param traceCtrl: trace document controller which will be used to obtain data.

        :type exportFileName: string
        :param exportFileName: name of the file to export data to

        :type startTime: int
        :param startTime: start time for trace export. If ``startTime`` and ``endTime``
                             are set to 0, then all data is exported.

        :type endTime: int
        :param endTime: end time for trace export. If ``startTime`` and ``endTime``
                           are set to 0, then all data is exported.

        :type isBinaryExport: boolean
        :param isBinaryExport: if ``true``, trace data is exported in binary format. If
                                  ``false``, XML format is used.

        Python example: _sample_link{trace_data,test_get_binary_export_config}

        |

        *Overload 2:*

        This factory method returns initialized object for parsing of XML
        trace files. Use this method when trace data was exported to XML file.

        :type fileName: string
        :param fileName: name of the file with trace XML export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        Python example: _sample_link{trace_data,test_get_binary_export_config}

        |

        *Overload 3:*

        This factory method returns initialized object for parsing of binary trace files.
        Use this method when trace data was exported to binary file.

        :type fileName: string
        :param fileName: name of the file with trace binary export. If you use
                            relative file path, be aware that script working directory is
                            used as a starting point, not winIDEA workspace directory.

        :type exportFormat: :py:class:`CTraceBinExportFormat`
        :param exportFormat: this object is used to obtain information about export
                                format. First the header presence and version are obtained.
                                If there is no header or the version is less than 2, then
                                other flags in this object are used to get the exact file
                                format.
                                If header is present and version is 2, then exact format
                                is retrieved from the file and other settings in this object
                                are ignored.

        Python example: _sample_link{trace_data,test_get_binary_export_config}
        """
        return _connect.CTraceData_createInstance(*args)

    def getBinaryExportConfig(self):
        r"""
        Returns file format. If header version 2 was specified in
        call to createInstance(file, exportConfig), then this object
        is filled with information form the header. Otherwise it is
        returned unchanged. If binary parser is not active, an exception is
        thrown.

        Python example: _sample_link{trace_data,test_get_binary_export_config}
        """
        return _connect.CTraceData_getBinaryExportConfig(self)

    def getParserWarnings(self):
        r"""
        This method returns warnings related to input document. If there
        were no warnings, an empty string is returned. Always call this method
        after createInstance().

        Python example: _sample_link{trace_data,test_trace_get_parser_warnings}
        """
        return _connect.CTraceData_getParserWarnings(self)

    def closeParser(self):
        r"""
        This method releases parser resources and closes document file. It is
        recommended to call this method always after CTraceTimelineIterator
        is no longer used.

        Python example: _sample_link{trace_data,test_trace_get_timeline_iterator}
        """
        return _connect.CTraceData_closeParser(self)

    def getTimelineIterator(self):
        r"""
        Returns iterator, which will iterate trace samples.

        Python example: _sample_link{trace_data,test_trace_get_timeline_iterator}
        """
        return _connect.CTraceData_getTimelineIterator(self)
    __swig_destroy__ = _connect.delete_CTraceData

# Register CTraceData in _connect:
_connect.CTraceData_swigregister(CTraceData)
class CTraceConfigWizard(object):
    r"""
    This class can be used to configure trace in a similar way as it
    is done via GUI wizard. To get instance of this class, use one of the static
    factory methods.

    Python example: _sample_link{trace_ctrl,test_ctrace_config_wizard}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ERead = _connect.CTraceConfigWizard_ERead
    r"""read access"""
    EWrite = _connect.CTraceConfigWizard_EWrite
    r"""write access"""
    EReadWrite = _connect.CTraceConfigWizard_EReadWrite
    r"""read-write access"""
    EWidthAny = _connect.CTraceConfigWizard_EWidthAny
    r"""any width"""
    EWidth1 = _connect.CTraceConfigWizard_EWidth1
    r"""width of 1 MAU"""
    EWidth2 = _connect.CTraceConfigWizard_EWidth2
    r"""width of 2 MAUs"""
    EWidth4 = _connect.CTraceConfigWizard_EWidth4
    r"""width of 4 MAUs"""
    ERisingEdge = _connect.CTraceConfigWizard_ERisingEdge
    r"""rising edge"""
    EFallingEdge = _connect.CTraceConfigWizard_EFallingEdge
    r"""falling edge"""
    EAUXState = _connect.CTraceConfigWizard_EAUXState
    ERecordEverything = _connect.CTraceConfigWizard_ERecordEverything
    r"""record everything"""
    ERecordProgramFlow = _connect.CTraceConfigWizard_ERecordProgramFlow
    r"""record program flow"""
    ERecordDataAccess = _connect.CTraceConfigWizard_ERecordDataAccess
    r"""record data access"""
    ERecordInstrumentationMsgs = _connect.CTraceConfigWizard_ERecordInstrumentationMsgs
    r"""record instrumentation messages OTM/ITM"""
    ESamplesBefore = _connect.CTraceConfigWizard_ESamplesBefore
    r"""record few samples before"""
    ESamplesAfter = _connect.CTraceConfigWizard_ESamplesAfter
    r"""record few samples after"""
    ESamplesBeforeAndAfter = _connect.CTraceConfigWizard_ESamplesBeforeAndAfter
    r"""record few samples before and after"""
    EAllTheTime = _connect.CTraceConfigWizard_EAllTheTime
    r"""record all the time"""
    EBetweenTwoEvents = _connect.CTraceConfigWizard_EBetweenTwoEvents
    r"""record between two events"""

    @staticmethod
    def createImmediateTrigger():
        r"""
        This method creates trigger configuration equal to selecting
        'Trigger Immediately' radio button in trace wizard GUI.
        """
        return _connect.CTraceConfigWizard_createImmediateTrigger()

    @staticmethod
    def createDataAccessTrigger(*args):
        r"""
        *Overload 1:*

        This method creates trigger configuration for data access event.

        :type varName: string
        :param varName: name of a variable or literal address, where access
                           triggers trace recording
        :type isCoverEntireObject: boolean
        :param isCoverEntireObject: if true, access to entire object is monitored
        :type endAddress: string
        :param endAddress: name of variable or literal address, where monitoring
                              for trigger ends
        :type accessType: int
        :param accessType: type of memory access

        |

        *Overload 2:*

        This method creates trigger configuration for data access event.

        :type varName: string
        :param varName: name of a variable or literal address, where access
                           triggers trace recording
        :type isCoverEntireObject: boolean
        :param isCoverEntireObject: if true, access to entire object is monitored
        :type endAddress: string
        :param endAddress: name of variable or literal address, where monitoring
                              for trigger ends
        :type accessType: int
        :param accessType: type of memory access

        :type dataWidth: int
        :param dataWidth: data width type

        :type value: int
        :param value: value that triggers trace recording

        :type mask: int
        :param mask: bit mask - 0 ignore, 1 consider
        """
        return _connect.CTraceConfigWizard_createDataAccessTrigger(*args)

    @staticmethod
    def createCodeExecTrigger(funcName):
        r"""
        This method creates trigger configuration for code execution event.

        :type funcName: string
        :param funcName: name of a function or literal address, where execution
                            triggers trace recording

        Python example: _sample_link{trace_ctrl,test_ctrace_config_wizard}
        """
        return _connect.CTraceConfigWizard_createCodeExecTrigger(funcName)

    @staticmethod
    def createAUXStateTrigger(signalsMask, signalsValue):
        return _connect.CTraceConfigWizard_createAUXStateTrigger(signalsMask, signalsValue)

    @staticmethod
    def createAUXEdgeTrigger(edgeType, signalNumber):
        return _connect.CTraceConfigWizard_createAUXEdgeTrigger(edgeType, signalNumber)

    def setRecordingContent(self, *args):
        r"""
        If this method is not called, then 'Record Everything' is configured.
        If more detailed configuration is required, call it for each
        ERecordingContent, which you want to record.

        :type recType: int
        :param recType: if set to ERecordEverything, then all other recording
                           settings are reset. Other function parameters are ignored.
        :type identifierOrStartAddr: string, optional
        :param identifierOrStartAddr: name of function or variable (depending on recType),
                                         or literal start address of area to trace
        :type identifierOrEndAddr: string, optional
        :param identifierOrEndAddr: name of function or variable (depending on recType),
                                       or literal end address of area to trace
        :type accessType: int, optional
        :param accessType: memory access type, used only when recType == ERecordDataAccess.
        """
        return _connect.CTraceConfigWizard_setRecordingContent(self, *args)

    def setRecordingAttibutes(self, samplesOffsetType, recordingDuration):
        r"""
        This method sets additional recording properties.

        :type samplesOffsetType: int
        :param samplesOffsetType: defines any additional samples to record
        :type recordingDuration: int
        :param recordingDuration: defines the recording duration
        """
        return _connect.CTraceConfigWizard_setRecordingAttibutes(self, samplesOffsetType, recordingDuration)

    def setProcess(self, name):
        r"""
        This method sets process name
         :type name: string
         :param name: process name
        """
        return _connect.CTraceConfigWizard_setProcess(self, name)

    def configureOptions(self, ide, docFileName, triggerIdx):
        return _connect.CTraceConfigWizard_configureOptions(self, ide, docFileName, triggerIdx)
    __swig_destroy__ = _connect.delete_CTraceConfigWizard

# Register CTraceConfigWizard in _connect:
_connect.CTraceConfigWizard_swigregister(CTraceConfigWizard)
class CProfilerStatus(object):
    r"""
    This class contains profiler status. It should not be instantiated by
    clients. Call CProfilerController::getStatus() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNoOfSamples(self):
        r"""
        Returns the number of recorded or analyzed samples, depending
        on flags of CProfilerController::getStatus() method.
        """
        return _connect.CProfilerStatus_getNoOfSamples(self)

    def isMustInit(self):
        r"""Returns true, if profiler must be initialized."""
        return _connect.CProfilerStatus_isMustInit(self)

    def isIdle(self):
        r"""Returns true, if profiler is idle."""
        return _connect.CProfilerStatus_isIdle(self)

    def isWaiting(self):
        r"""Returns true, if profiler is waiting for trigger."""
        return _connect.CProfilerStatus_isWaiting(self)

    def isActive(self):
        r"""Returns true, if profiler is recording."""
        return _connect.CProfilerStatus_isActive(self)

    def isErrorInBuffer(self):
        r"""Returns true, if there was error in buffer."""
        return _connect.CProfilerStatus_isErrorInBuffer(self)

    def isBufferOverrun(self):
        r"""Returns true, if there was buffer overrun."""
        return _connect.CProfilerStatus_isBufferOverrun(self)

    def isRecordingError(self):
        r"""Returns true, if there was error in recording."""
        return _connect.CProfilerStatus_isRecordingError(self)

    def isError(self):
        r"""Returns true if any of the above errors occurs."""
        return _connect.CProfilerStatus_isError(self)

    def isLoading(self):
        r"""Returns true, if profiler is loading data to PC."""
        return _connect.CProfilerStatus_isLoading(self)

    def getAnalysisError(self):
        r"""Returns profiler analysis error code. If there was no error, 0 is returned."""
        return _connect.CProfilerStatus_getAnalysisError(self)

    def toString(self):
        r"""Returns object data as YAML string."""
        return _connect.CProfilerStatus_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerStatus

# Register CProfilerStatus in _connect:
_connect.CProfilerStatus_swigregister(CProfilerStatus)
class CProfilerStatistic(object):
    r"""
    This class contains statistic results for one profiler area.

    Deprecated: Use CProfilerController2 class instead of CProfilerController.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CProfilerStatistic_swiginit(self, _connect.new_CProfilerStatistic())

    def getHandle(self):
        r"""Returns handle of the area, related to these profiler results."""
        return _connect.CProfilerStatistic_getHandle(self)

    def getValue(self):
        r"""
        Returns value of the data, related to these profiler results. Valid only for
                   data areas.
        """
        return _connect.CProfilerStatistic_getValue(self)

    def getMinTime(self):
        r"""Returns min time spent in function or min duration of the data value."""
        return _connect.CProfilerStatistic_getMinTime(self)

    def getMaxTime(self):
        r"""Returns max time spent in function or max duration of the data value."""
        return _connect.CProfilerStatistic_getMaxTime(self)

    def getTotalTime(self):
        r"""Returns total time spent in function or total duration of the data value."""
        return _connect.CProfilerStatistic_getTotalTime(self)

    def getNumHits(self):
        r"""Returns how many times the function was called or data changed to the value."""
        return _connect.CProfilerStatistic_getNumHits(self)

    def toString(self):
        r"""
         Returns object's data as YAML string. This method is intended for debugging
        purposes only, do not parse the returned data!
        """
        return _connect.CProfilerStatistic_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerStatistic

# Register CProfilerStatistic in _connect:
_connect.CProfilerStatistic_swigregister(CProfilerStatistic)
class CProfilerHistory(object):
    r"""
    This class contains history results for one profiler area.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CProfilerHistory_swiginit(self, _connect.new_CProfilerHistory(*args))

    def getSProfilerHistory(self):
        r"""When wrapper class lacks some functionality, use this access."""
        return _connect.CProfilerHistory_getSProfilerHistory(self)

    def getHandle(self):
        r"""Returns handle of the area, related to these profiler results."""
        return _connect.CProfilerHistory_getHandle(self)

    def getHitTime(self):
        r"""Returns time, when the function started execution or data changed."""
        return _connect.CProfilerHistory_getHitTime(self)

    def getValue(self):
        r"""
        Returns data value.
        Use this method only when querying data items, which were
        obtained by getHistoryAll() or getHistoryForHandle().
        Otherwise use methods isActive() and isInactive()
        """
        return _connect.CProfilerHistory_getValue(self)

    def isActive(self):
        r"""
        :rtype: boolean
        :return: For functions: The function is currently executing
                    For data: The value is equal to the filtered one
        """
        return _connect.CProfilerHistory_isActive(self)

    def isInactive(self):
        r"""
        :rtype: boolean
        :return: For functions: The function is currently not executing.
                    Note, that it may be on stack - has called another function.
                    For data: The value is NOT equal to the filtered one
        """
        return _connect.CProfilerHistory_isInactive(self)

    def toString(self):
        r"""Returns object data as YAML string."""
        return _connect.CProfilerHistory_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerHistory

# Register CProfilerHistory in _connect:
_connect.CProfilerHistory_swigregister(CProfilerHistory)
class CProfilerCapabilities(object):
    r"""
    This class provides information about profiler capabilities.
    Clients should not instantiate this class. Call
    method CProfilerController::getCapabilities() to get instance of this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CProfilerCapabilities_swiginit(self, _connect.new_CProfilerCapabilities())

    def getNumExecAreas(self):
        r"""Returns the number of execution areas that can be profiled."""
        return _connect.CProfilerCapabilities_getNumExecAreas(self)

    def getNumDataAreas(self):
        r"""Returns the number of data areas that can be profiled."""
        return _connect.CProfilerCapabilities_getNumDataAreas(self)

    def getSingleDataWidth(self):
        r"""Returns the width of single data in memory addressable units."""
        return _connect.CProfilerCapabilities_getSingleDataWidth(self)

    def isAvailable(self):
        r"""Returns true, if profiler is available."""
        return _connect.CProfilerCapabilities_isAvailable(self)

    def canUseStartingPoint(self):
        r"""Returns true, if profiler can use starting point."""
        return _connect.CProfilerCapabilities_canUseStartingPoint(self)

    def canProfileExec(self):
        r"""Returns true, if profiler can profile execution."""
        return _connect.CProfilerCapabilities_canProfileExec(self)

    def canProfileFuncLines(self):
        r"""Returns true, if profiler can profile functions."""
        return _connect.CProfilerCapabilities_canProfileFuncLines(self)

    def canProfileData(self):
        r"""Returns true, if profiler can profile data."""
        return _connect.CProfilerCapabilities_canProfileData(self)

    def isSingleData(self):
        r"""Returns true, if profiler can profile single data."""
        return _connect.CProfilerCapabilities_isSingleData(self)

    def isSingleDataAddress(self):
        r"""Returns true, if single data requires address specification."""
        return _connect.CProfilerCapabilities_isSingleDataAddress(self)

    def isSingleDataSize(self):
        r"""Returns true, if single data requires size specification."""
        return _connect.CProfilerCapabilities_isSingleDataSize(self)

    def toString(self):
        r"""Returns object data as YAML string."""
        return _connect.CProfilerCapabilities_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerCapabilities

# Register CProfilerCapabilities in _connect:
_connect.CProfilerCapabilities_swigregister(CProfilerCapabilities)
class CAreaProperties(object):
    r"""This class contains profiler area properties."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, areaName, handle, address):
        r"""
        Initializes the instance.

        :type areaName: string
        :param areaName: name of the profiler area
        :type handle: int
        :param handle: profiler area handle
        :type address: int
        :param address: profiler area start address
        """
        _connect.CAreaProperties_swiginit(self, _connect.new_CAreaProperties(areaName, handle, address))

    def getName(self):
        r"""Returns area name."""
        return _connect.CAreaProperties_getName(self)

    def getHandle(self):
        r"""Returns area handle."""
        return _connect.CAreaProperties_getHandle(self)

    def getAddress(self):
        r"""Returns area address."""
        return _connect.CAreaProperties_getAddress(self)

    def toString(self):
        r"""Returns object data as YAML string."""
        return _connect.CAreaProperties_toString(self)
    __swig_destroy__ = _connect.delete_CAreaProperties

# Register CAreaProperties in _connect:
_connect.CAreaProperties_swigregister(CAreaProperties)
class CProfilerController(object):
    r"""
    *Deprecated* - Use isys::CProfilerController2 instead. 

    This class controls winIDEA profiler.

    Example:


        profiler.startConfiguration(isystem.connect.IConnectProfiler.cfTimeStampTime, "targetInit")
        profiler.addFunction("Type_Simple")
        profiler.start()


    Deprecated: This class is provided for backward compatibility only. Use
    isys::CProfilerController2 instead.




    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        """
        _connect.CProfilerController_swiginit(self, _connect.new_CProfilerController(connectionMgr))
    __swig_destroy__ = _connect.delete_CProfilerController

    def getIConnectProfiler(self):
        r"""
        Returns the **isystem.connect** profiler interface. Use this method only when
        some functionality of the IConnectProfiler2 interface is not accessible
        from this wrapper.
        """
        return _connect.CProfilerController_getIConnectProfiler(self)

    def getCapabilities(self):
        r"""
        Returns profiler capabilities.

        :raises: IOException in case of an error
        """
        return _connect.CProfilerController_getCapabilities(self)

    def startConfiguration(self, *args):
        r"""
        *Overload 1:*

        Configures profiler for start without waiting for trigger.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution

        |

        *Overload 2:*

        Configures profiler for start when the instruction on the
        specified address will be executed.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution
        :type memArea: BYTE
        :param memArea: memory area of the profiler start address
        :type address: int
        :param address: profiler start address

        |

        *Overload 3:*

        Configures profiler for start when execution of the
        specified function starts.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution
        :type functionName: string
        :param functionName: name of the profiler trigger function

        |

        *Overload 4:*

        Sets the given configuration for profiler. Use this method only if other
        overloaded variants do not support some settings in configuration.

        :type startConfigFlags: int
        :param startConfigFlags: define profiler resolution
        :type pStartingPoint: :py:class:`SProfilerStartingPoint`
        :param pStartingPoint: the starting point
        """
        return _connect.CProfilerController_startConfiguration(self, *args)

    def addFunction(self, functionName, isIncludeFunctionLines=False):
        r"""
        Adds function area to the current profiler configuration.

        :type functionName: string
        :param functionName: name of the function to profile
        :type isIncludeFunctionLines: boolean, optional
        :param isIncludeFunctionLines: if true, profiles also each line of a function,
            however accuracy of these results may be low on some systems. Results for each
            line are currently not accessible from isystem.connect interface.
        """
        return _connect.CProfilerController_addFunction(self, functionName, isIncludeFunctionLines)

    def addVariable(self, variableName, isTaskId=False, isSingleData=False):
        r"""
        Adds variable area to the current profiler configuration.

        :type variableName: string
        :param variableName: name of the variable to profile
        :type isTaskId: boolean, optional
        :param isTaskId: set this to true, if variable is task ID
        :type isSingleData: boolean, optional
        :param isSingleData: set this to true, if variable is the 'single data' (OTM style)
                   object.
        """
        return _connect.CProfilerController_addVariable(self, variableName, isTaskId, isSingleData)

    def addRegion(self, name, isTaskId, isSingleData, byMemArea, aAddress, aSize):
        r"""
        Adds memory region to the current profiler configuration.

        :type name: string
        :param name: area name
        :type isTaskId: boolean
        :param isTaskId: set this to true, if area is task ID
        :type isSingleData: boolean
        :param isSingleData: set this to true, if area is the 'single data' (OTM style)
                   object.
        :type byMemArea: BYTE
        :param byMemArea: memory area of the start address
        :type aAddress: int
        :param aAddress: start address of the area
        :type aSize: int
        :param aSize: size of the area
        """
        return _connect.CProfilerController_addRegion(self, name, isTaskId, isSingleData, byMemArea, aAddress, aSize)

    def addRoutine(self, name, byMemArea, aAddress, aSize, exits):
        r"""
        Adds profiler area as a low level routine.

        :type name: string
        :param name: area name
        :type byMemArea: BYTE
        :param byMemArea: memory area of the start address
        :type aAddress: int
        :param aAddress: start address of the area
        :type aSize: int
        :param aSize: size of the area
        :type exits: :py:class:`AddressVector`
        :param exits: points to a vector of ADDRESS_64 type objects, each specifying an exit
                    point from afTypeRoutine object
        """
        return _connect.CProfilerController_addRoutine(self, name, byMemArea, aAddress, aSize, exits)

    def getNumAreas(self):
        r"""
        Returns the number of result areas. Area handles have values
        in the range [0, numAreas - 1], so we can easily iterate all areas.
        """
        return _connect.CProfilerController_getNumAreas(self)

    def getAreaProperties(self, *args):
        r"""
        *Overload 1:*

        Returns area properties, such as handle and address.

        :type areaName: string
        :param areaName: name of the area, which properties should be returned

        |

        *Overload 2:*

        Returns area properties, such as name and address.

        :type handle: int
        :param handle: handle of the area, which properties should be returned

        |

        *Overload 3:*

        Returns area properties, such as name and handle.

        :type dwResultAreaFlags: int
        :param dwResultAreaFlags: should be IConnectProfiler2::grafTypeExec or
                                     IConnectProfiler2::grafTypeData, depending on address
                                     type
        :type aAddress: int
        :param aAddress: address of the area, which properties should be returned
        """
        return _connect.CProfilerController_getAreaProperties(self, *args)

    def start(self):
        r"""Starts profiler."""
        return _connect.CProfilerController_start(self)

    def stop(self):
        r"""
        Stops profiler.

        :rtype: boolean
        :return: true, is profiler was running, false if profiler was stopped
        """
        return _connect.CProfilerController_stop(self)

    def getStatus(self, *args):
        r"""
        Polls the profiler status.

        :type statusFlags: ::IConnectProfiler::EGetStatusFlags, optional
        :param statusFlags: define the type of information returned in CProfilerStatus.
                   See IConnectProfiler::EGetStatusFlags.
        """
        return _connect.CProfilerController_getStatus(self, *args)

    def getStatisticsAll(self, expectedSize, statisticsList):
        r"""
        Retrieves statistic results for all areas. If output vector size equals expectedSize,
        it means that there is more data to retrieve. Increase expected size and call
        this method again to get all data.

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsAll(self, expectedSize, statisticsList)

    def getStatisticsForHandle(self, handle, expectedSize, statisticsList):
        r"""
        Retrieves statistic results for area with the given handle. If output vector
        size equals expectedSize, it means that there is more data to retrieve.
        Increase expected size and call this method again to get all data.

        :type handle: int
        :param handle: profiler area handle

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsForHandle(self, handle, expectedSize, statisticsList)

    def getStatisticsForTask(self, *args):
        r"""
        *Overload 1:*

        Retrieves statistic results for task with the given ID, for all areas. If output
        vector size equals expectedSize, it means that there is more data to retrieve.
        Increase expected size and call this method again to get all data.

        :type taskID: int
        :param taskID: ID of the task

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return

        |

        *Overload 2:*

        Retrieves statistic results for task with the given profiler area handle.
        If output vector size equals expectedSize,
        it means that there is more data to retrieve.
        Increase expected size and call this method again to get all data.

        :type handle: int
        :param handle: profiler area handle
        :type taskId: int
        :param taskId: ID of the task

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsForTask(self, *args)

    def getStatisticsForValue(self, handle, value, expectedSize, statisticsList):
        r"""
        Retrieves statistic results for data area with the given handle and
        value.
        If output vector size equals expectedSize, it means that there is more data to
        retrieve. Increase expected size and call this method again to get all data.

        :type handle: int
        :param handle: profiler area handle
        :type value: int
        :param value: value of the task

        :type expectedSize: int
        :param expectedSize: expected number of statistics items to be returned. If it
            is to small only the specified number of items will be returned. If it is to big,
            to much memory is allocated for local buffer.

        :type statisticsList: :py:class:`StatisticsVector`
        :param statisticsList: the vector, which will contain results on return
        """
        return _connect.CProfilerController_getStatisticsForValue(self, handle, value, expectedSize, statisticsList)

    def getHistoryAll(self, startIDx, len, historyList):
        r"""
        Retrieves history of invocations for all areas.

        :type startIDx: int
        :param startIDx: start index of array of data to retrieve
        :type len: int
        :param len: number of history items to retrieve
        :type historyList: :py:class:`HistoryVector`
        :param historyList: vector to contain data on return
        """
        return _connect.CProfilerController_getHistoryAll(self, startIDx, len, historyList)

    def getHistoryForHandle(self, handle, startIDx, len, historyList):
        return _connect.CProfilerController_getHistoryForHandle(self, handle, startIDx, len, historyList)

    def getHistoryForTask(self, *args):
        return _connect.CProfilerController_getHistoryForTask(self, *args)

    def getHistoryForValue(self, handle, value, startIDx, len, historyList):
        return _connect.CProfilerController_getHistoryForValue(self, handle, value, startIDx, len, historyList)

    def waitUntilLoaded(self, timeout=0, pollingInterval=100):
        r"""
        This method polls profiler status with the given polling interval and
        returns when profiler stops loading samples from the hardware, or
        timeout expires.

        :type timeout: int, optional
        :param timeout: timeout in milliseconds. 0 means infinite timeout
        :type pollingInterval: int, optional
        :param pollingInterval: time between two readings of the profiler status
        :rtype: boolean
        :return: true if CPU is in stopped state, false if timeout expired
        """
        return _connect.CProfilerController_waitUntilLoaded(self, timeout, pollingInterval)

# Register CProfilerController in _connect:
_connect.CProfilerController_swigregister(CProfilerController)
class ITestCaseController(object):
    r"""Interface class for test case controllers."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_ITestCaseController

    def init(self):
        return _connect.ITestCaseController_init(self)

    def clean(self):
        return _connect.ITestCaseController_clean(self)

    def destroy(self):
        return _connect.ITestCaseController_destroy(self)

    def getTestCaseHandle(self):
        r"""
        Returns the test case handle. To be used when there is a need for
        other processes to access the test case info.
        """
        return _connect.ITestCaseController_getTestCaseHandle(self)

    def setTestTimeout(self, timeout):
        r"""
        Sets timeout in milliseconds for test execution - after this
        timeout the test is terminated.
        """
        return _connect.ITestCaseController_setTestTimeout(self, timeout)

    def createStub(self, *args):
        return _connect.ITestCaseController_createStub(self, *args)

    def createUserStub(self, functionName, stubFunctionName):
        return _connect.ITestCaseController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self):
        return _connect.ITestCaseController_getActiveStub(self)

    def createPersistentVariable(self, variableName, typeName):
        r"""
        This method creates variable on stack. The variable object
        created with this method is destroyed when the parent
        CSystemTestController object is destroyed. This method may
        *not* be called when unit test is in progress.
        Call initPersistentVars() and modify() to initialize the
        created variable.

        :type variableName: string
        :param variableName: name of the variable to be created

        :type typeName: string
        :param typeName: type of the variable. This should be one of
                            the existing types in the application under
                            test (defined in debug symbol table).

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.ITestCaseController_createPersistentVariable(self, variableName, typeName)

    def deletePersistentVariable(self, variableName):
        r"""
        Deletes variable. Note that method commitDeletedVars() must be called after
        all vars are deleted to apply changes on the target.

        :type variableName: string
        :param variableName: name of the variable to be deleted. The variable
                                had to be created with createVariable() before this call.

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.ITestCaseController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self):
        r"""
        Deletes variables deleted with deletePersistentVariable() on the target.

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.ITestCaseController_commitDeletedVars(self)

    def initPersistentVars(self):
        r"""
        Allocates persistent variables, which were created
        with createPersistentVariable(), on the stack. When persistent
        variables are no longer needed, call cleanPersistentVars().

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.ITestCaseController_initPersistentVars(self)

    def cleanPersistentVars(self):
        r"""
        Cleans persistent variables from the stack.

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.ITestCaseController_cleanPersistentVars(self)

    def setTestBatchNS(self, isBatchBegin):
        return _connect.ITestCaseController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self):
        return _connect.ITestCaseController_setDebugModeOn(self)

    def evaluate(self, expression, dwEvalFlags=0):
        return _connect.ITestCaseController_evaluate(self, expression, dwEvalFlags)

    def modify(self, lval, rval, dwEvalFlags=0):
        return _connect.ITestCaseController_modify(self, lval, rval, dwEvalFlags)

    def modifyAsString(self, lval, rval, dwEvalFlags=0):
        return _connect.ITestCaseController_modifyAsString(self, lval, rval, dwEvalFlags)

    def getStatus(self, *args):
        return _connect.ITestCaseController_getStatus(self, *args)

    def run(self):
        return _connect.ITestCaseController_run(self)

    def waitUntilStopped(self, timeout=0, pollingInterval=100):
        return _connect.ITestCaseController_waitUntilStopped(self, timeout, pollingInterval)

# Register ITestCaseController in _connect:
_connect.ITestCaseController_swigregister(ITestCaseController)
class CTestCaseController(ITestCaseController):
    r"""
    This class provides low level interface for configuration and
    execution of unit tests. Tests are executed on target without
    code instrumentation.


    Each test case has its life-cycle composed of several possible
    states. The figure below shows available states and events,
    which trigger transition between states. Event names with '()'
    are methods from this class, which trigger the transition.


    [*] --> offline: CTestCaseController()
    offline --> [*]: ~CTestCaseController
    offline --> initialized: init()
    initialized --> offline: destroy()
    initialized --> running: run()
    running --> ended: function under test returend
    running --> unexpectedstop: user stop or bp hit
    unexpectedstop --> running: run() when stub or test point BP was hit
    unexpectedstop --> offline: destroy() call when user BP was hit
    ended --> offline: destroy()
    running --> ended: on timeout


    The following rules apply for data access:
    - Function parameters may be created and evaluated only in state ``initialized``.
    - Return value is only available in state ``ended``.
    - local variables (created with createVariable())can be accessed in any state except ``offline``.

    Python example with script callbacks: _sample_link{itest,script_callback_methods}
    Python example: _sample_link{test_case_ctrl,test_init_close}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates test case for the given function. The test case declaration
        is stored in winIDEA buffer, and does not get on target until it is
        initialized. Only one test case may be in initialized state.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        :type functionName: string
        :param functionName: name of the function to test

        :type retValName: string
        :param retValName: name of the variable used to store the
                              function return value, so that it can be
                              used after test for verification. May be empty
                              string if it is not used by test or function
                              is of type void.

        Python example: _sample_link{test_case_ctrl,test_init_close}

        |

        *Overload 2:*

        Creates test case controller for the given handle. When using this ctor,
        test case controller with the given handle must exist, and this instance
        is valid only as long as the original controller exists. The purpose of
        this ctor is to be used from Python, when original controller was created
        in testIDEA. We can not pass pointers to other processes, so we pass a handle
        when Python script functions are being called during test.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        :type testCaseHandle: int
        :param testCaseHandle: handle of existing test case
            Python example: _sample_link{test_case_ctrl,test_set_test_batch}
        """
        _connect.CTestCaseController_swiginit(self, _connect.new_CTestCaseController(*args))
    __swig_destroy__ = _connect.delete_CTestCaseController

    def destroy(self):
        r"""
        Destroys object on the target. If this method is not called,
        the object is destroyed by destructor.

        Python example: _sample_link{test_case_ctrl,test_control}
        """
        return _connect.CTestCaseController_destroy(self)

    def getTestCaseHandle(self):
        r"""
        Returns the test case handle. To be used when there is a need for
        other processes to access the test case info.

        Python example: _sample_link{test_case_ctrl,test_get_test_case_handle}
        """
        return _connect.CTestCaseController_getTestCaseHandle(self)

    def createParameter(self, *args):
        r"""
        Creates function parameter and assignes a name to it, because
        debug information does not provide it.

        :type parameterIndex: int
        :param parameterIndex: 0-based index of parameter in function parameter list

        :type parameterName: string
        :param parameterName: name of parameter to be used when setting it's value.

        :type parameterValue: string, optional
        :param parameterValue: Value of parameter; default value is "".

        Python example: _sample_link{test_case_ctrl,test_create_parameter}
        """
        return _connect.CTestCaseController_createParameter(self, *args)

    def createVariable(self, *args):
        r"""
        Utility method for variable creation. The variable object created
        with this method is destroyed when the parent CTestCaseController
        object is destroyed.

        :type variableName: string
        :param variableName: name of the variable to be created

        :type typeName: string
        :param typeName: type of the variable. This should be one of
                            the existing types in the application under
                            test (defined in debug symbol table).

        :type flags: int, optional
        :param flags: see IConnectTest::ECreateVariableExFlags

        Python example: _sample_link{test_case_ctrl,test_modify}
        Python example: _sample_link{itest,test_case_controller_example}
        """
        return _connect.CTestCaseController_createVariable(self, *args)

    def deletePersistentVariable(self, variableName):
        r"""
        See also: ITestCaseController::deletePersistentVariable()

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CTestCaseController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self):
        r"""
        See also: ITestCaseController::commitDeletedVars()
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CTestCaseController_commitDeletedVars(self)

    def setTestTimeout(self, timeout):
        r"""
        Sets timeout in which the test should be terminated if it does
        not end normally.
        Python example: _sample_link{test_case_ctrl,test_set_test_timeout}
        """
        return _connect.CTestCaseController_setTestTimeout(self, timeout)

    def createStub(self, *args):
        r"""
        *Overload 1:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent CTestCaseController
        object is destroyed. Breakpoints for stubs created with this method are
        managed automatically by winIDEA.

        :type functionName: string
        :param functionName: name of the stubbed function

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}

        |

        *Overload 2:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent CTestCaseController
        object is destroyed.

        :type flags: int
        :param flags: see IConnectTest::EStubFlags
        :type stubbedFunctionName: string
        :param stubbedFunctionName: name of the stubbed function

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CTestCaseController_createStub(self, *args)

    def createUserStub(self, functionName, stubFunctionName):
        r"""
        This method creates user stub. If ``stubFunctionName`` parameter
        is not empty, then execution continues on stub method on the target,
        when this stub is hit. If the ``stubFunctionName``  parameter is empty string,
        then return instruction is inserted at the start of the stubbed function.

        For the first approach with target function name in ``stubFunctionName``,
        we have to provide additional function on target,
        with the same prototype as stubbed methods.

        The second approach with immediate return should be used only for
        void functions without output parameters.

        :type functionName: string
        :param functionName: name of the stubbed function
        :type stubFunctionName: string
        :param stubFunctionName: name of the function, which should be
                                    called instead of the stubbed function, or
                                    an empty string

        Python example: _sample_link{test_case_ctrl,test_create_user_stub}
        """
        return _connect.CTestCaseController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self):
        r"""
        When test case execution stops at stub, this method returns
        the stub controller. It can be used to set stub return value
        and other variables. This method should only be called when
        the method getStatus() returns IConnectTest::stateStub.

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CTestCaseController_getActiveStub(self)

    def createPersistentVariable(self, variableName, typeName):
        r"""Python example: _sample_link{test_case_ctrl,test_persistent_vars}"""
        return _connect.CTestCaseController_createPersistentVariable(self, variableName, typeName)

    def initPersistentVars(self):
        r"""Python example: _sample_link{test_case_ctrl,test_persistent_vars}"""
        return _connect.CTestCaseController_initPersistentVars(self)

    def cleanPersistentVars(self):
        r"""Python example: _sample_link{test_case_ctrl,test_persistent_vars}"""
        return _connect.CTestCaseController_cleanPersistentVars(self)

    def evaluate(self, expression, dwEvalFlags=0):
        r"""
        Evaluates the given expression and returns result as a string.
        This method is similar to IConnectDebug::Evaluate(). The difference is
        in variable scope, since this method takes into account also variables
        created by createVariable() and the test case return value.


        See state descriptions above for data accessibility.

        __Important:__ Returned string depends on GUI settings for integer types,
        for example for value -11 of type `short` the function returns 0xFFF5 if
        hex mode is selected in winIDEA watch window. To avoid this dependency,
        add format postfix to the the expression, for
        example `d`: `evaluate("counter,d")`.

        :type expression: string
        :param expression: the expression to be evaluated
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: _sample_link{itest,test_case_controller_example}
        Python example: _sample_link{test_case_ctrl,test_evaluate}
        """
        return _connect.CTestCaseController_evaluate(self, expression, dwEvalFlags)

    def modify(self, expression, value, dwEvalFlags=0):
        r"""
        Modifies expression to the given value. Expression must be an lvalue.


        See state descriptions above for data accessibility.

        :type expression: string
        :param expression: lvalue to be modified
        :type value: string
        :param value: the value to be assigned to 'expression'
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example with callback methods: _sample_link{itest,script_callback_methods}
        Python example: _sample_link{test_case_ctrl,test_modify}
        """
        return _connect.CTestCaseController_modify(self, expression, value, dwEvalFlags)

    def modifyAsString(self, lval, rval, dwEvalFlags=0):
        r"""
        Sets lval to rval. If rval is double quoted string, then lval
        must be pointer or array. Assignments lval[i] = 'rval[i]' for
        each element in rval are made. Normal assignment (lval = rval)
        is performed if rval does not start and end with double quote.

        :type lval: string
        :param lval: left-value, for example name of variable, register, ...
        :type rval: string
        :param rval: value to assign. Can be "double quoted" string for string
                        array assignments or array of values for array assignment:
                        {0, 1, 2, 3, 4}
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        Python example: _sample_link{itest,test_case_controller_example}
        Python example: _sample_link{test_case_ctrl,test_modify}
        """
        return _connect.CTestCaseController_modifyAsString(self, lval, rval, dwEvalFlags)

    def getStatus(self, *args):
        r"""
        *Overload 1:*

        Returns the current test case status.

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}

        |

        *Overload 2:*

        Returns the current test case status.

        :type flags: int
        :param flags: use IConnectTest::EStatusFlags
        """
        return _connect.CTestCaseController_getStatus(self, *args)

    def init(self):
        r"""
        Initializes the test case by initializing environment on
        the target according to function under test. Brings the
        test from limbo state or reinitializes an already
        initialized test case.

        :raises: IllegalStateException if there already exists an
            initialized test case. Call clean() on the active test case
            first.

        :rtype: boolean
        :return: false if ret val was specified and function returns void.
                          Returns true otherwise.

        Python example: _sample_link{test_case_ctrl,test_modify}
        """
        return _connect.CTestCaseController_init(self)

    def clean(self):
        r"""
        Deprecated: call destroy() instead.

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CTestCaseController_clean(self)

    def setTestBatchNS(self, isBatchBegin):
        r"""
        Marks start of test batch. When ``isBatchBegin`` = ``true``, winIDEA
        remembers the batch start and saves
        target state, but it does not restore it at the end of the test, but only
        when this method is called again with ``isBatchBegin`` is ``false``.
        This method can be called several times with ``isBatchBegin`` = ``true``,
        but it must be called the same number of times with ``isBatchBegin`` = ``false``
        to restore the state. Postfix NS stands for non-static. Use ctor
        CTestCaseController(std::shared_ptr<ConnectionMgr> connectionMgr, 0) to
        instantiate object for calling this method.

        :type isBatchBegin: boolean
        :param isBatchBegin: when true, winIDEA saves target state, when false, it is restored.

        See also: setTestBatch(ConnectionMgrSPtr, bool)

        Python example: _sample_link{test_case_ctrl,test_set_test_batch}
        """
        return _connect.CTestCaseController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self):
        r"""
        Turns debug mode on for the next test case. Speed optimizations
        will be disabled, so winIDEA UI will be refreshed. This method must
        be called after method ``init()`` to have effect.

        Python example: _sample_link{test_case_ctrl,test_set_debug_mode_on}
        """
        return _connect.CTestCaseController_setDebugModeOn(self)

    @staticmethod
    def setTestBatch(connectionMgr, isBatchBegin):
        r"""
        Static variant of setTestBatchNS(bool) .
        See also: setTestBatchNS(bool)
        """
        return _connect.CTestCaseController_setTestBatch(connectionMgr, isBatchBegin)

    def run(self):
        r"""
        Runs an initialized test case; it has no effect if the test
        case is not initialized (i.e. in limbo); valid only if the
        test case is clean initialized (not valid for resume).

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CTestCaseController_run(self)

    def abort(self):
        return _connect.CTestCaseController_abort(self)

    def pause(self):
        return _connect.CTestCaseController_pause(self)

    @staticmethod
    def clearAllTests(connection):
        r"""
        Removes all test data from isystem.connect. All existing instances of
        this class should be destroyed, because their handles are no
        longer valid. Use this method when the state of the
        ``iconnect.test`` is not known, for example at application
        startup, to remove any data that remained from the previous run.


        Python example: _sample_link{test_case_ctrl,test_init_close}
        """
        return _connect.CTestCaseController_clearAllTests(connection)

    def waitUntilStopped(self, timeoutMs=0, pollingIntervalMs=100):
        r"""
        This method polls test execution status with the given polling interval and
        returns when the test stops or timeout expires. The test may stop for
        several reasons. To get the reason, call the getStatus() method.

        :type timeoutMs: int, optional
        :param timeoutMs: timeout in milliseconds. 0 means infinite timeout
        :type pollingIntervalMs: int, optional
        :param pollingIntervalMs: time in milliseconds between two readings of the test status

        :rtype: boolean
        :return: true if the test is in stopped state, false if timeout expired

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CTestCaseController_waitUntilStopped(self, timeoutMs, pollingIntervalMs)

    @staticmethod
    def testState2str(state):
        r"""
        Converts test state to enum string. This is a utility function for logging
        and error reporting. Program logic should always use enum directly.
        If enum value can't be mapped
        to one of defined values, the return string contains its integer
        representation.
        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CTestCaseController_testState2str(state)

    def stubState2str(self, state):
        r"""
        Converts stub state to enum string. This is a utility function for logging
        and error reporting. Program logic should always use enum directly.
        If enum value can't be mapped
        to one of defined values, the return string contains its integer
        representation.
        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CTestCaseController_stubState2str(self, state)

    @staticmethod
    def s2i64(numStr):
        r"""
        Utility method for string to number conversion. It accepts numbers
        in decimal, hexadecimal formats and character formats, for
        example: "16", "0x10", and "\xFF".
        No leading spaces are allowed or signs for decimal numbers.

        Python example: _sample_link{test_case_ctrl,test_s2i64}
        """
        return _connect.CTestCaseController_s2i64(numStr)

    @staticmethod
    def verifyRetVal(icTest, retVal, description, handle, objectId):
        return _connect.CTestCaseController_verifyRetVal(icTest, retVal, description, handle, objectId)

# Register CTestCaseController in _connect:
_connect.CTestCaseController_swigregister(CTestCaseController)
CTestCaseController.POSITION_PARAM_NAME_PREFIX = _connect.cvar.CTestCaseController_POSITION_PARAM_NAME_PREFIX

class CTestStubController(object):
    r"""
    This class wraps test case stubs, which are created, used, and
    destroyed by IControlTest class. Stubs may have lifetime different
    than single test case, for example they may be used by several test cases.


    Stub replaces function called by function under test. Since no
    code instrumentation is allowed, only breakpoint is set at the given
    function. When the function is called, the test case execution stops,
    and then the test framework can define next actions. Usually it will
    simulate desired side effects of a stubbed function (for example set
    return value, local and global variables), and then continue execution of the
    function under test.


    Destructor automatically destroys the stub on the target.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SCRIPT_STUB = _connect.CTestStubController_E_SCRIPT_STUB
    r"""
    stub is implemented as breakpoint at the start of the
    stubbed function. Target stops and program (script) on PC takes control
    """
    E_RT_USER_STUB = _connect.CTestStubController_E_RT_USER_STUB
    r"""user specified function on a target is called instead of the stubbed function"""
    E_RT_EMPTY_STUB = _connect.CTestStubController_E_RT_EMPTY_STUB
    r"""
    the stubbed function is not executed, but ths execution immediately
    returns to the caller
    """

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates empty controller, call method create() to actually create
        stub in winIDEA. Use this ctor, when greater flexibility is required
        for stub creation (for example, when  stub breakpoint setting should
        not be managed by winIDEA (for example, when there are not enough HW BPs)).

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        |

        *Overload 2:*

        Creates function stub on the target.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA

        :type stubbedFunctionName: string
        :param stubbedFunctionName: name of the function to be stubbed
        """
        _connect.CTestStubController_swiginit(self, _connect.new_CTestStubController(*args))
    __swig_destroy__ = _connect.delete_CTestStubController

    def create(self, flags, stubbedFunctionName):
        r"""
        Creates stub in winIDEA.

        :type flags: int
        :param flags: see IConnectTest::EStubFlags
        :type stubbedFunctionName: string
        :param stubbedFunctionName: name of the function to be stubbed
        """
        return _connect.CTestStubController_create(self, flags, stubbedFunctionName)

    def createParameter(self, parameterIndex, parameterName):
        r"""
         Assigns a name to stub parameter at the given position.
        The assigned name may be used in expressions by
        CTestCaseController::evaluate() and
        CTestCaseController::modify().

        :type parameterIndex: int
        :param parameterIndex: 0 - based parameter index
        :type parameterName: string
        :param parameterName: name assigned to parameter
        """
        return _connect.CTestStubController_createParameter(self, parameterIndex, parameterName)

    def createReturnValue(self, retValName):
        r"""
        Assigns a name to stub return value.
        The assigned name may be used in expressions by
        CTestCaseController::evaluateExpression() and
        CTestCaseController::modifyExpression() to define value returned
        to the function under test.

        :type retValName: string
        :param retValName: name assigned to return value
        """
        return _connect.CTestStubController_createReturnValue(self, retValName)

    def getStubName(self):
        r"""Returns stub name."""
        return _connect.CTestStubController_getStubName(self)

    def getRetValName(self):
        r"""Returns return value name."""
        return _connect.CTestStubController_getRetValName(self)

    def getHandle(self):
        r"""Returns handle as used by IConnectTest."""
        return _connect.CTestStubController_getHandle(self)

# Register CTestStubController in _connect:
_connect.CTestStubController_swigregister(CTestStubController)
class CSystemTestController(ITestCaseController):
    r"""
    This class can create and execute tests, which are not limited
    to single function. We can initialize target and start test
    programatically, and then the same way stop the target and
    analyze the target state (registers, variables, ...).

    API implemented by this class is relatively low lever. Python clients are
    advised to use the PTestCase class.

    Python example: _sample_link{test_case_ctrl,test_persistent_vars}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection to winIDEA
        """
        _connect.CSystemTestController_swiginit(self, _connect.new_CSystemTestController(connectionMgr))
    __swig_destroy__ = _connect.delete_CSystemTestController

    def init(self):
        r"""
        Applies created stubs on the target. Call this method before
        running target.
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_init(self)

    def clean(self):
        r"""
        Deprecated: call destroy() instead.

        If this method is not called, objects are destroyed in
        destructor.
        """
        return _connect.CSystemTestController_clean(self)

    def destroy(self):
        r"""
        Destroys all items related to test, for example stubs, and persistent
        variables.

        If this method is not called, objects are destroyed in
        destructor.
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_destroy(self)

    def getTestCaseHandle(self):
        return _connect.CSystemTestController_getTestCaseHandle(self)

    def createPersistentVariable(self, variableName, typeName):
        r"""
        This method creates variable on stack. The variable object
        created with this method is destroyed when the parent
        CSystemTestController object is destroyed. This method may
        *not* be called when unit test is in progress.
        Call initPersistentVars() and modify() to initialize the
        created variable.

        :type variableName: string
        :param variableName: name of the variable to be created

        :type typeName: string
        :param typeName: type of the variable. This should be one of
                            the existing types in the application under
                            test (defined in debug symbol table).

        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_createPersistentVariable(self, variableName, typeName)

    def deletePersistentVariable(self, variableName):
        r"""
        See also: ITestCaseController::deletePersistentVariable()
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_deletePersistentVariable(self, variableName)

    def commitDeletedVars(self):
        r"""
        See also: ITestCaseController::commitDeletedVars()
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_commitDeletedVars(self)

    def initPersistentVars(self):
        r"""
        Allocates persistent variables, which were created
        with createPersistentVariable(), on the stack. When persistent
        variables are no longer needed, call cleanPersistentVars().
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_initPersistentVars(self)

    def cleanPersistentVars(self):
        r"""
        Cleans persistent variables from the stack.
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_cleanPersistentVars(self)

    def setTestTimeout(self, timeout):
        r"""
        Sets timeout in ms.
        Python example: _sample_link{test_case_ctrl,test_persistent_vars}
        """
        return _connect.CSystemTestController_setTestTimeout(self, timeout)

    def createStub(self, *args):
        r"""
        *Overload 1:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent
        CSystemTestController object is destroyed. When this stub is
        hit, control is transferred to script running on PC - it
        can modify parameters, set return value and restart
        execution.

        The stub is implemented as breakpoint at the first method
        instruction.

        :type functionName: string
        :param functionName: name of the stubbed function

        Python example: _sample_link{sysTests,stubs_and_user_stubs_in_sys_tests}
        Python example: _sample_link{test_case_ctrl,test_get_active_stub}

        |

        *Overload 2:*

        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent
        CSystemTestController object is destroyed. When this stub is
        hit, control is transferred to script running on PC - it
        can modify parameters, set return value and restart
        execution.

        The stub is implemented as breakpoint at the first method
        instruction. Breakpoint handling can be automatic or custom
        controlled - see flags.

        :type flags: int
        :param flags: see IConnectTest::EStubFlags
        :type functionName: string
        :param functionName: name of the stubbed function

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CSystemTestController_createStub(self, *args)

    def createUserStub(self, functionName, stubFunctionName):
        r"""
        Utility method for stub creation. The stub object created
        with this method is destroyed when the parent
        CSystemTestController object is destroyed. When this stub is
        hit, execution continues in stub function on the target,
        which replaces stubbed function. We have to provide
        additional functions with the same prototype as stubbed
        functions to be used as stubs.

        The stub is implemented as replacement of the first
        instruction in the stubbed function with jump to the stub function.

        :type functionName: string
        :param functionName: name of the stubbed function
        :type stubFunctionName: string
        :param stubFunctionName: name of the function, which should be
                                    called instead of the stubbed function

        Python example: _sample_link{test_case_ctrl,test_create_user_stub}
        """
        return _connect.CSystemTestController_createUserStub(self, functionName, stubFunctionName)

    def getActiveStub(self):
        r"""
        When test case execution stops at stub, this method returns
        the stub controller. It can be used to set stub return value
        and other variables. This method should only be called when
        the method ``getStatus()`` returns ``IConnectTest::stateStub``.

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CSystemTestController_getActiveStub(self)

    def setTestBatchNS(self, isBatchBegin):
        return _connect.CSystemTestController_setTestBatchNS(self, isBatchBegin)

    def setDebugModeOn(self):
        return _connect.CSystemTestController_setDebugModeOn(self)

    def evaluate(self, expression, dwEvalFlags=0):
        r"""
        Evaluates the given expression and returns result as a string.
        This method is similar to IConnectDebug::Evaluate(). The difference is
        in variable scope, since this method takes into account also variables
        created by createPersistentVariable().


        :type expression: string
        :param expression: the expression to be evaluated
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: _sample_link{itest,persistent_vars}
        Python example: _sample_link{test_case_ctrl,test_evaluate}
        """
        return _connect.CSystemTestController_evaluate(self, expression, dwEvalFlags)

    def modify(self, expression, value, dwEvalFlags=0):
        r"""
        Modifies expression to the given value. Expression must be an lvalue.


        :type expression: string
        :param expression: lvalue to be modified
        :type value: string
        :param value: the value to be assigned to 'expression'
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        :rtype: string
        :return: evaluation result

        Python example: _sample_link{test_case_ctrl,test_modify}
        """
        return _connect.CSystemTestController_modify(self, expression, value, dwEvalFlags)

    def modifyAsString(self, expression, value, dwEvalFlags=0):
        r"""
        Sets lval to rval. If rval is double quoted string, then lval
        must be pointer or array. Assignments lval[i] = 'rval[i]' for
        each element in rval are made. Normal assignment (lval = rval)
        is performed if rval does not start and end with double quote.

        :type expression: string
        :param expression: left-value, for example name of variable, register, ...
        :type value: string
        :param value: value to assign. Can be "double quoted" string for string
                        array assignments or array of values for array assignment:
                        {0, 1, 2, 3, 4}
        :type dwEvalFlags: int, optional
        :param dwEvalFlags: see IConnectTest::EEvaluateFlags

        Python example: _sample_link{test_case_ctrl,test_modify}
        """
        return _connect.CSystemTestController_modifyAsString(self, expression, value, dwEvalFlags)

    def getStatus(self, *args):
        r"""
        *Overload 1:*

        Returns the current execution status.

        Python example: _sample_link{sysTests,stubs_and_user_stubs_in_sys_tests}
        Python example: _sample_link{test_case_ctrl,test_get_active_stub}

        |

        *Overload 2:*

        Returns the current execution status.

        :type flags: int
        :param flags: use IConnectTest::EStatusFlags

        Python example: _sample_link{sysTests,stubs_and_user_stubs_in_sys_tests}
        """
        return _connect.CSystemTestController_getStatus(self, *args)

    def run(self):
        r"""
        Runs the target.

        Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CSystemTestController_run(self)

    def stop(self):
        r"""
        Stops the target.

        Python example: _sample_link{sysTests,stubs_and_user_stubs_in_sys_tests}
        """
        return _connect.CSystemTestController_stop(self)

    def waitUntilStopped(self, timeoutMs=0, pollingIntervalMs=100):
        r"""
        This method polls test execution status with the given polling interval and
        returns when the target stops or timeout expires. The execution may stop for
        several reasons. To get the reason, call the getStatus() method.

        :type timeoutMs: int, optional
        :param timeoutMs: timeout in milliseconds. 0 means infinite timeout
        :type pollingIntervalMs: int, optional
        :param pollingIntervalMs: time in milliseconds between two readings of the test status

        :rtype: boolean
        :return: true if the test is in stopped state, false if timeout expired
            Python example: _sample_link{test_case_ctrl,test_get_active_stub}
        """
        return _connect.CSystemTestController_waitUntilStopped(self, timeoutMs, pollingIntervalMs)

# Register CSystemTestController in _connect:
_connect.CSystemTestController_swigregister(CSystemTestController)
class CDebugFacade(object):
    r"""
    This class is a facade for few other classes. It adds no new
    functionality, but provides all-in-one interface for the most common
    isystem.connect operations. It contains most of the functionality of
    the following classes:
    - CAddressController
    - CBreakpointController
    - CDataController
    - CExecutionController
    - CLoaderController




    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.

        Python example: _sample_link{debug_facade,test_get_controllers}
        """
        _connect.CDebugFacade_swiginit(self, _connect.new_CDebugFacade(connectionMgr))
    __swig_destroy__ = _connect.delete_CDebugFacade

    def getAddressController(self):
        r"""
         Returns reference to address controller.

        Python example: _sample_link{debug_facade,test_get_controllers}
        """
        return _connect.CDebugFacade_getAddressController(self)

    def getBreakpointController(self):
        r"""
         Returns reference to breakpoint controller.
        Python example: _sample_link{debug_facade,test_get_controllers}
        """
        return _connect.CDebugFacade_getBreakpointController(self)

    def getDataController(self):
        r"""
         Returns reference to data controller.
        Python example: _sample_link{debug_facade,test_get_controllers}
        """
        return _connect.CDebugFacade_getDataController(self)

    def getExecutionController(self):
        r"""
         Returns reference to execution controller.
        Python example: _sample_link{debug_facade,test_get_controllers}
        """
        return _connect.CDebugFacade_getExecutionController(self)

    def getLoaderController(self):
        r"""
         Returns reference to loader controller.
        Python example: _sample_link{debug_facade,test_get_controllers}
        """
        return _connect.CDebugFacade_getLoaderController(self)

    def getCodeArea(self, bPhysical):
        r"""See documentation of CAddressController::getCodeArea(bool)  ."""
        return _connect.CDebugFacade_getCodeArea(self, bPhysical)

    def getFunctionAddress(self, functionName):
        r"""See documentation of CAddressController::getFunctionAddress(const std::string &)  ."""
        return _connect.CDebugFacade_getFunctionAddress(self, functionName)

    def getVariableAddress(self, variableName):
        r"""See documentation of CAddressController::getVariableAddress(const std::string &) ."""
        return _connect.CDebugFacade_getVariableAddress(self, variableName)

    def getExpressionAddress(self, expression):
        r"""See documentation of CAddressController::getExpressionAddress(const std::string &) ."""
        return _connect.CDebugFacade_getExpressionAddress(self, expression)

    def getLabelAddress(self, labelName):
        r"""See documentation of CAddressController::getLabelAddress(const std::string &) ."""
        return _connect.CDebugFacade_getLabelAddress(self, labelName)

    def getSymbolInfo(self, flags, expression):
        r"""See documentation of CAddressController::getSymbolInfo(uint32_t, const std::string &) ."""
        return _connect.CDebugFacade_getSymbolInfo(self, flags, expression)

    def getSymbolAtAddress(self, *args):
        r"""See documentation of CAddressController::getSymbolAtAddress(isys::IConnectDebug::ESymbolFlags, uint8_t, ADDRESS_64, isys::IConnectDebug::ESymbolFlags) ."""
        return _connect.CDebugFacade_getSymbolAtAddress(self, *args)

    def getAddressOfSourceLineAtPathSource(self, fileName, line, source, isReportSize=False):
        r"""See documentation of CAddressController::getAddressOfSourceLineAtPathSource(const std::string &,int,const CAddressController::EPathSource&, bool) ."""
        return _connect.CDebugFacade_getAddressOfSourceLineAtPathSource(self, fileName, line, source, isReportSize)

    def getAddressOfSourceLine(self, fileName, line, isReportSize=False):
        r"""See documentation of CAddressController::getAddressOfSourceLine(const std::string &,int,bool) ."""
        return _connect.CDebugFacade_getAddressOfSourceLine(self, fileName, line, isReportSize)

    def getSourceLineAtAddress(self, *args):
        r"""
        *Overload 1:*
        See documentation of CAddressController::getSourceLineAtAddress(ADDRESS_64) .

        |

        *Overload 2:*
        See documentation of CAddressController::getSourceLineAtAddress(ADDRESS_64, bool, bool) .
        """
        return _connect.CDebugFacade_getSourceLineAtAddress(self, *args)

    def getSourceLineAtAddressAtPathSource(self, *args):
        r"""
        *Overload 1:*
        See documentation of CAddressController::getSourceLineAtAddressAtPathSource(ADDRESS_64, const CAddressController::EPathSource&) .

        |

        *Overload 2:*
        See documentation of CAddressController::getSourceLineAtAddressAtPathSource(ADDRESS_64, bool, bool, const CAddressController::EPathSource&) .
        """
        return _connect.CDebugFacade_getSourceLineAtAddressAtPathSource(self, *args)

    def setBP(self, *args):
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setBP(const std::string &, int, const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setBP(int, const std::string &, int, const std::string &) .

        |

        *Overload 3:*
        See documentation of CBreakpointController#setBP(int, const std::string &, int, const std::string &) .

        |

        *Overload 4:*
        See documentation of CBreakpointController#setBP(int, const std::string &, int, const std::string &) .

        |

        *Overload 5:*
        See documentation of CBreakpointController#setBP(int, ADDRESS_64, int, const std::string &) .

        |

        *Overload 6:*
        See documentation of CBreakpointController#setBP(int, ADDRESS_64, int, const std::string &) .

        |

        *Overload 7:*
        See documentation of CBreakpointController#setBP(int, ADDRESS_64, int, const std::string &) .
        """
        return _connect.CDebugFacade_setBP(self, *args)

    def setHWBP(self, *args):
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setHWBP(DWORD, DWORD, DWORD, bool, const std::string &, DWORD) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setHWBP(DWORD, DWORD, DWORD, int, ADDRESS_64, DWORD) .
        """
        return _connect.CDebugFacade_setHWBP(self, *args)

    def deleteBP(self, *args):
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#deleteBP(const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#deleteBP(const std::string &, int) .

        |

        *Overload 3:*
        See documentation of CBreakpointController#deleteBP(int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_deleteBP(self, *args)

    def deleteHWBP(self, *args):
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#deleteHWBP(const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#deleteHWBP(int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_deleteHWBP(self, *args)

    def deleteAll(self):
        r"""See documentation of CBreakpointController#deleteAll() ."""
        return _connect.CDebugFacade_deleteAll(self)

    def deleteAllHWBP(self):
        r"""See documentation of CBreakpointController#deleteAllHWBP() ."""
        return _connect.CDebugFacade_deleteAllHWBP(self)

    def setEnabled(self, *args):
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setEnabled(bool, const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setEnabled(bool, const std::string &, int) .

        |

        *Overload 3:*
        See documentation of CBreakpointController#setEnabled(bool, int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_setEnabled(self, *args)

    def setHWEnabled(self, *args):
        r"""
        *Overload 1:*
        See documentation of CBreakpointController#setHWEnabled(bool, const std::string &) .

        |

        *Overload 2:*
        See documentation of CBreakpointController#setHWEnabled(bool, int, ADDRESS_64) .
        """
        return _connect.CDebugFacade_setHWEnabled(self, *args)

    def setHWEnabledAll(self, isEnabled):
        r"""See documentation of CBreakpointController#setHWEnabledAll(bool) ."""
        return _connect.CDebugFacade_setHWEnabledAll(self, isEnabled)

    def setEnabledAll(self, isEnabled):
        r"""See documentation of CBreakpointController#setEnabledAll(bool) ."""
        return _connect.CDebugFacade_setEnabledAll(self, isEnabled)

    def reapplyAll(self):
        r"""See documentation of CBreakpointController#reapplyAll() ."""
        return _connect.CDebugFacade_reapplyAll(self)

    def getCPUInfo(self):
        r"""See documentation of CDataController#getCPUInfo() ."""
        return _connect.CDebugFacade_getCPUInfo(self)

    def getMemoryAreaBytesPerMAU(self, memArea):
        r"""See documentation of CDataController#getMemoryAreaBytesPerMAU(int) ."""
        return _connect.CDebugFacade_getMemoryAreaBytesPerMAU(self, memArea)

    def readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU):
        r"""
        See documentation
        of CDataController#readMemory(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, ADDRESS_64, BYTE)  .
        """
        return _connect.CDebugFacade_readMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU)

    def writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff):
        r"""
        See documentation
        of CDataController#writeMemory(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, ADDRESS_64, BYTE, std::vector<BYTE> &) .
        """
        return _connect.CDebugFacade_writeMemory(self, accessFlags, memArea, aAddress, aNumMAUs, bytesPerMAU, buff)

    def readRegister(self, accessFlags, registerName):
        r"""See documentation of CDataController#readRegister(IConnectDebug::EAccessFlags, const std::string &) ."""
        return _connect.CDebugFacade_readRegister(self, accessFlags, registerName)

    def writeRegister(self, accessFlags, registerName, registerInfo):
        r"""See documentation of CDataController#writeRegister(IConnectDebug::EAccessFlags, const std::string &, const CValueType &) ."""
        return _connect.CDebugFacade_writeRegister(self, accessFlags, registerName, registerInfo)

    def readValue(self, accessFlags, memArea, aAddress, type):
        r"""See documentation of CDataController#readValue(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, const SType &) ."""
        return _connect.CDebugFacade_readValue(self, accessFlags, memArea, aAddress, type)

    def writeValue(self, *args):
        r"""
        *Overload 1:*
        See documentation of CDataController#writeValue(IConnectDebug::EAccessFlags, BYTE, ADDRESS_64, const CValueType &) .

        |

        *Overload 2:*
        See documentation of CDataController#writeValue(IConnectDebug::EAccessFlags, bool, BYTE, ADDRESS_64, const CValueType &) .
        """
        return _connect.CDebugFacade_writeValue(self, *args)

    def evaluate(self, *args):
        r"""
        *Overload 1:*
        See documentation of CDataController#evaluate(IConnectDebug#EAccessFlags, const std::string &) .

        |

        *Overload 2:*
        See documentation of CDataController#evaluate(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &) .
        """
        return _connect.CDebugFacade_evaluate(self, *args)

    def modify(self, *args):
        r"""
        *Overload 1:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, const std::string &, const CValueType &, bool) .

        |

        *Overload 2:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, const std::string &, const std::string &, bool) .

        |

        *Overload 3:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, const std::string &, const std::string &, bool) .

        |

        *Overload 4:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .

        |

        *Overload 5:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const CValueType &, bool) .

        |

        *Overload 6:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const std::string &, bool) .

        |

        *Overload 7:*
        See documentation of CDataController#modify(IConnectDebug::EAccessFlags, IConnectDebug::EEvaluate, const std::string &, const std::string &, bool) .
        """
        return _connect.CDebugFacade_modify(self, *args)

    def run(self, *args):
        r"""
        *Overload 1:*
        See documentation of CExecutionController#run() .

        |

        *Overload 2:*
        See documentation of CExecutionController#run(CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_run(self, *args)

    def runUntilReturn(self, *args):
        r"""
        *Overload 1:*
        See documentation of CExecutionController#runUntilReturn() .

        |

        *Overload 2:*
        See documentation of CExecutionController#runUntilReturn(isys::CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_runUntilReturn(self, *args)

    def runUntilAddress(self, *args):
        r"""
        *Overload 1:*
        See documentation of CExecutionController#runUntilAddress(uint8_t, ADDRESS_64) .

        |

        *Overload 2:*
        See documentation of CExecutionController#runUntilAddress(uint8_t, ADDRESS_64, CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_runUntilAddress(self, *args)

    def runUntilFunction(self, *args):
        r"""
        *Overload 1:*
        See documentation of CExecutionController#runUntilFunction(const std::string &) .

        |

        *Overload 2:*
        See documentation of CExecutionController#runUntilFunction(const std::string &, CExecutionController::ETimeoutMode, bool) .
        """
        return _connect.CDebugFacade_runUntilFunction(self, *args)

    def setSlowRun(self, isSlowRun):
        r"""See documentation of CExecutionController#setSlowRun(bool) ."""
        return _connect.CDebugFacade_setSlowRun(self, isSlowRun)

    def gotoAddress(self, memArea, address):
        r"""See documentation of CExecutionController#gotoAddress(uint8_t, ADDRESS_64) ."""
        return _connect.CDebugFacade_gotoAddress(self, memArea, address)

    def gotoFunction(self, functionName):
        r"""See documentation of CExecutionController#gotoFunction(const std::string &) ."""
        return _connect.CDebugFacade_gotoFunction(self, functionName)

    def reset(self):
        r"""See documentation of CExecutionController#reset() ."""
        return _connect.CDebugFacade_reset(self)

    def stop(self):
        r"""See documentation of CExecutionController#stop() ."""
        return _connect.CDebugFacade_stop(self)

    def stepHigh(self, *args):
        r"""See documentation of CExecutionController#stepHigh() ."""
        return _connect.CDebugFacade_stepHigh(self, *args)

    def stepOverHigh(self, *args):
        r"""See documentation of CExecutionController#stepOverHigh(CExecutionController::ETimeoutMode, bool) ."""
        return _connect.CDebugFacade_stepOverHigh(self, *args)

    def stepInst(self, *args):
        r"""See documentation of CExecutionController#stepInst() ."""
        return _connect.CDebugFacade_stepInst(self, *args)

    def stepOverInst(self, *args):
        r"""See documentation of CExecutionController#stepOverInst(CExecutionController::ETimeoutMode, bool) ."""
        return _connect.CDebugFacade_stepOverInst(self, *args)

    def call(self, functionName):
        r"""
         See documentation of CExecutionController#call(const std::string &) . If you need
        to specify function parameters, use overloads of this method in
        CExecutionController .
        """
        return _connect.CDebugFacade_call(self, functionName)

    def getCPUStatus(self, wantStopReason=True):
        r"""See documentation of CExecutionController#getCPUStatus(bool) ."""
        return _connect.CDebugFacade_getCPUStatus(self, wantStopReason)

    def setPollingEnabled(self, isEnabled):
        r"""See documentation of CExecutionController#setPollingEnabled(bool) ."""
        return _connect.CDebugFacade_setPollingEnabled(self, isEnabled)

    def waitUntilStopped(self, timeoutMs=0, pollingIntervalMs=100):
        r"""See documentation of CExecutionController#waitUntilStopped(int, uint32_t, bool) ."""
        return _connect.CDebugFacade_waitUntilStopped(self, timeoutMs, pollingIntervalMs)

    def waitWhileRunning(self, timeoutMs, pollingIntervalMs=100):
        r"""See documentation of CExecutionController#waitWhileRunning(int, uint32_t, bool) ."""
        return _connect.CDebugFacade_waitWhileRunning(self, timeoutMs, pollingIntervalMs)

    def download(self):
        r"""See documentation of CLoaderController#download() ."""
        return _connect.CDebugFacade_download(self)

    def runUntilExpression(self, *args):
        r"""
        *Overload 1:*

        This method evaluates the given expression, which must evaluate to address.
        Then it runs the target with runUntilAddress .
        This method aggregates calls to CDataController#evaluate  and
        CExecutionController#runUntilAddress  and does not have
        equivalent in CExecutionController. This method returns immediately - the
        target may still be in running mode after return!

        :type expression: string
        :param expression: expression, which evaluates to address. This can be one of
                   - function name, for example 'main'
                   - label, for example 'calc_speed_EXIT'
                   - literal value, for example '0x40004356'
                   - expression, for example: '&main + 0x42'. Note the '&' before main!

        :rtype: int
        :return: #S_OK if operation passed, #ICONNECT_E_TIMEOUT in case of timeout
                    or #ICONNECT_S_MSG_WARN in case of a warning
            Python example: _sample_link{debug_facade,test_run_until_expression}

        |

        *Overload 2:*

        This method evaluates the given expression, which must evaluate to address.
        Then it runs the target with runUntilAddress .
        This method aggregates calls to CDataController#evaluate  and
        CExecutionController#runUntilAddress  and does not have
        equivalent in CExecutionController.

        :type expression: string
        :param expression: expression, which evaluates to address. This can be one of
                   - function name, for example 'main'
                   - label, for example 'calc_speed_EXIT'
                   - literal value, for example '0x40004356'
                   - expression, for example: '&main + 0x42'. Note the '&' before main!
        :type timeoutMode: int
        :param timeoutMode: timeout mode

        :rtype: int
        :return: #S_OK if operation passed, #ICONNECT_E_TIMEOUT in case of timeout or #ICONNECT_S_MSG_WARN in case of warning
            Python example: _sample_link{debug_facade,test_run_until_expression}
        """
        return _connect.CDebugFacade_runUntilExpression(self, *args)

    def adjustAddressExpression(self, expression):
        return _connect.CDebugFacade_adjustAddressExpression(self, expression)

# Register CDebugFacade in _connect:
_connect.CDebugFacade_swigregister(CDebugFacade)
class CSessionBaseCtrl(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr):
        _connect.CSessionBaseCtrl_swiginit(self, _connect.new_CSessionBaseCtrl(spConnectionMgr))
    __swig_destroy__ = _connect.delete_CSessionBaseCtrl

# Register CSessionBaseCtrl in _connect:
_connect.CSessionBaseCtrl_swigregister(CSessionBaseCtrl)
class CTerminalCtrl(CSessionBaseCtrl):
    r"""
    Conditional comment: IGNORE_CLASS

    This class is designed to replace the `CTerminalDocController` class. It offers functionality
    to manage terminal interactions within a session. To obtain an instance of `CTerminalCtrl`,
    use the `CSessionCtrl::get_terminal()` method.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, strConfiguration):
        r"""
        Constructs a `CTerminalCtrl` instance with the specified configuration.

        Initializes the terminal control with the given configuration and connects it to the
        provided connection manager.
        Connects to the associated terminal.

        :type spConnectionMgr: :py:class:`ConnectionMgr`
        :param spConnectionMgr: smart pointer to the connection manager instance.
        :type strConfiguration: string
        :param strConfiguration:
        """
        _connect.CTerminalCtrl_swiginit(self, _connect.new_CTerminalCtrl(spConnectionMgr, strConfiguration))
    __swig_destroy__ = _connect.delete_CTerminalCtrl

    def disconnect(self):
        r"""
        Disconnects from the associated terminal.

        :raises: TEXCEPTION if disconnecting fails
        """
        return _connect.CTerminalCtrl_disconnect(self)

    def read(self):
        r"""
        Reads a string from the terminal

        This method reads a string of data from the terminal. The string is read from
        the terminal's input buffer, and the method returns it.

        :rtype: string
        :return: std::string The string read from the terminal.

        :raises: TEXCEPTION if operation fails.
        """
        return _connect.CTerminalCtrl_read(self)

    def write(self, strWrite):
        r"""
        Writes a string to the terminal

        :type strWrite: string
        :param strWrite: The string to be written to the terminal

        :raises: TEXCEPTION if operation fails.
        """
        return _connect.CTerminalCtrl_write(self, strWrite)

# Register CTerminalCtrl in _connect:
_connect.CTerminalCtrl_swigregister(CTerminalCtrl)
class SAccessBatchItem(object):
    r"""This class holds Access Batch Item results (including data)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time_us = property(_connect.SAccessBatchItem_time_us_get, _connect.SAccessBatchItem_time_us_set, doc=r"""
    Timestamp of item in microseconds from start of access batch. Applicable for all item types.

    Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
    """)
    data = property(_connect.SAccessBatchItem_data_get, _connect.SAccessBatchItem_data_set, doc=r"""
    Data buffer containing read data. Applicable only for read type operations.

    Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
    """)
    access_info = property(_connect.SAccessBatchItem_access_info_get, _connect.SAccessBatchItem_access_info_set, doc=r"""
    Buffer containing access info, where each byte indicates single MAU access success.
    Applicable for read, write and poll type operations.

    Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
    """)
    poll_duration_us = property(_connect.SAccessBatchItem_poll_duration_us_get, _connect.SAccessBatchItem_poll_duration_us_set, doc=r"""
    Duration of poll operation in microseconds. Applicable only for poll operation.

    Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
    """)

    def __init__(self):
        _connect.SAccessBatchItem_swiginit(self, _connect.new_SAccessBatchItem())
    __swig_destroy__ = _connect.delete_SAccessBatchItem

# Register SAccessBatchItem in _connect:
_connect.SAccessBatchItem_swigregister(SAccessBatchItem)
class SAddressInfo(object):
    r"""Address info structure describing linear target memory entity."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def dest_core(self, core_index, mem_area):
        r"""
        Set core memory as destination.

        :type core_index: int
        :param core_index: Index of a core to be set as destination.
        :type mem_area: uint8_t
        :param mem_area: Memory area within core to be set as destination.
        """
        return _connect.SAddressInfo_dest_core(self, core_index, mem_area)

    def dest_bus(self, bus_index):
        r"""
        Set memory bus as destination.

        :type bus_index: uint8_t
        :param bus_index: Index of a bus to be set as destination.
        """
        return _connect.SAddressInfo_dest_bus(self, bus_index)

    def dest_module(self, module_index):
        r"""
        Set module as destination.

        :type module_index: uint8_t
        :param module_index: Index of module to be set as destination.
        """
        return _connect.SAddressInfo_dest_module(self, module_index)

    def memory_area(self, mem_area):
        r"""
        Set destination memory area.

        :type mem_area: uint8_t
        :param mem_area: Memory area of destination.
        """
        return _connect.SAddressInfo_memory_area(self, mem_area)

    def address(self, address):
        r"""
        Set memory address.

        :type address: int
        :param address: Memory address.
        """
        return _connect.SAddressInfo_address(self, address)
    core = _connect.SAddressInfo_core
    bus = _connect.SAddressInfo_bus
    module = _connect.SAddressInfo_module
    m_eDest = property(_connect.SAddressInfo_m_eDest_get, _connect.SAddressInfo_m_eDest_set)
    m_byMemArea = property(_connect.SAddressInfo_m_byMemArea_get, _connect.SAddressInfo_m_byMemArea_set)
    m_dwCoreIndex = property(_connect.SAddressInfo_m_dwCoreIndex_get, _connect.SAddressInfo_m_dwCoreIndex_set)
    m_adrBase = property(_connect.SAddressInfo_m_adrBase_get, _connect.SAddressInfo_m_adrBase_set)

    def __init__(self):
        _connect.SAddressInfo_swiginit(self, _connect.new_SAddressInfo())
    __swig_destroy__ = _connect.delete_SAddressInfo

# Register SAddressInfo in _connect:
_connect.SAddressInfo_swigregister(SAddressInfo)
class CAccessBatch(object):
    r"""
    Holds a batch of access operations including read, write, fill, and test. Main benefits are that sequence is
    executed faster and can be saved for later to repeat it.

    The CAccessBatch class:
     - Only holds data to perform accesses and access results. To actually execute
       queued accesses use CSoCCtrl.access_batch().
     - Provides methods to queue batch operations on a memory address or code store.
     - Provides method to queue FNet trigger generation (FTrig).
     - Allows retrieval of individual access batch items by handle.

    This method allows user to queue multiple operations and execute them at once, as opposed to calling each
    action separately in user script. This saves time and number of communication cycles:
     1. Between user script and SDK.
     2. Between SDK and winIDEA.
     3. In case of using BlueBox debuggers, between winIDEA and BlueBox.

    Python example: _sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CAccessBatch_swiginit(self, _connect.new_CAccessBatch())
    __swig_destroy__ = _connect.delete_CAccessBatch

    def set_base(self, address_info):
        r"""
        Set base address for batch access entries added after this call.

        :type address_info: :py:class:`SAddressInfo`
        :param address_info: Address info structure describing base (see SAddressInfo).

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_set_base(self, address_info)

    def read(self, offset, num_MAUs):
        r"""
        Add read operation to access batch queue, use destination relative to the address set in base() call.

        :type offset: int
        :param offset: Offset to be added to base address for this operation.
        :type num_MAUs: int
        :param num_MAUs: Number of memory access units to read.

        :raises: TException If operation could not be added (e.g. base address info is not set).

        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_read(self, offset, num_MAUs)

    def read_a(self, address_info, num_MAUs):
        r"""
        Add read operation to access batch queue, use destination provided in address_info parameter.

        :type address_info: :py:class:`SAddressInfo`
        :param address_info: Address info structure describing access destination (see SAddressInfo).
        :type num_MAUs: int
        :param num_MAUs: Number of memory access units to read.

        :raises: TException If operation could not be added.

        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_read_a(self, address_info, num_MAUs)

    def write(self, offset, data):
        r"""
        Add write operation to access batch queue, use destination relative to the address set in base() call.

        :type offset: int
        :param offset: Offset to be added to base address for this operation.
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: Data to be written.

        :raises: TException If operation could not be added (e.g. base address info is not set).

        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_write(self, offset, data)

    def write_a(self, address_info, data):
        r"""
        Add write operation to access batch queue, use destination provided in address_info parameter.

        :type address_info: :py:class:`SAddressInfo`
        :param address_info: Address info structure describing access destination (see SAddressInfo).
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: Data to be written.

        :raises: TException If operation could not be added.

        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_write_a(self, address_info, data)

    def write_CS_a(self, address_info, code_store):
        r"""
        Add write operation, of data stored in code store, to access batch queue.
        Use destination provided in address_info parameter.

        :type address_info: :py:class:`SAddressInfo`
        :param address_info: Address info structure describing access destination (see SAddressInfo).
        :type code_store: :py:class:`CCodeStore`
        :param code_store: Shared pointer to the code store.

        :raises: TException If operation could not be added.

        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_write_CS_a(self, address_info, code_store)

    def fill(self, offset, num_MAUs, data):
        r"""
        Add fill operation to access batch queue, use destination relative to the address set in base() call.

        :type offset: int
        :param offset: Offset to be added to base address for this operation.
        :type num_MAUs: int
        :param num_MAUs: Number of memory access units to fill.
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: Data to be used for filling.

        :raises: TException If operation could not be added (e.g. base address info is not set).

        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_fill(self, offset, num_MAUs, data)

    def fill_a(self, address_info, num_MAUs, data):
        r"""
        Add fill operation to access batch queue, use destination provided in address_info parameter.

        :type address_info: :py:class:`SAddressInfo`
        :param address_info: Address info structure describing access destination (see SAddressInfo).
        :type num_MAUs: int
        :param num_MAUs: Number of memory access units to fill.
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: Data to be used for filling.

        :raises: TException If operation could not be added.

        :rtype: int
        :return: uint32_t Handle identifying the access batch item

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_fill_a(self, address_info, num_MAUs, data)

    def poll(self, offset, data, mask, timeout_us):
        r"""
        Add poll operation to access batch queue, use destination relative to the address set in base() call.

        :type offset: int
        :param offset: Offset to be added to base address for this operation.
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: Data to be compared.
        :type mask: std::vector< uint8_t,std::allocator< uint8_t > >
        :param mask: Mask used for comparison.
        :type timeout_us: int
        :param timeout_us: Timeout duration in microseconds.

        :raises: TException If operation could not be added (e.g. base address info is not set).

        :rtype: int
        :return: uint32_t Handle identifying the access batch item

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_poll(self, offset, data, mask, timeout_us)

    def poll_a(self, address_info, data, mask, timeout_us):
        r"""
        Add poll operation to access batch queue, use destination provided in address_info parameter.

        :type address_info: :py:class:`SAddressInfo`
        :param address_info: Address info structure describing access destination (see SAddressInfo).
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: Data to be compared.
        :type mask: std::vector< uint8_t,std::allocator< uint8_t > >
        :param mask: Mask used for comparison.
        :type timeout_us: int
        :param timeout_us: Timeout duration in microseconds.

        :raises: TException If operation could not be added.

        :rtype: int
        :return: uint32_t Handle identifying the access batch item

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_poll_a(self, address_info, data, mask, timeout_us)

    def ftrig(self, n_trig):
        r"""
        Add FNet trigger generation to access batch queue.

        More information on FNet triggers can be found in winIDEA help:
        [FNet Communication Network / Overview / FNet Triggers and Actions](https://www.isystem.com/downloads/winIDEA/help/fnet-triggers.html)

        :type n_trig: uint8_t
        :param n_trig: Index of FNet trigger to generate.
        :rtype: int
        :return: uint32_t Handle identifying the access batch item.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_ftrig(self, n_trig)

    def item(self, handle):
        r"""
        Retrieves an access batch item by handle.

        Access batch item structure holds

        :type handle: int
        :param handle: Handle identifying the access batch item.
        :rtype: :py:class:`SAccessBatchItem`
        :return: Shared pointer to the SAccessBatchItem associated with the handle.

        Python example (_sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}):
        """
        return _connect.CAccessBatch_item(self, handle)

# Register CAccessBatch in _connect:
_connect.CAccessBatch_swigregister(CAccessBatch)
class CCoreCtrl(CSessionBaseCtrl):
    r"""
    Provides control functions for interacting with a specific core during a debug session.

    This class allows users to perform various operations on individual cores, such as memory
    manipulation and core observation. It is typically used within the context of an active debug
    session and provides high-level access to core-specific functionality.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rHSC):
        r"""
        Constructs a CCoreCtrl instance for controlling a core in a debug session.

        Initializes core control by associating it with a connection manager and Struct Hardware(BlueBox)-SoC-Core index
        (SHSC). This object allows memory operations and core observation during debugging.

        :type spConnectionMgr: :py:class:`ConnectionMgr`
        :param spConnectionMgr: Shared pointer to the connection manager
        :type rHSC: SHSC
        :param rHSC:            Reference to the SHSC
        """
        _connect.CCoreCtrl_swiginit(self, _connect.new_CCoreCtrl(spConnectionMgr, rHSC))

    def observe(self, bObserve):
        r"""
        Enables or disables core observation within an active debug session.

        This operation is only valid while a session is active (e.g., after calling `begin_reset()`).

        :type bObserve: boolean
        :param bObserve: Set to `true` to enable core observation, or `false` to disable it.

        :raises: TException if the operation fails.

        Python example: _sample_link{core_ctrl,test_observe}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> core_ctrl = soc.get_core(0)

            >>> core_ctrl.observe(True)
        """
        return _connect.CCoreCtrl_observe(self, bObserve)

    def memory_fill(self, nMemoryArea, nAddress, nNumMAUs, rvPattern):
        r"""
        Fills a specified memory area with a repeating pattern.

        This method fills a memory region starting from the given address with a pattern of bytes.
        If the pattern is shorter than the specified number of memory access units (MAUs), it will be
        repeated to fill the entire region.

        :type nMemoryArea: uint8_t
        :param nMemoryArea: Index of the memory area to use.
        :type nAddress: int
        :param nAddress:    Address at which to begin the memory fill operation.
        :type nNumMAUs: int
        :param nNumMAUs:    Number of memory access units to fill.
        :type rvPattern: std::vector< uint8_t,std::allocator< uint8_t > >
        :param rvPattern:   The byte pattern to write into the memory. If shorter than `nNumMAUs`, it is
                               repeated.

        :raises: TException if the operation fails.


        Python example: _sample_link{core_ctrl,test_memory_fill}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> vect = ic.VectorBYTE([1, 2, 3, 4])

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> core_ctrl = soc.get_core(0)

            >>> core_ctrl.memory_fill(0, 0x200000A0, 4, vect)

            >>> vect = core_ctrl.memory_read(0, 0x200000A0, 4)

            >>> [e for e in vect]
            [1, 2, 3, 4]
        """
        return _connect.CCoreCtrl_memory_fill(self, nMemoryArea, nAddress, nNumMAUs, rvPattern)

    def memory_write(self, nMemoryArea, nAddress, rvData, pvAccess=None):
        r"""
        Writes data to a specified memory area.

        Writes a sequence of bytes into the memory starting at the given address. Optionally, access
        information can be provided for each accessed location.

        :type nMemoryArea: uint8_t
        :param nMemoryArea: Index of the memory area to use.
        :type nAddress: int
        :param nAddress:    Address at which to begin writing data.
        :type rvData: std::vector< uint8_t,std::allocator< uint8_t > >
        :param rvData:      The data to write to the memory.
        :type pvAccess: std::vector< uint8_t,std::allocator< uint8_t > >, optional
        :param pvAccess:    (Optional) Pointer to a vector where access information for each accessed
                               location is returned.

        :raises: TException if the operation fails.

        Python example: _sample_link{core_ctrl,test_memory_write}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> vect = ic.VectorBYTE([1, 2, 3, 4])

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> core_ctrl = soc.get_core(0)

            >>> core_ctrl.memory_write(0, 0x200000A0, vect)

            >>> vect = core_ctrl.memory_read(0, 0x200000A0, 4)

            >>> [e for e in vect]
            [1, 2, 3, 4]
        """
        return _connect.CCoreCtrl_memory_write(self, nMemoryArea, nAddress, rvData, pvAccess)

    def memory_read(self, nMemoryArea, nAddress, nNumMAUs, pvAccess=None):
        r"""
        Reads data from a specified memory area.

        Reads a sequence of bytes from the memory starting at the specified address. Optionally,
        access information can be returned for each accessed location.

        :type nMemoryArea: uint8_t
        :param nMemoryArea: Index of the memory area to use.
        :type nAddress: int
        :param nAddress:    Address from which to begin reading data.
        :type nNumMAUs: int
        :param nNumMAUs:    Number of memory access units to read.
        :type pvAccess: std::vector< uint8_t,std::allocator< uint8_t > >, optional
        :param pvAccess:    (Optional) Pointer to a vector where access information for each accessed
                               location is returned.

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: std::vector<uint8_t> A vector containing the data read from memory.

        :raises: TException if the operation fails.

        Python example: _sample_link{core_ctrl,test_memory_read}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> vect = ic.VectorBYTE([1, 2, 3, 4])

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> core_ctrl = soc.get_core(0)

            >>> core_ctrl.memory_fill(0, 0x200000A0, 4, vect)

            >>> vect = core_ctrl.memory_read(0, 0x200000A0, 4)

            >>> [e for e in vect]
            [1, 2, 3, 4]
        """
        return _connect.CCoreCtrl_memory_read(self, nMemoryArea, nAddress, nNumMAUs, pvAccess)
    __swig_destroy__ = _connect.delete_CCoreCtrl

# Register CCoreCtrl in _connect:
_connect.CCoreCtrl_swigregister(CCoreCtrl)
class CSoCCtrl(CSessionBaseCtrl):
    r"""
    This class provides control and interaction with a System on Chip (SoC) during a debug session.
    It offers functionality to focus on cores, perform memory operations, and handle various bus-related tasks
    on the SoC.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, spSessionCtrl, rHSC, rstrSoC):
        r"""
        Constructor for CSoCCtrl.

        :type spConnectionMgr: :py:class:`ConnectionMgr`
        :param spConnectionMgr:  Shared pointer to the connection manager.
        :type spSessionCtrl: :py:class:`CSessionCtrl`
        :param spSessionCtrl:    Shared pointer to the session controller.
        :type rHSC: SHSC
        :param rHSC:             Reference to a HSC struct.
        :type rstrSoC: string
        :param rstrSoC:          Name of the SoC.
        """
        _connect.CSoCCtrl_swiginit(self, _connect.new_CSoCCtrl(spConnectionMgr, spSessionCtrl, rHSC, rstrSoC))

    def get_core(self, dwCoreIndex):
        r"""
        Retrieves a shared pointer for a specific core control on the SoC.

        :type dwCoreIndex: int
        :param dwCoreIndex:  Index of the core to be retrieved.
        :rtype: :py:class:`CCoreCtrl`
        :return: SPCoreCtrl   Core control shared pointer.
        """
        return _connect.CSoCCtrl_get_core(self, dwCoreIndex)

    def attach(self):
        r"""
        Attaches to the specified SoC. This call is only valid within an active session.

        :raises: TException if the operation fails.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_attach}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> soc.attach()
        """
        return _connect.CSoCCtrl_attach(self)

    def detach(self):
        r"""
        Detaches from the specified SoC. This call is only valid within an active session.

        :raises: TException if the operation fails.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_detach}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> soc.attach()

            >>> soc.detach()
        """
        return _connect.CSoCCtrl_detach(self)

    def SMP_set_focused_core(self, dwCoreIndex):
        r"""
        Sets the focused core in an SMP process.

        :type dwCoreIndex: int
        :param dwCoreIndex: Index of the core to set focus on

        :raises: TException If the operation fails or `dwCoreIndex` is not in the current process's SMP binding.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_smp_set_focused_core}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> focused_core = soc.SMP_get_focused_core(0)

            >>> focused_core
            0

            >>> soc.SMP_set_focused_core(focused_core)
        """
        return _connect.CSoCCtrl_SMP_set_focused_core(self, dwCoreIndex)

    def SMP_get_focused_core(self, dwCoreIndex):
        r"""
        Retrieves the currently focused core index in an SMP process

        :type dwCoreIndex: int
        :param dwCoreIndex: Identifies the SMP binding

        :rtype: int
        :return: uint32_t Index of the focused core in the current process's SMP binding

        :raises: TException if the operation fails

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_smp_get_focused_core}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> soc.SMP_get_focused_core(0)
            0
        """
        return _connect.CSoCCtrl_SMP_get_focused_core(self, dwCoreIndex)

    def bus_fill(self, nBusIndex, nAddress, nNumMAUs, rvPattern):
        r"""
        Fills a memory region with a specified pattern via the specified bus.

        :type nBusIndex: uint8_t
        :param nBusIndex: Index of the bus to use.
        :type nAddress: int
        :param nAddress:  Address to start writing the pattern.
        :type nNumMAUs: int
        :param nNumMAUs:  Number of Memory Access Units (MAUs) to write.
        :type rvPattern: std::vector< uint8_t,std::allocator< uint8_t > >
        :param rvPattern: Pattern to fill the memory with. If shorter than `nNumMAUs`, the pattern repeats.

        :raises: TException if the operation fails.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_bus_fill}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> vect = ic.VectorBYTE([1, 2, 3, 4])

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> soc.bus_fill(0, 0x20000000, 4, vect)

            >>> vect_read = soc.bus_read(0, 0x20000000, 4)

            >>> [e for e in vect_read]
            [1, 2, 3, 4]
        """
        return _connect.CSoCCtrl_bus_fill(self, nBusIndex, nAddress, nNumMAUs, rvPattern)

    def bus_write(self, nBusIndex, nAddress, rvData, pvAccess=None):
        r"""
        Writes data to memory via the specified bus.

        :type nBusIndex: uint8_t
        :param nBusIndex: Index of the bus to use.
        :type nAddress: int
        :param nAddress:  Address to write the data to.
        :type rvData: std::vector< uint8_t,std::allocator< uint8_t > >
        :param rvData:    Data to write.
        :type pvAccess: std::vector< uint8_t,std::allocator< uint8_t > >, optional
        :param pvAccess:  Optional access information returned for each location accessed.

        :raises: TException if the operation fails.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_bus_write}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> vect = ic.VectorBYTE([8, 7, 6, 5])

            >>> soc.bus_write(0, 0x20000000, vect)

            >>> vect_read = soc.bus_read(0, 0x20000000, 4)

            >>> [e for e in vect_read]
            [8, 7, 6, 5]
        """
        return _connect.CSoCCtrl_bus_write(self, nBusIndex, nAddress, rvData, pvAccess)

    def bus_read(self, nBusIndex, nAddress, nNumMAUs, pvAccess=None):
        r"""
        Reads data from memory via the specified bus.

        :type nBusIndex: uint8_t
        :param nBusIndex: Index of the bus to use.
        :type nAddress: int
        :param nAddress:  Address to read from.
        :type nNumMAUs: int
        :param nNumMAUs:  Number of MAUs to read.
        :type pvAccess: std::vector< uint8_t,std::allocator< uint8_t > >, optional
        :param pvAccess:  Optional access information returned for each location accessed.

        :rtype: std::vector< uint8_t,std::allocator< uint8_t > >
        :return: std::vector<uint8_t> Data read from memory.

        :raises: TException if the operation fails.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_bus_read}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_reset()

            >>> soc = sess_ctrl.get_SoC('')

            >>> vect = ic.VectorBYTE([8, 7, 6, 5])

            >>> soc.bus_write(0, 0x20000000, vect)

            >>> vect_read = soc.bus_read(0, 0x20000000, 4)

            >>> [e for e in vect_read]
            [8, 7, 6, 5]
        """
        return _connect.CSoCCtrl_bus_read(self, nBusIndex, nAddress, nNumMAUs, pvAccess)
    OK = _connect.CSoCCtrl_OK
    r"""Batch access was successful"""
    Fail = _connect.CSoCCtrl_Fail
    r"""Batch access failed"""
    Timeout = _connect.CSoCCtrl_Timeout
    r"""One of the poll items in access batch failed"""
    Abort = _connect.CSoCCtrl_Abort
    r"""Batch access was aborted"""
    BadParam = _connect.CSoCCtrl_BadParam
    r"""Specified parameters are incorrect, e.g. in test Data and TestMask must be of identical size"""

    def access_batch(self, rAccessBatch):
        r"""
        Performs a batch memory access operation.

        :type rAccessBatch: :py:class:`CAccessBatch`
        :param rAccessBatch: Reference to access batch structure containing the details of the batch operation.
                                The data can be received by calling CAccessBatch::item(...) and reading from it's data member.

        :rtype: int
        :return: EAccessBatchResult Result of the access batch operation.

        :raises: TException if the operation fails.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_bus_access_batch}
        """
        return _connect.CSoCCtrl_access_batch(self, rAccessBatch)
    __swig_destroy__ = _connect.delete_CSoCCtrl

# Register CSoCCtrl in _connect:
_connect.CSoCCtrl_swigregister(CSoCCtrl)
class SProcess_Thread(object):
    r"""
    Represents information about a specific thread.

    This struct instance should only be received via CProcessCtrl::threads method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def name(self):
        r"""
        :rtype: string
        :return: std::string Name of the thread
        """
        return _connect.SProcess_Thread_name(self)

    def __init__(self):
        _connect.SProcess_Thread_swiginit(self, _connect.new_SProcess_Thread())
    __swig_destroy__ = _connect.delete_SProcess_Thread

# Register SProcess_Thread in _connect:
_connect.SProcess_Thread_swigregister(SProcess_Thread)
class CProcessCtrl(CSessionBaseCtrl):
    r"""This class provides debug session function"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrProcessURL):
        r"""
        Constructor for CProcessCtrl.

        :type spConnectionMgr: :py:class:`ConnectionMgr`
        :param spConnectionMgr:   Shared pointer to the connection manager
        :type rstrProcessURL: string
        :param rstrProcessURL:    URL or identifier of the process to be controlled in the debug session.
        """
        _connect.CProcessCtrl_swiginit(self, _connect.new_CProcessCtrl(spConnectionMgr, rstrProcessURL))

    def thread_list(self):
        r"""
        Obtains information about process's threads

        :rtype: std::vector< isys::SPProcess_Thread,std::allocator< isys::SPProcess_Thread > >
        :return: vector of current threads
        """
        return _connect.CProcessCtrl_thread_list(self)

    def thread_focus(self, rstrName):
        r"""
        Change focused thread

        :type rstrName: string
        :param rstrName: name of thread to focus
        """
        return _connect.CProcessCtrl_thread_focus(self, rstrName)
    __swig_destroy__ = _connect.delete_CProcessCtrl

# Register CProcessCtrl in _connect:
_connect.CProcessCtrl_swigregister(CProcessCtrl)
class SSessionTopology_Core(object):
    r"""
    Represents information about a specific core for the current session.

    This struct instance should only be received via SSessionTopology_SoC::cores() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def name(self):
        r"""
        :rtype: string
        :return: std::string Name of the core
        """
        return _connect.SSessionTopology_Core_name(self)

    def core_type(self):
        r"""
        :rtype: string
        :return: std::string Type of the core
        """
        return _connect.SSessionTopology_Core_core_type(self)

    def CPU_info(self):
        r"""
        :rtype: :py:class:`CCPUInfo`
        :return: CCPUInfo struct with variety of data for the CPU
        """
        return _connect.SSessionTopology_Core_CPU_info(self)

    def __init__(self):
        _connect.SSessionTopology_Core_swiginit(self, _connect.new_SSessionTopology_Core())
    __swig_destroy__ = _connect.delete_SSessionTopology_Core

# Register SSessionTopology_Core in _connect:
_connect.SSessionTopology_Core_swigregister(SSessionTopology_Core)
class SSessionTopology_CoreBinding(object):
    r"""
    Provides information for core bindings

    This struct instance should only be received via SSessionTopology_SoC::SMPs() or SSessionTopology_SoC::lock_steps() methods.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def name(self):
        r"""
        :rtype: string
        :return: std::string Name of the binding
        """
        return _connect.SSessionTopology_CoreBinding_name(self)

    def core_indexes(self):
        r"""
        :rtype: std::vector< uint32_t,std::allocator< uint32_t > >
        :return: std::vector<uint32_t> A vector of core indexes
        """
        return _connect.SSessionTopology_CoreBinding_core_indexes(self)

    def __init__(self):
        _connect.SSessionTopology_CoreBinding_swiginit(self, _connect.new_SSessionTopology_CoreBinding())
    __swig_destroy__ = _connect.delete_SSessionTopology_CoreBinding

# Register SSessionTopology_CoreBinding in _connect:
_connect.SSessionTopology_CoreBinding_swigregister(SSessionTopology_CoreBinding)
class SSessionTopology_SoC(object):
    r"""
    Provides information about the SoC used.

    This struct instance should only be received via SSessionTopology::SoCs() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def name(self):
        r"""
        :rtype: string
        :return: std::string Name of the SoC
        """
        return _connect.SSessionTopology_SoC_name(self)

    def device(self):
        r"""
        :rtype: string
        :return: std::string Name of the device
        """
        return _connect.SSessionTopology_SoC_device(self)

    def cores(self):
        r"""
        :rtype: std::vector< isys::SPSessionTopology_Core,std::allocator< isys::SPSessionTopology_Core > >
        :return: std::vector<SPSessionTopology_Core> A vector of information about each core
        """
        return _connect.SSessionTopology_SoC_cores(self)

    def SMPs(self):
        r"""
        :rtype: std::vector< isys::SPSessionTopology_CoreBinding,std::allocator< isys::SPSessionTopology_CoreBinding > >
        :return: std::vector<SPSessionTopology_CoreBinding> A vector of information about each SMP
        """
        return _connect.SSessionTopology_SoC_SMPs(self)

    def lock_steps(self):
        r"""
        :rtype: std::vector< isys::SPSessionTopology_CoreBinding,std::allocator< isys::SPSessionTopology_CoreBinding > >
        :return: std::vector<SPSessionTopology_CoreBinding> A vector of information about each lock step
        """
        return _connect.SSessionTopology_SoC_lock_steps(self)

    def __init__(self):
        _connect.SSessionTopology_SoC_swiginit(self, _connect.new_SSessionTopology_SoC())
    __swig_destroy__ = _connect.delete_SSessionTopology_SoC

# Register SSessionTopology_SoC in _connect:
_connect.SSessionTopology_SoC_swigregister(SSessionTopology_SoC)
class SSessionTopology_Process(object):
    r"""
    Provides information about current process.

    This struct instance should only be received via SSessionTopology::processes() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def URL(self):
        r"""
        :rtype: string
        :return: std::string URL of the process
        """
        return _connect.SSessionTopology_Process_URL(self)

    def application(self):
        r"""
        :rtype: string
        :return: std::string Name of the application for this process
        """
        return _connect.SSessionTopology_Process_application(self)

    def __init__(self):
        _connect.SSessionTopology_Process_swiginit(self, _connect.new_SSessionTopology_Process())
    __swig_destroy__ = _connect.delete_SSessionTopology_Process

# Register SSessionTopology_Process in _connect:
_connect.SSessionTopology_Process_swigregister(SSessionTopology_Process)
class SSessionTopology(object):
    r"""
    Provides information about current session.

    This struct instance should only be received via CSessionCtrl::get_topology() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def SoCs(self):
        r"""
        :rtype: std::vector< isys::SPSessionTopology_SoC,std::allocator< isys::SPSessionTopology_SoC > >
        :return: std::vector<SPSessionTopology_SoC> A vector filed with structs for SoC topologies
        """
        return _connect.SSessionTopology_SoCs(self)

    def processes(self):
        r"""
        :rtype: std::vector< isys::SPSessionTopology_Process,std::allocator< isys::SPSessionTopology_Process > >
        :return: std::vector<SPSessionTopology_Process> A vector filled with structs for process topologies
        """
        return _connect.SSessionTopology_processes(self)

    def __init__(self):
        _connect.SSessionTopology_swiginit(self, _connect.new_SSessionTopology())
    __swig_destroy__ = _connect.delete_SSessionTopology

# Register SSessionTopology in _connect:
_connect.SSessionTopology_swigregister(SSessionTopology)
class SSessionStatus_Core(object):
    r"""
    A struct for status of the core in current session.

    This struct instance should only be received via SSessionStatus_SoC::cores() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def status(self):
        r"""
        :rtype: int
        :return: EStatus_Core Current status of the core
        """
        return _connect.SSessionStatus_Core_status(self)

    def status_string(self):
        r"""
        :rtype: string
        :return: std::string The core status
        """
        return _connect.SSessionStatus_Core_status_string(self)

    def PC(self):
        r"""
        :rtype: int
        :return: ADDRESS_64 Value of the PC represented by 64 bits
        """
        return _connect.SSessionStatus_Core_PC(self)

    def __init__(self):
        _connect.SSessionStatus_Core_swiginit(self, _connect.new_SSessionStatus_Core())
    __swig_destroy__ = _connect.delete_SSessionStatus_Core

# Register SSessionStatus_Core in _connect:
_connect.SSessionStatus_Core_swigregister(SSessionStatus_Core)
class SSessionStatus_SoC(object):
    r"""
    A struct for status of the SoC

    This struct instance should only be received via SSessionStatus::SoCs() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def status(self):
        r"""
        :rtype: int
        :return: EStatus_SoC Current status of the SoC
        """
        return _connect.SSessionStatus_SoC_status(self)

    def status_string(self):
        r"""
        :rtype: string
        :return: std::string Current status of the SoC
        """
        return _connect.SSessionStatus_SoC_status_string(self)

    def cores(self):
        r"""
        :rtype: std::vector< isys::SPSessionStatus_Core,std::allocator< isys::SPSessionStatus_Core > >
        :return: std::vector<SPSessionStatus_Core> A vector filled with statuses for every core
        """
        return _connect.SSessionStatus_SoC_cores(self)

    def __init__(self):
        _connect.SSessionStatus_SoC_swiginit(self, _connect.new_SSessionStatus_SoC())
    __swig_destroy__ = _connect.delete_SSessionStatus_SoC

# Register SSessionStatus_SoC in _connect:
_connect.SSessionStatus_SoC_swigregister(SSessionStatus_SoC)
class SSessionStatus(object):
    r"""
    This struct provides status of the current session.

    This struct instance should only be received via CSessionCtrl::get_status() method.
    Do not create instances of this struct directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def SoCs(self):
        r"""
        :rtype: std::vector< isys::SPSessionStatus_SoC,std::allocator< isys::SPSessionStatus_SoC > >
        :return: std::vector<SPSessionStatus_SoC> A vector of statuses for every SoC
        """
        return _connect.SSessionStatus_SoCs(self)

    def is_active(self):
        r"""
        :rtype: boolean
        :return: bool True if the session is established, false otherwise
        """
        return _connect.SSessionStatus_is_active(self)

    def process_focused(self):
        r"""
        :rtype: string
        :return: string URL of focused process
        """
        return _connect.SSessionStatus_process_focused(self)

    def thread_focused(self):
        r"""
        :rtype: string
        :return: string name of focused process
        """
        return _connect.SSessionStatus_thread_focused(self)

    def __init__(self):
        _connect.SSessionStatus_swiginit(self, _connect.new_SSessionStatus())
    __swig_destroy__ = _connect.delete_SSessionStatus

# Register SSessionStatus in _connect:
_connect.SSessionStatus_swigregister(SSessionStatus)
class CSessionCtrl(CSessionBaseCtrl):
    r"""This class provides debug session function"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr):
        _connect.CSessionCtrl_swiginit(self, _connect.new_CSessionCtrl(spConnectionMgr))
    __swig_destroy__ = _connect.delete_CSessionCtrl

    def program_verify(self):
        r"""
        Performs post-download verification to ensure data integrity and correctness.

        This function checks the validity of the downloaded data and ensures that it meets
        expected standards (e.g., checksum verification, completeness).

        :raises: IOException if the verification process fails due to file read issues or
                    any I/O operation errors.
        :raises: IllegalStateException if the downloaded data is found to be corrupted or
                    incomplete during the verification process.
        """
        return _connect.CSessionCtrl_program_verify(self)

    def begin_program(self):
        r"""
        Initializes a new debug session, starts emulation (HAR)
        on all SoCs, and programs them with the target code.

        In simpler terms, this method downloads the executable code to the target SoCs
        and halts execution at the reset vector

        :raises: TException if the session initialization or code programming fails.
                    This may occur due to connection issues, target misconfiguration, or
                    other internal errors during the initialization process.

        Python example: _sample_link{session_ctrl,test_begin_program}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_program()

            >>> sess_ctrl.get_status().SoCs()[0].status_string()
            'ATTACHED'
        """
        return _connect.CSessionCtrl_begin_program(self)

    def begin_reset(self):
        r"""
        Initializes a new debug session and starts emulation (HAR)
        on all System on Chips (SoCs).

        Specifically, this method resets the target SoCs and halts execution at the reset vector,
        without performing any code programming.

        :raises: TException if the session initialization or code programming fails.
                    This may occur due to connection issues, target misconfiguration, or
                    other internal errors during the initialization process.

        Python example: _sample_link{soc_ctrl,test_soc_ctrl_attach}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_reset()

            >>> sess_ctrl.get_status().SoCs()[0].status_string()
            'ATTACHED'
        """
        return _connect.CSessionCtrl_begin_reset(self)

    def begin_attach(self):
        r"""
        Starts a new debug session and attaches to all System on Chips (SoCs) that are
        configured to attach on session start.

        This method connects to an already running target without resetting or programming it.

        :raises: TException if session initialization fails, which can occur due to connection
                    issues, incorrect configuration, or other hardware-related problems.

        Python example: _sample_link{session_ctrl,test_get_process}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_attach()

            >>> sess_ctrl.get_status().SoCs()[0].status_string()
            'ATTACHED'
        """
        return _connect.CSessionCtrl_begin_attach(self)

    def begin_prepare(self):
        r"""
        Initializes a new debug session without attaching to any SoC.

        This method sets up the Blue Box and the debug session, stopping just before any
        interaction with the target hardware. It allows you to prepare the environment
        without affecting the target.

        :raises: TException if session initialization fails, which can occur due to connection
                    issues, incorrect configuration, or other hardware-related problems.

        Python example: _sample_link{session_ctrl,test_begin_prepare}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()

            >>> sess_ctrl.get_status().SoCs()[0].status_string()
            'DETACHED'
        """
        return _connect.CSessionCtrl_begin_prepare(self)

    def end(self):
        r"""
        Ends debug session (detaches from all SoCs).

        Python example: _sample_link{session_ctrl,test_begin_prepare}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()

            >>> sess_strl.end()

            >>> len(sess_ctrl.get_status().SoCs())
            0
        """
        return _connect.CSessionCtrl_end(self)

    def get_status(self):
        r"""
        Returns the current state of the debug session.

        This method returns the session's status, including information about connected
        SoCs, their states, and other relevant details.

        :raises: TException if the session status cannot be obtained, which may occur due
                    to connection or other issues.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()

            >>> sess_ctrl.get_status().SoCs()[0].status_string()
            'DETACHED'
        """
        return _connect.CSessionCtrl_get_status(self)

    def get_topology(self):
        r"""
        Retrieves the current session topology, including attached SoCs (Systems on Chips)
        and their associated processes.

        The session topology provides detailed information about the SoCs, such as their
        names, devices, and the cores they contain.

        :raises: TException if the topology information cannot be retrieved, which may
                    occur due to connection issues or if the session is not properly initialized.

        Python example: _sample_link{session_ctrl,test_get_topology}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()

            >>> sess_ctrl.get_topology().SoCs()[0].name()
            'MCU'

            >>> sess_ctrl.get_topology().SoCs()[0].device()
            'STM32F412xG'

            >>> sess_ctrl.get_topology().SoCs()[0].cores()[0].name()
            'CORE0'
        """
        return _connect.CSessionCtrl_get_topology(self)

    def get_core_SMP_bindings(self, dwSoCIndex=0):
        r"""
        Retrieves a union of SMP and non-SMP core bindings
        for the specified SoC (System on Chip).

        For non-SMP cores, the binding will reference the core's name and its core index.
        SMP cores will be included as part of the union, representing all cores in the
        SMP group.

        :type dwSoCIndex: int, optional
        :param dwSoCIndex: The index of the SoC for which core bindings should be retrieved.
                              Defaults to 0 if no index is provided.

        :rtype: std::vector< isys::SPSessionTopology_CoreBinding,std::allocator< isys::SPSessionTopology_CoreBinding > >
        :return: std::vector<SPSessionTopology_CoreBinding> A vector containing the core bindings
                    for both SMP and non-SMP cores within the specified SoC.
        """
        return _connect.CSessionCtrl_get_core_SMP_bindings(self, dwSoCIndex)

    def instance_attach(self, *args):
        r"""
        *Overload 1:*

        Attaches to a specified instance by its name and returns the corresponding connection manager.
        If no existing connection is found, this method may launch a new winIDEA instance.

        :type strName: string
        :param strName: The name of the instance to attach to, as specified in SPSessionTopology_CoreBinding.

        :rtype: :py:class:`ConnectionMgr`
        :return: SPConnectionMgr The connection manager for the specified instance.

        :raises: TException if the provided instance name is invalid or if the attachment process fails.



            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()

            >>> sess_ctrl.get_topology().SoCs()[0].cores()[0].name()
            'CORE0'

            >>> cmgr1 = ses_ctrl.instance_attach('CORE0')

            >>> cmgr1.isAttached()
            True

        |

        *Overload 2:*

        Attaches to a specified instance by its name and returns the corresponding connection manager.
        If no existing connection is found, this method may launch a new winIDEA instance.

        :type dwCoreIndex: int
        :param dwCoreIndex: The index of the instance to attach to, as specified in SPSessionTopology_CoreBinding.

        :rtype: :py:class:`ConnectionMgr`
        :return: SPConnectionMgr The connection manager for the specified instance.

        :raises: TException if the provided instance name is invalid or if the attachment process fails.



            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()

            >>> cmgr1 = ses_ctrl.instance_attach(0)

            >>> cmgr1.isAttached()
            True
        """
        return _connect.CSessionCtrl_instance_attach(self, *args)

    def instance_is_attached(self, dwCoreIndex):
        r"""
        Checks if the winIDEA instance controlling the specified core index is currently attached.

        :type dwCoreIndex: int
        :param dwCoreIndex: The index of the core to check.

        :rtype: boolean
        :return: bool True if the instance managing the specified core is attached, false otherwise.

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_prepare()
        """
        return _connect.CSessionCtrl_instance_is_attached(self, dwCoreIndex)

    def process_attach(self):
        r"""
        Attaches to the specified process, loads its symbol files, and creates a working image.

        This method establishes a connection to the target process, ensuring that its symbol files are loaded
        and a working image is created for debugging purposes.

        :rtype: string
        :return: std::string The URL of the attached process.

        :raises: TException If the attachment process fails.

        Python example: _sample_link{session_ctrl,test_process_attach}
        """
        return _connect.CSessionCtrl_process_attach(self)

    def process_focus(self, strProcessURL):
        r"""
        Focuses on the specified process by its URL.

        This method brings the process identified by the provided URL into focus, making it the current
        target for debugging operations. This is typically used to direct further actions or inspections
        to the specified process.

        :type strProcessURL: string
        :param strProcessURL: The URL of the process to focus. This should be a valid URL as obtained from
                                 the process list in the session topology.

        :raises: TException If the process cannot be focused, or if an invalid URL is provided.

        Python example: _sample_link{session_ctrl,test_process_focus}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_attach()

            >>> sess_ctrl.get_topology().processes()[0].URL()
            'App/CORE0'

            >>> sess_ctrl.process_focus('App/CORE0')
        """
        return _connect.CSessionCtrl_process_focus(self, strProcessURL)

    def get_process(self, strProcessURL):
        r"""
        Retrieves a control object for the specified process.

        This method returns a `CProcessCtrl` instance that provides control over the process identified
        by the given URL. The process URL should match one of the processes listed in the session
        topology. This control object allows you to interact with and manage the specified process.

        :type strProcessURL: string
        :param strProcessURL: The URL of the process to retrieve. This URL should be obtained from
                                 the session's topology and must correspond to a valid process.

        :rtype: :py:class:`CProcessCtrl`
        :return: SPProcessCtrl smart pointer to the control object for the specified process.

        :raises: TException If the process cannot be found or the operation fails.

        Python example: _sample_link{session_ctrl,test_get_process}

            >>> cmgr = ic.ConnectionMgr()

            >>> cmgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(cmgr)

            >>> sess_ctrl.begin_attach()

            >>> sess_ctrl.get_topology().processes()[0].URL()
            'App/CORE0'

            >>> type(sess_ctrl.get_process('App/CORE0'))
            <class 'isystem.connect.CProcessCtrl'>
        """
        return _connect.CSessionCtrl_get_process(self, strProcessURL)

    def get_SoC(self, strSoC):
        r"""
        Retrieves a control object for the specified System on Chip (SoC).

        This method returns a `CSoCCtrl` instance that provides control over the SoC identified
        by the given name. The session must be active, which means it should have been started
        with one of the `begin_` methods such as `begin_attach` or `begin_program`.

        :type strSoC: string
        :param strSoC: The name of the SoC as configured in winIDEA. If only one SoC is used in the session,
                          this string can be left empty to retrieve the default SoC.

        :rtype: :py:class:`CSoCCtrl`
        :return: SPSoCCtrl smart pointer to the control object for the specified SoC.

        :raises: TException If the session is not active or the SoC cannot be found.

        Python example: _sample_link{session_ctrl,test_get_soc}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_attach()

            >>> soc_ctrl = sess_ctrl.get_SoC('')

            >>> type(soc_ctrl)
            <class 'isystem.connect.CSoCCtrl'>
        """
        return _connect.CSessionCtrl_get_SoC(self, strSoC)

    def get_terminal(self, *args):
        r"""
        Retrieves a control object for the specified terminal configuration.

        This method returns an `CTerminalCtrl` instance that provides control over the terminal
        specified by the given configuration name. If the configuration name is empty, it retrieves
        the control object for the default or first terminal configuration.

        :type strConfiguration: string, optional
        :param strConfiguration: The name of the terminal configuration to retrieve. If this string is
                                    empty, the method returns the control object for the default terminal
                                    configuration.

        :rtype: :py:class:`CTerminalCtrl`
        :return: SPTerminalCtrl smart pointer to the control object for the specified terminal.

        :raises: TException If the terminal configuration cannot be found or if the operation fails.

        Python example: _sample_link{session_ctrl,test_get_terminal}

            >>> conn_mgr = ic.ConnectionMgr()

            >>> conn_mgr.connect()

            >>> sess_ctrl = ic.CSessionCtrl(conn_mgr)

            >>> sess_ctrl.begin_attach()

            >>> terminal_ctrl = sess_ctrl.get_terminal('')

            >>> type(terminal_ctrl)
            <class 'isystem.connect.CTerminalCtrl'>
        """
        return _connect.CSessionCtrl_get_terminal(self, *args)

# Register CSessionCtrl in _connect:
_connect.CSessionCtrl_swigregister(CSessionCtrl)
class COptionController(object):
    r"""
    COptionController controller.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionController_swiginit(self, _connect.new_COptionController(connectionMgr, rstrBaseURL))
    __swig_destroy__ = _connect.delete_COptionController

    def URL(self):
        r"""
        Returns full option URL of this instance.

        :rtype: string
        :return: full option URL

        Python example: _sample_link{opt_ctrl,test_url}
        """
        return _connect.COptionController_URL(self)

    def opt(self, rstrOption):
        r"""
        Returns COptionController based on rstrOption (appended to the base URL).

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL

        :rtype: :py:class:`COptionController`
        :return: COptionController instance

        Python example: _sample_link{opt_ctrl,test_opt}
        """
        return _connect.COptionController_opt(self, rstrOption)

    def get(self, rstrOption):
        r"""
        Returns string value of rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL

        :rtype: string
        :return: string value

        :raises: TException if rstrOption is invalid

        Python example: _sample_link{opt_ctrl,test_get_set}
        """
        return _connect.COptionController_get(self, rstrOption)

    def set(self, rstrOption, rstrValue):
        r"""
        Sets rstrValue to rstrOption (appended to the base URL).

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL
        :type rstrValue: string
        :param rstrValue: string value

        :raises: TException if rstrOption is invalid

        Python example: _sample_link{opt_ctrl,test_get_set}
        """
        return _connect.COptionController_set(self, rstrOption, rstrValue)

    def set_multi(self, inParams):
        r"""
        Sets multiple option values with one call.

        :type inParams: :py:class:`StrStrMap`
        :param inParams: map of string option value pairs

        Note: Python and Java support Python mapping and Java Map as input
        type in addition to `isystem.connect.StrStrMap`. Examples:

            Python: optCtrlApp0.set_multi({"Name": "MyApp", "SymbolFiles.DefaultFile": "0"});

            Java:   optCtrlApp0.set_multi(Map.of("Name", "MyApp", "SymbolFiles.DefaultFile", "0"));

        Python example: _sample_link{opt_ctrl,test_set_multi}
        """


        if isinstance(inParams, dict):
            inParams = StrStrMap(inParams)


        return _connect.COptionController_set_multi(self, inParams)


    def set_bool(self, rstrOption, bValue):
        r"""
        Sets bValue to rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL
        :type bValue: boolean
        :param bValue: bool value

        :raises: TException if rstrOption is invalid

        Python example: _sample_link{opt_ctrl,test_get_set_bool}
        """
        return _connect.COptionController_set_bool(self, rstrOption, bValue)

    def get_bool(self, rstrOption):
        r"""
        Gets bool value of rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL

        :rtype: boolean
        :return: bool value

        :raises: TException if rstrOption is invalid, or type is not bool

        Python example: _sample_link{opt_ctrl,test_get_set_bool}
        """
        return _connect.COptionController_get_bool(self, rstrOption)

    def set_int(self, rstrOption, iValue):
        r"""
        Sets iValue to rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL
        :type iValue: int
        :param iValue: int64_t value

        :raises: TException if rstrOption is invalid

        Python example: _sample_link{opt_ctrl,test_get_set_int_uint}
        """
        return _connect.COptionController_set_int(self, rstrOption, iValue)

    def get_int(self, rstrOption):
        r"""
        Gets integer value of rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL

        :rtype: int
        :return: int64_t value

        :raises: TException if rstrOption is invalid, or type is not integer

        Python example: _sample_link{opt_ctrl,test_get_set_int_uint}
        """
        return _connect.COptionController_get_int(self, rstrOption)

    def set_uint(self, rstrOption, nValue):
        r"""
        Sets nValue to rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL
        :type nValue: int
        :param nValue: uint64_t value

        :raises: TException if rstrOption is invalid

        Python example: _sample_link{opt_ctrl,test_get_set_int_uint}
        """
        return _connect.COptionController_set_uint(self, rstrOption, nValue)

    def get_uint(self, rstrOption):
        r"""
        Gets unsigned integer value of rstrOption.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL

        :rtype: int
        :return: uint64_t value

        :raises: TException if rstrOption is invalid, or type is not a positive integer

        Python example: _sample_link{opt_ctrl,test_get_set_int_uint}
        """
        return _connect.COptionController_get_uint(self, rstrOption)

    def size(self):
        r"""
        Returns array size of this instance.

        :rtype: int
        :return: size of array

        :raises: TException if this is not an array

        Python example: _sample_link{opt_ctrl,test_size}
        """
        return _connect.COptionController_size(self)

    def at(self, nIndex):
        r"""
        Return COptionController for element at nIndex.

        :type nIndex: int
        :param nIndex: element index

        :rtype: :py:class:`COptionController`
        :return: COptionController for element at index

        Python example: _sample_link{opt_ctrl,test_at}
        """
        return _connect.COptionController_at(self, nIndex)

    def add(self):
        r"""
        Adds an element to the array and returns COptionController for it

        :rtype: :py:class:`COptionController`
        :return: COptionController instance

        :raises: TException if this is not an array, or the array size is static

        Python example: _sample_link{opt_ctrl,test_add_remove}
        """
        return _connect.COptionController_add(self)

    def clear(self):
        r"""
        Removes all elements

        :raises: TException if this is not an array, the array size is static

        Python example: _sample_link{opt_ctrl,test_add_remove}
        """
        return _connect.COptionController_clear(self)

    def remove(self, nIndex):
        r"""
        Removes element at nIndex.

        :type nIndex: int
        :param nIndex: element index

        :raises: TException if this is not an array, the array size is static, or nIndex is out of array range

        Python example: _sample_link{opt_ctrl,test_add_remove}
        """
        return _connect.COptionController_remove(self, nIndex)

    def index_of(self, rstrOption, rstrValue):
        r"""
        Returns index of element whose element rstrOption has value rstrValue, or -1 if element is not found

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL
        :type rstrValue: string
        :param rstrValue: option value

        :rtype: int
        :return: index if element exists, -1 otherwise

        :raises: TException if this is not an array, or rstrOption is not an element name

        Python example: _sample_link{opt_ctrl,test_index_of}
        """
        return _connect.COptionController_index_of(self, rstrOption, rstrValue)

    def find(self, rstrOption, rstrValue, bAllowEmptyForSingleElement=False):
        r"""
        Returns COptionController for the element whose rstrOption has value rstrValue.

        :type rstrOption: string
        :param rstrOption: option string which is appended to the base URL
        :type rstrValue: string
        :param rstrValue: option value
        :type bAllowEmptyForSingleElement: boolean, optional
        :param bAllowEmptyForSingleElement: if a single element is present, allow access with empty rstrValue

        :rtype: :py:class:`COptionController`
        :return: COptionController for the element found

        :raises: TException if this is not an array, rstrOption is not a valid option, or the element is not found

        Python example: _sample_link{opt_ctrl,test_find}
        """
        return _connect.COptionController_find(self, rstrOption, rstrValue, bAllowEmptyForSingleElement)

# Register COptionController in _connect:
_connect.COptionController_swigregister(COptionController)
class COptionFilesCfg(COptionController):
    r"""Option controller for files"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def add_file(self, rstrPath, rstrType, aOffset):
        r"""
        Adds a new file and returns COptionController for it

        :type rstrPath: string
        :param rstrPath: path to the file (may be relative to workspace path)
        :type rstrType: string
        :param rstrType: file type (BIN | HEX | S37 | UBROF | OMF51 | SIT | IEEE-695 | ELF | TMSCOFF | Stabs | PE)
        :type aOffset: int
        :param aOffset:  file load offset

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example:
        """
        return _connect.COptionFilesCfg_add_file(self, rstrPath, rstrType, aOffset)
    __swig_destroy__ = _connect.delete_COptionFilesCfg

# Register COptionFilesCfg in _connect:
_connect.COptionFilesCfg_swigregister(COptionFilesCfg)
class COptionSoCCfg(COptionController):
    r"""SoC option controller"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def add_memory_space(self, rstrName, rstrLocation, rstrApp):
        r"""
        Adds a new memory space and returns COptionController for it

        :type rstrName: string
        :param rstrName: memory space user name
        :type rstrLocation: string
        :param rstrLocation: core or SMP name to where the memory space is mapped
        :type rstrApp: string
        :param rstrApp:  name of application executing in this memory space

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example:
        """
        return _connect.COptionSoCCfg_add_memory_space(self, rstrName, rstrLocation, rstrApp)

    def add_SMP(self, rstrName, rstrCores):
        r"""
        Adds a new SMP binding and returns COptionController for it

        :type rstrName: string
        :param rstrName: SMP user name
        :type rstrCores: string
        :param rstrCores: comma separated list of cores bound into the SMP binding

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example:
        """
        return _connect.COptionSoCCfg_add_SMP(self, rstrName, rstrCores)

    def program_files(self):
        r"""
        Returns COptionController for program files

        :rtype: :py:class:`COptionFilesCfg`
        :return: COptionFilesCfg

        Python example:
        """
        return _connect.COptionSoCCfg_program_files(self)
    __swig_destroy__ = _connect.delete_COptionSoCCfg

# Register COptionSoCCfg in _connect:
_connect.COptionSoCCfg_swigregister(COptionSoCCfg)
class COptionAppCfg(COptionController):
    r"""App option controller"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def symbol_files(self):
        r"""
        Returns COptionController for symbol files

        :rtype: :py:class:`COptionFilesCfg`
        :return: COptionFilesCfg

        Python example:
        """
        return _connect.COptionAppCfg_symbol_files(self)
    __swig_destroy__ = _connect.delete_COptionAppCfg

# Register COptionAppCfg in _connect:
_connect.COptionAppCfg_swigregister(COptionAppCfg)
class COptionAppsCfg(COptionController):
    r"""Apps option controller"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def add_app(self, rstrName):
        r"""
        Adds a new application and returns COptionController for it

        :type rstrName: string
        :param rstrName: application name

        :rtype: :py:class:`COptionAppCfg`
        :return: COptionAppCfg

        Python example:
        """
        return _connect.COptionAppsCfg_add_app(self, rstrName)
    __swig_destroy__ = _connect.delete_COptionAppsCfg

# Register COptionAppsCfg in _connect:
_connect.COptionAppsCfg_swigregister(COptionAppsCfg)
class COptionSessionCfg(COptionController):
    r"""Session option controller"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def apps(self):
        r"""
        Returns COptionController for applications

        :rtype: :py:class:`COptionAppsCfg`
        :return: COptionAppsCfg

        Python example:
        """
        return _connect.COptionSessionCfg_apps(self)

    def app(self, rstrName):
        r"""
        Returns COptionController for given application

        :type rstrName: string
        :param rstrName: application name

        :rtype: :py:class:`COptionAppCfg`
        :return: COptionAppCfg

        Python example:
        """
        return _connect.COptionSessionCfg_app(self, rstrName)

    def add_app(self, rstrName):
        r"""
        Adds a new application and returns COptionController for it

        :type rstrName: string
        :param rstrName: application name

        :rtype: :py:class:`COptionAppCfg`
        :return: COptionAppCfg

        Python example:
        """
        return _connect.COptionSessionCfg_add_app(self, rstrName)

    def SoCs(self):
        r"""
        Returns COptionController for SoCs

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example:
        """
        return _connect.COptionSessionCfg_SoCs(self)

    def SoC(self, rstrName):
        r"""
        Returns COptionController for given SoC

        :type rstrName: string
        :param rstrName: SoC name

        :rtype: :py:class:`COptionSoCCfg`
        :return: COptionSoCCfg

        Python example:
        """
        return _connect.COptionSessionCfg_SoC(self, rstrName)
    __swig_destroy__ = _connect.delete_COptionSessionCfg

# Register COptionSessionCfg in _connect:
_connect.COptionSessionCfg_swigregister(COptionSessionCfg)
class CConfigurationController(object):
    r"""
    This class provides convenient access to the most popular options. Methods
    of this class return instances of COptionController initialized with URL for
    specific winIDEA options, which can be used to get/set the options.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        _connect.CConfigurationController_swiginit(self, _connect.new_CConfigurationController(connectionMgr))
    __swig_destroy__ = _connect.delete_CConfigurationController

    def ide_session(self):
        r"""
        Returns COptionController for the debug session configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionSessionCfg`
        :return: COptionSessionCfg

        Python example: _sample_link{cfg_ctrl,test_ide_apps}
        """
        return _connect.CConfigurationController_ide_session(self)

    def ide_apps(self):
        r"""
        Returns COptionController for the applications configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_apps}
        """
        return _connect.CConfigurationController_ide_apps(self)

    def ide_app(self, *args):
        r"""
        Returns COptionController for the application configuration node with specified name.
        See COptionController.URL() to get the exact URL.

        :type rstrName: string, optional
        :param rstrName: application name

        :rtype: :py:class:`COptionAppCfg`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_a}
        """
        return _connect.CConfigurationController_ide_app(self, *args)

    def ide_app_files(self, rstrName):
        r"""
        Returns COptionController for the application configuration files node with the specified name.
        See COptionController.URL() to get the exact URL.

        :type rstrName: string
        :param rstrName: application name

        :rtype: :py:class:`COptionFilesCfg`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_app_files}
        """
        return _connect.CConfigurationController_ide_app_files(self, rstrName)

    def ide_SoCs(self):
        r"""
        Returns COptionController for the SoCs configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_socs}
        """
        return _connect.CConfigurationController_ide_SoCs(self)

    def ide_SoC(self, *args):
        r"""
        Returns COptionController for the SoC configuration node with the specified name.
        See COptionController.URL() to get the exact URL.

        :type rstrName: string, optional
        :param rstrName: SoC name

        :rtype: :py:class:`COptionSoCCfg`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_soc}
        """
        return _connect.CConfigurationController_ide_SoC(self, *args)

    def ide_SoC_files(self, rstrSoCUserName):
        r"""
        Returns COptionController for the list of download files for the given
        SoC name. Use COptionController.URL() of the returned object to get URL,
        which can be used in winIDEA `Display Options` dialog to find available settings.

        :type rstrSoCUserName: string
        :param rstrSoCUserName: SoC name. Search for `SoCs` and option `UserName` in
                                   winIDEA `Display options` dialog to see available SoC names.

        :rtype: :py:class:`COptionFilesCfg`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_soc_files}
        """
        return _connect.CConfigurationController_ide_SoC_files(self, rstrSoCUserName)

    def ide_test(self):
        r"""
        Returns COptionController for the (i)test configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_test}
        """
        return _connect.CConfigurationController_ide_test(self)

    def ide_ws_info(self):
        r"""
        Returns COptionController for the workspace information node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_ws}
        """
        return _connect.CConfigurationController_ide_ws_info(self)

    def ide_ws(self):
        r"""
        Returns COptionController for the workspace configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_ws}
        """
        return _connect.CConfigurationController_ide_ws(self)

    def ide_opt(self):
        r"""
        Returns COptionController for the IDE options configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_ide_opt}
        """
        return _connect.CConfigurationController_ide_opt(self)

    def doc(self, rstrFile):
        r"""
        Returns COptionController for the document configuration node with specified name.
        See COptionController.URL() to get the exact URL.

        :type rstrFile: string
        :param rstrFile: document file name

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_doc}
        """
        return _connect.CConfigurationController_doc(self, rstrFile)

    def doc_an_triggers(self, spDoc):
        r"""
        Returns COptionController for the analyzer triggers configuration node.
        See COptionController.URL() to get the exact URL.

        :type spDoc: :py:class:`COptionController`
        :param spDoc: document COptionController returned from doc

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_doc_an_trig}
        """
        return _connect.CConfigurationController_doc_an_triggers(self, spDoc)

    def doc_an_trig_processes(self, spTrigger):
        r"""
        Returns COptionController for the analyzer trigger processes configuration node.
        See COptionController.URL() to get the exact URL.

        :type spTrigger: :py:class:`COptionController`
        :param spTrigger: trigger COptionController obtained from doc_an_triggers

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_doc_an_trig_process}
        """
        return _connect.CConfigurationController_doc_an_trig_processes(self, spTrigger)

    def doc_an_trig_process_profiler_data(self, spProcess):
        r"""
        Returns COptionController for the analyzer trigger process (data) configuration node.
        See COptionController.URL() to get the exact URL.

        :type spProcess: :py:class:`COptionController`
        :param spProcess: process COptionController obtained from doc_an_trig_processes

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_doc_an_trig_process_profiler_data}
        """
        return _connect.CConfigurationController_doc_an_trig_process_profiler_data(self, spProcess)

    def doc_an_trig_process_profiler_code(self, spProcess):
        r"""
        Returns COptionController for the analyzer trigger process (code) configuration node.
        See COptionController.URL() to get the exact URL.

        :type spProcess: :py:class:`COptionController`
        :param spProcess: process COptionController obtained from doc_an_trig_processes

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_doc_an_trig_process_profiler_code}
        """
        return _connect.CConfigurationController_doc_an_trig_process_profiler_code(self, spProcess)

    def doc_an_trig_process_profiler_OS(self, spProcess):
        r"""
        Returns COptionController for the analyzer trigger process (OS) configuration node.
        See COptionController.URL() to get the exact URL.

        :type spProcess: :py:class:`COptionController`
        :param spProcess: process COptionController obtained from doc_an_trig_processes

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_doc_an_trig_process_profiler_os}
        """
        return _connect.CConfigurationController_doc_an_trig_process_profiler_OS(self, spProcess)

    def plugin_config(self, rstrPluginURL):
        r"""
        Returns COptionController for the plugin configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController

        Python example: _sample_link{cfg_ctrl,test_plugin_config}
        """
        return _connect.CConfigurationController_plugin_config(self, rstrPluginURL)

    def prototype(self, rstrPrototypeDomain):
        r"""
        Returns COptionController for the prototype configuration node.
        See COptionController.URL() to get the exact URL.

        :type rstrPrototypeDomain: string
        :param rstrPrototypeDomain: - the prototype domain, e.g. "SFR"

        :rtype: :py:class:`COptionController`
        :return: COptionController
        """
        return _connect.CConfigurationController_prototype(self, rstrPrototypeDomain)

    def bb_HW(self):
        r"""
        Returns COptionController for the BlueBox HW configuration node.
        See COptionController.URL() to get the exact URL.

        :rtype: :py:class:`COptionController`
        :return: COptionController
        """
        return _connect.CConfigurationController_bb_HW(self)

    def bb_SoC(self, nSoC=0):
        r"""
        Returns COptionController for the BlueBox SoC configuration node.
        See COptionController.URL() to get the exact URL.

        :type nSoC: int, optional
        :param nSoC: - index of the SoC

        :rtype: :py:class:`COptionController`
        :return: COptionController
        """
        return _connect.CConfigurationController_bb_SoC(self, nSoC)

# Register CConfigurationController in _connect:
_connect.CConfigurationController_swigregister(CConfigurationController)
class CPluginController(object):
    r"""
    This class is used to control winIDEA plugins. It can provide content of the
    plugin view, invoke plugin specific commands, and refresh the view.

    Python example: _sample_link{plugin_ctrl,test_plugin_control}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrPluginName):
        r"""
        This class provides winIDEA plugin control.

        :type spConnectionMgr: :py:class:`ConnectionMgr`
        :param spConnectionMgr: connection object
        :type rstrPluginName: string
        :param rstrPluginName: as defined in winIDEA

        Python example: _sample_link{plugin_ctrl,test_plugin_control}
        """
        _connect.CPluginController_swiginit(self, _connect.new_CPluginController(spConnectionMgr, rstrPluginName))
    __swig_destroy__ = _connect.delete_CPluginController

    def open(self, rstrViewName):
        r"""
        Opens a view.

        :raises: IOException if operation fails.

        :type rstrViewName: string
        :param rstrViewName: specifies view name

        Python example: _sample_link{plugin_ctrl,test_plugin_control}
        """
        return _connect.CPluginController_open(self, rstrViewName)

    def close(self, rstrViewName):
        r"""
        Closes a view.

        :raises: IOException if operation fails.

        :type rstrViewName: string
        :param rstrViewName: specifies view name

        Python example: _sample_link{plugin_ctrl,test_plugin_control}
        """
        return _connect.CPluginController_close(self, rstrViewName)

    def is_open(self, rstrViewName):
        r"""
        Returns true if view is open.

        :raises: IOException if operation fails.

        :type rstrViewName: string
        :param rstrViewName: specifies view name

        :rtype: boolean
        :return: true if view open, false otherwise

        Python example: _sample_link{plugin_ctrl,test_plugin_control}
        """
        return _connect.CPluginController_is_open(self, rstrViewName)

    def refresh(self, rstrViewName):
        r"""
        Refreshes a view.

        :raises: IOException if operation fails.

        :type rstrViewName: string
        :param rstrViewName: specifies view name

        Python example: _sample_link{plugin_ctrl,test_plugin_control}
        """
        return _connect.CPluginController_refresh(self, rstrViewName)

    def invoke(self, *args):
        r"""
        *Overload 1:*

        This method invokes plugin specific commands (non generic).

        :raises: IOException if operation fails.

        :type rstrCommand: string
        :param rstrCommand: command name
        :type rstrParameters: string
        :param rstrParameters: command parameters separated by colon

        :rtype: string
        :return: command operation results
            Python example: _sample_link{plugin_ctrl,test_plugin_control}

        |

        *Overload 2:*

        This method invokes plugin specific commands (non generic).

        :raises: IOException if operation fails.

        :type rstrViewName: string
        :param rstrViewName: specifies view name
        :type rstrCommand: string
        :param rstrCommand: command
        :type rstrParameters: string
        :param rstrParameters: command parameters separated by colon

        :rtype: string
        :return: command operation results
            Python example: _sample_link{plugin_ctrl,test_plugin_control}
        """
        return _connect.CPluginController_invoke(self, *args)

    def get_content(self, rstrViewName, rstrItemPath, rvnColumns, bIsRecursive=True, bExpandOnDemand=False):
        r"""
        Returns view content.

        :raises: IOException if operation fails.

        :type rstrViewName: string
        :param rstrViewName: view name
        :type rstrItemPath: string
        :param rstrItemPath: item path (starts with '/', components are delimited with '/'); if empty, all items will
            be returned
        :type rvnColumns: :py:class:`IntVector`
        :param rvnColumns: column indexes (0-based); if empty, all columns will be returned
        :type bIsRecursive: boolean, optional
        :param bIsRecursive: if true, all descendants of the specified item will be returned too
        :type bExpandOnDemand: boolean, optional
        :param bExpandOnDemand: if true, all items on the way to (and including) the specified item will be
            temporarily expanded to load their contents if necessary

        :rtype: :py:class:`StrStrVectorMap`
        :return: view content as map - keys are item paths, their values are vectors of column values; the "header"
            key contains column names

        Python example: _sample_link{plugin_ctrl,test_get_content}
        """
        return _connect.CPluginController_get_content(self, rstrViewName, rstrItemPath, rvnColumns, bIsRecursive, bExpandOnDemand)

# Register CPluginController in _connect:
_connect.CPluginController_swigregister(CPluginController)
class CInstruction(object):
    r"""
    This class contains additional information to IInstruction, and provides
    convenient wrapper methods.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sInstr):
        _connect.CInstruction_swiginit(self, _connect.new_CInstruction(sInstr))

    def getAddress(self):
        r"""Returns location of the current instruction."""
        return _connect.CInstruction_getAddress(self)

    def getJumpTarget(self):
        r"""
        When isFlowDirectJump() returns true, this method returns absolute
        target address.
        """
        return _connect.CInstruction_getJumpTarget(self)

    def getFlags(self):
        return _connect.CInstruction_getFlags(self)

    def getSize(self):
        return _connect.CInstruction_getSize(self)

    def getMemAccessSize(self):
        return _connect.CInstruction_getMemAccessSize(self)

    def getOpCode(self):
        return _connect.CInstruction_getOpCode(self)

    def isFlowSequential(self):
        r"""Returns true, if this is sequential instruction."""
        return _connect.CInstruction_isFlowSequential(self)

    def isFlowDirectJump(self):
        r"""
        Returns true, if this is a direct change of flow. Method
        getJumpTarget() returns valid value.
        """
        return _connect.CInstruction_isFlowDirectJump(self)

    def isFlowIndirectJump(self):
        r"""Returns true, if this is an indirect change of flow."""
        return _connect.CInstruction_isFlowIndirectJump(self)

    def isConditional(self):
        r"""Returns true, if this is conditional instruction."""
        return _connect.CInstruction_isConditional(self)

    def isCall(self):
        r"""
        This instruction is a call to a routine which will return and resume
        execution after this instruction.
        """
        return _connect.CInstruction_isCall(self)

    def isRelative(self):
        r"""This call is valid when method isFlowDirectJump() returns true."""
        return _connect.CInstruction_isRelative(self)

    def isWriteAccess(self):
        r"""Execution of instruction will generate a write access."""
        return _connect.CInstruction_isWriteAccess(self)

    def isReadAccess(self):
        r"""Execution of instruction  will generate a read access."""
        return _connect.CInstruction_isReadAccess(self)

    def incExecCounter(self):
        r"""Increments execution counter."""
        return _connect.CInstruction_incExecCounter(self)

    def setExecCounter(self, n):
        r"""Sets execution counter."""
        return _connect.CInstruction_setExecCounter(self, n)

    def getExecCounter(self):
        r"""Returns execution counter."""
        return _connect.CInstruction_getExecCounter(self)

    def toString(self):
        return _connect.CInstruction_toString(self)
    __swig_destroy__ = _connect.delete_CInstruction

# Register CInstruction in _connect:
_connect.CInstruction_swigregister(CInstruction)
class CPartitionCodeInfo(object):
    r"""This class handles instructions for one application domain."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, instructions):
        _connect.CPartitionCodeInfo_swiginit(self, _connect.new_CPartitionCodeInfo(instructions))

    def getInstructionAtAddress(self, address):
        r"""
        Reads instructions. To release memory occupied by these data, call
        method release().
        """
        return _connect.CPartitionCodeInfo_getInstructionAtAddress(self, address)

    def getInstructionAtIndex(self, index):
        return _connect.CPartitionCodeInfo_getInstructionAtIndex(self, index)

    def getIndexForAddress(self, address):
        return _connect.CPartitionCodeInfo_getIndexForAddress(self, address)

    def getFunction(self, address):
        return _connect.CPartitionCodeInfo_getFunction(self, address)

    def getFile(self, address):
        return _connect.CPartitionCodeInfo_getFile(self, address)

    def getLine(self, address):
        return _connect.CPartitionCodeInfo_getLine(self, address)

    def getSrcCode(self, address):
        return _connect.CPartitionCodeInfo_getSrcCode(self, address)

    def getCalledFunctions(self, funcName, level, calledFunctions):
        return _connect.CPartitionCodeInfo_getCalledFunctions(self, funcName, level, calledFunctions)
    __swig_destroy__ = _connect.delete_CPartitionCodeInfo

# Register CPartitionCodeInfo in _connect:
_connect.CPartitionCodeInfo_swigregister(CPartitionCodeInfo)
class CPartitionExecInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CPartitionExecInfo_swiginit(self, _connect.new_CPartitionExecInfo())
    __swig_destroy__ = _connect.delete_CPartitionExecInfo

# Register CPartitionExecInfo in _connect:
_connect.CPartitionExecInfo_swigregister(CPartitionExecInfo)
class CInstructionIter(object):
    r"""
    This class should be used to access instructions from other languages
    than C++, otherwise garbage collector may release objects to early and
    application will crash.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CInstructionIter_swiginit(self, _connect.new_CInstructionIter(*args))

    def hasNext(self):
        r"""Returns true, if iterator has not reached range end."""
        return _connect.CInstructionIter_hasNext(self)

    def next(self):
        r"""Returns next element from iterator range."""
        return _connect.CInstructionIter_next(self)

    def peek(self):
        r"""Returns current element."""
        return _connect.CInstructionIter_peek(self)

    def branch(self, address):
        r"""
        Returns true for forward jump, false if branch is made to same
        address or backward.
        """
        return _connect.CInstructionIter_branch(self, address)

    def isAddressInRange(self, address):
        r"""Returns true, if the given adress is in range of this iterator."""
        return _connect.CInstructionIter_isAddressInRange(self, address)
    __swig_destroy__ = _connect.delete_CInstructionIter

# Register CInstructionIter in _connect:
_connect.CInstructionIter_swigregister(CInstructionIter)
class CSOCCodeInfo(object):
    r"""Contains inctructions for complete SOC."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CSOCCodeInfo

    def release(self):
        return _connect.CSOCCodeInfo_release(self)

    def getCodeInfo(self, partition):
        return _connect.CSOCCodeInfo_getCodeInfo(self, partition)

    def loadCodeInfo(self, dataCtrl2, partition):
        return _connect.CSOCCodeInfo_loadCodeInfo(self, dataCtrl2, partition)

    def __init__(self):
        _connect.CSOCCodeInfo_swiginit(self, _connect.new_CSOCCodeInfo())

# Register CSOCCodeInfo in _connect:
_connect.CSOCCodeInfo_swigregister(CSOCCodeInfo)
class CLogger(object):
    r"""
    This class can be used to add logging to all controller classes. Unlike
    usual loggers, this class produces runnable Python or Java code. For this
    reason the log() methods are a bit different - they accept object name
    and method name as parameters, which are than used when writing code to
    the log file. The result
    is program file, which contains only calls to isystem.connect. This is
    useful, when we would like to quickly reproduce the problem or simply
    for readable overview of what is going on between our application and
    target hardware. 


    However, although the log file is a runnable program, the functionality
    will usually NOT be the same as that of original program. For example,
    if the original program calls ``getStatus()`` in a loop until condition is met,
    the log file will contain on the number of ``getStatus()`` calls, without
    loop or condition. The log file is intended as debugging help, not as
    full substitute of the original program.

    **NOTE**: This class is not intended to be used directly by end users. It
    is used internally, when the user code makes ``isystem.connect`` calls. See
    ConnectionMgr::initLogger() for initialization of internal logger.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    JAVA = _connect.CLogger_JAVA
    r"""write log statements in Java language (limited support)"""
    PYTHON = _connect.CLogger_PYTHON
    r"""write log statements in Python language"""

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Opens log file and initializes it. Logging is ON by default.

        :type fileName: string
        :param fileName: name of the logFile
        :type language: int
        :param language: defines syntax used for command logging
        :type isLogToStdOut: boolean
        :param isLogToStdOut: NOT IMPLEMENTED! (if true, output will be also printed to std out)
        :type timeDiffToIgnore: float
        :param timeDiffToIgnore: time delays shorter than this value are not logged.
            This value should be specified in seconds. Use large value to disable logging
            of delays.
        :type header: string
        :param header: string containing header of the log file. It may include
            imports, class and method declarations, so that the generated log file is
            compilable Java or Python source file. It may as well be empty or include
            comment only.

        |

        *Overload 2:*

        Opens log file and initializes it. Logging is ON by default. Time difference
        to be ignored is set to 1 second by default.

        :type fileName: string
        :param fileName: name of the logFile
        :type language: int
        :param language: defines syntax used for command logging
        """
        _connect.CLogger_swiginit(self, _connect.new_CLogger(*args))

    def writeHeader(self, header):
        return _connect.CLogger_writeHeader(self, header)

    def setIgnorableTimeDiff(self, timeDiff):
        return _connect.CLogger_setIgnorableTimeDiff(self, timeDiff)
    __swig_destroy__ = _connect.delete_CLogger

    def closeLog(self, footer):
        r"""
        Closes log file and turns off the logging. No logging will be done after
        this call. Log file

        :type footer: string
        :param footer: end of Java or Python program, for example closing parantheses
            in Java. May also be empty or contain comment.
        """
        return _connect.CLogger_closeLog(self, footer)

    def resetStartTime(self):
        r"""
        Resets start time so that it will start counting from 0 when the first method is
        executed. Useful, when we want to repeat script without restarting.
        """
        return _connect.CLogger_resetStartTime(self)

    def setIndent(self, indent):
        r"""
        Sets indentation for the following logged statements. Call with
        argument 0 to disable indentation.

        :type indent: int
        :param indent: the number of spaces used for indentation
        """
        return _connect.CLogger_setIndent(self, indent)

    def loggingOn(self):
        r"""
        Turns logging on.

        See also: #loggingOff
        """
        return _connect.CLogger_loggingOn(self)

    def loggingOff(self):
        r"""
        Turns logging off. Calls to ``log()`` methods will produce no
        output after this call.

        See also: #loggingOn
        """
        return _connect.CLogger_loggingOff(self)

    def isLoggingOn(self):
        r"""
        Returns if logging is turned on

        :rtype: boolean
        :return: true if logging is enabled, otherwise false
        """
        return _connect.CLogger_isLoggingOn(self)

    def logc(self, comment):
        r"""
        This method may be called from client code to insert user specific comments.
        The language specific comment character is automatically prepended.
        """
        return _connect.CLogger_logc(self, comment)

    def logf(self, objName, methodName, format):
        r"""
        Logging of function call with variable arguments.

        :type objName: string
        :param objName: name of the object to be used in the generated code. For example 'addrCtrl'.
        :type methodName: string
        :param methodName: name of the method to be used in the generated code. For
                              example `"getFunctionAddress"` to generate `addrCtrl.getFunctionAddress("main")`
                              when format string is `"s"` and additional parameter is `"main"`.
        :type format: string
        :param format: format string, may contain:
                   - i - int
                   - s - std::string
                   - b - bool
                   - l - int64_t
                   - u - unsigned
                   - D - DWORD
                   - E - enum, followed by conversion function pointer. If the
                         pointer == NULL, enum is logged as integer

        __Note:__ This method can not be called from Python.
        """
        return _connect.CLogger_logf(self, objName, methodName, format)

    def log(self, *args):
        r"""
        *Overload 1:*

        This method may be called from client code to insert user specific script code.

        |

        *Overload 2:*
         Logs call of method with no parameter. See also: logf

        |

        *Overload 3:*
         Logs call of method with DWORD parameter. See also: logf

        |

        *Overload 4:*

        Logs call of method with Logs call with string parameter.
        See also: logf
        """
        return _connect.CLogger_log(self, *args)

    def createVar(self, varName, varType):
        r"""
        Logs declaration and assignment statement, for example
        SProfilerStartingPoint sp = SProfilerStartingPoint();
        """
        return _connect.CLogger_createVar(self, varName, varType)

    def fillVectorBYTE(self, varName, buff):
        r"""Creates vector of bytes in script language and assigns its values from buff."""
        return _connect.CLogger_fillVectorBYTE(self, varName, buff)

    def createSType(self, valueName, sType):
        r"""
        Creates and fills CValueType object.
                void createCValueType(const std::string &valueName, const CValueType &value);

        Creates and fills SType object.
        """
        return _connect.CLogger_createSType(self, valueName, sType)

    @staticmethod
    def icDebugAccessFlags2str(flags):
        r"""Returns string corresponding to value of flags to IConnectDebug::EAccessFlags"""
        return _connect.CLogger_icDebugAccessFlags2str(flags)

    @staticmethod
    def icDebugSymbolFlags2str(flags):
        r"""Returns string corresponding to value of flags to IConnectDebug::ESymbolFlags."""
        return _connect.CLogger_icDebugSymbolFlags2str(flags)

    @staticmethod
    def icDebugAddressFlags2str(flags):
        r"""
         Returns string corresponding to value of flags to IConnectDebug::EGetAddressFlags.
        Converts only the most often used values.
        Useful for logging, but not for generating program code.
        """
        return _connect.CLogger_icDebugAddressFlags2str(flags)

    @staticmethod
    def icDebugEvaluateFlags2str(flags):
        r"""Returns string corresponding to value of flags to IConnectDebug::EEvaluateFlags."""
        return _connect.CLogger_icDebugEvaluateFlags2str(flags)

    @staticmethod
    def icSTypeType2str(flags):
        r"""Returns string corresponding to enum in STYpe."""
        return _connect.CLogger_icSTypeType2str(flags)

    @staticmethod
    def lang2str(flags):
        r"""Returns string corresponding to CCoverageController::ERangeItem.  Returns string corresponding to IConnectCoverage::ECoverageRangesTypes.  Returns string corresponding to IConnectCoverage::ECoverageStatisticsFlags.  Returns string corresponding to IConnectCoverage::EConfigFlags.  Returns string corresponding to IConnectCoverage::EGetStatusFlags.  Returns string corresponding to logger language settings."""
        return _connect.CLogger_lang2str(flags)

# Register CLogger in _connect:
_connect.CLogger_swigregister(CLogger)
class CWinIDEAVersion(object):
    r"""
    This class contains a winIDEA version number. It is not intended to be
    instantiated by clients; use isys::CIDEController::getWinIDEAVersion() or
    isys::ConnectionMgr::getWinIDEAVersion() to obtain an instance.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        :type version: string
        :param version: must be in <major>.<minor>.<build>[.<subbuild>] format,
                   for example: 9.12.209, or 9.12.209.4302
        """
        _connect.CWinIDEAVersion_swiginit(self, _connect.new_CWinIDEAVersion(*args))

    @staticmethod
    def getFileVersion(fileName):
        return _connect.CWinIDEAVersion_getFileVersion(fileName)

    def getMajor(self):
        r"""Returns the major winIDEA version."""
        return _connect.CWinIDEAVersion_getMajor(self)

    def getMinor(self):
        r"""Returns the minor winIDEA version."""
        return _connect.CWinIDEAVersion_getMinor(self)

    def getBuild(self):
        r"""Returns the winIDEA build number."""
        return _connect.CWinIDEAVersion_getBuild(self)

    def getSubbuild(self):
        r"""
         Returns the winIDEA sub-build number. Returns 0xffff if sub-build version
        was not set.
        """
        return _connect.CWinIDEAVersion_getSubbuild(self)

    def getSccRevision(self):
        r"""
         Returns the winIDEA source control revision number. Returns 0xffff'ffff if this version
        was not set.
        """
        return _connect.CWinIDEAVersion_getSccRevision(self)

    def getBuildYear(self):
        r"""Returns winIDEA build year. Returns 0 if build year was not set."""
        return _connect.CWinIDEAVersion_getBuildYear(self)

    def getBuildMonth(self):
        r"""Returns winIDEA build month in range [1..12]. Returns 0 if build month was not set."""
        return _connect.CWinIDEAVersion_getBuildMonth(self)

    def getBuildDay(self):
        r"""Returns winIDEA build day in range [1..31]. Returns 0 if build day was not set."""
        return _connect.CWinIDEAVersion_getBuildDay(self)

    def compare(self, other):
        r"""
        Returns -1 if this version is smaller than other, 0 if equal,
        and 1 if greater.
        """
        return _connect.CWinIDEAVersion_compare(self, other)

    def get_InstallDir(self):
        r"""Returns the installation directory"""
        return _connect.CWinIDEAVersion_get_InstallDir(self)

    def toString(self):
        r"""
        Returns version number as string. Format: <major>.<minor>.<build>.
        If sub-build number was also set, the return string is <major>.<minor>.<build>.<sub-build>.
        Example: 9.10.115
        """
        return _connect.CWinIDEAVersion_toString(self)
    __swig_destroy__ = _connect.delete_CWinIDEAVersion

# Register CWinIDEAVersion in _connect:
_connect.CWinIDEAVersion_swigregister(CWinIDEAVersion)

def getSdkVersion():
    r"""
    This function returns version of current isystem.connect module. It returns
    the same version as getModuleVersion(), but source control version is also set.
    """
    return _connect.getSdkVersion()
class CUMIController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        r"""test_write.py Python example."""
        _connect.CUMIController_swiginit(self, _connect.new_CUMIController(connectionMgr))
    __swig_destroy__ = _connect.delete_CUMIController

    def write(self, *args):
        r"""
        *Overload 1:*

        Writes contents of pre-configured files to device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
            test_write.py Python example.

        |

        *Overload 2:*

        Writes contents of file to device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type fileFormat: int
        :param fileFormat: should be one of ``wFile...`` flags from IConnectUMI::EOperationFlags,
                              for example IConnectUMI::wFileFormatAuto, IConnectUMI::wFileFormatBin,
                              IConnectUMI::wFileFormatS, IConnectUMI::wFileFormatHex.
        :type offset: int
        :param offset: offset to add to the address in the file
        :type fileName: string
        :param fileName: path to the file to program

        test_write.py Python example.

        |

        *Overload 3:*

        Writes data to device.
        :param dwDevice: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to write to
        :type size: int
        :param size: size of the data to write
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector of data to be written

        test_write.py Python example.
        """
        return _connect.CUMIController_write(self, *args)

    def read(self, deviceIndex, address, size, data):
        r"""
        Reads data from device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to read from
        :type size: int
        :param size: size of the data to read
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector to contain read data on return
            test_read.py Python example.
        """
        return _connect.CUMIController_read(self, deviceIndex, address, size, data)

    def flush(self, deviceIndex):
        r"""
        Programs the device from the intermediate cache.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.

        test_flush.py Python example.
        """
        return _connect.CUMIController_flush(self, deviceIndex)

    def erase(self, *args):
        r"""
        *Overload 1:*

        Erases complete device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.

        test_erase.py Python example.

        |

        *Overload 2:*

        Erases the specified region.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to erase from
        :type size: int
        :param size: size of the data to be erased

        test_erase.py Python example.
        """
        return _connect.CUMIController_erase(self, *args)

    def verify(self, *args):
        r"""
        *Overload 1:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.

        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
            test_verify.py Python example.

        |

        *Overload 2:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.

        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified

        test_verify.py Python example.
        """
        return _connect.CUMIController_verify(self, *args)

    def blankCheck(self, *args):
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :raises: CUMIException if device is not empty
        Deprecated: Call isDeviceEmpty(DWORD deviceIndex) instead.

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :raises: CUMIException if device is not empty
        Deprecated: Call isDeviceEmpty(DWORD deviceIndex, ADDRESS address, ADDRESS size) instead.
        """
        return _connect.CUMIController_blankCheck(self, *args)

    def fill(self, deviceIndex):
        r"""
        Fills device with a preconfigured value which is device specific. Operation not supported by all devices.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :raises: CUMIException if device is not empty

        test_fill.py Python example.
        """
        return _connect.CUMIController_fill(self, deviceIndex)

    def isDeviceEmpty(self, *args):
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :rtype: boolean
        :return: true if the device is empty, false otherwise
            test_is_device_empty.py Python example.

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :rtype: boolean
        :return: true if the device is empty, false otherwise

        test_is_device_empty.py Python example.
        """
        return _connect.CUMIController_isDeviceEmpty(self, *args)

    def secure(self, *args):
        r"""
        *Overload 1:*

        Secures the device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
            test_secure_unsecure_check.py Python example.

        |

        *Overload 2:*

        Secures the sector.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address of the sector to be secured
        :type size: int
        :param size: size of the sector to be secured

        test_secure_unsecure_check.py Python example.
        """
        return _connect.CUMIController_secure(self, *args)

    def unsecure(self, *args):
        r"""
        *Overload 1:*

        Unsecures the device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
            test_secure_unsecure_check.py Python example.

        |

        *Overload 2:*

        Unsecures the sector.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
            test_secure_unsecure_check.py Python example.
        """
        return _connect.CUMIController_unsecure(self, *args)

    def secureCheck(self, *args):
        r"""
        *Overload 1:*

        Checks if security is set on device.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
            test_secure_unsecure_check.py Python example.

        |

        *Overload 2:*

        Checks if security is set on sector.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
            test_secure_unsecure_check.py Python example.
        """
        return _connect.CUMIController_secureCheck(self, *args)

    def readState(self, deviceIndex, programMode, address, size, stateResult):
        r"""
        Reads the device program state.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address
        :type size: int
        :param size: size of the data to be examined
        :type stateResult: std::vector< BYTE,std::allocator< BYTE > >
        :param stateResult: Program state as vector of bytes, returned as an unpacked byte array (1 MAU per byte).
                   Vector size must be the size of the data to be examined. Value equals to 1 if MAU programmed and 0 if not.
            test_read_state.py Python example.
        """
        return _connect.CUMIController_readState(self, deviceIndex, programMode, address, size, stateResult)

    def readHash(self, *args):
        r"""
        *Overload 1:*

        Reads target device data MURMUR2 hash.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 BYTES.
            test_read_hash.py Python example.

        |

        *Overload 2:*

        Reads target device data MURMUR2 hash.
        :type deviceIndex: int
        :param deviceIndex: index of the UMI device. Use method getDeviceIndex() to obtain this
                   value from device name, to make the code more robust.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address for hash calculation
        :type size: int
        :param size: size of the data to be hashed
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 bytes, since hash is 4-bytes long.
            test_read_hash.py Python example.
        """
        return _connect.CUMIController_readHash(self, *args)

    def getDeviceIndex(self, deviceName, isThrowOnNotFound=True):
        r"""
        Gets device index for the given device name. It is highly recommended to use this
        method for obtaining device index when calling other methods of this class.
        This way you code will be more robust and will work also if device order changes.
        :type deviceName: string
        :param deviceName: UMI device name
        :type isThrowOnNotFound: boolean, optional
        :param isThrowOnNotFound: if true IllegalStateException is raised in case device not found
        :rtype: int
        :return: index of device, or -1 if device was not found
        :raises: IllegalStateException if device index for the given name can't be retrieved.
            test_get_device_index.py Python example.
        """
        return _connect.CUMIController_getDeviceIndex(self, deviceName, isThrowOnNotFound)

    def getLastError(self):
        r"""
        This function returns error description, after UMI isystem.connect call fails.
        If there is no error message available, an empty string is returned.
        test_get_last_error.py Python example.
        """
        return _connect.CUMIController_getLastError(self)

# Register CUMIController in _connect:
_connect.CUMIController_swigregister(CUMIController)
class CEMMCPartitionInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bootStatus, bootModifyStatus, nameModifyStatus, offsetModifyStatus, sizeModifyStatus, removeStatus, enhancedOffset, enhancedSize, offset, size, extended, type, name):
        _connect.CEMMCPartitionInfo_swiginit(self, _connect.new_CEMMCPartitionInfo(bootStatus, bootModifyStatus, nameModifyStatus, offsetModifyStatus, sizeModifyStatus, removeStatus, enhancedOffset, enhancedSize, offset, size, extended, type, name))
    __swig_destroy__ = _connect.delete_CEMMCPartitionInfo

    def isBootable(self):
        r"""Returns ``true`` if partition is bootable, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_isBootable(self)

    def canModifyBoot(self):
        r"""Returns ``true`` if partition boot status can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifyBoot(self)

    def canModifyName(self):
        r"""Returns ``true`` if partition name can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifyName(self)

    def canModifyOffset(self):
        r"""Returns ``true`` if partition offset can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifyOffset(self)

    def canModifySize(self):
        r"""Returns ``true`` if partition size can be changed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canModifySize(self)

    def canRemove(self):
        r"""Returns ``true`` if partition can be removed, ``false`` otherwise."""
        return _connect.CEMMCPartitionInfo_canRemove(self)

    def getEnhancedOffset(self):
        r"""In case of device enhanced mode (generic name for SLC/MLC implementation), this represent enhanced partition offset address."""
        return _connect.CEMMCPartitionInfo_getEnhancedOffset(self)

    def getEnhancedSize(self):
        r"""In case of device enhanced mode (generic name for SLC/MLC implementation), this represent enhanced partition size."""
        return _connect.CEMMCPartitionInfo_getEnhancedSize(self)

    def getOffset(self):
        r"""Returns partition offset."""
        return _connect.CEMMCPartitionInfo_getOffset(self)

    def getSize(self):
        r"""Returns partition size."""
        return _connect.CEMMCPartitionInfo_getSize(self)

    def getExtended(self):
        r"""Returns partition extended status."""
        return _connect.CEMMCPartitionInfo_getExtended(self)

    def getType(self):
        r"""
        Legacy method and not supported anymore.
        Returns an empty string.
        """
        return _connect.CEMMCPartitionInfo_getType(self)

    def getName(self):
        r"""Returns partition name."""
        return _connect.CEMMCPartitionInfo_getName(self)

# Register CEMMCPartitionInfo in _connect:
_connect.CEMMCPartitionInfo_swigregister(CEMMCPartitionInfo)
class CEMMCDeviceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name, configurationApplyStatus, partitionCreateStatus, type, busWidth, partitionNames):
        _connect.CEMMCDeviceInfo_swiginit(self, _connect.new_CEMMCDeviceInfo(name, configurationApplyStatus, partitionCreateStatus, type, busWidth, partitionNames))

    def getName(self):
        r"""Returns device name."""
        return _connect.CEMMCDeviceInfo_getName(self)

    def canApplyConfiguration(self):
        r"""Returns configuration apply status."""
        return _connect.CEMMCDeviceInfo_canApplyConfiguration(self)

    def canCreatePartition(self):
        r"""Returns partition creation status."""
        return _connect.CEMMCDeviceInfo_canCreatePartition(self)

    def getType(self):
        r"""Returns device type."""
        return _connect.CEMMCDeviceInfo_getType(self)

    def getBusWidth(self):
        r"""Returns device bus width (number of lines - x1=1, x2=2,...)."""
        return _connect.CEMMCDeviceInfo_getBusWidth(self)

    def getPartitionNames(self):
        r"""Returns vector of partition names."""
        return _connect.CEMMCDeviceInfo_getPartitionNames(self)
    __swig_destroy__ = _connect.delete_CEMMCDeviceInfo

# Register CEMMCDeviceInfo in _connect:
_connect.CEMMCDeviceInfo_swigregister(CEMMCDeviceInfo)
class CEMMCController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CEMMCController_swiginit(self, _connect.new_CEMMCController(*args))
    __swig_destroy__ = _connect.delete_CEMMCController
    textFile = _connect.CEMMCController_textFile
    r"""text file"""
    binFile = _connect.CEMMCController_binFile
    r"""binary file"""

    def initialize(self, deviceName):
        r"""
        Initialize environment. Needs to be called once before any class method is executed,
        except getDevicesNumber() and getDevicesNames() class methods.

        :type deviceName: string
        :param deviceName: storage device name
        :raises: IllegalStateException in case if operation fails.

        Python example: test_init_terminate.py 
        """
        return _connect.CEMMCController_initialize(self, deviceName)

    def terminate(self):
        r"""
        Terminate environment. Needs to be called after the last class method is executed.

        :raises: IllegalStateException in case of monitor unload fails.

        Python example: test_init_terminate.py 
        """
        return _connect.CEMMCController_terminate(self)

    def getDevicesNumber(self):
        r"""
        Returns number of available emmc storage devices.

        :rtype: int
        :return: number of available emmc storage devices.

        :raises: IllegalStateException if number of emmc storage devices can't be retrieved.

        Python example: test_get_devices_number.py 
        """
        return _connect.CEMMCController_getDevicesNumber(self)

    def getDevicesNames(self, deviceNames):
        r"""
        Returns vector of available emmc storage device names.

        :rtype: void
        :return: vector of available emmc storage device names.

        :raises: IllegalStateException if vector of emmc storage device names can't be retrieved.

        Python example: test_get_devices_names.py 
        """
        return _connect.CEMMCController_getDevicesNames(self, deviceNames)

    def getDeviceInfo(self):
        r"""
        Returns device information.

        :rtype: :py:class:`CEMMCDeviceInfo`
        :return: CEMMCDeviceInfo

        :raises: IllegalStateException if device information can't be retrieved.

        Python example: test_get_device_info.py 
        """
        return _connect.CEMMCController_getDeviceInfo(self)

    def getPartitionInfo(self, partitionName):
        r"""
        Returns device's partition information.

        :type partitionName: string
        :param partitionName: partition name
        :rtype: :py:class:`CEMMCPartitionInfo`
        :return: CEMMCPartitionInfoSPtr

        Python example: test_get_partition_info.py 
        """
        return _connect.CEMMCController_getPartitionInfo(self, partitionName)

    def read(self, partitionName, offset, sizeInBytes, data):
        r"""
        Reads data from the storage device.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to read
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: vector to contain read data on return

        Python example: test_emmc_read.py 
        """
        return _connect.CEMMCController_read(self, partitionName, offset, sizeInBytes, data)

    def write(self, *args):
        r"""
        *Overload 1:*

        Writes data to the storage device from the input vector.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to write
        :type data: std::vector< uint8_t,std::allocator< uint8_t > >
        :param data: vector of data to be written

        Python example: test_emmc_read_write.py 


        |

        *Overload 2:*

        Writes contents of file to the storage device offset.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type filePath: string
        :param filePath: path to the file in binary or Motorola S format

        Python example: test_emmc_read_write.py 
        """
        return _connect.CEMMCController_write(self, *args)

    def erase(self, *args):
        r"""
        *Overload 1:*

        Erases content of selected partition.

        :type partitionName: string
        :param partitionName: name of partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to be erased from the start of partition

        Python example: test_emmc_erase.py 


        |

        *Overload 2:*

        Erases content of selected partition.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to be erased from the start of partition

        Python example: test_emmc_erase.py 
        """
        return _connect.CEMMCController_erase(self, *args)

    def modify(self, partitionName, offset, sizeInBytes, isBoot):
        r"""
        Modifies parameters of the selected partition.

        :type partitionName: string
        :param partitionName: name of partition
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes reserved for selected partition
        :type isBoot: boolean
        :param isBoot: bootable partition flag

        Python example: test_emmc_modify.py 
        """
        return _connect.CEMMCController_modify(self, partitionName, offset, sizeInBytes, isBoot)

    def isDeviceEmpty(self, *args):
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :type partitionName: string
        :param partitionName: name of partition
        :rtype: boolean
        :return: true if the device is empty, false otherwise

        Python example: test_emmc_is_device_empty.py 


        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes to be compared with
        :rtype: boolean
        :return: true if the device is empty, false otherwise

        Python example: test_emmc_is_device_empty.py 
        """
        return _connect.CEMMCController_isDeviceEmpty(self, *args)

# Register CEMMCController in _connect:
_connect.CEMMCController_swigregister(CEMMCController)
class CStorageDeviceController(object):
    r"""This class presents a common API for all storage devices."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CStorageDeviceController

    def read(self, address, size, data):
        r"""
        Reads data from device.
        :type address: int
        :param address: address to read from
        :type size: int
        :param size: size of the data to read
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector to contain read data on return

        Python example: _sample_link{storage_dev_ctrl,test_storage_read}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_read}
        """
        return _connect.CStorageDeviceController_read(self, address, size, data)

    def write(self, *args):
        r"""
        *Overload 1:*

        Writes contents of pre-configured files to device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache. For eMMC devices IConnectUMI::wProgDevice is always used.
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_write}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_read_write}

        |

        *Overload 2:*

        Writes contents of file to device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache. For eMMC devices IConnectUMI::wProgDevice is always used.
        :type fileFormat: int
        :param fileFormat: should be one of ``wFile...`` flags from IConnectUMI::EOperationFlags,
                              for example IConnectUMI::wFileFormatAuto, IConnectUMI::wFileFormatBin,
                              IConnectUMI::wFileFormatS, IConnectUMI::wFileFormatHex.
        :type offset: int
        :param offset: offset to add to the address in the file
        :type fileName: string
        :param fileName: path to the file to program

        Python example: _sample_link{storage_dev_ctrl,test_storage_write}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_read_write}

        |

        *Overload 3:*

        Writes data to device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache. For eMMC devices IConnectUMI::wProgDevice is always used.
        :type address: int
        :param address: address to write to
        :type size: int
        :param size: size of the data to write
        :type data: std::vector< BYTE,std::allocator< BYTE > >
        :param data: vector of data to be written

        Python example: _sample_link{storage_dev_ctrl,test_storage_write}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_read_write}
        """
        return _connect.CStorageDeviceController_write(self, *args)

    def erase(self, *args):
        r"""
        *Overload 1:*

        Erases complete device.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.

        Python example: _sample_link{storage_dev_ctrl,test_storage_erase}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_erase}

        |

        *Overload 2:*

        Erases the specified region (sector, partition,...).
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: address to erase from
        :type size: int
        :param size: size of the data to be erased

        Python example: _sample_link{storage_dev_ctrl,test_storage_erase}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_erase}
        """
        return _connect.CStorageDeviceController_erase(self, *args)

    def flush(self):
        r"""
        Programs the device from the intermediate cache.
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_flush}
        """
        return _connect.CStorageDeviceController_flush(self)

    def verify(self, *args):
        r"""
        *Overload 1:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_verify}

        |

        *Overload 2:*

        Compares device contents to cache. Throws `CUMIException` in case of verification
        error (contents do not match), throws `IOException` in case of any
        other _isystem.connect_ error.

        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_verify}
        """
        return _connect.CStorageDeviceController_verify(self, *args)

    def isDeviceEmpty(self, *args):
        r"""
        *Overload 1:*

        Compares device contents to the empty value.
        :rtype: boolean
        :return: true if the device is empty, false otherwise
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_is_device_empty}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_is_device_empty}

        |

        *Overload 2:*

        Compares device contents to the empty value at given address.
        :type address: int
        :param address: address to verify from
        :type size: int
        :param size: size of the data to be verified
        :rtype: boolean
        :return: true if the device is empty, false otherwise
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_is_device_empty}
        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_is_device_empty}
        """
        return _connect.CStorageDeviceController_isDeviceEmpty(self, *args)

    def fill(self):
        return _connect.CStorageDeviceController_fill(self)

    def readState(self, programMode, address, size, stateResult):
        r"""
        Reads the device program state.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address
        :type size: int
        :param size: size of the data to be examined
        :type stateResult: std::vector< BYTE,std::allocator< BYTE > >
        :param stateResult: Program state as vector of bytes, returned as an unpacked byte array (1 MAU per byte).
                   Vector size must be the size of the data to be examined. Value equals to 1 if MAU programmed and 0 if not.
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_read_state}
        """
        return _connect.CStorageDeviceController_readState(self, programMode, address, size, stateResult)

    def readHash(self, *args):
        r"""
        *Overload 1:*

        Reads target device data MURMUR2 hash.
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 BYTES.
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_read_hash}

        |

        *Overload 2:*

        Reads target device data MURMUR2 hash.
        :type programMode: int
        :param programMode: should be either IConnectUMI::wProgDevice or
                               IConnectUMI::wProgCache.
        :type address: int
        :param address: starting address for hash calculation
        :type size: int
        :param size: size of the data to be hashed
        :type hashResult: std::vector< BYTE,std::allocator< BYTE > >
        :param hashResult: Hash result as vector of bytes. LSB is returned first.
                   Vector capacity should be at least 4 bytes, since hash is 4-bytes long.
        :raises: IllegalStateException if operation not supported.

        Python example: _sample_link{storage_dev_ctrl,test_storage_read_hash}
        """
        return _connect.CStorageDeviceController_readHash(self, *args)

    def getLastError(self):
        r"""
        This function returns error description, after call fails.
        If there is no error message available, an empty string is returned.
        :rtype: string
        :return: error description string

        Python example: _sample_link{storage_dev_ctrl,test_storage_get_last_error}
        """
        return _connect.CStorageDeviceController_getLastError(self)

    def getSecurityModule(self):
        r"""
        Returns security storage device module.
        :rtype: :py:class:`CStorageDeviceSecurityModule`
        :return: security storage device module if available, otherwise return nullptr
        """
        return _connect.CStorageDeviceController_getSecurityModule(self)

    def getPartitionConfigurationModule(self):
        r"""
        Returns configuration module for partition based devices.
        :rtype: :py:class:`CPartitionConfigurationModule`
        :return: configuration module for partition based devices if available, otherwise return nullptr

        Python example: _sample_link{storage_dev_ctrl,test_storage_get_partition_info}
        """
        return _connect.CStorageDeviceController_getPartitionConfigurationModule(self)

    def getPerformanceModule(self):
        return _connect.CStorageDeviceController_getPerformanceModule(self)

# Register CStorageDeviceController in _connect:
_connect.CStorageDeviceController_swigregister(CStorageDeviceController)
EStorageDevice_EmbeddedFlashDevice = _connect.EStorageDevice_EmbeddedFlashDevice
r"""internal storage device type"""
EStorageDevice_EMMCDevice = _connect.EStorageDevice_EMMCDevice
r"""emmc storage device type"""
EStorageDevice_SPIDevice = _connect.EStorageDevice_SPIDevice
r"""spi storage device type"""
EStorageDevice_HyperFlash = _connect.EStorageDevice_HyperFlash
r"""hyper flash storage device"""
class CStorageDeviceFactory(object):
    r"""This class presents a storage devices factory methods."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def makeDevice(*args):
        r"""
        *Overload 1:*

        Creates pointer to specified device type by device name.
        When using partition based devices (emmc), makeDevice loads monitor to the device.
        Don't call any non-storage SDK function before unloading monitor with terminateDevice.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceName: string
        :param deviceName: device name
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type

        |

        *Overload 2:*

        Creates pointer to specified device type by device and partition name.
        When using partition based devices (emmc), makeDevice loads monitor to the device.
        Don't call any non-storage SDK function before unloading monitor with terminateDevice.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceName: string
        :param deviceName: device name
        :type partitionName: string
        :param partitionName: partition name
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type

        |

        *Overload 3:*

        Creates pointer to specified device type by device index.
        When using partition based devices (emmc), makeDevice loads monitor to the device.
        Don't call any non-storage SDK function before unloading monitor with terminateDevice.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceIndex: int
        :param deviceIndex: device index
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type

        |

        *Overload 4:*

        Creates pointer to specified device type by device index and partition name.
        When using partition based devices (emmc), makeDevice loads monitor to the device.
        Don't call any non-storage SDK function before unloading monitor with terminateDevice.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceIndex: int
        :param deviceIndex: device index
        :type partitionName: string
        :param partitionName: partition name
        :rtype: :py:class:`CStorageDeviceController`
        :return: pointer to specified device type
        """
        return _connect.CStorageDeviceFactory_makeDevice(*args)

    @staticmethod
    def terminateDevice(*args):
        r"""
        *Overload 1:*

        Terminates device connection by name. Valid only for partition based devices (emmc).
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceName: string
        :param deviceName: device name

        Python example: _sample_link{storage_dev_ctrl,test_storage_init_terminate}

        |

        *Overload 2:*

        Terminates device connection by index. Valid only for partition based devices (emmc).
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type type: int
        :param type: storage device type
        :type deviceIndex: int
        :param deviceIndex: device index
        """
        return _connect.CStorageDeviceFactory_terminateDevice(*args)

    @staticmethod
    def getDeviceNames(connectionMgr, deviceNames):
        r"""
        Collects all enabled storage device names.
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type deviceNames: std::vector< std::string,std::allocator< std::string > >
        :param deviceNames: vector of all available storage device names

        Python example: _sample_link{storage_dev_ctrl,test_storage_get_devices_names}
        Python example: _sample_link{storage_dev_ctrl,test_storage_get_devices_number}
        """
        return _connect.CStorageDeviceFactory_getDeviceNames(connectionMgr, deviceNames)

    @staticmethod
    def getDeviceInfo(connectionMgr, deviceName, elements):
        r"""
        Provides device info - internal device structure. Valid only for partition based devices (emmc).
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: connection manager
        :type deviceName: string
        :param deviceName: storage device name
        :type elements: :py:class:`StrStrMap`
        :param elements: device parameters as mapping
        :raises: IOException if no device by deviceName exists.

        Python example: _sample_link{storage_dev_ctrl,test_storage_get_device_info}
        """
        return _connect.CStorageDeviceFactory_getDeviceInfo(connectionMgr, deviceName, elements)

    def __init__(self):
        _connect.CStorageDeviceFactory_swiginit(self, _connect.new_CStorageDeviceFactory())
    __swig_destroy__ = _connect.delete_CStorageDeviceFactory

# Register CStorageDeviceFactory in _connect:
_connect.CStorageDeviceFactory_swigregister(CStorageDeviceFactory)
CStorageDeviceFactory.DEVICES_OPT_URL = _connect.cvar.CStorageDeviceFactory_DEVICES_OPT_URL

class CStorageDeviceSecurityModule(object):
    r"""This class presents a common API for storage devices security module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CStorageDeviceSecurityModule

    def secure(self, *args):
        r"""
        *Overload 1:*

        Secures the device.
        Python example: _sample_link{storage_dev_security_module,test_secure_unsecure_check}

        |

        *Overload 2:*

        Secures the sector.
        :type address: int
        :param address: address of the sector to be secured
        :type size: int
        :param size: size of the sector to be secured
            Python example: _sample_link{storage_dev_security_module,test_secure_unsecure_check}
        """
        return _connect.CStorageDeviceSecurityModule_secure(self, *args)

    def unsecure(self, *args):
        r"""
        *Overload 1:*

        Unsecures the device.
        Python example: _sample_link{storage_dev_security_module,test_secure_unsecure_check}

        |

        *Overload 2:*

        Unsecures the sector.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
            Python example: _sample_link{storage_dev_security_module,test_secure_unsecure_check}
        """
        return _connect.CStorageDeviceSecurityModule_unsecure(self, *args)

    def secureCheck(self, *args):
        r"""
        *Overload 1:*

        Checks if security is set on device.
        Python example: _sample_link{storage_dev_security_module,test_secure_unsecure_check}

        |

        *Overload 2:*

        Checks if security is set on sector.
        :type address: int
        :param address: address of the sector to be unsecured
        :type size: int
        :param size: size of the sector to be unsecured
            Python example: _sample_link{storage_dev_security_module,test_secure_unsecure_check}
        """
        return _connect.CStorageDeviceSecurityModule_secureCheck(self, *args)

# Register CStorageDeviceSecurityModule in _connect:
_connect.CStorageDeviceSecurityModule_swigregister(CStorageDeviceSecurityModule)
class CBasicFlashSecurityModule(CStorageDeviceSecurityModule):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, umiCtrl, deviceIndex):
        _connect.CBasicFlashSecurityModule_swiginit(self, _connect.new_CBasicFlashSecurityModule(umiCtrl, deviceIndex))
    __swig_destroy__ = _connect.delete_CBasicFlashSecurityModule

    def secure(self, *args):
        return _connect.CBasicFlashSecurityModule_secure(self, *args)

    def unsecure(self, *args):
        return _connect.CBasicFlashSecurityModule_unsecure(self, *args)

    def secureCheck(self, *args):
        return _connect.CBasicFlashSecurityModule_secureCheck(self, *args)

# Register CBasicFlashSecurityModule in _connect:
_connect.CBasicFlashSecurityModule_swigregister(CBasicFlashSecurityModule)
class CBasicFlashStorageDevice(CStorageDeviceController):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CBasicFlashStorageDevice_swiginit(self, _connect.new_CBasicFlashStorageDevice(*args))
    __swig_destroy__ = _connect.delete_CBasicFlashStorageDevice

    def read(self, address, size, data):
        return _connect.CBasicFlashStorageDevice_read(self, address, size, data)

    def write(self, *args):
        return _connect.CBasicFlashStorageDevice_write(self, *args)

    def erase(self, *args):
        return _connect.CBasicFlashStorageDevice_erase(self, *args)

    def flush(self):
        return _connect.CBasicFlashStorageDevice_flush(self)

    def verify(self, *args):
        return _connect.CBasicFlashStorageDevice_verify(self, *args)

    def isDeviceEmpty(self, *args):
        return _connect.CBasicFlashStorageDevice_isDeviceEmpty(self, *args)

    def fill(self):
        return _connect.CBasicFlashStorageDevice_fill(self)

    def readState(self, programMode, address, size, stateResult):
        return _connect.CBasicFlashStorageDevice_readState(self, programMode, address, size, stateResult)

    def readHash(self, *args):
        return _connect.CBasicFlashStorageDevice_readHash(self, *args)

    def getLastError(self):
        return _connect.CBasicFlashStorageDevice_getLastError(self)

    def getSecurityModule(self):
        return _connect.CBasicFlashStorageDevice_getSecurityModule(self)

    def getPartitionConfigurationModule(self):
        return _connect.CBasicFlashStorageDevice_getPartitionConfigurationModule(self)

    def getPerformanceModule(self):
        return _connect.CBasicFlashStorageDevice_getPerformanceModule(self)

# Register CBasicFlashStorageDevice in _connect:
_connect.CBasicFlashStorageDevice_swigregister(CBasicFlashStorageDevice)
class CEMMCStorageDevice(CStorageDeviceController):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CEMMCStorageDevice_swiginit(self, _connect.new_CEMMCStorageDevice(*args))
    __swig_destroy__ = _connect.delete_CEMMCStorageDevice

    def read(self, address, size, data):
        return _connect.CEMMCStorageDevice_read(self, address, size, data)

    def write(self, *args):
        return _connect.CEMMCStorageDevice_write(self, *args)

    def erase(self, *args):
        return _connect.CEMMCStorageDevice_erase(self, *args)

    def flush(self):
        return _connect.CEMMCStorageDevice_flush(self)

    def verify(self, *args):
        return _connect.CEMMCStorageDevice_verify(self, *args)

    def isDeviceEmpty(self, *args):
        return _connect.CEMMCStorageDevice_isDeviceEmpty(self, *args)

    def fill(self):
        return _connect.CEMMCStorageDevice_fill(self)

    def readState(self, programMode, address, size, stateResult):
        return _connect.CEMMCStorageDevice_readState(self, programMode, address, size, stateResult)

    def readHash(self, *args):
        return _connect.CEMMCStorageDevice_readHash(self, *args)

    def getLastError(self):
        return _connect.CEMMCStorageDevice_getLastError(self)

    @staticmethod
    def terminate(*args):
        return _connect.CEMMCStorageDevice_terminate(*args)

    def getSecurityModule(self):
        return _connect.CEMMCStorageDevice_getSecurityModule(self)

    def getPartitionConfigurationModule(self):
        return _connect.CEMMCStorageDevice_getPartitionConfigurationModule(self)

    def getPerformanceModule(self):
        return _connect.CEMMCStorageDevice_getPerformanceModule(self)

# Register CEMMCStorageDevice in _connect:
_connect.CEMMCStorageDevice_swigregister(CEMMCStorageDevice)
class CPartitionInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isBootable(self):
        r"""Returns ``true`` if partition is bootable, ``false`` otherwise."""
        return _connect.CPartitionInfo_isBootable(self)

    def canModifyBoot(self):
        r"""Returns ``true`` if partition boot status can be changed, ``false`` otherwise."""
        return _connect.CPartitionInfo_canModifyBoot(self)

    def canModifyName(self):
        r"""Returns ``true`` if partition name can be changed, ``false`` otherwise."""
        return _connect.CPartitionInfo_canModifyName(self)

    def canModifyOffset(self):
        r"""Returns ``true`` if partition offset can be changed, ``false`` otherwise."""
        return _connect.CPartitionInfo_canModifyOffset(self)

    def canModifySize(self):
        r"""Returns ``true`` if partition size can be changed, ``false`` otherwise."""
        return _connect.CPartitionInfo_canModifySize(self)

    def canRemove(self):
        r"""Returns ``true`` if partition can be removed, ``false`` otherwise."""
        return _connect.CPartitionInfo_canRemove(self)

    def getEnhancedOffset(self):
        r"""Returns partition enhanced offset."""
        return _connect.CPartitionInfo_getEnhancedOffset(self)

    def getEnhancedSize(self):
        r"""Returns partition enhanced size."""
        return _connect.CPartitionInfo_getEnhancedSize(self)

    def getOffset(self):
        r"""Returns partition offset."""
        return _connect.CPartitionInfo_getOffset(self)

    def getSize(self):
        r"""Returns partition size."""
        return _connect.CPartitionInfo_getSize(self)

    def getExtended(self):
        r"""Returns partition extended status."""
        return _connect.CPartitionInfo_getExtended(self)

    def getType(self):
        r"""Returns partition type."""
        return _connect.CPartitionInfo_getType(self)

    def getName(self):
        r"""Returns partition name."""
        return _connect.CPartitionInfo_getName(self)
    __swig_destroy__ = _connect.delete_CPartitionInfo

# Register CPartitionInfo in _connect:
_connect.CPartitionInfo_swigregister(CPartitionInfo)
class CPartitionConfigurationModule(object):
    r"""This class presents a common API to configure parameters for partition based storage devices."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CPartitionConfigurationModule

    def modify(self, offset, sizeInBytes, isBoot):
        r"""
        Modifies parameters of the selected partition.
        :type offset: int
        :param offset: to add to the address of the selected partition
        :type sizeInBytes: int
        :param sizeInBytes: number of bytes reserved for selected partition
        :type isBoot: boolean
        :param isBoot: bootable partition flag

        Python example: _sample_link{storage_dev_ctrl,test_storage_emmc_modify}
        """
        return _connect.CPartitionConfigurationModule_modify(self, offset, sizeInBytes, isBoot)

    def getPartitionInfo(self):
        r"""
        Returns device's partition information.
        :rtype: :py:class:`CPartitionInfo`
        :return: CPartitionInfoSPtr

        Python example: _sample_link{storage_dev_ctrl,test_storage_get_partition_info}
        """
        return _connect.CPartitionConfigurationModule_getPartitionInfo(self)

# Register CPartitionConfigurationModule in _connect:
_connect.CPartitionConfigurationModule_swigregister(CPartitionConfigurationModule)
class CEMMCPartitionConfigurationModule(CPartitionConfigurationModule):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, emmcCtrl, partitionName):
        _connect.CEMMCPartitionConfigurationModule_swiginit(self, _connect.new_CEMMCPartitionConfigurationModule(emmcCtrl, partitionName))
    __swig_destroy__ = _connect.delete_CEMMCPartitionConfigurationModule

    def modify(self, offset, sizeInBytes, isBoot):
        return _connect.CEMMCPartitionConfigurationModule_modify(self, offset, sizeInBytes, isBoot)

    def getPartitionInfo(self):
        return _connect.CEMMCPartitionConfigurationModule_getPartitionInfo(self)

# Register CEMMCPartitionConfigurationModule in _connect:
_connect.CEMMCPartitionConfigurationModule_swigregister(CEMMCPartitionConfigurationModule)
class SSingleOperationDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_downloadTimeInUs = property(_connect.SSingleOperationDiagnostics_m_downloadTimeInUs_get, _connect.SSingleOperationDiagnostics_m_downloadTimeInUs_set)
    m_downloadSize = property(_connect.SSingleOperationDiagnostics_m_downloadSize_get, _connect.SSingleOperationDiagnostics_m_downloadSize_set)
    m_executionTimeInUs = property(_connect.SSingleOperationDiagnostics_m_executionTimeInUs_get, _connect.SSingleOperationDiagnostics_m_executionTimeInUs_set)
    m_affectedSize = property(_connect.SSingleOperationDiagnostics_m_affectedSize_get, _connect.SSingleOperationDiagnostics_m_affectedSize_set)

    def __init__(self):
        _connect.SSingleOperationDiagnostics_swiginit(self, _connect.new_SSingleOperationDiagnostics())
    __swig_destroy__ = _connect.delete_SSingleOperationDiagnostics

# Register SSingleOperationDiagnostics in _connect:
_connect.SSingleOperationDiagnostics_swigregister(SSingleOperationDiagnostics)
class SAtomicOperationsDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_operationName = property(_connect.SAtomicOperationsDiagnostics_m_operationName_get, _connect.SAtomicOperationsDiagnostics_m_operationName_set)
    m_operationAddress = property(_connect.SAtomicOperationsDiagnostics_m_operationAddress_get, _connect.SAtomicOperationsDiagnostics_m_operationAddress_set)
    m_operationDataSize = property(_connect.SAtomicOperationsDiagnostics_m_operationDataSize_get, _connect.SAtomicOperationsDiagnostics_m_operationDataSize_set)
    m_operationTimeInUs = property(_connect.SAtomicOperationsDiagnostics_m_operationTimeInUs_get, _connect.SAtomicOperationsDiagnostics_m_operationTimeInUs_set)
    m_sumSingleDownloadTimeInUs = property(_connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadTimeInUs_get, _connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadTimeInUs_set)
    m_sumSingleDownloadSize = property(_connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadSize_get, _connect.SAtomicOperationsDiagnostics_m_sumSingleDownloadSize_set)
    m_sumSingleExecutionTimeInUs = property(_connect.SAtomicOperationsDiagnostics_m_sumSingleExecutionTimeInUs_get, _connect.SAtomicOperationsDiagnostics_m_sumSingleExecutionTimeInUs_set)
    m_singleOperations = property(_connect.SAtomicOperationsDiagnostics_m_singleOperations_get, _connect.SAtomicOperationsDiagnostics_m_singleOperations_set)

    def __init__(self):
        _connect.SAtomicOperationsDiagnostics_swiginit(self, _connect.new_SAtomicOperationsDiagnostics())
    __swig_destroy__ = _connect.delete_SAtomicOperationsDiagnostics

# Register SAtomicOperationsDiagnostics in _connect:
_connect.SAtomicOperationsDiagnostics_swigregister(SAtomicOperationsDiagnostics)
class SAtomicSumOperationsDiagnostics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_operationName = property(_connect.SAtomicSumOperationsDiagnostics_m_operationName_get, _connect.SAtomicSumOperationsDiagnostics_m_operationName_set)
    m_sumOperationTimeInUs = property(_connect.SAtomicSumOperationsDiagnostics_m_sumOperationTimeInUs_get, _connect.SAtomicSumOperationsDiagnostics_m_sumOperationTimeInUs_set)
    m_sumExecutionTimeInUs = property(_connect.SAtomicSumOperationsDiagnostics_m_sumExecutionTimeInUs_get, _connect.SAtomicSumOperationsDiagnostics_m_sumExecutionTimeInUs_set)

    def __init__(self):
        _connect.SAtomicSumOperationsDiagnostics_swiginit(self, _connect.new_SAtomicSumOperationsDiagnostics())
    __swig_destroy__ = _connect.delete_SAtomicSumOperationsDiagnostics

# Register SAtomicSumOperationsDiagnostics in _connect:
_connect.SAtomicSumOperationsDiagnostics_swigregister(SAtomicSumOperationsDiagnostics)
class CStorageDeviceDiagnostics(object):
    r"""
    This is a storage device operations diagnostic data container.
    For example to measure load/unload time, write time,...
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, results):
        _connect.CStorageDeviceDiagnostics_swiginit(self, _connect.new_CStorageDeviceDiagnostics(results))
    __swig_destroy__ = _connect.delete_CStorageDeviceDiagnostics

    def getMonitorLoadTimeInUs(self):
        r"""
        Returns monitor load time.

        :rtype: int
        :return: load time in us
        """
        return _connect.CStorageDeviceDiagnostics_getMonitorLoadTimeInUs(self)

    def getMonitorUnloadTimeInUs(self):
        r"""
        Returns monitor unload time.

        :rtype: int
        :return: unload time in us
        """
        return _connect.CStorageDeviceDiagnostics_getMonitorUnloadTimeInUs(self)

    def getTotalOperationTimeInUs(self):
        r"""
        Returns total time for the executed operation.

        :rtype: int
        :return: operation time in us
        """
        return _connect.CStorageDeviceDiagnostics_getTotalOperationTimeInUs(self)

    def getOperations(self, rvstrOperations):
        r"""
        Populates vector of executed operations.

        :type rvstrOperations: std::vector< std::string,std::allocator< std::string > >
        :param rvstrOperations: vector of executed operations
        """
        return _connect.CStorageDeviceDiagnostics_getOperations(self, rvstrOperations)

# Register CStorageDeviceDiagnostics in _connect:
_connect.CStorageDeviceDiagnostics_swigregister(CStorageDeviceDiagnostics)
class CStorageDevicePerformanceModule(object):
    r"""
    This class presents a common API for storage devices performance module.

    Python example: _sample_link{storage_dev_security_module,test_set_test_mode}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, ideCtrl):
        _connect.CStorageDevicePerformanceModule_swiginit(self, _connect.new_CStorageDevicePerformanceModule(ideCtrl))
    __swig_destroy__ = _connect.delete_CStorageDevicePerformanceModule

    def getDiagnostic(self):
        r"""
        Provides time performances for executed UMI operations.
        :rtype: :py:class:`CStorageDeviceDiagnostics`
        :return: CStorageDeviceDiagnostics object of diagnostic results
            Python example: _sample_link{storage_dev_security_module,test_get_diagnostic}
        """
        return _connect.CStorageDevicePerformanceModule_getDiagnostic(self)

    def setBufferSize(self, size):
        r"""
        Set internal buffer size for data received from winIDEA.
        :type size: int
        :param size: buffer size in bytes; 16KB by default
            Python example: _sample_link{storage_dev_security_module,test_set_buffer_size}
        """
        return _connect.CStorageDevicePerformanceModule_setBufferSize(self, size)

    def clearDiagnostic(self, status):
        r"""
        Clears diagnostic for each UMI operation execution. Otherwise diagnostic is accumulated.
        :type status: boolean
        :param status: if true diagnostic is cleared for each UMI operation; true by default
            Python example: _sample_link{storage_dev_security_module,test_clear_diagnostic}
        """
        return _connect.CStorageDevicePerformanceModule_clearDiagnostic(self, status)

    def setTestMode(self, status):
        r"""
        Test mode modifies default monitor behavior as: disable double buffering, disable multiple
        sector erase before download, executes init, deinit, erase and program operation immediately,
        disables on the fly verify
        :type status: boolean
        :param status: if true test mode is enabled; false by default
            Python example: _sample_link{storage_dev_security_module,test_clear_diagnostic}
        """
        return _connect.CStorageDevicePerformanceModule_setTestMode(self, status)

# Register CStorageDevicePerformanceModule in _connect:
_connect.CStorageDevicePerformanceModule_swigregister(CStorageDevicePerformanceModule)
E_FALSE = _connect.E_FALSE
E_TRUE = _connect.E_TRUE
E_DEFAULT = _connect.E_DEFAULT

def putStrStrMap(container, key, value):
    r"""
    Deprecated: SWIG generates wrappers for C++ std containers, so new
    items can be added with Python syntax, for example: `smap['x'] = 'y'`.

    Utility method for adding (key, value) pairs to StrStrMap. Intended to be
    used from Python and Java code.
    """
    return _connect.putStrStrMap(container, key, value)

def getModuleVersion():
    r"""
    This function returns version of current isystem.connect module in
    format: ``{``<major>.<minor>.<build>.<sub_build>},
    for example '9.12.184.0'. Use this function if you want to print version only,
    otherwise usage of getSdkVersion() is preferred.
    See also: getSDKVersion()
    """
    return _connect.getModuleVersion()

def requires_SDK(*args):
    r"""
    Checks if current version is older than specified in parameters and throws
    exception if that is the case.

    :type nMajor: uint8_t
    :param nMajor:    major version number
    :type nMinor: uint8_t
    :param nMinor:    minor version number
    :type nBuild: int
    :param nBuild:    build number
    :type nSubBuild: int, optional
    :param nSubBuild: sub-build number, optional
    :type nSccBuild: int, optional
    :param nSccBuild: source control revision number, optional
    """
    return _connect.requires_SDK(*args)

def readChar():
    r"""
    Reads a single character from stdin, if available. If
    the character is not available, 0 is returned.
    """
    return _connect.readChar()

def getUID():
    r"""
    Returns string unique for this process. This function is not reentrant.
    The string may contain numbers and letters.
    """
    return _connect.getUID()

def use_winepath_conversion(flag):
    r"""
    experimental feature, use with caution
    If set to true, implicitly convert host paths to the required format.

     >>> ic.use_winepath_conversion(False)

     >>> connection_config.workspace('Z:/home/user/path/to/your/workspace.xjrf')


     >>> ic.use_winepath_conversion(True)

     >>> connection_config.workspace('/home/user/path/to/your/workspace.xjrf')
    """
    return _connect.use_winepath_conversion(flag)

def is_use_winepath_conversion():
    r"""
    experimental feature, use with caution

    returns true, if paths should be implicitly converted to host paths
    """
    return _connect.is_use_winepath_conversion()

def parse_qualified_name(svFQN):
    r"""
    This function parses fully qualified name of a symbol and returns its
    components in a struct. Symbols in an application can have many
    qualifiers to be uniquely identifiable, but not all of them are
    always necessary. Additionally this function supports parsing of
    modifiers, which are used only for presentation of symbol value.

    Symbol name is composed of:

    - qualified name:  `<file name>#<function>##<instance>###<namespace><naked><signature>`
      - file name - source file where the symbol is defined
      - function - function where the symbol is defined, for example static variables in C
      - instance
      - namespace - C++ namespace
      - naked - only identifier name, for example function name or variable name
      - signature - function parameters and return value
    - extended qualifiers
      - partition
      - process
    - modifier - modifier is used for presentation only, for example in watch window.

    The following terms are also used:
    - fully qualified name `<qualified name>,,<partition>,,,<process>`
    - presentation name: `<fully qualified name>,<modifier>`

    See also: create_qualified_name
    """
    return _connect.parse_qualified_name(svFQN)

def create_qualified_name(*args):
    r"""
    This function creates a string with qualified symbol name from
    components given in the input struct.

    See also: parse_qualified_name
    """
    return _connect.create_qualified_name(*args)
class CUtil(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CUtil_swiginit(self, _connect.new_CUtil())
    __swig_destroy__ = _connect.delete_CUtil

# Register CUtil in _connect:
_connect.CUtil_swigregister(CUtil)
CUtil.g_qualifiedFuncNamePattern = _connect.cvar.CUtil_g_qualifiedFuncNamePattern
CUtil.g_qualifiedVarNamePattern = _connect.cvar.CUtil_g_qualifiedVarNamePattern
CUtil.MODULE_GRP_IDX = _connect.cvar.CUtil_MODULE_GRP_IDX
CUtil.DEREF_ASSOC_GRP_IDX = _connect.cvar.CUtil_DEREF_ASSOC_GRP_IDX
CUtil.SYM_NAME_GRP_IDX = _connect.cvar.CUtil_SYM_NAME_GRP_IDX
CUtil.SIGNATURE_GRP_IDX = _connect.cvar.CUtil_SIGNATURE_GRP_IDX
CUtil.DOWNLOAD_FILE_GRP_IDX = _connect.cvar.CUtil_DOWNLOAD_FILE_GRP_IDX

class PathTransformer(object):
    r"""
    This class converts paths between native Linux paths and paths in winIDEA domain,
    for example WINE paths. It provides interface of a singleton pattern, so you may initialize
    it only once. However, ctors are public to enable creating custom
    instances for complex use cases, for example controlling two winIDEAs in different
    environments.

    Typical usage:

        auto pt = isys::PathTransformer::get_instance();

    This will provide you with an instance properly initialized in the following cases:

    - client app is running on Windows, winIDEA is running on Windows
    - client app is running on Linux, winIDEA is running in WINE on Linux

    For other use cases, you have to initialize the instance:

        pt->init(client_env, winidea_env);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eWinToUnix = _connect.PathTransformer_eWinToUnix
    eUnixToWin = _connect.PathTransformer_eUnixToWin

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates object with default settings. See class description for
        more details.

        |

        *Overload 2:*

        Creates object with the given parameters.

        :type eSourceOS: isys::SOSVersion
        :param eSourceOS: environment where client app (the app using winIDEA SDK) is running
        :type eWinIDEAOs: isys::SOSVersion
        :param eWinIDEAOs: environment where winIDEA is running
        """
        _connect.PathTransformer_swiginit(self, _connect.new_PathTransformer(*args))

    def init(self, eSourceOS, eWinIDEAOs):
        r"""
        Initializes instance with the given parameters. This overrides settings given in ctor.

        :type eSourceOS: isys::SOSVersion
        :param eSourceOS: environment where client app (the app using winIDEA SDK) is running
        :type eWinIDEAOs: isys::SOSVersion
        :param eWinIDEAOs: environment where winIDEA is running
        """
        return _connect.PathTransformer_init(self, eSourceOS, eWinIDEAOs)

    @staticmethod
    def get_instance():
        r"""
        Returns singleton instance. When this method is called for the first time,
        the instance is created with default parameters. See class description for
        more details on default parameters.

        :rtype: :py:class:`PathTransformer`
        :return: shared pointer to the singleton instance
        """
        return _connect.PathTransformer_get_instance()

    def winepath(self, input, direction):
        r"""
        This function implements functionality of the `winepath` utility.

        :type input: string
        :param input:: string path representation to be converted
        :type direction: int
        :param direction:: conversion direction wine->unix or unix->wine

        :rtype: string
        :return: converted path string
        """
        return _connect.PathTransformer_winepath(self, input, direction)

    def to_winidea_path(self, host_path, is_relative_to_winidea=True):
        r"""
        Converts host path to winIDEA path. It checks values of
        host and winIDEA environment set in ctor and then calls appropriate path
        conversion functions when environments are different.

        If you call this method with path in winIDEA environment,
        the result will be invalid path.

        :type host_path: string
        :param host_path: path in client environment (app using winIDEA SDK)
        :type is_relative_to_winidea: boolean, optional
        :param is_relative_to_winidea: if false, relative to cwd is assumed,
                                           otherwise, relative paths are not processed.
        :rtype: string
        :return: path in winIDEA environment, for example WINE.
        """
        return _connect.PathTransformer_to_winidea_path(self, host_path, is_relative_to_winidea)

    def to_host_path(self, winidea_path, is_relative_to_winidea=True):
        r"""
        Reverse as PathTransformer::to_winidea_path().

        :type winidea_path: string
        :param winidea_path: path in winIDEA environment (for example WINE path)
        :type is_relative_to_winidea: boolean, optional
        :param is_relative_to_winidea: if true, relative path to winIDEA workspace is assumed,
                   the path is left intact, only path separators are replaced if necessary
        :rtype: string
        :return: path in client environment (app using winIDEA SDK).
        """
        return _connect.PathTransformer_to_host_path(self, winidea_path, is_relative_to_winidea)
    __swig_destroy__ = _connect.delete_PathTransformer

# Register PathTransformer in _connect:
_connect.PathTransformer_swigregister(PathTransformer)
class CTestObject(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EYAMLScalar = _connect.CTestObject_EYAMLScalar
    EYAMLBool = _connect.CTestObject_EYAMLBool
    EYAMLEnum = _connect.CTestObject_EYAMLEnum
    EYAMLSeqence = _connect.CTestObject_EYAMLSeqence
    EYAMLMap = _connect.CTestObject_EYAMLMap
    ETestBase = _connect.CTestObject_ETestBase
    ETestBaseList = _connect.CTestObject_ETestBaseList
    __swig_destroy__ = _connect.delete_CTestObject

    def setConst(self, isConst):
        r"""
        Sets object state to const. Only getters may called, setters throw an
        exception.
        """
        return _connect.CTestObject_setConst(self, isConst)

    def assign(self, ptr):
        return _connect.CTestObject_assign(self, ptr)

    def getTestObjType(self):
        r"""
        If the object is one of CYAMLObject descendants, this method returns
        a reference to it. Otherwise an exception is thrown.

        If the object is one of CTestBase descendants, this method returns
        a reference to it. Otherwise an exception is thrown.
                   Returns object type.
        """
        return _connect.CTestObject_getTestObjType(self)

    def copy(self):
        r"""Returns deep copy of an object."""
        return _connect.CTestObject_copy(self)

    def isEmpty(self):
        r"""
        Returns contents as string in YAML flow style.
        Sequences and Maps are returned without enclosing [] or {}.
                  This value is given to YAML parser which then sets the data.  Returns true if object contains no data.
        """
        return _connect.CTestObject_isEmpty(self)

    def toString(self):
        r"""Returns string representation of object, usually in YAML format."""
        return _connect.CTestObject_toString(self)

# Register CTestObject in _connect:
_connect.CTestObject_swigregister(CTestObject)
class CTestBase(CTestObject):
    r"""
    This is a base class for all data objects in itest. It may contain
    other objects of derived types, lists of derived types, scalars,
    mappings and lists.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NEW_LINE_COMMENT = _connect.CTestBase_NEW_LINE_COMMENT
    END_OF_LINE_COMMENT = _connect.CTestBase_END_OF_LINE_COMMENT
    KEY = _connect.CTestBase_KEY
    VALUE = _connect.CTestBase_VALUE
    LIST_ITEM = _connect.CTestBase_LIST_ITEM
    EMayBeEmpty = _connect.CTestBase_EMayBeEmpty
    EMandatory = _connect.CTestBase_EMandatory
    __swig_destroy__ = _connect.delete_CTestBase

    def getClassName(self):
        return _connect.CTestBase_getClassName(self)

    def createInstance(self, parent):
        return _connect.CTestBase_createInstance(self, parent)

    def setParent(self, parent):
        return _connect.CTestBase_setParent(self, parent)

    def getParent(self):
        return _connect.CTestBase_getParent(self)

    def copy(self):
        return _connect.CTestBase_copy(self)

    @staticmethod
    def cast(obj):
        return _connect.CTestBase_cast(obj)

    def assign(self, base):
        return _connect.CTestBase_assign(self, base)

    def containsSection(self, section):
        return _connect.CTestBase_containsSection(self, section)

    def isSectionEmpty(self, sectionId):
        return _connect.CTestBase_isSectionEmpty(self, sectionId)

    def getNonNullEmptySections(self, emptySections):
        return _connect.CTestBase_getNonNullEmptySections(self, emptySections)

    def equalsData(self, other):
        return _connect.CTestBase_equalsData(self, other)

    def getContainerTestNode(self):
        return _connect.CTestBase_getContainerTestNode(self)

    def getHierarchyLevel(self):
        return _connect.CTestBase_getHierarchyLevel(self)

    def isMerged(self):
        return _connect.CTestBase_isMerged(self)

    def isEmpty(self):
        r"""This method returns true, if the object contains no data."""
        return _connect.CTestBase_isEmpty(self)

    def isTestSpecification(self):
        return _connect.CTestBase_isTestSpecification(self)

    def getCachedMergedTestSpec(self, sectionId):
        return _connect.CTestBase_getCachedMergedTestSpec(self, sectionId)

    def isSectionSet(self, section):
        return _connect.CTestBase_isSectionSet(self, section)

    def serialize(self, emitter):
        r"""Sends contents of this class to emitter."""
        return _connect.CTestBase_serialize(self, emitter)

    def validate(self):
        return _connect.CTestBase_validate(self)

    def toString(self):
        r"""Returns object data as YAML string."""
        return _connect.CTestBase_toString(self)

    def setMainMapStyle(self, mappingStyle):
        return _connect.CTestBase_setMainMapStyle(self, mappingStyle)

    def getSectionId(self, sectionName):
        return _connect.CTestBase_getSectionId(self, sectionName)

    def getSectionType(self, section):
        return _connect.CTestBase_getSectionType(self, section)

    def setSectionValue(self, section, objPtr):
        return _connect.CTestBase_setSectionValue(self, section, objPtr)

    def getTestBase(self, section, isConst):
        return _connect.CTestBase_getTestBase(self, section, isConst)

    def getTestBaseList(self, section, isConst):
        return _connect.CTestBase_getTestBaseList(self, section, isConst)

    def createTestBase(self, *args):
        return _connect.CTestBase_createTestBase(self, *args)

    def getTestObjType(self):
        return _connect.CTestBase_getTestObjType(self)

    def getSectionIds(self, sectionIds):
        return _connect.CTestBase_getSectionIds(self, sectionIds)

    def getDeprecatedSectionIds(self, sectionIds):
        return _connect.CTestBase_getDeprecatedSectionIds(self, sectionIds)

    def getTagName(self, section):
        return _connect.CTestBase_getTagName(self, section)

    def getIntValue(self, section):
        return _connect.CTestBase_getIntValue(self, section)

    def getTagValue(self, *args):
        return _connect.CTestBase_getTagValue(self, *args)

    def getTagValueOrDefault(self, section, key):
        return _connect.CTestBase_getTagValueOrDefault(self, section, key)

    def getBoolTagValue(self, section):
        return _connect.CTestBase_getBoolTagValue(self, section)

    def getBoolValueAsBool(self, section):
        return _connect.CTestBase_getBoolValueAsBool(self, section)

    def getEnumTagValue(self, section):
        return _connect.CTestBase_getEnumTagValue(self, section)

    def getSectionValue(self, section, isConst):
        return _connect.CTestBase_getSectionValue(self, section, isConst)

    def containsMapEntry(self, section, key):
        return _connect.CTestBase_containsMapEntry(self, section, key)

    def removeMapEntry(self, section, key):
        return _connect.CTestBase_removeMapEntry(self, section, key)

    def removeValue(self, section):
        return _connect.CTestBase_removeValue(self, section)

    def setTagValue(self, *args):
        return _connect.CTestBase_setTagValue(self, *args)

    def setBoolTagValue(self, section, value):
        return _connect.CTestBase_setBoolTagValue(self, section, value)

    def setEnumTagValue(self, section, enumValue):
        return _connect.CTestBase_setEnumTagValue(self, section, enumValue)

    def setComment(self, *args):
        return _connect.CTestBase_setComment(self, *args)

    def getComment(self, *args):
        return _connect.CTestBase_getComment(self, *args)

    def getCommentForSeqElement(self, section, idx, commentType):
        return _connect.CTestBase_getCommentForSeqElement(self, section, idx, commentType)

    def getDefaultValue(self, sectionId):
        return _connect.CTestBase_getDefaultValue(self, sectionId)

    def getEnumValues(self, sectionId, values):
        return _connect.CTestBase_getEnumValues(self, sectionId, values)

    def enum2Str(self, sectionId, enumValue):
        return _connect.CTestBase_enum2Str(self, sectionId, enumValue)

    def isSerializedAsList(self, isParsing):
        return _connect.CTestBase_isSerializedAsList(self, isParsing)

# Register CTestBase in _connect:
_connect.CTestBase_swigregister(CTestBase)
class CTestBaseList(CTestObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CTestBaseList_swiginit(self, _connect.new_CTestBaseList(*args))
    __swig_destroy__ = _connect.delete_CTestBaseList

    def assign(self, ptr):
        r"""
        Assigns copies of elements from the given list to this object. Original
        contents of this list is cleared.

        :type ptr: :py:class:`CTestObject`
        :param ptr: reference to instance of CTestBaseList
        """
        return _connect.CTestBaseList_assign(self, ptr)

    @staticmethod
    def cast(obj):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestBaseList_cast(obj)

    def getParent(self):
        r"""Returns parent."""
        return _connect.CTestBaseList_getParent(self)

    def setParent(self, parent):
        r"""Sets parent."""
        return _connect.CTestBaseList_setParent(self, parent)

    def moveElements(self, src):
        r"""
        Moves elements from source list to this list. The source list is cleared
        after move. This is much faster than assign, since assign makes deep copy,
        while this method copies only references.
        """
        return _connect.CTestBaseList_moveElements(self, src)

    def copy(self):
        r"""Returns deep copy of an object."""
        return _connect.CTestBaseList_copy(self)

    def equalsData(self, other):
        r"""
        Returns true, if the two objects have equal data, including comments.
        Formatting is not compared. The order of elements in the list is
        important.
        """
        return _connect.CTestBaseList_equalsData(self, other)

    def clearEmptySections(self):
        r"""
        This method releases all sections, which contain no data (only
        empty strings). It can save some memory this way - it exists for
        optimization purposes, not functionality.

        Not implemented yet. Will call method ``clearEmptySections()`` on all elements.
        """
        return _connect.CTestBaseList_clearEmptySections(self)

    def setParentToElements(self, parent):
        r"""Sets the given parent to all elements in the list."""
        return _connect.CTestBaseList_setParentToElements(self, parent)

    def add(self, idx, testBase):
        r"""
        Adds element to the list at the given index.

        :type idx: int
        :param idx: where to insert the element. If out of range,
                       the element is appended to the list.
        """
        return _connect.CTestBaseList_add(self, idx, testBase)

    def get(self, idx):
        r"""
        Returns element at the given index.

        :param index: index of element to return. If negative, elements
                         from the end are returned (for example, -1 returns
                         the last element).
        """
        return _connect.CTestBaseList_get(self, idx)

    def size(self):
        r"""Returns the number of elements in the list."""
        return _connect.CTestBaseList_size(self)

    def find(self, item):
        r"""
        Returns index of item in the child list by comparing pointer equality.

        :rtype: int
        :return: index of item, or -1 if item was not found
        """
        return _connect.CTestBaseList_find(self, item)

    def remove(self, idx):
        r"""
        Removes element at the given index.

        :param index: index of element to remove.
        """
        return _connect.CTestBaseList_remove(self, idx)

    def clear(self):
        r"""Removes all elements from the list."""
        return _connect.CTestBaseList_clear(self)

    def serialize(self, emitter):
        r"""Serializes all members to the given emitter."""
        return _connect.CTestBaseList_serialize(self, emitter)

    def getTestObjType(self):
        r"""Returns object type."""
        return _connect.CTestBaseList_getTestObjType(self)

    def isEmpty(self):
        r"""Returns true if object contains no data."""
        return _connect.CTestBaseList_isEmpty(self)

    def toString(self):
        r"""Returns string representation of object, usually in YAML format."""
        return _connect.CTestBaseList_toString(self)

# Register CTestBaseList in _connect:
_connect.CTestBaseList_swigregister(CTestBaseList)
class CScalarAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CScalarAdapter

    def __init__(self, obj, section, isConst):
        _connect.CScalarAdapter_swiginit(self, _connect.new_CScalarAdapter(obj, section, isConst))

    def getValue(self):
        return _connect.CScalarAdapter_getValue(self)

    def getBoolValue(self):
        return _connect.CScalarAdapter_getBoolValue(self)

    def getComment(self, commentType):
        r"""
        :type commentType: int
        :param commentType: specifies whether it is end of line or new line comment
        """
        return _connect.CScalarAdapter_getComment(self, commentType)

    def setValue(self, value):
        return _connect.CScalarAdapter_setValue(self, value)

    def setComment(self, commentType, comment):
        return _connect.CScalarAdapter_setComment(self, commentType, comment)

    def toString(self):
        return _connect.CScalarAdapter_toString(self)

# Register CScalarAdapter in _connect:
_connect.CScalarAdapter_swigregister(CScalarAdapter)
class CSequenceAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CSequenceAdapter

    def __init__(self, *args):
        _connect.CSequenceAdapter_swiginit(self, _connect.new_CSequenceAdapter(*args))

    def assign(self, src):
        return _connect.CSequenceAdapter_assign(self, src)

    def equalsData(self, other):
        return _connect.CSequenceAdapter_equalsData(self, other)

    def size(self):
        return _connect.CSequenceAdapter_size(self)

    def getValue(self, idx):
        return _connect.CSequenceAdapter_getValue(self, idx)

    def getComment(self, commentType, idx):
        return _connect.CSequenceAdapter_getComment(self, commentType, idx)

    def getStrVector(self, strVector):
        return _connect.CSequenceAdapter_getStrVector(self, strVector)

    def getMapAdapter(self, idx):
        return _connect.CSequenceAdapter_getMapAdapter(self, idx)

    def getSeqAdapter(self, idx):
        return _connect.CSequenceAdapter_getSeqAdapter(self, idx)

    def resize(self, newSize):
        return _connect.CSequenceAdapter_resize(self, newSize)

    def add(self, *args):
        r"""
        *Overload 1:*
        Inserts value at idx or appends if idx < 0.

        |

        *Overload 2:*
        Inserts value at idx or appends if idx < 0.
        """
        return _connect.CSequenceAdapter_add(self, *args)

    def setValue(self, *args):
        return _connect.CSequenceAdapter_setValue(self, *args)

    def setComment(self, idx, nlComment, eolComment):
        return _connect.CSequenceAdapter_setComment(self, idx, nlComment, eolComment)

    def remove(self, idx):
        return _connect.CSequenceAdapter_remove(self, idx)

    def toString(self):
        return _connect.CSequenceAdapter_toString(self)

# Register CSequenceAdapter in _connect:
_connect.CSequenceAdapter_swigregister(CSequenceAdapter)
class CMapAdapter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CMapAdapter

    def __init__(self, *args):
        r"""
        Creates object with its own mapping, which is not member of CTestBase.

        Used for serialization for cut/copy operations.
        """
        _connect.CMapAdapter_swiginit(self, _connect.new_CMapAdapter(*args))

    def assign(self, src):
        return _connect.CMapAdapter_assign(self, src)

    def equalsData(self, src):
        return _connect.CMapAdapter_equalsData(self, src)

    def contains(self, key):
        return _connect.CMapAdapter_contains(self, key)

    def size(self):
        return _connect.CMapAdapter_size(self)

    def getValue(self, key):
        return _connect.CMapAdapter_getValue(self, key)

    def getComment(self, commentType, key):
        r"""
        :type commentType: int
        :param commentType: specifies whether it is end of line or new line comment
        """
        return _connect.CMapAdapter_getComment(self, commentType, key)

    def getStrStrMap(self, strMap):
        return _connect.CMapAdapter_getStrStrMap(self, strMap)

    def getKeys(self, strVector):
        return _connect.CMapAdapter_getKeys(self, strVector)

    def getKey(self, index):
        r"""Returns key at the given index. Throws exception if index is out of range."""
        return _connect.CMapAdapter_getKey(self, index)

    def getKeyIndex(self, key):
        r"""Returns index of the given key in ordered map."""
        return _connect.CMapAdapter_getKeyIndex(self, key)

    def getMapAdapter(self, key):
        return _connect.CMapAdapter_getMapAdapter(self, key)

    def getSeqAdapter(self, key):
        return _connect.CMapAdapter_getSeqAdapter(self, key)

    def setValue(self, *args):
        return _connect.CMapAdapter_setValue(self, *args)

    def setComment(self, key, nlComment, eolComment):
        return _connect.CMapAdapter_setComment(self, key, nlComment, eolComment)

    def renameKey(self, oldKey, newKey):
        r"""
        Replaces ``oldKey`` with ``newKey``, while value, comments, and order
        are preserved.
        """
        return _connect.CMapAdapter_renameKey(self, oldKey, newKey)

    def removeEntry(self, key):
        r"""
        Removes entry with the existing key.

        :rtype: boolean
        :return: true, if entry existed, false if there was no such key in the map.
        """
        return _connect.CMapAdapter_removeEntry(self, key)

    def removeAll(self):
        r"""Removes all entries, formatting is left unchanged."""
        return _connect.CMapAdapter_removeAll(self)

    def insertKey(self, key, predecessors):
        r"""
        Inserts the given key and empty scalar value after any key found
        in ``predecessors``.

        :rtype: boolean
        :return: false if the key was not inserted - it already existed in the map
                    true otherwise
        """
        return _connect.CMapAdapter_insertKey(self, key, predecessors)

    def moveKey(self, key, predecessors):
        return _connect.CMapAdapter_moveKey(self, key, predecessors)

    def serialize(self):
        return _connect.CMapAdapter_serialize(self)

    def parse(self, yamlStr):
        r"""Sets content of this object according to the given YAML spec."""
        return _connect.CMapAdapter_parse(self, yamlStr)

    def toString(self):
        return _connect.CMapAdapter_toString(self)

# Register CMapAdapter in _connect:
_connect.CMapAdapter_swigregister(CMapAdapter)
class CTestFilter(CTestBase):
    r"""
    This class defies conditions, which test case must satisfy to be
    executed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BUILT_IN_FILTER = _connect.CTestFilter_BUILT_IN_FILTER
    r"""filter algorithm implemented in this class is used"""
    SCRIPT_FILTER = _connect.CTestFilter_SCRIPT_FILTER
    r"""filter algorithm implemented in user provided script is used"""

    def filterQualifier(self, filterRegExs, testCaseQualifier):
        return _connect.CTestFilter_filterQualifier(self, filterRegExs, testCaseQualifier)
    E_SECTION_FILTER_ID = _connect.CTestFilter_E_SECTION_FILTER_ID
    E_SECTION_FILTER_TYPE = _connect.CTestFilter_E_SECTION_FILTER_TYPE
    E_SECTION_CORE_ID = _connect.CTestFilter_E_SECTION_CORE_ID
    E_SECTION_PARTITIONS = _connect.CTestFilter_E_SECTION_PARTITIONS
    E_SECTION_MODULES = _connect.CTestFilter_E_SECTION_MODULES
    E_SECTION_INCLUDED_IDS = _connect.CTestFilter_E_SECTION_INCLUDED_IDS
    E_SECTION_EXCLUDED_IDS = _connect.CTestFilter_E_SECTION_EXCLUDED_IDS
    E_SECTION_INCLUDED_FUNCTIONS = _connect.CTestFilter_E_SECTION_INCLUDED_FUNCTIONS
    E_SECTION_EXCLUDED_FUNCTIONS = _connect.CTestFilter_E_SECTION_EXCLUDED_FUNCTIONS
    E_SECTION_MUST_HAVE_ALL_TAGS = _connect.CTestFilter_E_SECTION_MUST_HAVE_ALL_TAGS
    E_SECTION_MUST_HAVE_ONE_OF_TAGS = _connect.CTestFilter_E_SECTION_MUST_HAVE_ONE_OF_TAGS
    E_SECTION_MUST_NOT_HAVE_ALL_TAGS = _connect.CTestFilter_E_SECTION_MUST_NOT_HAVE_ALL_TAGS
    E_SECTION_MUST_NOT_HAVE_ONE_OF_TAGS = _connect.CTestFilter_E_SECTION_MUST_NOT_HAVE_ONE_OF_TAGS
    E_SECTION_IS_OR_TAGS_1 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_1
    E_SECTION_IS_OR_TAGS_2 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_2
    E_SECTION_IS_OR_TAGS_3 = _connect.CTestFilter_E_SECTION_IS_OR_TAGS_3
    E_SECTION_SCRIPT_FUNCTION = _connect.CTestFilter_E_SECTION_SCRIPT_FUNCTION
    E_SECTION_SCRIPT_FUNCTION_PARAMS = _connect.CTestFilter_E_SECTION_SCRIPT_FUNCTION_PARAMS

    def __init__(self, parent):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBench class. Used
            only when parsing YAML declaration. Can be specified as
            NULL if the object is not initialized by parser.
        """
        _connect.CTestFilter_swiginit(self, _connect.new_CTestFilter(parent))

    def createInstance(self, parent):
        return _connect.CTestFilter_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestFilter_cast(testBase)

    def getFilterType(self):
        r"""Returns true, if script function is set."""
        return _connect.CTestFilter_getFilterType(self)

    def getFilterId(self):
        r"""Returns the ID of this filter."""
        return _connect.CTestFilter_getFilterId(self)

    def getCoreId(self):
        r"""Returns core or application ID."""
        return _connect.CTestFilter_getCoreId(self)

    def getPartitions(self, partitions):
        r"""
        Returns regex for partition names (download file) where symbols are located. If this item is
        empty string, symbols from all partitions in winIDEA project are used as filter input.
        """
        return _connect.CTestFilter_getPartitions(self, partitions)

    def getModules(self, modules):
        r"""
        Returns regex for module names (source files), which should be used as
        a source for symbols. If this string is empty, all symbols from partition
        are used as filter input.
        """
        return _connect.CTestFilter_getModules(self, modules)

    def getMustHaveAllTags(self, tags):
        r"""Returns tags, which must be present in test specification to be executed."""
        return _connect.CTestFilter_getMustHaveAllTags(self, tags)

    def getMustHaveOneOfTags(self, tags):
        r"""Returns tags, of which at least one must be present in test specification to be executed."""
        return _connect.CTestFilter_getMustHaveOneOfTags(self, tags)

    def getMustNotHaveAllTags(self, tags):
        r"""Returns tags, which must NOT be present in test specification to be executed."""
        return _connect.CTestFilter_getMustNotHaveAllTags(self, tags)

    def getMustNotHaveOneOfTags(self, tags):
        r"""Returns tags, of which at least one must NOT be present in test specification to be executed."""
        return _connect.CTestFilter_getMustNotHaveOneOfTags(self, tags)

    def isOrTags1(self):
        r"""
        Returns true, if the result of test for ``must have all tags`` is
        ANDed with other tests.
        """
        return _connect.CTestFilter_isOrTags1(self)

    def isOrTags2(self):
        r"""
        Returns true, if the result of test for ``must have any of tags`` is
        ANDed with other tests.
        """
        return _connect.CTestFilter_isOrTags2(self)

    def isOrTags3(self):
        r"""
        Returns true, if the result of test for ``must not have all tags`` is
        ANDed with other tests.
        """
        return _connect.CTestFilter_isOrTags3(self)

    def getIncludedIds(self, ids):
        r"""
        Returns the list of exception IDs.

        See also: setIncludedIds
        """
        return _connect.CTestFilter_getIncludedIds(self, ids)

    def getExcludedIds(self, ids):
        r"""
        Returns the list of exception IDs.

        See also: setExcludedIds
        """
        return _connect.CTestFilter_getExcludedIds(self, ids)

    def getIncludedFunctions(self, functions):
        r"""
        Returns the list of exception function names.

        See also: setIncludedFunctions
        """
        return _connect.CTestFilter_getIncludedFunctions(self, functions)

    def getExcludedFunctions(self, functions):
        r"""
        Returns the list of exception function names.

        See also: setExcludedFunctions
        """
        return _connect.CTestFilter_getExcludedFunctions(self, functions)

    def getScriptFunction(self):
        r"""
         Returns script function, which performs filtering.
        If the function returns null, test spec. is executed. If the
        function returns string, it is printed into test report, why the
        test spec. was not executed.
        """
        return _connect.CTestFilter_getScriptFunction(self)

    def getScriptFunctionParams(self, params):
        r"""Returns the list of script function parameters."""
        return _connect.CTestFilter_getScriptFunctionParams(self, params)

    def setFilterId(self, filterId):
        r"""Sets id of this filter."""
        return _connect.CTestFilter_setFilterId(self, filterId)

    def setFilterType(self, filterType):
        r"""Sets type of filter performed."""
        return _connect.CTestFilter_setFilterType(self, filterType)

    def setMustHaveAllTags(self, tags):
        r"""
         Test specification must have all tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustHaveAllTags(self, tags)

    def setMustHaveOneOfTags(self, tags):
        r"""
         Test specification must have at least one of tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustHaveOneOfTags(self, tags)

    def setMustNotHaveAllTags(self, tags):
        r"""
         Test specification must not have any of tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustNotHaveAllTags(self, tags)

    def setMustNotHaveOneOfTags(self, tags):
        r"""
         Test specification must not have at least one of tags set with this method.

        :type tags: string
        :param tags: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setMustNotHaveOneOfTags(self, tags)

    def setOrTags1(self, isOr1):
        r"""
        :type isOr1: boolean
        :param isOr1: if true, AND logical operation is applied between test for
            must have all tags and other tags tests.
        """
        return _connect.CTestFilter_setOrTags1(self, isOr1)

    def setOrTags2(self, isOr2):
        r"""
        :type isOr2: boolean
        :param isOr2: if true, AND logical operation is applied between test for
            must have any of tags and other tags tests.
        """
        return _connect.CTestFilter_setOrTags2(self, isOr2)

    def setOrTags3(self, isOr3):
        r"""
        :type isOr3: boolean
        :param isOr3: if true, AND logical operation is applied between test for
            must not have all tags and other tags tests.
        """
        return _connect.CTestFilter_setOrTags3(self, isOr3)

    def setIncludedIds(self, ids):
        r"""
        Test specification, which have test ID equal to one of the ids specified
        with this method, are added as an exception to the pool of executed test
        specifications. Note that test for function name is executed BEFORE the
        test for test ID.

        :type ids: string
        :param ids: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setIncludedIds(self, ids)

    def setExcludedIds(self, ids):
        r"""
        Test specification, which have test ID equal to one of the ids specified
        with this method, are removed as an exception from the pool of executed test
        specifications. If the same ID is in set also with the method
        ``setIncludedIds()``, the
        inclusion takes precedence - test spec. is executed.

        :type ids: string
        :param ids: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setExcludedIds(self, ids)

    def setIncludedFunctions(self, functions):
        r"""
        Test specification, which have function name equal to one of the ids specified
        with this method, are added as an exception to the pool of executed test
        specifications.

        :type functions: string
        :param functions: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setIncludedFunctions(self, functions)

    def setExcludedFunctions(self, functions):
        r"""
        Test specification, which have function name equal to one of the ids specified
        with this method, are removed as an exception from the pool of executed test
        specifications. If the same function name is in set also with the method
        ``setIncludedFunctions()``, the
        inclusion takes precedence - test spec. is executed.

        :type functions: string
        :param functions: YAML list of strings, for example: "[myName1, myName2]"
        """
        return _connect.CTestFilter_setExcludedFunctions(self, functions)

    def setScriptFunction(self, functionName):
        r"""Sets parameters for the script function."""
        return _connect.CTestFilter_setScriptFunction(self, functionName)

    def setScriptFunctionParams(self, params):
        r"""Returns the list of script function parameters."""
        return _connect.CTestFilter_setScriptFunctionParams(self, params)
    __swig_destroy__ = _connect.delete_CTestFilter

# Register CTestFilter in _connect:
_connect.CTestFilter_swigregister(CTestFilter)
class CTestFilterController(object):
    r"""
    This class maintains all data required for test case filtering, and
    contains methods, which perform the filtering.

    It maintains the following structure of symbols:
    coreInfo --> partition1 --> module1 --> func1
                                            func2
                                            ...
                                module2
                                ...
                 partition2 --> moduleN

                 partition3
                 ...
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def isEmpty(self):
        r"""Returns true, if there are no symbols stored in this object."""
        return _connect.CTestFilterController_isEmpty(self)

    def clear(self):
        r"""Clears symbols. Can be used to indicate that refresh is needed."""
        return _connect.CTestFilterController_clear(self)

    def countExecutableTests(self, testSpec, derivedLevel, testFilter):
        r"""
        Returns the number of tests which are executable (have 'run' flag set
        and are note excluded by the given filter.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test spec. and it's derived test specs to be counted
        :type derivedLevel: int
        :param derivedLevel: how deep to test derived test specifications
        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: filter to be used for test inclusion/exclusion. If
                   the filter specifies script function, an IllegalStateException is thrown,
                   since scripts can't be called from native code.
        """
        return _connect.CTestFilterController_countExecutableTests(self, testSpec, derivedLevel, testFilter)

    def isTestExecutable(self, testSpec, testFilter):
        r"""
        Returns true, if the test will be executed. This method is similar to
        filterTestSpec(), but always performs merging.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test spec. to be tested for execution
        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: filter to be used for test inclusion/exclusion. If
                   the filter specifies script function, an IllegalStateException is thrown,
                   since scripts can't be called from native code.
        """
        return _connect.CTestFilterController_isTestExecutable(self, testSpec, testFilter)

    def refreshSymbols(self, envConfig, globalsContainer):
        return _connect.CTestFilterController_refreshSymbols(self, envConfig, globalsContainer)

    def setDefaultCoreId(self, coreId):
        r"""Sets list of core IDs."""
        return _connect.CTestFilterController_setDefaultCoreId(self, coreId)

    def setDefaultPartition(self, coreId, defaultPartition):
        r"""
        Used for assigning test cases to groups. You can use CIDEController::getDefaultDownloadFile()
        to obtain this value.

        :type coreId: string
        :param coreId: core ID.
        :type defaultPartition: string
        :param defaultPartition: name of default download file as set in winIDEA.
        """
        return _connect.CTestFilterController_setDefaultPartition(self, coreId, defaultPartition)

    def setFunctionToModuleMap(self, coreId, functionToModuleMap):
        r"""
        Sets map with keys containing function name with partition, and modules as values.
        You can use CDataController::getFunctionToModuleMap() to obtain this information.

        :type coreId: string
        :param coreId: core ID.
        :type functionToModuleMap: :py:class:`StrStrMap`
        :param functionToModuleMap: function name to module name, for example: main,,sample.elf: main.c
        """
        return _connect.CTestFilterController_setFunctionToModuleMap(self, coreId, functionToModuleMap)

    def filterTestSpec(self, testSpec, isTestSpecMerged, filter):
        r"""
        Returns true, if testSpec passes filter, false otherwise.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to be filtered
        :type isTestSpecMerged: boolean
        :param isTestSpecMerged: if the given test spec is already merged,
                                    then specifying this flag as True saves
                                    some time. If false, the given test spec is
                                    merged before filter is applied.
        :type filter: :py:class:`CTestFilter`
        :param filter: contains data to be used for filtering
        """
        return _connect.CTestFilterController_filterTestSpec(self, testSpec, isTestSpecMerged, filter)

    def getTestItemsForFilter(self, testGroup, partitions, modules, qualFuncNames):
        r"""
        Returns all partitions, modules, and functions for coreID from filter,
        which pass filter.

        :type testGroup: :py:class:`CTestGroup`
        :param testGroup: test group.
        :type partitions: :py:class:`StrVector`
        :param partitions: vector to receive partition names.
        :type modules: :py:class:`StrVector`
        :param modules: vector to receive module names.
        :type qualFuncNames: :py:class:`StrVector`
        :param qualFuncNames: vector to receive qualified function names with module paths.

        :rtype: string
        :return: empty string if everything OK, warning or error otherwise (for example
                          core ID not found, not all partitions in filter exist in core).
        """
        return _connect.CTestFilterController_getTestItemsForFilter(self, testGroup, partitions, modules, qualFuncNames)

    def countTestCasesInGroup(self, group, partitionsWTestInGroup, modulesWTestInGroup, functionsWTestInGroup):
        r"""
        Based on filter from the given group, this m. returns all partitions,
        modules, and functions, which are tested by at least one test case in a group.
        """
        return _connect.CTestFilterController_countTestCasesInGroup(self, group, partitionsWTestInGroup, modulesWTestInGroup, functionsWTestInGroup)

    def toString(self):
        r"""Prints stored symbol information."""
        return _connect.CTestFilterController_toString(self)

    def __init__(self):
        _connect.CTestFilterController_swiginit(self, _connect.new_CTestFilterController())
    __swig_destroy__ = _connect.delete_CTestFilterController

# Register CTestFilterController in _connect:
_connect.CTestFilterController_swigregister(CTestFilterController)
class CTestGlobalsContainer(object):
    r"""
    IMPORTANT: Do not use this class as an intermediate between iconnect IGlobals
    data and Java, because is ti much faster to call CDataController2:getGlobals()
    directly from Java and then perform copying of data to Java only once. This class
    copies data to intermediate C++ data structures.

    This class contains all global symbols. It returns references
    to internal data for performance reasons, and is therefore intended for
    iSYSTEM internal use only.
    IMPORTANT:
    Never use reference returned by this class outside of scope where it
    was obtained, especially in other languages!
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def refresh(self, mccmgr, isRefreshTypes):
        r"""
        Reads globals from winIDEA and copies them to local structures.

        :type isRefreshTypes: boolean
        :param isRefreshTypes: if true types and typedefs are also
                   read. In some cases this may degrade performance (for example in
                   a project with 550_000 types and 150_000 typedefs), but is needed
                   only for code proposals and not for test execution. On the mentioned
                   project the time difference was 0.5s vs 9.5 s with types.
                   Retrieval from winIDEA took 2.3s, so 7.2 seconds were used for data
                   copying to std::strings.
                   For performance optimization consider custom std::string allocator,
                   or keep references to data returned by iconnect in this class and
                   avoid conversion to std::string.
        """
        return _connect.CTestGlobalsContainer_refresh(self, mccmgr, isRefreshTypes)

    def getCores(self, coreIds):
        r"""Returns IDs of all cores."""
        return _connect.CTestGlobalsContainer_getCores(self, coreIds)

    def getPartitions(self, coreId, isGetPaths, partitions):
        r"""Returns partitions for the given core."""
        return _connect.CTestGlobalsContainer_getPartitions(self, coreId, isGetPaths, partitions)

    def getModules(self, coreId, partitionIdx, isGetPaths, modules):
        r"""Returns modules for the given partition."""
        return _connect.CTestGlobalsContainer_getModules(self, coreId, partitionIdx, isGetPaths, modules)

    def getFunctionsForModule(self, coreId, partitionIdx, moduleIdx, functions):
        return _connect.CTestGlobalsContainer_getFunctionsForModule(self, coreId, partitionIdx, moduleIdx, functions)

    def getFunctionToModulesMap(self, coreId, functionsToModulesMap):
        return _connect.CTestGlobalsContainer_getFunctionToModulesMap(self, coreId, functionsToModulesMap)

    def toString(self):
        r"""Returns some statistics about symbols in this class."""
        return _connect.CTestGlobalsContainer_toString(self)

    def __init__(self):
        _connect.CTestGlobalsContainer_swiginit(self, _connect.new_CTestGlobalsContainer())
    __swig_destroy__ = _connect.delete_CTestGlobalsContainer

# Register CTestGlobalsContainer in _connect:
_connect.CTestGlobalsContainer_swigregister(CTestGlobalsContainer)
class CTestBench(CTestBase):
    r"""
    This class encapsulates all data required to run isystem unit tests.
    Use one of static methods to get instances of this class.

    Python example (from `filterTests.py`):


    Python example: _sample_link{itest,filter_tests}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ENV_CONFIG = _connect.CTestBench_E_SECTION_ENV_CONFIG
    E_SECTION_REPORT_CONFIG = _connect.CTestBench_E_SECTION_REPORT_CONFIG
    E_SECTION_FILTERS = _connect.CTestBench_E_SECTION_FILTERS
    E_SECTION_GROUPS = _connect.CTestBench_E_SECTION_GROUPS
    E_SECTION_TESTS = _connect.CTestBench_E_SECTION_TESTS
    E_SECTION_TEST_CASES = _connect.CTestBench_E_SECTION_TEST_CASES

    def __init__(self):
        _connect.CTestBench_swiginit(self, _connect.new_CTestBench())

    def createInstance(self, parent):
        return _connect.CTestBench_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestBench_cast(testBase)

    def getTestEnvironmentConfig(self, isConst):
        r"""Returns test environment configuration."""
        return _connect.CTestBench_getTestEnvironmentConfig(self, isConst)

    def getTestReportConfig(self, isConst):
        r"""Returns test report configuration."""
        return _connect.CTestBench_getTestReportConfig(self, isConst)

    def getTestFilters(self, isConst):
        r"""Returns test filters."""
        return _connect.CTestBench_getTestFilters(self, isConst)

    def getTestFilter(self, filterId):
        r"""Returns test filter with the given ID, or NULL if the filter is not found."""
        return _connect.CTestBench_getTestFilter(self, filterId)

    def getGroup(self, isConst):
        r"""Returns root group."""
        return _connect.CTestBench_getGroup(self, isConst)

    def getTestSpecification(self, isConst):
        r"""
        Returns root test case. This test case is a container only - it has no data set,
        but contains derived test cases (as they were defined in testIDEA, for example).
        """
        return _connect.CTestBench_getTestSpecification(self, isConst)

    def getWarnings(self):
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing. This method calls getWarning() on all
        aggregated classes, so it is not necessary to call getWarning() on each
        of them.
        """
        return _connect.CTestBench_getWarnings(self)

    def getFileName(self):
        r"""Returns file from which this test bench data was loaded, or saved to."""
        return _connect.CTestBench_getFileName(self)

    def setFileName(self, fileName):
        r"""
        Sets name of the file this test bench is related to. It should be
        always absolute, as this directory is considered as working directory, when
        relative path names are specified for other files in test spec (reports,
        diagrams, ...).
        """
        return _connect.CTestBench_setFileName(self, fileName)

    def getModelDirectory(self):
        r"""Returns directory of the model file."""
        return _connect.CTestBench_getModelDirectory(self)

    def setTestSpecification(self, testSpec):
        return _connect.CTestBench_setTestSpecification(self, testSpec)

    @staticmethod
    def load(fileName, filePos=0):
        r"""Loads test environment configuration and test specifications from the given file."""
        return _connect.CTestBench_load(fileName, filePos)

    @staticmethod
    def parse(yamlSpec):
        r"""Parses test environment configuration and test specifications from the given string."""
        return _connect.CTestBench_parse(yamlSpec)

    def save(self, fileName, isAppend=False, isSaveLineNumbers=False):
        r"""
        Saves test bench configuration into the given file.

        :type fileName: string
        :param fileName: file to save to
        :type isAppend: boolean, optional
        :param isAppend: if true, new data is appended to the end of the file,
                            otherwise any previous contents is erased.
        :type isSaveLineNumbers: boolean, optional
        :param isSaveLineNumbers: if true, line numbers are assigned to test specifications when saved
        """
        return _connect.CTestBench_save(self, fileName, isAppend, isSaveLineNumbers)

    @staticmethod
    def addUserInfoToReportConfig(reportConfig, testSpecificationFile, winIDEAWorkspace, winIDEAWorkspaceFile, defaultDlFile):
        r"""
        This method adds the following info to report config:
        - path to test spec. file given as parameter
        - path to winIDEA workspace file given as parameter
        - SDK (testIDEA) version (automatically obtained)
        - current date and time if specified in 'reportConfig'.
        """
        return _connect.CTestBench_addUserInfoToReportConfig(reportConfig, testSpecificationFile, winIDEAWorkspace, winIDEAWorkspaceFile, defaultDlFile)

    def getTestReportContainer(self):
        r"""Returns instance of class containing information for test reports."""
        return _connect.CTestBench_getTestReportContainer(self)

    def getFilterController(self):
        r"""Returns reference to filter controller."""
        return _connect.CTestBench_getFilterController(self)

    @staticmethod
    def createDirIfNotExists(filePath):
        r"""
        Creates directory for the given file path, if it does not exist.
        If path does not contain file name, it must end with path separator.
        """
        return _connect.CTestBench_createDirIfNotExists(filePath)

    @staticmethod
    def saveTestResults(testResults, reportConfig):
        r"""
        This method saves test results into file in the specified format.
        Only XML, YAML and CSV files are supported by this function.
        XLS and XLSX (Excel) formats are available only from testIDEA,
        but CSV format can be easily imported to Excel.

        Note for CSV format: Because there are three different tables
        stored (configuration, statistics, and results), three files are
        created for CSV format. File name specified in reportConfig gets
        appended '-config' and '-statistics' strings for configuration and
        statistics tables respectively.

        Python example: _sample_link{itest,create_test_report}
        """
        return _connect.CTestBench_saveTestResults(testResults, reportConfig)

    @staticmethod
    def saveCSV(testResults, newReportConfig):
        return _connect.CTestBench_saveCSV(testResults, newReportConfig)

    @staticmethod
    def saveYAML(testResults, newReportConfig):
        return _connect.CTestBench_saveYAML(testResults, newReportConfig)

    @staticmethod
    def saveXML(testResults, newReportConfig):
        return _connect.CTestBench_saveXML(testResults, newReportConfig)

    @staticmethod
    def initTargetForTest(config, debug, ideCtrl, targetStopTimeout):
        r"""
        Deprecated since 9.12.188, 2014-09-05, it works for old style
        init sequences only (download, reset, run, and runUntil actions are
        supported only and only in this order, no multicore support).
        Call 'executeInitAction' for all init actions in CTestEnvironmentConfig
        instead. Python has method PTestCase.executeInitSequence(), which
        replaces this method.

        Initializes target according to settings in 'config' to be ready for unit tests.

        :type config: :py:class:`CTestEnvironmentConfig`
        :param config: initialization configuration
        :type debug: :py:class:`CDebugFacade`
        :param debug: debug facade
        :type ideCtrl: :py:class:`CIDEController`
        :param ideCtrl: ide controller
        :type targetStopTimeout: int
        :param targetStopTimeout: timeout in milliseconds to wait for target
                                     to stop on the given function, address or breakpoint.
                                     TimeoutException is thrown in case of timeout.
        """
        return _connect.CTestBench_initTargetForTest(config, debug, ideCtrl, targetStopTimeout)

    @staticmethod
    def executeInitAction(envConfig, mccMgr, action, stepIdx, isWaitUntilStopped, targetStopTimeout):
        return _connect.CTestBench_executeInitAction(envConfig, mccMgr, action, stepIdx, isWaitUntilStopped, targetStopTimeout)

    @staticmethod
    def restoreTargetAfterTest(config, debug, ideCtrl, targetStopTimeout):
        return _connect.CTestBench_restoreTargetAfterTest(config, debug, ideCtrl, targetStopTimeout)

    @staticmethod
    def configureInterrupts(envConfig, mccMgr, interruptStates):
        return _connect.CTestBench_configureInterrupts(envConfig, mccMgr, interruptStates)

    @staticmethod
    def restoreInterrupts(envConfig, mccMgr, interruptStates):
        return _connect.CTestBench_restoreInterrupts(envConfig, mccMgr, interruptStates)

    @staticmethod
    def execTestCaseInitSequence(testCaseInitConfig, connectionMgr, debug, targetStopTimeout, isTestBatchOn):
        r"""
        This function initializes target before execution of each test case.

        :type testCaseInitConfig: :py:class:`CTestCaseTargetInitConfig`
        :param testCaseInitConfig: initialization configuration
        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr:      ConnectionMgr with connection to winIDEA instance to initialize.
        :type debug: :py:class:`CDebugFacade`
        :param debug:              debug facade
        :type targetStopTimeout: int
        :param targetStopTimeout:  timeout in milliseconds to wait for target
                                      to stop on the given function, address or breakpoint.
                                      TimeoutException is thrown in case of timeout.
        :type isTestBatchOn: boolean
        :param isTestBatchOn:      ``true`` test batch is on.
        """
        return _connect.CTestBench_execTestCaseInitSequence(testCaseInitConfig, connectionMgr, debug, targetStopTimeout, isTestBatchOn)

    @staticmethod
    def configureBreakpointsMode(ideCtrl, bpType, coreIdx, isBeforeInit):
        r"""
        This method configures type of breakpoints (software of hardware)
        as needed for target initialization.

        :type ideCtrl: :py:class:`CIDEController`
        :param ideCtrl: controller object needed to access winIDEA
        :type bpType: int
        :param bpType: type of breakpoints
        :type coreIdx: int
        :param coreIdx: index of core for BP configuration
        :type isBeforeInit: boolean
        :param isBeforeInit: should be true, when this method is called before init sequence,
                                false when it is called for the second time after init seq.
        """
        return _connect.CTestBench_configureBreakpointsMode(ideCtrl, bpType, coreIdx, isBeforeInit)

    @staticmethod
    def configureStackUsage(dataCtrl, runConfiguration, coreIdParam):
        r"""
        This method configures stack usage.

        :type dataCtrl: :py:class:`CDataController2`
        :param dataCtrl: controller object needed to access winIDEA
        :type runConfiguration: :py:class:`CTestEnvironmentConfig`
        :param runConfiguration: object containing stack measurement configurations
        :type coreIdParam: string
        :param coreIdParam: id of core for which stack usage measurement should be configured.
        """
        return _connect.CTestBench_configureStackUsage(dataCtrl, runConfiguration, coreIdParam)

    @staticmethod
    def isTestWithScripts(testSpec):
        r"""
        Returns true, if test contains scripts.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test spec. to be tested for usage of scripts
        """
        return _connect.CTestBench_isTestWithScripts(testSpec)

    def refreshSymbolsAndGroupsIfEmpty(self, mccmgr, customEnvConfig):
        r"""
        Refreshes symbols and assigns test cases to groups, if none are initialized.
        To refresh possibly existing symbols in this object, first call:
           testBench.getFilterController().clear();
        and then this method.

        :type mccmgr: :py:class:`CMulticoreConnectionMgr`
        :param mccmgr: connection object
        :type customEnvConfig: :py:class:`CTestEnvironmentConfig`
        :param customEnvConfig: if you want to specify custom coreIds. If null, then
                                   object returned by call to getTestEnvironmentConfig(true)
                                   is used.
        """
        return _connect.CTestBench_refreshSymbolsAndGroupsIfEmpty(self, mccmgr, customEnvConfig)

    @staticmethod
    def getCvrgFilterCandidates(mergedTestSpec):
        return _connect.CTestBench_getCvrgFilterCandidates(mergedTestSpec)

    def calculateGroupResults(self, mcmgr, envConfig):
        return _connect.CTestBench_calculateGroupResults(self, mcmgr, envConfig)

    def assignTestCasesToGroups(self, filterCtrl):
        return _connect.CTestBench_assignTestCasesToGroups(self, filterCtrl)

    def createTestBase(self, *args):
        return _connect.CTestBench_createTestBase(self, *args)
    __swig_destroy__ = _connect.delete_CTestBench

# Register CTestBench in _connect:
_connect.CTestBench_swigregister(CTestBench)
TMP_XSLT_CSS_EXTENSION = cvar.TMP_XSLT_CSS_EXTENSION

class CScriptConfig(CTestBase):
    r"""
    This class contains configuration for calling script functions from testIDEA.

    Default operator =() can be used.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SCRIPT_SECTION_WORKING_DIR = _connect.CScriptConfig_E_SCRIPT_SECTION_WORKING_DIR
    E_SCRIPT_SECTION_MODULES = _connect.CScriptConfig_E_SCRIPT_SECTION_MODULES
    E_SCRIPT_SECTION_SYS_PATH = _connect.CScriptConfig_E_SCRIPT_SECTION_SYS_PATH
    E_SCRIPT_SECTION_TIMEOUT = _connect.CScriptConfig_E_SCRIPT_SECTION_TIMEOUT
    E_SCRIPT_SECTION_EXTENSION_CLASS = _connect.CScriptConfig_E_SCRIPT_SECTION_EXTENSION_CLASS

    def __init__(self, parent):
        _connect.CScriptConfig_swiginit(self, _connect.new_CScriptConfig(parent))

    def createInstance(self, parent):
        r"""Creates a new empty instance of this class."""
        return _connect.CScriptConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CScriptConfig_cast(testBase)

    def getWorkingDir(self):
        r"""Returns script working directory."""
        return _connect.CScriptConfig_getWorkingDir(self)

    def getModules(self, modules):
        r"""
        Returns vector of modules/libraries to import/load by script interpreter
        before execution of tests.
        """
        return _connect.CScriptConfig_getModules(self, modules)

    def getSysPaths(self, paths):
        r"""Returns the module/library search path for script interpreter."""
        return _connect.CScriptConfig_getSysPaths(self, paths)

    def getExtensionClass(self):
        r"""Returns class to use as a extension object during tests."""
        return _connect.CScriptConfig_getExtensionClass(self)

    def getTimeout(self):
        r"""
        Returns how long in seconds caller should wait for script calls to return.
        If it does not return in this time, the test is considered as failed!
        """
        return _connect.CScriptConfig_getTimeout(self)

    def setWorkingDir(self, workingDir):
        r"""Sets script working directory."""
        return _connect.CScriptConfig_setWorkingDir(self, workingDir)

    def setModules(self, modules):
        r"""
        Setss vector of modules/libraries to import/load by script interpreter
        before execution of tests.
        """
        return _connect.CScriptConfig_setModules(self, modules)

    def setSysPaths(self, sysPaths):
        r"""
        Sets modules/libraries to import/load by script interpreter
        before execution of tests.
        """
        return _connect.CScriptConfig_setSysPaths(self, sysPaths)

    def setExtensionClass(self, extensionClass):
        r"""Sets class to use as a callback object during tests."""
        return _connect.CScriptConfig_setExtensionClass(self, extensionClass)

    def setTimeout(self, timeout):
        r"""
        Sets how long in seconds caller should wait for script calls to return.
        If it does not return in this time, the test is considered as failed!
        """
        return _connect.CScriptConfig_setTimeout(self, timeout)
    __swig_destroy__ = _connect.delete_CScriptConfig

# Register CScriptConfig in _connect:
_connect.CScriptConfig_swigregister(CScriptConfig)
CScriptConfig.EXT_METHOD_BEFORE_TESTS = _connect.cvar.CScriptConfig_EXT_METHOD_BEFORE_TESTS
CScriptConfig.EXT_METHOD_GET_TEST_REPORT_CUSTOM_DATA = _connect.cvar.CScriptConfig_EXT_METHOD_GET_TEST_REPORT_CUSTOM_DATA
CScriptConfig.EXT_METHOD_AFTER_REPORT_SAVE = _connect.cvar.CScriptConfig_EXT_METHOD_AFTER_REPORT_SAVE
CScriptConfig.EXT_METHOD_CUSTOM_PREFIX = _connect.cvar.CScriptConfig_EXT_METHOD_CUSTOM_PREFIX
CScriptConfig.EXT_METHOD_TABLE_PREFIX = _connect.cvar.CScriptConfig_EXT_METHOD_TABLE_PREFIX
CScriptConfig.EXT_METHOD_TABLE_TYPE = _connect.cvar.CScriptConfig_EXT_METHOD_TABLE_TYPE
CScriptConfig.EXT_METHOD_TYPE = _connect.cvar.CScriptConfig_EXT_METHOD_TYPE

class CEvaluatorConfig(CTestBase):
    r"""
    This class contains configuration for calling script functions from testIDEA.

    Default operator =() can be used.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ECDAscii = _connect.CEvaluatorConfig_ECDAscii
    ECDInteger = _connect.CEvaluatorConfig_ECDInteger
    ECDBoth = _connect.CEvaluatorConfig_ECDBoth
    EBDBlanks = _connect.CEvaluatorConfig_EBDBlanks
    EBDNoBlanksTrailingB = _connect.CEvaluatorConfig_EBDNoBlanksTrailingB
    EADHexNoPrefix = _connect.CEvaluatorConfig_EADHexNoPrefix
    EADHexPrefix = _connect.CEvaluatorConfig_EADHexPrefix
    EEDEnum = _connect.CEvaluatorConfig_EEDEnum
    EEDInteger = _connect.CEvaluatorConfig_EEDInteger
    EEDBoth = _connect.CEvaluatorConfig_EEDBoth
    E_EVALUATOR_SECTION_IS_OVERRIDE_WINIDEA_SETTINGS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_IS_OVERRIDE_WINIDEA_SETTINGS
    E_EVALUATOR_SECTION_CHAR_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_CHAR_DISPLAY
    E_EVALUATOR_SECTION_ANSI = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ANSI
    E_EVALUATOR_SECTION_HEX = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_HEX
    E_EVALUATOR_SECTION_BINARY_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_BINARY_DISPLAY
    E_EVALUATOR_SECTION_DISPLAY_POINTER_MEM_AREA = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DISPLAY_POINTER_MEM_AREA
    E_EVALUATOR_SECTION_CHAR_ARRAY_AS_STRING = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_CHAR_ARRAY_AS_STRING
    E_EVALUATOR_SECTION_DEREFERENCE_STRING_POINTERS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DEREFERENCE_STRING_POINTERS
    E_EVALUATOR_SECTION_ADDRESS_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ADDRESS_DISPLAY
    E_EVALUATOR_SECTION_ENUM_DISPLAY = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_ENUM_DISPLAY
    E_EVALUATOR_SECTION_DISPLAY_COLLAPSED_ARRAY_STRUCT = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_DISPLAY_COLLAPSED_ARRAY_STRUCT
    E_EVALUATOR_SECTION_VAGUE_FLOAT_PRECISION = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_VAGUE_FLOAT_PRECISION
    E_EVALUATOR_SECTION_IS_USE_DEFAULT_WI_SETTINGS = _connect.CEvaluatorConfig_E_EVALUATOR_SECTION_IS_USE_DEFAULT_WI_SETTINGS
    r"""deprecated item"""

    def __init__(self, parent):
        _connect.CEvaluatorConfig_swiginit(self, _connect.new_CEvaluatorConfig(parent))

    def createInstance(self, parent):
        r"""Creates a new empty instance of this class."""
        return _connect.CEvaluatorConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CEvaluatorConfig_cast(testBase)

    def applySettingsToWinIDEA(self, ideSPtr):
        r"""
        This methods sets evaluator options for displaying values in winIDEA
        Watch window. These settings are also used by isystem.connect's
        CDataController::evaluate() method and testIDEA. This method applies
        current settings regardless of value returned by isOverrideWinIDEASettings().

        :type ideSPtr: :py:class:`CIDEController`
        :param ideSPtr: shared pointer to CIDEController instance
        """
        return _connect.CEvaluatorConfig_applySettingsToWinIDEA(self, ideSPtr)

    def getCharDisplay(self):
        r"""Returns type of format for char values."""
        return _connect.CEvaluatorConfig_getCharDisplay(self)

    def isOverrideWinIDEASettings(self):
        r"""
        Returns E_TRUE, if winIDEA evaluator setting should be overridden with
        settings in this object. Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isOverrideWinIDEASettings(self)

    def isAnsi(self):
        r"""
        Returns E_TRUE, if chars should be displayed in ANSI format.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isAnsi(self)

    def isHex(self):
        r"""
        Returns E_TRUE, if integers should be displayed in hex format.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isHex(self)

    def getBinaryDisplay(self):
        r"""Returns type of format for binary values."""
        return _connect.CEvaluatorConfig_getBinaryDisplay(self)

    def isDisplayPointerMemArea(self):
        r"""
        Returns E_TRUE, if mem area should be displayed with pointers.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isDisplayPointerMemArea(self)

    def isCharArrayAsString(self):
        r"""
        Returns E_TRUE, if char arrays should be displayed as strings.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isCharArrayAsString(self)

    def isDereferenceStringPointers(self):
        r"""
        Returns E_TRUE, if pointers to 'char' should be dereferenced automatically.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isDereferenceStringPointers(self)

    def getAddressDisplay(self):
        r"""Returns type of format for addresses."""
        return _connect.CEvaluatorConfig_getAddressDisplay(self)

    def getEnumDisplay(self):
        r"""Returns type of format for enums."""
        return _connect.CEvaluatorConfig_getEnumDisplay(self)

    def isDisplayCollapsedArrayStruct(self):
        r"""
        Returns E_TRUE, if array and structure values are displayed.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CEvaluatorConfig_isDisplayCollapsedArrayStruct(self)

    def getVagueFloatPrecision(self):
        r"""
         Returns precision for floating point comparison. Numbers,
        which differ less than this value are considered equal.
        """
        return _connect.CEvaluatorConfig_getVagueFloatPrecision(self)

    def setOverrideWinIDEASettings(self, isOverrideWinIDEASettings):
        r"""
        If set to true, existing winIDEA evaluator settings will be overridden
        with settings from this object.
        """
        return _connect.CEvaluatorConfig_setOverrideWinIDEASettings(self, isOverrideWinIDEASettings)

    def setCharDisplay(self, charDisplay):
        r"""Sets type of format for char values."""
        return _connect.CEvaluatorConfig_setCharDisplay(self, charDisplay)

    def setAnsi(self, isAnsi):
        r"""If set to true, chars are displayed in ANSI format."""
        return _connect.CEvaluatorConfig_setAnsi(self, isAnsi)

    def setHex(self, isHex):
        r"""If set to true, integers are displayed in HEX format."""
        return _connect.CEvaluatorConfig_setHex(self, isHex)

    def setBinaryDisplay(self, binaryDisplay):
        r"""Sets format for binary numbers."""
        return _connect.CEvaluatorConfig_setBinaryDisplay(self, binaryDisplay)

    def setDisplayPointerMemArea(self, isDisplayPointerMemArea):
        r"""If set to true, mem area is displayed with pointers."""
        return _connect.CEvaluatorConfig_setDisplayPointerMemArea(self, isDisplayPointerMemArea)

    def setCharArrayAsString(self, isCharArrayAsString):
        r"""If set to true, char arrays are displayed as null terminated strings."""
        return _connect.CEvaluatorConfig_setCharArrayAsString(self, isCharArrayAsString)

    def setDereferenceStringPointers(self, isDereferenceStringPointers):
        r"""If set to true, pointers to 'char *' are automatically dereferenced."""
        return _connect.CEvaluatorConfig_setDereferenceStringPointers(self, isDereferenceStringPointers)

    def setAddressDisplay(self, addrDisplay):
        r"""Sets format for addresses."""
        return _connect.CEvaluatorConfig_setAddressDisplay(self, addrDisplay)

    def setEnumDisplay(self, enumDisplay):
        r"""Sets format for enums."""
        return _connect.CEvaluatorConfig_setEnumDisplay(self, enumDisplay)

    def setDisplayCollapsedArrayStruct(self, isDisplayCollapsedArrayStruct):
        r"""If set to true, array and struct values are displayed."""
        return _connect.CEvaluatorConfig_setDisplayCollapsedArrayStruct(self, isDisplayCollapsedArrayStruct)

    def setVagueFloatPrecision(self, precision):
        r"""
         Sets precision for floating point comparison. Numbers,
        which differ less than this value are considered equal.
        """
        return _connect.CEvaluatorConfig_setVagueFloatPrecision(self, precision)

    @staticmethod
    def charDisplayEnum2Str(val):
        r"""Returns string representation of enum."""
        return _connect.CEvaluatorConfig_charDisplayEnum2Str(val)

    @staticmethod
    def binaryDisplayEnum2Str(val):
        return _connect.CEvaluatorConfig_binaryDisplayEnum2Str(val)

    @staticmethod
    def addressDisplayEnum2Str(val):
        return _connect.CEvaluatorConfig_addressDisplayEnum2Str(val)

    @staticmethod
    def enumDisplayEnum2Str(val):
        return _connect.CEvaluatorConfig_enumDisplayEnum2Str(val)
    __swig_destroy__ = _connect.delete_CEvaluatorConfig

# Register CEvaluatorConfig in _connect:
_connect.CEvaluatorConfig_swigregister(CEvaluatorConfig)
class CInitSequenceAction(CTestBase):
    r"""
    This class defines target initialization steps to be performed
    before running tests. It supports initialization of multiple cores.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_INIT_SEQ_CORE_ID = _connect.CInitSequenceAction_E_INIT_SEQ_CORE_ID
    E_INIT_SEQ_ACTION = _connect.CInitSequenceAction_E_INIT_SEQ_ACTION
    E_INIT_SEQ_PARAMS = _connect.CInitSequenceAction_E_INIT_SEQ_PARAMS
    EIAConnectToCore = _connect.CInitSequenceAction_EIAConnectToCore
    r"""
    establish connection to secondary core(s). Normally
    primary winIDEA has to perform download before
    launching winIDEAs for other cores. Mandatory
    parameter is core index.
    """
    EIADownload = _connect.CInitSequenceAction_EIADownload
    r"""Downloads executable."""
    EIAReset = _connect.CInitSequenceAction_EIAReset
    r"""Resets target."""
    EIARun = _connect.CInitSequenceAction_EIARun
    r"""Runs target, optional parameter is stop function"""
    EIADeleteAllBreakpoints = _connect.CInitSequenceAction_EIADeleteAllBreakpoints
    r"""Deletes all breakpoints on core."""
    EIACallTargetFunction = _connect.CInitSequenceAction_EIACallTargetFunction
    r"""
    Calls function on target. Requires function name as first
    parameter, other parameters are passed as function parameters.
    """
    EIACallScriptFunction = _connect.CInitSequenceAction_EIACallScriptFunction
    r"""
    Calls script function. Requires function name as first parameter
    other parameters are passed as function parameters
    """
    EIALoadSymbolsOnly = _connect.CInitSequenceAction_EIALoadSymbolsOnly
    r"""
    If the code is already downloaded to the target, this
    action initializes debugger and loads symbols to winDEA.
    """
    EIAWaitUntilStopped = _connect.CInitSequenceAction_EIAWaitUntilStopped
    r"""
    Waits until core stops execution. Should be used after
    core is started from another core.
    """

    def __init__(self, parent):
        _connect.CInitSequenceAction_swiginit(self, _connect.new_CInitSequenceAction(parent))

    def createInstance(self, parent):
        r"""Creates a new empty instance of this class."""
        return _connect.CInitSequenceAction_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CInitSequenceAction_cast(testBase)

    def getCoreId(self):
        r"""Returns ID of the core where action should be performed."""
        return _connect.CInitSequenceAction_getCoreId(self)

    def getAction(self):
        r"""Returns action to be performed. Use CSequenceAdapter to get parameters."""
        return _connect.CInitSequenceAction_getAction(self)

    def getActionName(self):
        r"""
        Returns action name as human readable string - may be used for
        logging and debugging.
        """
        return _connect.CInitSequenceAction_getActionName(self)

    def setCoreId(self, coreId):
        r"""See also: getCoreId."""
        return _connect.CInitSequenceAction_setCoreId(self, coreId)

    def setAction(self, action):
        r"""See also: getAction."""
        return _connect.CInitSequenceAction_setAction(self, action)
    __swig_destroy__ = _connect.delete_CInitSequenceAction

# Register CInitSequenceAction in _connect:
_connect.CInitSequenceAction_swigregister(CInitSequenceAction)
class CTestCaseTargetInitConfig(CTestBase):
    r"""
    This class defines target initialization steps to be performed
    before each test case.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_TEST_CASE_SECTION_IS_DL_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_DL_ON_TC_INIT
    E_TEST_CASE_SECTION_IS_RESET_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_RESET_ON_TC_INIT
    E_TEST_CASE_SECTION_IS_RUN_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_IS_RUN_ON_TC_INIT
    E_TEST_CASE_SECTION_STOP_FUNC_ON_TC_INIT = _connect.CTestCaseTargetInitConfig_E_TEST_CASE_SECTION_STOP_FUNC_ON_TC_INIT

    def __init__(self, parent):
        _connect.CTestCaseTargetInitConfig_swiginit(self, _connect.new_CTestCaseTargetInitConfig(parent))

    def createInstance(self, parent):
        r"""Creates a new empty instance of this class."""
        return _connect.CTestCaseTargetInitConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestCaseTargetInitConfig_cast(testBase)

    def isDownloadOnTCInit(self):
        r"""
        If E_TRUE is returned, download is performed before each test case.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestCaseTargetInitConfig_isDownloadOnTCInit(self)

    def isResetOnTCInit(self):
        r"""
        If E_TRUE is returned, reset is performed before each test case.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestCaseTargetInitConfig_isResetOnTCInit(self)

    def isRunOnTCInit(self):
        r"""
        If E_TRUE is returned, target is started before each test case.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestCaseTargetInitConfig_isRunOnTCInit(self)

    def getStopFunctionOnTCInit(self):
        r"""
         Returns the name of the function to stop on in init sequence
        before each test case.
        Has no effect if isRunOnTCInit() returns false.
        """
        return _connect.CTestCaseTargetInitConfig_getStopFunctionOnTCInit(self)

    def setDownloadOnTCInit(self, isDownload):
        r"""See also: isDownloadOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setDownloadOnTCInit(self, isDownload)

    def setResetOnTCInit(self, isReset):
        r"""See also: isResetOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setResetOnTCInit(self, isReset)

    def setRunOnTCInit(self, isRun):
        r"""See also: isRunOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setRunOnTCInit(self, isRun)

    def setStopFunctionOnTCInit(self, stopFunction):
        r"""See also: getStopFunctionOnTCInit"""
        return _connect.CTestCaseTargetInitConfig_setStopFunctionOnTCInit(self, stopFunction)
    __swig_destroy__ = _connect.delete_CTestCaseTargetInitConfig

# Register CTestCaseTargetInitConfig in _connect:
_connect.CTestCaseTargetInitConfig_swigregister(CTestCaseTargetInitConfig)
class CStackUsageConfig(CTestBase):
    r"""This class defines values for stack usage measurements."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_CORE_ID = _connect.CStackUsageConfig_E_SECTION_CORE_ID
    E_SECTION_IS_ACTIVE = _connect.CStackUsageConfig_E_SECTION_IS_ACTIVE
    E_SECTION_BASE = _connect.CStackUsageConfig_E_SECTION_BASE
    E_SECTION_END = _connect.CStackUsageConfig_E_SECTION_END
    E_SECTION_PATTERN = _connect.CStackUsageConfig_E_SECTION_PATTERN

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBase.
        """
        _connect.CStackUsageConfig_swiginit(self, _connect.new_CStackUsageConfig(*args))
    __swig_destroy__ = _connect.delete_CStackUsageConfig

    def createInstance(self, parent):
        return _connect.CStackUsageConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CStackUsageConfig_cast(testBase)

    def getCoreId(self):
        r"""
        Returns ID of the core, which stack usage has to be measured. Core IDs
        are set in CTestEnvironmentConfig, tag 'coreIds'.
        """
        return _connect.CStackUsageConfig_getCoreId(self)

    def isActive(self):
        r"""
        Returns E_TRUE, if stack usage measurement should be initialized.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CStackUsageConfig_isActive(self)

    def getBase(self):
        r"""
        Deprecated: use getBaseExpr(), because it can return expressions
        Returns low address of stack area.
        """
        return _connect.CStackUsageConfig_getBase(self)

    def getEnd(self):
        r"""
        Deprecated: use getBaseExpr(), because it can return expressions
        Returns high address of stack area.
        """
        return _connect.CStackUsageConfig_getEnd(self)

    def getBaseExpr(self):
        r"""Returns low address of stack area."""
        return _connect.CStackUsageConfig_getBaseExpr(self)

    def getEndExpr(self):
        r"""Returns high address of stack area."""
        return _connect.CStackUsageConfig_getEndExpr(self)

    def getPattern(self):
        r"""Returns pattern for stack seed."""
        return _connect.CStackUsageConfig_getPattern(self)

    def setCoreId(self, coreId):
        r"""
        Sets ID of the core, which stack usage has to be measured. Core IDs
        are set in CTestEnvironmentConfig, tag 'coreIds'.
        """
        return _connect.CStackUsageConfig_setCoreId(self, coreId)

    def setActive(self, isActive):
        r"""Sets stack usage measurement status. E_DEFAULT means not active."""
        return _connect.CStackUsageConfig_setActive(self, isActive)

    def setBase(self, minSize):
        r"""Sets low address of stack area."""
        return _connect.CStackUsageConfig_setBase(self, minSize)

    def setEnd(self, maxSize):
        r"""Sets high address of stack area."""
        return _connect.CStackUsageConfig_setEnd(self, maxSize)

    def setPattern(self, pattern):
        r"""Sets pattern for stack seed."""
        return _connect.CStackUsageConfig_setPattern(self, pattern)

# Register CStackUsageConfig in _connect:
_connect.CStackUsageConfig_swigregister(CStackUsageConfig)
class CToolsConfig(CTestBase):
    r"""This class defines settings used by commands in iTools menu and wizards."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_IS_AUTO_SET_ANALYZER_FNAME = _connect.CToolsConfig_E_SECTION_IS_AUTO_SET_ANALYZER_FNAME
    r"""
    if true, analyzer file name is
    set if empty when analyzer is activated.
    """
    E_SECTION_ANALYZER_FNAME = _connect.CToolsConfig_E_SECTION_ANALYZER_FNAME
    E_SECTION_IS_SET_TEST_ID_ON_PASTE = _connect.CToolsConfig_E_SECTION_IS_SET_TEST_ID_ON_PASTE

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBase.
        """
        _connect.CToolsConfig_swiginit(self, _connect.new_CToolsConfig(*args))
    __swig_destroy__ = _connect.delete_CToolsConfig

    def createInstance(self, parent):
        return _connect.CToolsConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CToolsConfig_cast(testBase)

    def isAutoSetAnalyzerFName(self):
        r"""
        Returns E_TRUE, if analyzer file name should be set if empty and pattern is specified.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CToolsConfig_isAutoSetAnalyzerFName(self)

    def getAnalyzerFName(self):
        r"""
        Returns default analyzer file name, which is used in testIDEA when analyzer
        is activated, if ``isAutoSetAnalyzerFName()`` returns true.
        """
        return _connect.CToolsConfig_getAnalyzerFName(self)

    def isSetTestIdOnPaste(self):
        r"""Returns true, if testIDEA should set test IDs on paste."""
        return _connect.CToolsConfig_isSetTestIdOnPaste(self)

    def setAnalyzerFName(self, fName):
        r"""
        Sets default analyzer file name, which is used in testIDEA when analyzer
        is activated, if ``isAutoSetAnalyzerFName()`` returns true.
        """
        return _connect.CToolsConfig_setAnalyzerFName(self, fName)

    def setAutoSetAnalyzerFName(self, isActive):
        r"""
        Set to E_TRUE, if analyzer file name should be set if empty and pattern is specified.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CToolsConfig_setAutoSetAnalyzerFName(self, isActive)

# Register CToolsConfig in _connect:
_connect.CToolsConfig_swigregister(CToolsConfig)
class CTestEnvironmentConfig(CTestBase):
    r"""
    This class contains configuration for winIDEA connection and logging
    parameters.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EKeepWinIDEASetting = _connect.CTestEnvironmentConfig_EKeepWinIDEASetting
    r"""testIDEA does not change setting in winIDEA"""
    EUseHWBPs = _connect.CTestEnvironmentConfig_EUseHWBPs
    r"""testIDEA configures winIDEA to use hardware breakpoints"""
    EUseSWBPs = _connect.CTestEnvironmentConfig_EUseSWBPs
    r"""testIDEA configures winIDEA to use software breakpoints"""
    EUseHWBPsForInitThenSWBPs = _connect.CTestEnvironmentConfig_EUseHWBPsForInitThenSWBPs
    r"""
    testIDEA configures winIDEA to use hardware
    breakpoints during target initialization phase,
    and software breakpoints during testing. This
    setting is useful, when target init involves
    for example CRC verification of code, which fails
    in case of software breakpoints.
    """
    E_SECTION_VERSION = _connect.CTestEnvironmentConfig_E_SECTION_VERSION
    E_SECTION_WINIDEA_WORKSPACE_FILE_NAME = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_WORKSPACE_FILE_NAME
    E_SECTION_USE_QUALIFIED_FUNC_NAME = _connect.CTestEnvironmentConfig_E_SECTION_USE_QUALIFIED_FUNC_NAME
    E_SECTION_WINIDEA_ADDRESS = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_ADDRESS
    E_SECTION_WINIDEA_PORT = _connect.CTestEnvironmentConfig_E_SECTION_WINIDEA_PORT
    E_SECTION_CORE_IDS = _connect.CTestEnvironmentConfig_E_SECTION_CORE_IDS
    E_SECTION_IS_AUTO_CONNECT = _connect.CTestEnvironmentConfig_E_SECTION_IS_AUTO_CONNECT
    E_SECTION_AUTO_ID_FORMAT_STRING = _connect.CTestEnvironmentConfig_E_SECTION_AUTO_ID_FORMAT_STRING
    E_SECTION_DEFAULT_RET_VAL_NAME = _connect.CTestEnvironmentConfig_E_SECTION_DEFAULT_RET_VAL_NAME
    E_SECTION_LOG_PARAMETERS = _connect.CTestEnvironmentConfig_E_SECTION_LOG_PARAMETERS
    E_SECTION_ALWAYS_RUN_INIT_SEQ = _connect.CTestEnvironmentConfig_E_SECTION_ALWAYS_RUN_INIT_SEQ
    E_SECTION_DISABLE_INTERRUPTS = _connect.CTestEnvironmentConfig_E_SECTION_DISABLE_INTERRUPTS
    E_SECTION_TEST_TIMEOUT = _connect.CTestEnvironmentConfig_E_SECTION_TEST_TIMEOUT
    E_SECTION_BREAKPOINTS_TYPE = _connect.CTestEnvironmentConfig_E_SECTION_BREAKPOINTS_TYPE
    E_SECTION_INIT_SEQUENCE = _connect.CTestEnvironmentConfig_E_SECTION_INIT_SEQUENCE
    E_SECTION_SCRIPT = _connect.CTestEnvironmentConfig_E_SECTION_SCRIPT
    E_SECTION_TOOLS_CONFIG = _connect.CTestEnvironmentConfig_E_SECTION_TOOLS_CONFIG
    E_SECTION_EVALUATOR = _connect.CTestEnvironmentConfig_E_SECTION_EVALUATOR
    E_SECTION_TARGET_INIT = _connect.CTestEnvironmentConfig_E_SECTION_TARGET_INIT
    E_SECTION_STACK_USAGE = _connect.CTestEnvironmentConfig_E_SECTION_STACK_USAGE
    E_SECTION_CHECK_TARGET_STATE_BEFORE_RUN = _connect.CTestEnvironmentConfig_E_SECTION_CHECK_TARGET_STATE_BEFORE_RUN
    E_SECTION_VERIFY_SYMBOLS_BEFORE_RUN = _connect.CTestEnvironmentConfig_E_SECTION_VERIFY_SYMBOLS_BEFORE_RUN
    E_SECTION_STACK_USAGE_DEPR = _connect.CTestEnvironmentConfig_E_SECTION_STACK_USAGE_DEPR
    E_SECTION_IS_DOWNLOAD_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_DOWNLOAD_ON_INIT
    E_SECTION_IS_RESET_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_RESET_ON_INIT
    E_SECTION_IS_RUN_ON_INIT = _connect.CTestEnvironmentConfig_E_SECTION_IS_RUN_ON_INIT
    E_SECTION_STOP_FUNCTION = _connect.CTestEnvironmentConfig_E_SECTION_STOP_FUNCTION
    E_SECTION_DELETE_BPS = _connect.CTestEnvironmentConfig_E_SECTION_DELETE_BPS

    def __init__(self, parent):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
            only when parsing YAML declaration. Can be specified as
            NULL if the object is not initialized by parser.
        """
        _connect.CTestEnvironmentConfig_swiginit(self, _connect.new_CTestEnvironmentConfig(parent))

    def createInstance(self, parent):
        r"""Creates a new empty instance of this class."""
        return _connect.CTestEnvironmentConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestEnvironmentConfig_cast(testBase)

    def serialize(self, emitter):
        r"""Overrides base class method to change file version."""
        return _connect.CTestEnvironmentConfig_serialize(self, emitter)

    def getVersion(self):
        r"""Returns version of testIDEA which saved the test specification file."""
        return _connect.CTestEnvironmentConfig_getVersion(self)

    @staticmethod
    def getStaticVersion():
        r"""
        This method may be used by other classes during parsing to obtain
        version of currently parsed iyaml file. If the version was not parsed,
        empty string is returned.
        """
        return _connect.CTestEnvironmentConfig_getStaticVersion()

    def getWorkspace(self):
        r"""Returns workspace file path and name."""
        return _connect.CTestEnvironmentConfig_getWorkspace(self)

    def getPrimaryCoreId(self):
        r"""
        Returns core ID of the primary core (the first item from the list),
        or empty string is there are no core IDs specified.
        """
        return _connect.CTestEnvironmentConfig_getPrimaryCoreId(self)

    def getCoreIds(self, coreIds):
        r"""
        Returns vector of core IDs. If empty, single core is used with empty
        string as its ID.
        """
        return _connect.CTestEnvironmentConfig_getCoreIds(self, coreIds)

    def getCoreIdIndex(self, coreId, isThrow):
        r"""Returns index of the given coreId."""
        return _connect.CTestEnvironmentConfig_getCoreIdIndex(self, coreId, isThrow)

    def isUseQualifiedFuncNames(self):
        r"""
        Returns true, if qualified function names should be presented as
        content proposals in testIDEA.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isUseQualifiedFuncNames(self)

    def getAddress(self):
        r"""
        Returns address of remote host running winIDEA. If empty string is returned
        and port is 0, then local host is used.
        """
        return _connect.CTestEnvironmentConfig_getAddress(self)

    def getPort(self):
        r"""
        Returns port of remote host running winIDEA. If 0 is returned
        and address is empty string, then local host is used.
        """
        return _connect.CTestEnvironmentConfig_getPort(self)

    def isAutoConnectToWinIDEA(self):
        r"""
        If true is returned, then Test Bench will connect automatically to winIDEA,
        when names of functions or global vars are required.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isAutoConnectToWinIDEA(self)

    def isAlwaysRunInitSeqBeforeRun(self):
        r"""
        If true, init sequence is executed before test specifications are executed.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isAlwaysRunInitSeqBeforeRun(self)

    def isDownloadOnInit(self):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        If true, download is performed in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isDownloadOnInit(self)

    def isResetOnInit(self):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        If true, reset is performed in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isResetOnInit(self)

    def isRunOnInit(self):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        If true, target is started in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isRunOnInit(self)

    def getStopFunction(self):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        Returns the name of the function to stop on in init sequence.
        Has no effect if isRunOnInit() returns false.
        """
        return _connect.CTestEnvironmentConfig_getStopFunction(self)

    def isDeleteAllBPsOnInit(self):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        get action from CInitSequence.

        Returns true, if all breakpoints should be deleted in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isDeleteAllBPsOnInit(self)

    def isCheckTargetStateBeforeRun(self):
        r"""
        Returns true, if testIDEA should check target state before
        running tests and warn user if it does not match state defined in
        this class, for example the target is not stopped on function 'main'.
        """
        return _connect.CTestEnvironmentConfig_isCheckTargetStateBeforeRun(self)

    def isVerifySymbolsBeforeRun(self):
        r"""
        Returns true, if testIDEA should verify that functions exist on target
        before test run. If non-existent functions are found in test cases,
        pop-up dialog appears in testIDEA.
        """
        return _connect.CTestEnvironmentConfig_isVerifySymbolsBeforeRun(self)

    def isDisableInterrupts(self):
        r"""
        Returns true, if interrupts should be disabled in init sequence.
        Default value (E_DEFAULT) means false.
        """
        return _connect.CTestEnvironmentConfig_isDisableInterrupts(self)

    def getTestTimeout(self):
        r"""
        Returns timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout. This timeout value is overridden, if timeout
        is specified in test case.
        """
        return _connect.CTestEnvironmentConfig_getTestTimeout(self)

    def getBreakpointType(self):
        r"""Returns the type of breakpoints to be used during testing."""
        return _connect.CTestEnvironmentConfig_getBreakpointType(self)

    def getDefaultReturnValueName(self):
        r"""Returns the default name for variable, where function return value is stored."""
        return _connect.CTestEnvironmentConfig_getDefaultReturnValueName(self)

    def getAutoIdFormatString(self):
        r"""
         Returns string, which defines format of automatically assigned IDs.

        See also: setAutoIdFormatString
        """
        return _connect.CTestEnvironmentConfig_getAutoIdFormatString(self)

    def getScriptConfig(self, isConst):
        r"""Returns script configuration."""
        return _connect.CTestEnvironmentConfig_getScriptConfig(self, isConst)

    def getToolsConfig(self, isConst):
        r"""Returns tools configuration."""
        return _connect.CTestEnvironmentConfig_getToolsConfig(self, isConst)

    def getEvaluatorConfig(self, isConst):
        r"""Returns evaluator configuration."""
        return _connect.CTestEnvironmentConfig_getEvaluatorConfig(self, isConst)

    def getTestCaseTargetInitConfig(self, isConst):
        r"""Returns target initialization before each test case configuration."""
        return _connect.CTestEnvironmentConfig_getTestCaseTargetInitConfig(self, isConst)

    def getStackUsageConfig(self, isConst):
        r"""
        Deprecated: use getStackUsageOptions() instead

        Returns configuration for stack usage measurements.
        """
        return _connect.CTestEnvironmentConfig_getStackUsageConfig(self, isConst)

    def getStackUsageOptions(self, isConst):
        r"""Returns list of stack usage options for all cores for which it is defined."""
        return _connect.CTestEnvironmentConfig_getStackUsageOptions(self, isConst)

    def getLoggingParameters(self, params):
        r"""
        Returns vector of logging parameters. Parameters are stored in the list
        in the following order: ``logFileName``, ``logObjPrefix``. All parameters are
        optional. If none of them is specified, logging is off.
        """
        return _connect.CTestEnvironmentConfig_getLoggingParameters(self, params)

    def getWarnings(self):
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing.

        See also: CTestBench::getWarnings()
        """
        return _connect.CTestEnvironmentConfig_getWarnings(self)

    def setVersion(self, version):
        r"""Outputs contents of this class to emitter.  See also: getVersion"""
        return _connect.CTestEnvironmentConfig_setVersion(self, version)

    def setWorkspace(self, workspace):
        r"""See also: getWorkspace"""
        return _connect.CTestEnvironmentConfig_setWorkspace(self, workspace)

    def setAddress(self, address):
        r"""See also: getAddress"""
        return _connect.CTestEnvironmentConfig_setAddress(self, address)

    def setPort(self, port):
        r"""See also: getPort"""
        return _connect.CTestEnvironmentConfig_setPort(self, port)

    def setAutoConnectToWinIDEA(self, autoConnect):
        r"""
        If set to true, then Test Bench will connect automatically to winIDEA,
               when names of functions or global vars are required.
        """
        return _connect.CTestEnvironmentConfig_setAutoConnectToWinIDEA(self, autoConnect)

    def setAlwaysRunInitSeqBeforeRun(self, isAlwaysRunInitSeq):
        r"""If set to true, init sequence is run before each test start."""
        return _connect.CTestEnvironmentConfig_setAlwaysRunInitSeqBeforeRun(self, isAlwaysRunInitSeq)

    def setDownloadOnInit(self, isDownload):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence. This function should not be used
        for multicore init sequences, because order of actions can not be
        specified.

        See also: isDownloadOnInit
        """
        return _connect.CTestEnvironmentConfig_setDownloadOnInit(self, isDownload)

    def setResetOnInit(self, isReset):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: isResetOnInit
        """
        return _connect.CTestEnvironmentConfig_setResetOnInit(self, isReset)

    def setRunOnInit(self, isRun):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: isRunOnInit
        """
        return _connect.CTestEnvironmentConfig_setRunOnInit(self, isRun)

    def setStopFunction(self, stopFunction):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: getStopFunction
        """
        return _connect.CTestEnvironmentConfig_setStopFunction(self, stopFunction)

    def setDeleteAllBPsOnInit(self, isDeleteAllBPs):
        r"""
        Deprecated: use getTestBaseList(E_SECTION_INIT_SEQUENCE) and then
        set action in CInitSequence.

        See also: isDeleteAllBPsOnInit
        """
        return _connect.CTestEnvironmentConfig_setDeleteAllBPsOnInit(self, isDeleteAllBPs)

    def setCheckTargetStateBeforeRun(self, isCheckTargetState):
        r"""
        Defines, if testIDEA should check target state before running tests.
        For example, if run until function is specified in init sequence, testIDEA
        checks if target is stopped there.

        See also: isCheckTargetStateBeforeRun
        """
        return _connect.CTestEnvironmentConfig_setCheckTargetStateBeforeRun(self, isCheckTargetState)

    def setVerifySymbolsBeforeRun(self, isVerifySymbols):
        r"""
        Defines, if testIDEA should verify symbols before test run. It checks if
        all functions (tested, stubs, ...) exist on target.
        """
        return _connect.CTestEnvironmentConfig_setVerifySymbolsBeforeRun(self, isVerifySymbols)

    def setDisableInterrupts(self, isDisableInterrupts):
        r"""See also: isDisableInterrupts"""
        return _connect.CTestEnvironmentConfig_setDisableInterrupts(self, isDisableInterrupts)

    def setTestTimeout(self, timeout):
        r"""
        Sets timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout. This timeout value is overridden, if timeout
        is specified in test case.
        """
        return _connect.CTestEnvironmentConfig_setTestTimeout(self, timeout)

    def setBreakpointsType(self, breakpointsType):
        r"""Sets type of breakpoints to be used in testing."""
        return _connect.CTestEnvironmentConfig_setBreakpointsType(self, breakpointsType)

    def setDefaultReturnValueName(self, defaultRetValName):
        r"""Sets default name for variable, where function return value is stored."""
        return _connect.CTestEnvironmentConfig_setDefaultReturnValueName(self, defaultRetValName)

    def setAutoIdFormatString(self, format):
        r"""
        Sets format of automatically assigned IDs. The string format is
        specific to the tool, which applies IDs. See testIDEA help for
        testIDEA rules. Users may write their own scripts, which may specify
        custom formats.

        The string can be composed of
        variables and plain text between them. Variables have the following
        format: ``${<var>}``. The following variables are available:

        - ${id[,n[,m]]} - generates unique string ID.
                          Optional value ``n`` defines the
                          number of characters for the ID. Optional value ``m`` defines the
                          number of characters for the ID extension of derived tests. If ``m``
                          is specified, IDs of derived tests are formed as
                          [base test ID].[derived test id].
                          Letters, numbers and '.' are used in the
                          ID string.
        - ${seq[,n[,m]]} - generates IDs, which are the same as test case sequence number.
                          The first test gets number 0, the next one number 1, ...
                          Optional value ``n`` defines the
                          number of characters for the ID. Optional value ``m`` defines the
                          number of characters for the ID extension of derived tests. If ``m``
                          is specified, IDs of derived tests are formed as
                          [base test ID].[derived test id].
                          Only numbers and '.' are used in the
                          ID string.
        - ${function} - name of the function under test.
        - ${params} - values of parameters. Values of parameters are separated by '-' sign,
                      all characters, which are not allowed for test ID are replaced with '_'
        - ${tags} - test tags separated by '-'.

        Example format string:

        "/{$id,4}/${function}-${params}-${tags}
        </pre>
        """
        return _connect.CTestEnvironmentConfig_setAutoIdFormatString(self, format)

    def setLoggingParameters(self, params):
        r"""
        Sets logging parameters. Parameters are stored in the list
        in the following order: [``logFileName``, ``logObjPrefix]``. All parameters are
        optional. If none of them is specified, logging is off.
        """
        return _connect.CTestEnvironmentConfig_setLoggingParameters(self, params)

    def getConfiguredCoreID(self, testCaseCoreId):
        r"""
        Returns the given ``testCaseCoreId``, if it is not empty. If it is empty,
        the first item from ``envConfig`` core IDs is returned. If no
        core IDs are defined there, an empty string is returned.
        """
        return _connect.CTestEnvironmentConfig_getConfiguredCoreID(self, testCaseCoreId)
    __swig_destroy__ = _connect.delete_CTestEnvironmentConfig

# Register CTestEnvironmentConfig in _connect:
_connect.CTestEnvironmentConfig_swigregister(CTestEnvironmentConfig)
class CTestReportConfig(CTestBase):
    r"""
    This class contains information about test report, which is implicitly
    contained in the report, for example report format, and user info
    about test.


    Python example: _sample_link{itest,create_test_report}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DYNAMIC_PREFIX = _connect.CTestReportConfig_DYNAMIC_PREFIX
    RCONFIG_FULL = _connect.CTestReportConfig_RCONFIG_FULL
    r"""all measured values are in the report"""
    RCONFIG_ERRORS_ONLY = _connect.CTestReportConfig_RCONFIG_ERRORS_ONLY
    r"""only values which do not match expected are saved into report"""
    FMT_XML = _connect.CTestReportConfig_FMT_XML
    r"""XML format"""
    FMT_YAML = _connect.CTestReportConfig_FMT_YAML
    r"""YAML format"""
    FMT_CSV = _connect.CTestReportConfig_FMT_CSV
    r"""Comma Separated Values format"""
    FMT_XLS = _connect.CTestReportConfig_FMT_XLS
    r"""the old Excel binary format"""
    FMT_XLSX = _connect.CTestReportConfig_FMT_XLSX
    r"""the new Excel XML format"""
    HTML_VIEW_ALL = _connect.CTestReportConfig_HTML_VIEW_ALL
    HTML_VIEW_ERROS_ONLY = _connect.CTestReportConfig_HTML_VIEW_ERROS_ONLY
    E_SECTION_TEST_IDEA_VERSION = _connect.CTestReportConfig_E_SECTION_TEST_IDEA_VERSION
    E_SECTION_WIN_IDEA_VERSION = _connect.CTestReportConfig_E_SECTION_WIN_IDEA_VERSION
    E_SECTION_REPORT_CONTENTS = _connect.CTestReportConfig_E_SECTION_REPORT_CONTENTS
    E_SECTION_OUTPUT_FORMAT = _connect.CTestReportConfig_E_SECTION_OUTPUT_FORMAT
    E_SECTION_FILE_NAME = _connect.CTestReportConfig_E_SECTION_FILE_NAME
    E_SECTION_IYAML_FILE_NAME = _connect.CTestReportConfig_E_SECTION_IYAML_FILE_NAME
    E_SECTION_XML_XSLT_FOR_FULL_REPORT = _connect.CTestReportConfig_E_SECTION_XML_XSLT_FOR_FULL_REPORT
    E_SECTION_XML_XSLT_FOR_ERRORS = _connect.CTestReportConfig_E_SECTION_XML_XSLT_FOR_ERRORS
    E_SECTION_XML_LOGO_IMAGE = _connect.CTestReportConfig_E_SECTION_XML_LOGO_IMAGE
    E_SECTION_XML_REPORT_HEADER = _connect.CTestReportConfig_E_SECTION_XML_REPORT_HEADER
    E_SECTION_CSS_FILE = _connect.CTestReportConfig_E_SECTION_CSS_FILE
    E_SECTION_IS_EMBED_XML_XSLT_CSS = _connect.CTestReportConfig_E_SECTION_IS_EMBED_XML_XSLT_CSS
    E_SECTION_IS_CREATE_HTML = _connect.CTestReportConfig_E_SECTION_IS_CREATE_HTML
    E_SECTION_CSV_SEPARATOR = _connect.CTestReportConfig_E_SECTION_CSV_SEPARATOR
    E_SECTION_CSV_IS_HEADER_LINE = _connect.CTestReportConfig_E_SECTION_CSV_IS_HEADER_LINE
    E_SECTION_XLS_IS_VERTICAL_HEADER = _connect.CTestReportConfig_E_SECTION_XLS_IS_VERTICAL_HEADER
    E_SECTION_IS_INCLUDE_TEST_SPEC = _connect.CTestReportConfig_E_SECTION_IS_INCLUDE_TEST_SPEC
    E_SECTION_IS_ABS_PATHS_FOR_LINK_TYPO = _connect.CTestReportConfig_E_SECTION_IS_ABS_PATHS_FOR_LINK_TYPO
    E_SECTION_IS_ABS_PATHS_FOR_LINK = _connect.CTestReportConfig_E_SECTION_IS_ABS_PATHS_FOR_LINK
    E_SECTION_HTML_VIEW_MODE = _connect.CTestReportConfig_E_SECTION_HTML_VIEW_MODE
    E_SECTION_TEST_INFO = _connect.CTestReportConfig_E_SECTION_TEST_INFO
    E_SECTION_IS_USE_CUSTOM_TIME = _connect.CTestReportConfig_E_SECTION_IS_USE_CUSTOM_TIME

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance with NULL parent.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
            only when parsing YAML declaration. Can be specified as
            NULL if the object is not initialized by parser.
        """
        _connect.CTestReportConfig_swiginit(self, _connect.new_CTestReportConfig(*args))

    def createInstance(self, parent):
        return _connect.CTestReportConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestReportConfig_cast(testBase)

    def getReportContents(self):
        r"""Returns the type of contents in the report."""
        return _connect.CTestReportConfig_getReportContents(self)

    def getTestIDEAVersion(self):
        r"""Returns version of testIDEA used for running tests as set by client."""
        return _connect.CTestReportConfig_getTestIDEAVersion(self)

    def getWinIDEAVersion(self):
        return _connect.CTestReportConfig_getWinIDEAVersion(self)

    def getOutputFormat(self):
        r"""Returns the output format of the report."""
        return _connect.CTestReportConfig_getOutputFormat(self)

    def getFileName(self):
        r"""Returns the name of the file to save report to."""
        return _connect.CTestReportConfig_getFileName(self)

    def getIYamlFileName(self):
        r"""Returns name of iyaml file, which was used to generate this report."""
        return _connect.CTestReportConfig_getIYamlFileName(self)

    def getAbsReportFileName(self):
        r"""
        Returns the absolute name of the file to save report to. If report file
        name is already an absolute path, it is returned unchanged. If it is
        a relative path, then path of iyaml file is added to it.
        """
        return _connect.CTestReportConfig_getAbsReportFileName(self)

    def getXsltForFullReport(self):
        r"""Returns the name of the file to use as XML Stylesheet for the full report."""
        return _connect.CTestReportConfig_getXsltForFullReport(self)

    def getXsltForErrors(self):
        r"""
        Deprecated: only one xslt may be specified, call getXsltForFullReport().
        Returns the name of the file to use as XML Stylesheet for report, which contains errors only.
        """
        return _connect.CTestReportConfig_getXsltForErrors(self)

    def getLogoImageFileName(self):
        r"""Returns file name for logo image in report."""
        return _connect.CTestReportConfig_getLogoImageFileName(self)

    def getCssFile(self):
        r"""Returns the name of the file to use as CSS for report."""
        return _connect.CTestReportConfig_getCssFile(self)

    def isEmbedXsltCss(self):
        r"""Returns true, if XSLT and CSS files should be embedded into XML report."""
        return _connect.CTestReportConfig_isEmbedXsltCss(self)

    def isCreateHtml(self):
        r"""
        Returns true, if HTML file should also be created by processing created XML and XSLT.
        Has effect only if report is generated in XML format.
        """
        return _connect.CTestReportConfig_isCreateHtml(self)

    def getSelectedXsltFileName(self):
        r"""
        Returns XSLT file name for full report or for errors only
        report, depending on the value of output format.
        """
        return _connect.CTestReportConfig_getSelectedXsltFileName(self)

    def getCSVSeparator(self):
        r"""Returns separator to be used in CSV report files."""
        return _connect.CTestReportConfig_getCSVSeparator(self)

    def isCSVHeaderLine(self):
        r"""Returns true, if header line in CSV report format should contain names of columns."""
        return _connect.CTestReportConfig_isCSVHeaderLine(self)

    def isXLSVerticalHeader(self):
        r"""Returns true, if column headers in XLS tables should be written vertically."""
        return _connect.CTestReportConfig_isXLSVerticalHeader(self)

    def isIncludeTestSpec(self):
        r"""Returns true, is test specification should be included into test report."""
        return _connect.CTestReportConfig_isIncludeTestSpec(self)

    def isAbsPathForLinks(self):
        r"""
        If true is returned, then links in report (for example to export files)
        will be written with absolute path.
        """
        return _connect.CTestReportConfig_isAbsPathForLinks(self)

    def getUserInfo(self, userInfoMap):
        r"""
        Returns a map of key-value pairs to be stored into report,
        for example HW used for testing.
        """
        return _connect.CTestReportConfig_getUserInfo(self, userInfoMap)

    def hasUserInfo(self, key):
        r"""
        Returns true, if a user info for the given key exists in mapping.

        :type key: string
        :param key: mapping key.
        """
        return _connect.CTestReportConfig_hasUserInfo(self, key)

    def getXmlReportHeader(self):
        r"""Returns XML report header."""
        return _connect.CTestReportConfig_getXmlReportHeader(self)

    def getWarnings(self):
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing.

        See also: CTestBench::getWarnings()
        """
        return _connect.CTestReportConfig_getWarnings(self)

    def setReportContents(self, reportContents):
        r"""Sets the type of information to be stored in the report."""
        return _connect.CTestReportConfig_setReportContents(self, reportContents)

    def setTestIDEAVersion(self, testIDEAVersion):
        r"""Sets version of testIDEA used for running tests."""
        return _connect.CTestReportConfig_setTestIDEAVersion(self, testIDEAVersion)

    def setWinIDEAVersion(self, winIDEAVersion):
        return _connect.CTestReportConfig_setWinIDEAVersion(self, winIDEAVersion)

    def setOutputFormat(self, outFormat):
        r"""Sets report output format."""
        return _connect.CTestReportConfig_setOutputFormat(self, outFormat)

    def setFileName(self, fileName):
        r"""Sets the name of the report file."""
        return _connect.CTestReportConfig_setFileName(self, fileName)

    def setIYamlFileName(self, fileName):
        r"""Sets the name of the iyaml file, which generated this report."""
        return _connect.CTestReportConfig_setIYamlFileName(self, fileName)

    def setXsltForFullReport(self, xsltFileName):
        r"""Sets file name for XSLT for full reports."""
        return _connect.CTestReportConfig_setXsltForFullReport(self, xsltFileName)

    def setXsltForErrors(self, xsltFileName):
        r"""Sets file name for XSLT for reports, which contains errors only."""
        return _connect.CTestReportConfig_setXsltForErrors(self, xsltFileName)

    def setLogoImageFileName(self, logoImageFileName):
        r"""Returns file name for logo image in report."""
        return _connect.CTestReportConfig_setLogoImageFileName(self, logoImageFileName)

    def setCssFile(self, cssFileName):
        r"""Sets file to be used as a style-sheet for HTML rendering."""
        return _connect.CTestReportConfig_setCssFile(self, cssFileName)

    def setCsvSeparator(self, csvSeparator):
        r"""Sets CSV separator."""
        return _connect.CTestReportConfig_setCsvSeparator(self, csvSeparator)

    def setCsvHeaderLine(self, isCsvHeaderLine):
        r"""
        If ``isCsvHeaderLine`` is set to ``true``, then header line with
        names of columns is added to CSV test report file.
        """
        return _connect.CTestReportConfig_setCsvHeaderLine(self, isCsvHeaderLine)

    def setXLSVerticalHeader(self, isXLSVerticalHeader):
        r"""Sets XLS columns headers orientation."""
        return _connect.CTestReportConfig_setXLSVerticalHeader(self, isXLSVerticalHeader)

    def setIncludeTestSpec(self, isIncTestSpec):
        r"""Sets flag ."""
        return _connect.CTestReportConfig_setIncludeTestSpec(self, isIncTestSpec)

    def setXmlReportHeader(self, header):
        r"""Sets header for XML reports."""
        return _connect.CTestReportConfig_setXmlReportHeader(self, header)

    def setUserInfo(self, yamlSpec):
        r"""Sets mapping of user info, given in yaml format."""
        return _connect.CTestReportConfig_setUserInfo(self, yamlSpec)

    def clearDynamicUserItems(self):
        r"""
        Removes all items with key prefix `_`. These items are normally
        added by script called before report is saved, and are not supposed
        of sources tested. It is up to user which items assigned by script
        should be preserved between sessions and saved to yaml file, and
        which not. The user defines this behavior by using prefix `_`
        """
        return _connect.CTestReportConfig_clearDynamicUserItems(self)

    def setAbsPathForLinks(self, iaAbsPathsForLinks):
        r"""
        If set to true, then links in report (for example to export files)
        will be written with absolute path.
        """
        return _connect.CTestReportConfig_setAbsPathForLinks(self, iaAbsPathsForLinks)

    def addUserInfo(self, key, value):
        r"""
         Adds key/value pair to user info.

        :type key: string
        :param key: must be alphanumeric string
        :type value: string
        :param value: any string
        """
        return _connect.CTestReportConfig_addUserInfo(self, key, value)
    __swig_destroy__ = _connect.delete_CTestReportConfig

# Register CTestReportConfig in _connect:
_connect.CTestReportConfig_swigregister(CTestReportConfig)
BUILT_IN_XSLT_PREFIX = cvar.BUILT_IN_XSLT_PREFIX
DEFAULT_XSLT_NAME = cvar.DEFAULT_XSLT_NAME
DEFAULT_CSS_NAME = cvar.DEFAULT_CSS_NAME
CVRG_TO_COBERTURA_XSLT_FNAME = cvar.CVRG_TO_COBERTURA_XSLT_FNAME

class CTestReportContainer(object):
    r"""
    This class contains test results in ordered map, which means
    that insertion order is preserved.

    Python example: _sample_link{itest,create_test_report}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CTestReportContainer_swiginit(self, _connect.new_CTestReportContainer())

    def assign(self, src):
        return _connect.CTestReportContainer_assign(self, src)

    def clearResults(self):
        r"""Clears all stored test results."""
        return _connect.CTestReportContainer_clearResults(self)

    def putTestResult(self, testSpec, result):
        r"""Saves test result for the given test case."""
        return _connect.CTestReportContainer_putTestResult(self, testSpec, result)

    def getNoOfTestResults(self):
        r"""Returns the number of test results stored in this container."""
        return _connect.CTestReportContainer_getNoOfTestResults(self)

    def resetTestResultIterator(self):
        r"""Resets test result iterator."""
        return _connect.CTestReportContainer_resetTestResultIterator(self)

    def hasNextTestResult(self):
        r"""Returns true, if internal iterator has not reached the last test result yet."""
        return _connect.CTestReportContainer_hasNextTestResult(self)

    def nextTestResult(self):
        r"""Returns the next test result in container."""
        return _connect.CTestReportContainer_nextTestResult(self)

    def getTestResult(self, testSpec):
        r"""Returns test result for the given test case."""
        return _connect.CTestReportContainer_getTestResult(self, testSpec)

    def getNoOfTestGroupResults(self):
        r"""Returns the number of test group results stored in this container."""
        return _connect.CTestReportContainer_getNoOfTestGroupResults(self)

    def resetGroupResultIterator(self):
        r"""Resets test group result iterator."""
        return _connect.CTestReportContainer_resetGroupResultIterator(self)

    def hasNextGroupResult(self):
        r"""Returns true, if internal iterator has not reached the last test group result yet."""
        return _connect.CTestReportContainer_hasNextGroupResult(self)

    def nextGroupResult(self):
        r"""Returns the next test group result in container."""
        return _connect.CTestReportContainer_nextGroupResult(self)

    def getGroupResult(self, testGroup):
        r"""Returns test group result for the given test group."""
        return _connect.CTestReportContainer_getGroupResult(self, testGroup)

    def createGroupResults(self, mcmgr, filterCtrl, hostVars, group):
        r"""Creates group results."""
        return _connect.CTestReportContainer_createGroupResults(self, mcmgr, filterCtrl, hostVars, group)

    def toString(self):
        return _connect.CTestReportContainer_toString(self)
    __swig_destroy__ = _connect.delete_CTestReportContainer

# Register CTestReportContainer in _connect:
_connect.CTestReportContainer_swigregister(CTestReportContainer)
class CTestReportStatistic(object):
    r"""This class calculates and stores statistics for test results."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CTestReportStatistic_swiginit(self, _connect.new_CTestReportStatistic())

    def analyzeResult(self, testResult):
        r"""
        Call this method with all instances of CTestResult produced during
        test run.
        """
        return _connect.CTestReportStatistic_analyzeResult(self, testResult)

    def getErrors(self):
        r"""
        Returns the number of test cases that did not execute because of an
        error in test. For example: function name is misspelled, wrong
        parameter type, timeout occurred, ...
        """
        return _connect.CTestReportStatistic_getErrors(self)

    def getFailures(self):
        r"""
        Returns the number of tests, that executed, but their results
        do not match expected ones.
        """
        return _connect.CTestReportStatistic_getFailures(self)

    def serialize(self, emitter):
        r"""Writes collected data to the given emitter."""
        return _connect.CTestReportStatistic_serialize(self, emitter)
    __swig_destroy__ = _connect.delete_CTestReportStatistic

# Register CTestReportStatistic in _connect:
_connect.CTestReportStatistic_swigregister(CTestReportStatistic)
class CTestFunction(CTestBase):
    r"""
    This class encapsulates information required
    for function call, such as function name and
    parameters. Parameters can be specified either as named
    parameters, or position parameters. Named parameters are stored
    in map as [parameter name, parameter value] pairs, while
    position parameters are stored in vector as a list of
    values. Only one of these two groups of parameters
    may be specified in one specification.

    Default copy ctor may be used.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_FUNC_NAME = _connect.CTestFunction_E_SECTION_FUNC_NAME
    E_SECTION_PARAMS = _connect.CTestFunction_E_SECTION_PARAMS
    E_SECTION_RET_VAL_NAME = _connect.CTestFunction_E_SECTION_RET_VAL_NAME

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestBase class. May
            be specified as NULL if the object is not initialized by parser.
        """
        _connect.CTestFunction_swiginit(self, _connect.new_CTestFunction(*args))

    def createInstance(self, parent):
        return _connect.CTestFunction_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestFunction_cast(testBase)

    def assign(self, src):
        return _connect.CTestFunction_assign(self, src)

    def assignYAMLStyle(self, testFunc):
        return _connect.CTestFunction_assignYAMLStyle(self, testFunc)

    def getName(self):
        r"""Returns name of the function to be executed."""
        return _connect.CTestFunction_getName(self)

    def hasPositionParams(self):
        r"""Returns true, if function has parameters specified."""
        return _connect.CTestFunction_hasPositionParams(self)

    def getPositionParams(self, positionParams):
        r"""
        The given vector is filled with values of positional parameters.

        :type positionParams: :py:class:`StrVector`
        :param positionParams: vector to receive parameters
        """
        return _connect.CTestFunction_getPositionParams(self, positionParams)

    def getRetValueName(self):
        r"""
        Returns the name of the variable, which will be used to store the
          function return value.
        """
        return _connect.CTestFunction_getRetValueName(self)

    def isSerializedAsList(self, isParsing):
        return _connect.CTestFunction_isSerializedAsList(self, isParsing)

    def setName(self, functionName):
        r"""Sets function name."""
        return _connect.CTestFunction_setName(self, functionName)

    def setPositionParameters(self, parameters):
        r"""
        Sets positional parameters.

        :type parameters: :py:class:`StrVector`
        :param parameters:

        See also: getNamedParameters()
        """
        return _connect.CTestFunction_setPositionParameters(self, parameters)

    def setRetValueName(self, retValName):
        r"""
         Sets return value name.
        See also: getRetValueName
        """
        return _connect.CTestFunction_setRetValueName(self, retValName)
    __swig_destroy__ = _connect.delete_CTestFunction

# Register CTestFunction in _connect:
_connect.CTestFunction_swigregister(CTestFunction)
class CTestAssert(CTestBase):
    r"""This class defines assertions for test result."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ASSERT_IS_EXPECT_EXCEPTION = _connect.CTestAssert_E_SECTION_ASSERT_IS_EXPECT_EXCEPTION
    E_SECTION_ASSERT_EXPRESSIONS = _connect.CTestAssert_E_SECTION_ASSERT_EXPRESSIONS

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestAssert_swiginit(self, _connect.new_CTestAssert(*args))
    __swig_destroy__ = _connect.delete_CTestAssert

    def createInstance(self, parent):
        return _connect.CTestAssert_createInstance(self, parent)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAssert_isMerged(self)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAssert_cast(testBase)

    def isExpectException(self):
        r"""
        Returns true, if exception is expected to be thrown from function under test.
        Throws exception if this class is used to store test pre-condition.
        """
        return _connect.CTestAssert_isExpectException(self)

    def setExpectException(self, isExpectException):
        r"""
        Sets whether exception is expected as test result.
        Throws exception if this class is used to store test pre-condition.
        """
        return _connect.CTestAssert_setExpectException(self, isExpectException)

    def getExpressions(self, expressions):
        r"""
        Returns expressions, which are expected to evaluate to
        **true** after test ends.
        """
        return _connect.CTestAssert_getExpressions(self, expressions)

    def setExpressions(self, expressions):
        r"""
        Sets expressions, which are expected to evaluate to
        **true** after test ends.
        """
        return _connect.CTestAssert_setExpressions(self, expressions)

# Register CTestAssert in _connect:
_connect.CTestAssert_swigregister(CTestAssert)
class CTestCase(object):
    r"""
    This class is the main class of the ``isystem.test
    `` framework. It connects together classes with test
    specification and target controllers by providing methods for test
    execution.


    Methods is itestCpp(), and runTest() execute test
    case, while method getTestResults() returns result.


    **Note:** Wrappers for other languages, for example Python and Java, contain
    their replacement of this class.



    Python example for class PTestCase, which replaces this class in Python: _sample_link{itest,itest_sample}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes object with the given connection to winIDEA,
        and host variables.

        |

        *Overload 2:*

        Deprecated: use CTestCase(ConnectionMgrSPtr, CTestHostVarsSPtr) instead
        Initializes object with the given connection to winIDEA.
        """
        _connect.CTestCase_swiginit(self, _connect.new_CTestCase(*args))
    __swig_destroy__ = _connect.delete_CTestCase

    def getTestResults(self, *args):
        r"""
        *Overload 1:*

        This method returns test result based on data stored internally in this class,
        including test specification.

        |

        *Overload 2:*

        **Deprecated**.
        Deprecated: call getTestResults() without parameter instead

        This method returns test result based on data stored internally in this class,
        including test specification.
        """
        return _connect.CTestCase_getTestResults(self, *args)

    def itestCpp(self, *args):
        r"""
        *Overload 1:*

        This method parses test specification given in YAML format, and then calls
        method runTest().

        See also: runTest()

        :type yamlSpec: string
        :param yamlSpec: test specification in YAML format. See
                            User's guide for details.

        :type isDebug: boolean, optional
        :param isDebug: if true, then test is not reset in case of error.
                           If execution stops at user breakpoint, it is then
                           possible to check variables and step through the code.

        |

        *Overload 2:*

        **Deprecated**.
        Deprecated: use itestCpp(yamlSpec, isDebug) instead.

        Return parameter differences contains only the most basic test
        results. Call getTestResult() to get complete information, including
        expression differences.

        :type yamlSpec: string
        :param yamlSpec:    YAML test spec.
        :type differences: :py:class:`StrVector`
        :param differences: after return this vector contains a
                               human readable evaluations of expressions from
                               section assert, which evaluated to false, and
                               values of variables used in the expressions.
        :type isDebug: boolean, optional
        :param isDebug:     Debug.

        |

        *Overload 3:*

        **Deprecated**.
        Deprecated: use itestCpp(yamlSpec, isDebug) instead.

        Return parameter differences contains only the most basic test
        results. Call getTestResult() to get complete information, including
        expression differences.

        :type yamlSpec: string
        :param yamlSpec:    YAML test spec.
        :type differences: :py:class:`StrVector`
        :param differences: after return this vector contains a
                               human readable evaluations of expressions from
                               section assert, which evaluated to false, and
                               values of variables used in the expressions.
        :param isDebug:     Debug.
        """
        return _connect.CTestCase_itestCpp(self, *args)

    def runTest(self, *args):
        r"""
        *Overload 1:*

        Runs single test specification. It sets the environment on the target, calls the
        function to be tested, handles stubs, and finally verifies
        the result. Because of callbacks for ``init, end,
        `` and ``stub`` function, it can be used only
        if callbacks are implemented in C++. If any of these
        methods is specified in test specification (tags
        ``initFunc, endFunc, stub [func]``), method
        setCallbackObject() must be called
        with non-NULL argument before this method.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to be executed

        :type testTimeout: int
        :param testTimeout: test execution timeout in milliseconds. Value 0
                               means infinite timeout.

        :type isDebug: boolean
        :param isDebug: if true, then test is not reset in case of error.
                           If execution stops at user breakpoint, it is then
                           possible to check variables and step through the code.

        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: if not empty, test specification must match the
                              condition specified by the filter to be executed. If
                              empty, no filtering is performed and test spec is executed
                              if not empty or abstract. Empty filter can be created with
                              default ctor CTestFilter().
                              Note: Partition and module are not used for filtering. Call
                              overload with CTestFilterController for complete filtering.

        |

        *Overload 2:*

        Runs single test specification. It sets the environment on the target, calls the
        function to be tested, handles stubs, and finally verifies
        the result. Because of callbacks for ``init, end,
        `` and ``stub`` function, it can be used only
        if callbacks are implemented in C++. If any of these
        methods is specified in test specification (tags
        ``initFunc, endFunc, stub [func]``), method
        setCallbackObject() must be called
        with non-NULL argument before this method.

        Call getTestResults() after this method returns to get test results.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to be executed

        :type testTimeout: int
        :param testTimeout: test execution timeout in milliseconds. Value 0
                               means infinite timeout.

        :type isDebug: boolean
        :param isDebug: if true, then test is not reset in case of error.
                           If execution stops at user breakpoint, it is then
                           possible to check variables and step through the code.

        :type testFilter: :py:class:`CTestFilter`
        :param testFilter: if not empty, test specification must match the
                              condition specified by the filter to be executed. If
                              empty, no filtering is performed and test spec is executed
                              if not empty or abstract. Empty filter can be created with
                              default ctor CTestFilter().
        :type filterCtrl: :py:class:`CTestFilterController`
        :param filterCtrl: class used for performing filtering. If null, no filtering
                              is performed.

        |

        *Overload 3:*

        **Deprecated**.
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Calls runTest()  with empty test filter, which means the
        given test specification is not filtered - if not empty or abstract,
        it is executed.

        |

        *Overload 4:*

        **Deprecated**.
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Calls runTest()  with empty test filter, which means the
        given test specification is not filtered - if not empty or abstract,
        it is executed.

        |

        *Overload 5:*

        **Deprecated**.
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Calls runTest()  with infinite timeout.

        |

        *Overload 6:*

        **Deprecated**.
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead,
                    create empty instance of testFilter with default ctor. CTestFilter().

        Return parameter differences contains only the most basic test
        results. Call getTestResult() to get complete information, including
        expression differences.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec:    Test specification.
        :type differences: :py:class:`StrVector`
        :param differences: after return this vector contains a
                               human readable evaluations of expressions from
                               section assert, which evaluated to false, and
                               values of variables used in the expressions.
        :type testTimeout: int
        :param testTimeout: Timeout.
        :type isDebug: boolean
        :param isDebug:     Debug.
        :type testFilter: :py:class:`CTestFilter`
        :param testFilter:  Test filters.

        |

        *Overload 7:*

        **Deprecated**.
        Deprecated: use runTest(testCase, testTimeout, isDebug, testFilter, filterCtrl) instead
        """
        return _connect.CTestCase_runTest(self, *args)

    @staticmethod
    def getISystemRetValName():
        return _connect.CTestCase_getISystemRetValName()

    def runTest_init_target(self, testSpec, isDebug, isTestBatchOn):
        return _connect.CTestCase_runTest_init_target(self, testSpec, isDebug, isTestBatchOn)

    def runTest_init_test(self, isInitAnalyzers, isMeasureStackUsage, testTimeout):
        return _connect.CTestCase_runTest_init_test(self, isInitAnalyzers, isMeasureStackUsage, testTimeout)

    def runTest_exec_begin(self):
        return _connect.CTestCase_runTest_exec_begin(self)

    def runTest_exec_loopStart(self, testSpec, isResumeCoverage, isStubOrTestPoint):
        return _connect.CTestCase_runTest_exec_loopStart(self, testSpec, isResumeCoverage, isStubOrTestPoint)

    def runTest_exec_waitForStop(self, testSpec, unitTestTimeout):
        return _connect.CTestCase_runTest_exec_waitForStop(self, testSpec, unitTestTimeout)

    def runTest_exec_langSpecific(self):
        return _connect.CTestCase_runTest_exec_langSpecific(self)

    def setTargetException(self, isTargetException):
        return _connect.CTestCase_setTargetException(self, isTargetException)

    def runTest_exec_end(self):
        return _connect.CTestCase_runTest_exec_end(self)

    def runTest_finalize(self, differences, isDryRun, analyzerFilesToMerge):
        return _connect.CTestCase_runTest_finalize(self, differences, isDryRun, analyzerFilesToMerge)

    def handleException(self):
        return _connect.CTestCase_handleException(self)

    def clearTest(self):
        return _connect.CTestCase_clearTest(self)

    def stopTest(self):
        return _connect.CTestCase_stopTest(self)

    def setStopConditionForSysTest(self, testSpec):
        return _connect.CTestCase_setStopConditionForSysTest(self, testSpec)

    def isSystemTestStopOnBP(self):
        return _connect.CTestCase_isSystemTestStopOnBP(self)

    def setStopConditionBP(self, stopCondition, testPointOrTestCaseId):
        return _connect.CTestCase_setStopConditionBP(self, stopCondition, testPointOrTestCaseId)

    def deleteStopConditionBP(self, stopCondition, testPointOrTestCaseId):
        return _connect.CTestCase_deleteStopConditionBP(self, stopCondition, testPointOrTestCaseId)

    def checkStopConditionStop(self, stopCondition):
        return _connect.CTestCase_checkStopConditionStop(self, stopCondition)

    def checkStopConditionExpr(self, stopCondition):
        return _connect.CTestCase_checkStopConditionExpr(self, stopCondition)

    def getTestController(self):
        return _connect.CTestCase_getTestController(self)

    def getDebugFacade(self):
        return _connect.CTestCase_getDebugFacade(self)

    def getHostVars(self):
        return _connect.CTestCase_getHostVars(self)

    def callStubs(self, isRunNativeCustomFunc, scriptParams, tpResult):
        return _connect.CTestCase_callStubs(self, isRunNativeCustomFunc, scriptParams, tpResult)

    def execTestPointEvalAssign(self, testCaseCtrl, scriptParams, tpResult):
        return _connect.CTestCase_execTestPointEvalAssign(self, testCaseCtrl, scriptParams, tpResult)

    def waitForAnalyzerToDownloadData(self, timeout=0):
        return _connect.CTestCase_waitForAnalyzerToDownloadData(self, timeout)

    def logStatus(self, testCaseCtrl, logConfig, section, logResult):
        return _connect.CTestCase_logStatus(self, testCaseCtrl, logConfig, section, logResult)

    def replaceHostVariables(self, expression):
        return _connect.CTestCase_replaceHostVariables(self, expression)

    def runUntilStopPoint(self, stopCondition, testPointOrTestCaseId):
        return _connect.CTestCase_runUntilStopPoint(self, stopCondition, testPointOrTestCaseId)

    @staticmethod
    def applyDryRun(testSpec, mergedTestSpec, result):
        return _connect.CTestCase_applyDryRun(testSpec, mergedTestSpec, result)

    def setEnableStub(self, testSpec, stubbedFunction, isEnabled):
        r"""
        Enables or disables existing stub. Use this method when you know
        the order in which stubs and test points are hit and there are not enough hardware
        breakpoints to enable/disable test points and stubs. This way you can
        keep the number
        of active stubs and test points below the number of available
        hardware breakpoints.

        See also: setEnableTestPoint
        """
        return _connect.CTestCase_setEnableStub(self, testSpec, stubbedFunction, isEnabled)

    def setEnableTestPoint(self, testSpec, tpId, isEnabled):
        r"""
        Enables or disables existing test point. Use this method when you know
        the order in which stubs and test points are hit and there are not enough hardware
        breakpoints to enable/disable test points and stubs. This way you can
        keep the number
        of active stubs and test points below the number of available
        hardware breakpoints.

        See also: setEnableStub
        """
        return _connect.CTestCase_setEnableTestPoint(self, testSpec, tpId, isEnabled)

    def deletePersistentVars(self, persistentVars):
        return _connect.CTestCase_deletePersistentVars(self, persistentVars)

    def clearTestPoints(self):
        return _connect.CTestCase_clearTestPoints(self)

    def closeAnalyzer(self):
        return _connect.CTestCase_closeAnalyzer(self)

# Register CTestCase in _connect:
_connect.CTestCase_swigregister(CTestCase)
class CTestAnalyzer(CTestBase):
    r"""
    This class contains specification for analyzer document.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    M_OFF = _connect.CTestAnalyzer_M_OFF
    r"""analyzer will not be configured or started"""
    M_START = _connect.CTestAnalyzer_M_START
    r"""start analyzer"""
    EUpdate = _connect.CTestAnalyzer_EUpdate
    r"""
    When document is opened, data is not erased.
    The document must exist.
    """
    EWrite = _connect.CTestAnalyzer_EWrite
    r"""
    When document is opened, data is erased,
    configuration is kept. If the doc. does not
    exist, it is created.
    """
    EAppend = _connect.CTestAnalyzer_EAppend
    r"""
    When document is opened, data is preserved,
    start will append new recording to existing
    data. Currently available only for coverage,
    and only when profiler analysis is not performed.
    """
    E_SECTION_RUN_MODE = _connect.CTestAnalyzer_E_SECTION_RUN_MODE
    E_SECTION_DOC_FILE_NAME = _connect.CTestAnalyzer_E_SECTION_DOC_FILE_NAME
    E_SECTION_OPEN_MODE = _connect.CTestAnalyzer_E_SECTION_OPEN_MODE
    E_SECTION_IS_SLOW_RUN = _connect.CTestAnalyzer_E_SECTION_IS_SLOW_RUN
    E_SECTION_TRIGGER = _connect.CTestAnalyzer_E_SECTION_TRIGGER
    E_SECTION_IS_PREDEF_TRIGGER = _connect.CTestAnalyzer_E_SECTION_IS_PREDEF_TRIGGER
    E_SECTION_IS_SAVE_AFTER_TEST = _connect.CTestAnalyzer_E_SECTION_IS_SAVE_AFTER_TEST
    E_SECTION_IS_CLOSE_AFTER_TEST = _connect.CTestAnalyzer_E_SECTION_IS_CLOSE_AFTER_TEST
    E_SECTION_TRACE = _connect.CTestAnalyzer_E_SECTION_TRACE
    E_SECTION_COVERAGE = _connect.CTestAnalyzer_E_SECTION_COVERAGE
    E_SECTION_PROFILER = _connect.CTestAnalyzer_E_SECTION_PROFILER

    def __init__(self, parent):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzer_swiginit(self, _connect.new_CTestAnalyzer(parent))

    def createInstance(self, parent):
        return _connect.CTestAnalyzer_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzer_cast(testBase)

    def getRunMode(self):
        r"""Returns run mode."""
        return _connect.CTestAnalyzer_getRunMode(self)

    def isPredefinedTrigger(self):
        r"""
        Returns E_TRUE, if existing trigger from trd file should be used.
        testIDEA does not modify trigger settings in such case.
        """
        return _connect.CTestAnalyzer_isPredefinedTrigger(self)

    def isSlowRun(self):
        r"""Returns E_TRUE, if slow run should be used for analyzer."""
        return _connect.CTestAnalyzer_isSlowRun(self)

    def getDocumentFileName(self):
        r"""Returns name of the document to contain trace results."""
        return _connect.CTestAnalyzer_getDocumentFileName(self)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAnalyzer_isMerged(self)

    def getOpenMode(self):
        r"""Returns open mode."""
        return _connect.CTestAnalyzer_getOpenMode(self)

    def getTriggerName(self):
        r"""
        Returns the name of the trigger to be used for trace
        start. The trigger should be defined in winIDEA GUI.
        """
        return _connect.CTestAnalyzer_getTriggerName(self)

    def isSaveAfterTest(self):
        r"""Returns true, if the document should be saved after test."""
        return _connect.CTestAnalyzer_isSaveAfterTest(self)

    def isCloseAfterTest(self):
        r"""Returns true, if the document should be closed after test."""
        return _connect.CTestAnalyzer_isCloseAfterTest(self)

    def getTrace(self, isConst):
        r"""Returns trace configuration."""
        return _connect.CTestAnalyzer_getTrace(self, isConst)

    def getCoverage(self, isConst):
        r"""Returns coverage configuration."""
        return _connect.CTestAnalyzer_getCoverage(self, isConst)

    def getProfiler(self, isConst):
        r"""Returns profiler configuration."""
        return _connect.CTestAnalyzer_getProfiler(self, isConst)

    def setPredefinedTrigger(self, isPredefinedTrigger):
        r"""
        If isPredefinedTrigger == E_TRUE, then analyzer trigger is
        not modified by testIDEA. User has to define it in trd file in advance.
        """
        return _connect.CTestAnalyzer_setPredefinedTrigger(self, isPredefinedTrigger)

    def setRunMode(self, mode):
        r"""Sets run mode."""
        return _connect.CTestAnalyzer_setRunMode(self, mode)

    def setSlowRun(self, isSlowRun):
        r"""If parameter is ``true``, then slow run is used for analyzer."""
        return _connect.CTestAnalyzer_setSlowRun(self, isSlowRun)

    def setDocumentFileName(self, docFileName):
        r"""Sets the name of the trace document."""
        return _connect.CTestAnalyzer_setDocumentFileName(self, docFileName)

    def setOpenMode(self, openMode):
        r"""Sets open mode for document."""
        return _connect.CTestAnalyzer_setOpenMode(self, openMode)

    def setTriggerName(self, triggerName):
        r"""
        Sets name of the trigger to be used for trace start. The trigger
        must be defined in winIDEA GUI.
        """
        return _connect.CTestAnalyzer_setTriggerName(self, triggerName)

    def setSaveAfterTest(self, isSave):
        r"""Sets save operation for trace document after test."""
        return _connect.CTestAnalyzer_setSaveAfterTest(self, isSave)

    def setCloseAfterTest(self, isClose):
        r"""Sets close  operation for trace document after test."""
        return _connect.CTestAnalyzer_setCloseAfterTest(self, isClose)
    __swig_destroy__ = _connect.delete_CTestAnalyzer

# Register CTestAnalyzer in _connect:
_connect.CTestAnalyzer_swigregister(CTestAnalyzer)
class CTestAnalyzerTrace(CTestBase):
    r"""
    This class contains specification for trace recording during
    test execution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EX_TrcAsText = _connect.CTestAnalyzerTrace_EX_TrcAsText
    EX_TrcAsCSV = _connect.CTestAnalyzerTrace_EX_TrcAsCSV
    EX_TrcAsBinary = _connect.CTestAnalyzerTrace_EX_TrcAsBinary
    EX_TrcAsXML = _connect.CTestAnalyzerTrace_EX_TrcAsXML
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerTrace_E_SECTION_IS_ACTIVE
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerTrace_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerTrace_E_SECTION_EXPORT_FILE

    def __init__(self, parent):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzerTrace_swiginit(self, _connect.new_CTestAnalyzerTrace(parent))

    def createInstance(self, parent):
        return _connect.CTestAnalyzerTrace_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzerTrace_cast(testBase)

    def isMerged(self):
        return _connect.CTestAnalyzerTrace_isMerged(self)

    def isActive(self):
        r"""
        Returns E_TRUE if this section is active (export is performed,
        and analysis is run for coverage and profiler).
        """
        return _connect.CTestAnalyzerTrace_isActive(self)

    def getExportFormat(self):
        r"""Returns the export format type. See CAnalyzerDocController for possible values."""
        return _connect.CTestAnalyzerTrace_getExportFormat(self)

    def getExportFileName(self):
        r"""Returns the export file name."""
        return _connect.CTestAnalyzerTrace_getExportFileName(self)

    def setActive(self, isActive):
        r"""
        If ``isActive`` == ``true``, recording is exported and
        analysis is performed.
        """
        return _connect.CTestAnalyzerTrace_setActive(self, isActive)

    def setExportFormat(self, exportFormat):
        r"""
        Sets export format for the trace document. See CAnalyzerDocController
        for possible values.
        """
        return _connect.CTestAnalyzerTrace_setExportFormat(self, exportFormat)

    def setExportFileName(self, exportFileName):
        r"""Sets the export file name."""
        return _connect.CTestAnalyzerTrace_setExportFileName(self, exportFileName)
    __swig_destroy__ = _connect.delete_CTestAnalyzerTrace

# Register CTestAnalyzerTrace in _connect:
_connect.CTestAnalyzerTrace_swigregister(CTestAnalyzerTrace)
class CTestAnalyzerCoverage(CTestBase):
    r"""
    This class contains specification for coverage recording during
    test execution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EX_CCAsHTML = _connect.CTestAnalyzerCoverage_EX_CCAsHTML
    EX_CCAsText = _connect.CTestAnalyzerCoverage_EX_CCAsText
    EX_CCAsCSV = _connect.CTestAnalyzerCoverage_EX_CCAsCSV
    EX_CCAsXML = _connect.CTestAnalyzerCoverage_EX_CCAsXML
    EX_CCAsReviewHTML = _connect.CTestAnalyzerCoverage_EX_CCAsReviewHTML
    EX_CCAsReviewText = _connect.CTestAnalyzerCoverage_EX_CCAsReviewText
    ENone = _connect.CTestAnalyzerCoverage_ENone
    r"""no merging is performed"""
    ESiblingsOnly = _connect.CTestAnalyzerCoverage_ESiblingsOnly
    r"""only coverage of test cases with the same immediate parent and their children get merged"""
    ESiblingsAndParent = _connect.CTestAnalyzerCoverage_ESiblingsAndParent
    r"""only coverage of parent and test cases with the same immediate parent and their children get merged"""
    EAll = _connect.CTestAnalyzerCoverage_EAll
    r"""coverage of all test cases executed so far will be merged."""
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerCoverage_E_SECTION_IS_ACTIVE
    E_SECTION_IS_MEASURE_ALL_FUNCTIONS = _connect.CTestAnalyzerCoverage_E_SECTION_IS_MEASURE_ALL_FUNCTIONS
    E_SECTION_IS_IGNORE_UNREACHABLE_CODE = _connect.CTestAnalyzerCoverage_E_SECTION_IS_IGNORE_UNREACHABLE_CODE
    E_SECTION_MERGE_SCOPE = _connect.CTestAnalyzerCoverage_E_SECTION_MERGE_SCOPE
    E_SECTION_MERGE_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_MERGE_FILTER
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXFMT_VARIANT = _connect.CTestAnalyzerCoverage_E_SECTION_EXFMT_VARIANT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FILE
    E_SECTION_IS_ASSEMBLER_INFO = _connect.CTestAnalyzerCoverage_E_SECTION_IS_ASSEMBLER_INFO
    E_SECTION_IS_LAUNCH_VIEWER = _connect.CTestAnalyzerCoverage_E_SECTION_IS_LAUNCH_VIEWER
    E_SECTION_IS_EXPORT_MODULE_LINES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_MODULE_LINES
    E_SECTION_IS_EXPORT_SOURCES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_SOURCES
    E_SECTION_IS_EXPORT_FUNCTION_LINES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_FUNCTION_LINES
    E_SECTION_IS_EXPORT_ASM = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_ASM
    E_SECTION_IS_EXPORT_RANGES = _connect.CTestAnalyzerCoverage_E_SECTION_IS_EXPORT_RANGES
    E_SECTION_EXPORT_FUNCTIONS_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_FUNCTIONS_FILTER
    E_SECTION_EXPORT_MODULES_FILTER = _connect.CTestAnalyzerCoverage_E_SECTION_EXPORT_MODULES_FILTER
    E_SECTION_STATISTICS = _connect.CTestAnalyzerCoverage_E_SECTION_STATISTICS

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance with NULL parent.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzerCoverage_swiginit(self, _connect.new_CTestAnalyzerCoverage(*args))

    def createInstance(self, parent):
        r"""
        Creates new empty instance of this class. Can be used when we only have
        pointer to base but want to get instance of derived class.
        """
        return _connect.CTestAnalyzerCoverage_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzerCoverage_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAnalyzerCoverage_isMerged(self)

    def assignStatistics(self, src):
        r"""This method copies statistics data from the object given as parameter to this object."""
        return _connect.CTestAnalyzerCoverage_assignStatistics(self, src)

    def isActive(self):
        r"""
        Returns E_TRUE if this section is active (export is performed,
        and analysis is run for coverage and profiler).
        """
        return _connect.CTestAnalyzerCoverage_isActive(self)

    def isMeasureAllFunctions(self):
        r"""
        Returns E_TRUE, if all functions should be measured, not only ones from
        statistics list. If E_FALSE is returned, only functions from statistics list
        will be measured.
        """
        return _connect.CTestAnalyzerCoverage_isMeasureAllFunctions(self)

    def isIgnoreNonReachableCode(self):
        r"""
        Returns true, if the code inside the function which is not reachable by
        sequential or (conditional)direct branch flow is not considered for coverage statistics.
        """
        return _connect.CTestAnalyzerCoverage_isIgnoreNonReachableCode(self)

    def getMergeScope(self):
        r"""Returns coverage merge scope."""
        return _connect.CTestAnalyzerCoverage_getMergeScope(self)

    def getMergeFilter(self, isConst):
        r"""
        Returns coverage merge filer. Test cases included in
        merge scope are included in merge only if they
        match this filter.
        """
        return _connect.CTestAnalyzerCoverage_getMergeFilter(self, isConst)

    def getExportFormat(self):
        r"""Returns the export format. Empty string means XML format."""
        return _connect.CTestAnalyzerCoverage_getExportFormat(self)

    def getExportFormatVariant(self):
        r"""Returns the export format variant. Empty string means the 'default' variant."""
        return _connect.CTestAnalyzerCoverage_getExportFormatVariant(self)

    def getExportFileName(self):
        r"""Returns the export file name. If empty, no export is performed."""
        return _connect.CTestAnalyzerCoverage_getExportFileName(self)

    def isProvideAssemblerInfo(self):
        r"""
        Returns ETrue, if assembly level coverage should be performed.
        EDefault means that assembly level coverage will **not** be performed.
        """
        return _connect.CTestAnalyzerCoverage_isProvideAssemblerInfo(self)

    def isLaunchViewer(self):
        r"""Returns true, if viewer should be launched after coverage."""
        return _connect.CTestAnalyzerCoverage_isLaunchViewer(self)

    def isExportModuleLines(self):
        r"""Returns true, if module lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportModuleLines(self)

    def isExportSources(self):
        r"""Returns true, if source files coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportSources(self)

    def isExportFunctionLines(self):
        r"""Returns true, if function lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportFunctionLines(self)

    def isExportAsm(self):
        r"""Returns true, if assembler coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportAsm(self)

    def isExportRanges(self):
        r"""Returns true, if ranges coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_isExportRanges(self)

    def getExportFunctionsFilter(self):
        r"""Returns filter for functions export."""
        return _connect.CTestAnalyzerCoverage_getExportFunctionsFilter(self)

    def getExportModulesFilter(self):
        r"""Returns filter for modules export."""
        return _connect.CTestAnalyzerCoverage_getExportModulesFilter(self)

    def getStatisticsList(self, isConst):
        r"""Returns vector of coverage statistic items."""
        return _connect.CTestAnalyzerCoverage_getStatisticsList(self, isConst)

    def findStatistic(self, functionName):
        r"""
        Returns index of statistics for the given function, or -1 if no such
        function exists.
        """
        return _connect.CTestAnalyzerCoverage_findStatistic(self, functionName)

    def getStatistics(self, idx):
        r"""Returns the requested statistics."""
        return _connect.CTestAnalyzerCoverage_getStatistics(self, idx)

    def swapStatistics(self, idx1, idx2):
        r"""Swaps two statistics in the list."""
        return _connect.CTestAnalyzerCoverage_swapStatistics(self, idx1, idx2)

    def setActive(self, isActive):
        r"""
        If ``isActive`` == ``true``, recording is exported and
        analysis is performed.
        """
        return _connect.CTestAnalyzerCoverage_setActive(self, isActive)

    def setMeasureAllFunctions(self, isMeasureAllFunctions):
        r"""
        :type isMeasureAllFunctions: int
        :param isMeasureAllFunctions: if E_TRUE, all functions should be
            measured, not only ones from
            statistics list. If E_FALSE, only functions from statistics list
            will be measured.
        """
        return _connect.CTestAnalyzerCoverage_setMeasureAllFunctions(self, isMeasureAllFunctions)

    def setExportFormat(self, format):
        r"""Sets format variant of the export format."""
        return _connect.CTestAnalyzerCoverage_setExportFormat(self, format)

    def setExportFormatVariant(self, variant):
        r"""Sets format variant of the export format."""
        return _connect.CTestAnalyzerCoverage_setExportFormatVariant(self, variant)

    def setExportFileName(self, file):
        r"""Sets format variant of the export format."""
        return _connect.CTestAnalyzerCoverage_setExportFileName(self, file)

    def setAssemblyInfo(self, isAssemblyInfo):
        r"""
        Sets whether assembly information should be provided with coverage.
        :type isAssemblyInfo: int
        :param isAssemblyInfo: if EDefault assembly information will **not** be
                                  provided with coverage.
        """
        return _connect.CTestAnalyzerCoverage_setAssemblyInfo(self, isAssemblyInfo)

    def setLaunchViewer(self, isLaunchViewer):
        r"""Sets whether viewer should be launched after coverage."""
        return _connect.CTestAnalyzerCoverage_setLaunchViewer(self, isLaunchViewer)

    def setExportModuleLines(self, isExportModuleLines):
        r"""Sets whether module lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportModuleLines(self, isExportModuleLines)

    def setExportSources(self, isExportSources):
        r"""Sets whether source files coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportSources(self, isExportSources)

    def setExportFunctionLines(self, isExportFunctionLines):
        r"""Sets whether function lines coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportFunctionLines(self, isExportFunctionLines)

    def setExportAsm(self, isExportAsm):
        r"""Sets whether assembler coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportAsm(self, isExportAsm)

    def setExportRanges(self, isExportRanges):
        r"""Sets whether ranges coverage should be exported."""
        return _connect.CTestAnalyzerCoverage_setExportRanges(self, isExportRanges)

    def setExportFunctionsFilter(self, filter):
        r"""Sets filter for functions export."""
        return _connect.CTestAnalyzerCoverage_setExportFunctionsFilter(self, filter)

    def setExportModulesFilter(self, filter):
        r"""Sets filter for modules export."""
        return _connect.CTestAnalyzerCoverage_setExportModulesFilter(self, filter)
    __swig_destroy__ = _connect.delete_CTestAnalyzerCoverage

# Register CTestAnalyzerCoverage in _connect:
_connect.CTestAnalyzerCoverage_swigregister(CTestAnalyzerCoverage)
class CTestAnalyzerProfiler(CTestBase):
    r"""
    This class contains specification for profiler recording during
    test execution.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DATA_AREA = _connect.CTestAnalyzerProfiler_DATA_AREA
    r"""profiler data area"""
    CODE_AREA = _connect.CTestAnalyzerProfiler_CODE_AREA
    r"""profiler code area"""
    EProfilerAsText = _connect.CTestAnalyzerProfiler_EProfilerAsText
    EProfilerAsXML = _connect.CTestAnalyzerProfiler_EProfilerAsXML
    EProfilerAsCSV = _connect.CTestAnalyzerProfiler_EProfilerAsCSV
    EProfilerAsText1 = _connect.CTestAnalyzerProfiler_EProfilerAsText1
    EProfilerAsXMLBinaryTimeline = _connect.CTestAnalyzerProfiler_EProfilerAsXMLBinaryTimeline
    EProfilerAsBTF = _connect.CTestAnalyzerProfiler_EProfilerAsBTF
    EProfilerAsMDF = _connect.CTestAnalyzerProfiler_EProfilerAsMDF
    E_SECTION_IS_ACTIVE = _connect.CTestAnalyzerProfiler_E_SECTION_IS_ACTIVE
    E_SECTION_IS_MEASURE_ALL_FUNCTIONS = _connect.CTestAnalyzerProfiler_E_SECTION_IS_MEASURE_ALL_FUNCTIONS
    E_SECTION_EXPORT_FORMAT = _connect.CTestAnalyzerProfiler_E_SECTION_EXPORT_FORMAT
    E_SECTION_EXPORT_FILE = _connect.CTestAnalyzerProfiler_E_SECTION_EXPORT_FILE
    E_SECTION_IS_EXPORT_ACTIVE_AREAS_ONLY = _connect.CTestAnalyzerProfiler_E_SECTION_IS_EXPORT_ACTIVE_AREAS_ONLY
    E_SECTION_IS_PROFILE_AUX = _connect.CTestAnalyzerProfiler_E_SECTION_IS_PROFILE_AUX
    E_SECTION_IS_SAVE_HISTORY = _connect.CTestAnalyzerProfiler_E_SECTION_IS_SAVE_HISTORY
    E_SECTION_CODE_AREAS = _connect.CTestAnalyzerProfiler_E_SECTION_CODE_AREAS
    E_SECTION_DATA_AREAS = _connect.CTestAnalyzerProfiler_E_SECTION_DATA_AREAS

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestAnalyzerProfiler_swiginit(self, _connect.new_CTestAnalyzerProfiler(*args))

    def createInstance(self, parent):
        r"""Creates a new empty instance of this class."""
        return _connect.CTestAnalyzerProfiler_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestAnalyzerProfiler_cast(testBase)

    def assignCodeAreas(self, src):
        r"""This method copies code areas from src to this object."""
        return _connect.CTestAnalyzerProfiler_assignCodeAreas(self, src)

    def assignDataAreas(self, src):
        r"""This method copies code areas from src to this object."""
        return _connect.CTestAnalyzerProfiler_assignDataAreas(self, src)

    def isActive(self):
        r"""
        Returns E_TRUE if this section is active (export is performed,
        and analysis is run for coverage and profiler).
        """
        return _connect.CTestAnalyzerProfiler_isActive(self)

    def isMeasureAllFunctions(self):
        r"""
        Returns E_TRUE, if all functions should be measured, not only ones from
        code areas list. If E_FALSE is returned, only functions from code areas list
        will be measured.
        """
        return _connect.CTestAnalyzerProfiler_isMeasureAllFunctions(self)

    def isMerged(self):
        r"""
        Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestAnalyzerProfiler_isMerged(self)

    def getExportFormat(self):
        r"""Returns the export format. Empty string means XML format."""
        return _connect.CTestAnalyzerProfiler_getExportFormat(self)

    def getExportFileName(self):
        r"""Returns the export file name. If empty, no export is performed."""
        return _connect.CTestAnalyzerProfiler_getExportFileName(self)

    def isExportActiveAreasOnly(self):
        r"""
        Returns true, when only areas with recoded activity will be exported.
        Returns false, if all configured areas will be exported.
        """
        return _connect.CTestAnalyzerProfiler_isExportActiveAreasOnly(self)

    def isProfileAUX(self):
        r"""Returns true, if AUX signals should be recorded during profiler session."""
        return _connect.CTestAnalyzerProfiler_isProfileAUX(self)

    def isSaveHistory(self):
        r"""Returns true, if profiler history should also be saved to output file."""
        return _connect.CTestAnalyzerProfiler_isSaveHistory(self)

    def getAreas(self, areaType, isConst):
        r"""Returns areas of the given type."""
        return _connect.CTestAnalyzerProfiler_getAreas(self, areaType, isConst)

    def getCodeAreas(self, isConst):
        r"""
        Returns code areas specified for profiler. The returned list contains instances
        of CTestProfilerStatisticsSPtr.
        """
        return _connect.CTestAnalyzerProfiler_getCodeAreas(self, isConst)

    def getDataAreas(self, isConst):
        r"""
        Returns code areas specified for profiler. The returned list contains instances
        of CTestProfilerStatisticsSPtr.
        """
        return _connect.CTestAnalyzerProfiler_getDataAreas(self, isConst)

    def findArea(self, *args):
        r"""
        *Overload 1:*

        Returns index of the area or -1 if the area is not found.

        :type areaType: int
        :param areaType: if set to DATA_AREA, then only data areas
                            without value set can match.
        :type areaName: string
        :param areaName:

        |

        *Overload 2:*

        Returns index of the data area, or -1 if the area is not found.
        This method searches for data areas with value set.
        """
        return _connect.CTestAnalyzerProfiler_findArea(self, *args)

    def getArea(self, areaType, idx):
        r"""Returns the requested area."""
        return _connect.CTestAnalyzerProfiler_getArea(self, areaType, idx)

    def swapAreas(self, areaType, idx1, idx2):
        r"""Swaps two areas in the list."""
        return _connect.CTestAnalyzerProfiler_swapAreas(self, areaType, idx1, idx2)

    def setActive(self, isActive):
        r"""
        If ``isActive`` == ``true``, recording is exported and
        analysis is performed.
        """
        return _connect.CTestAnalyzerProfiler_setActive(self, isActive)

    def setMeasureAllFunctions(self, isMeasureAllFunctions):
        r"""
        :type isMeasureAllFunctions: int
        :param isMeasureAllFunctions: if E_TRUE, all functions should be
            measured, not only ones from
            code areas list. If E_FALSE, only functions from code areas list
            will be measured.
        """
        return _connect.CTestAnalyzerProfiler_setMeasureAllFunctions(self, isMeasureAllFunctions)

    def setExportFormat(self, exportFormat):
        r"""Sets format variant of the export format."""
        return _connect.CTestAnalyzerProfiler_setExportFormat(self, exportFormat)

    def setExportFileName(self, file):
        r"""Sets format variant of the export format."""
        return _connect.CTestAnalyzerProfiler_setExportFileName(self, file)

    def setExportActiveAreasOnly(self, isExportActiveAreasOnly):
        r"""
        If ``isExportActiveAreasOnly`` is true, then only areas with
        recorded activity (executed functions and modified data) will
        be exported. Otherwise all configured areas will be exported.
        """
        return _connect.CTestAnalyzerProfiler_setExportActiveAreasOnly(self, isExportActiveAreasOnly)

    def setProfileAUX(self, isProfileAUX):
        r"""If parameter is ``true``, then AUX signals are recorded during profiling."""
        return _connect.CTestAnalyzerProfiler_setProfileAUX(self, isProfileAUX)

    def setSaveHistory(self, isSave):
        r"""Sets the save mode for output file. If true, history will also be saved."""
        return _connect.CTestAnalyzerProfiler_setSaveHistory(self, isSave)

    def setCodeAreas(self, arg2):
        r"""Sets code areas for profiler."""
        return _connect.CTestAnalyzerProfiler_setCodeAreas(self, arg2)

    def setDataAreas(self, arg2):
        r"""Sets data areas for profiler."""
        return _connect.CTestAnalyzerProfiler_setDataAreas(self, arg2)
    __swig_destroy__ = _connect.delete_CTestAnalyzerProfiler

# Register CTestAnalyzerProfiler in _connect:
_connect.CTestAnalyzerProfiler_swigregister(CTestAnalyzerProfiler)
class CTestCoverageStatistics(CTestBase):
    r"""
    This class contains coverage requirements. If function name is not specified, function under test
    is assumed. This is serializable version of CCoverageStatistics2.
    This class is aggregated by CTestAnalyzerCoverage (values are specified in
    percentage) and CTestCoverageResult.
    All results are set and returned in percentage, which means in range [0%..100%].
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_FUNC_NAME = _connect.CTestCoverageStatistics_E_SECTION_FUNC_NAME
    E_SECTION_BYTES_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_BYTES_EXECUTED
    E_SECTION_SOURCE_LINES_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_SOURCE_LINES_EXECUTED
    E_SECTION_BRANCH_EXECUTED = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_EXECUTED
    E_SECTION_BRANCH_TAKEN = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_TAKEN
    E_SECTION_BRANCH_NOT_TAKEN = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_NOT_TAKEN
    E_SECTION_BRANCH_BOTH = _connect.CTestCoverageStatistics_E_SECTION_BRANCH_BOTH
    E_SECTION_EXECUTION_COUNT = _connect.CTestCoverageStatistics_E_SECTION_EXECUTION_COUNT
    E_SECTION_CALL_COUNT = _connect.CTestCoverageStatistics_E_SECTION_CALL_COUNT
    E_SECTION_MC_DC = _connect.CTestCoverageStatistics_E_SECTION_MC_DC

    def __init__(self, *args):
        _connect.CTestCoverageStatistics_swiginit(self, _connect.new_CTestCoverageStatistics(*args))
    __swig_destroy__ = _connect.delete_CTestCoverageStatistics

    def createInstance(self, parent):
        return _connect.CTestCoverageStatistics_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestCoverageStatistics_cast(testBase)

    def getFunctionName(self):
        r"""Returns function name."""
        return _connect.CTestCoverageStatistics_getFunctionName(self)

    def getSourceLinesExecuted(self):
        r"""Returns the ratio of source lines to be executed in %."""
        return _connect.CTestCoverageStatistics_getSourceLinesExecuted(self)

    def getBytesExecuted(self):
        r"""Returns the ratio of bytes to be executed in %."""
        return _connect.CTestCoverageStatistics_getBytesExecuted(self)

    def getBranchExecuted(self):
        r"""Returns the ratio of branches to be executed in %."""
        return _connect.CTestCoverageStatistics_getBranchExecuted(self)

    def getBranchTaken(self):
        r"""Returns the ratio of branches to be taken in %."""
        return _connect.CTestCoverageStatistics_getBranchTaken(self)

    def getBranchNotTaken(self):
        r"""Returns the ratio of branches not to be taken in %."""
        return _connect.CTestCoverageStatistics_getBranchNotTaken(self)

    def getBranchBoth(self):
        r"""Returns the ratio of branches to be executed both ways in %."""
        return _connect.CTestCoverageStatistics_getBranchBoth(self)

    def getExecutionCount(self):
        r"""Returns how may times the item was executed."""
        return _connect.CTestCoverageStatistics_getExecutionCount(self)

    def getBytesExecutedText(self):
        r"""Returns true if MC/DC coverage is required."""
        return _connect.CTestCoverageStatistics_getBytesExecutedText(self)

    def getSourceLinesExecutedText(self):
        return _connect.CTestCoverageStatistics_getSourceLinesExecutedText(self)

    def getBranchExecutedText(self):
        return _connect.CTestCoverageStatistics_getBranchExecutedText(self)

    def getBranchTakenText(self):
        return _connect.CTestCoverageStatistics_getBranchTakenText(self)

    def getBranchNotTakenText(self):
        return _connect.CTestCoverageStatistics_getBranchNotTakenText(self)

    def getBranchBothText(self):
        return _connect.CTestCoverageStatistics_getBranchBothText(self)

    def setFunctionName(self, functionName):
        r"""Sets the name of the function to be covered."""
        return _connect.CTestCoverageStatistics_setFunctionName(self, functionName)

    def setCodeExecuted(self, codeExecuted):
        r"""Sets the amount of code executed in %."""
        return _connect.CTestCoverageStatistics_setCodeExecuted(self, codeExecuted)

    def setSourceLinesExecuted(self, codeExecuted):
        r"""Sets the amount of source lines executed in %."""
        return _connect.CTestCoverageStatistics_setSourceLinesExecuted(self, codeExecuted)

    def setBranchExecuted(self, branchExecuted):
        r"""Sets the number of branches executed in %."""
        return _connect.CTestCoverageStatistics_setBranchExecuted(self, branchExecuted)

    def setBranchTaken(self, branchTaken):
        r"""Sets the number of branches taken in %."""
        return _connect.CTestCoverageStatistics_setBranchTaken(self, branchTaken)

    def setBranchNotTaken(self, branchNotTaken):
        r"""Sets the number of branches not taken in %."""
        return _connect.CTestCoverageStatistics_setBranchNotTaken(self, branchNotTaken)

    def setBranchBoth(self, branchBoth):
        r"""Sets the number of branches taken both ways in %."""
        return _connect.CTestCoverageStatistics_setBranchBoth(self, branchBoth)

# Register CTestCoverageStatistics in _connect:
_connect.CTestCoverageStatistics_swigregister(CTestCoverageStatistics)
class CTestProfilerTime(CTestBase):
    r"""
    This class stores expected profiler results for one time type (net, call, gross, ...).


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_MIN_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_TIME
    r"""min time ID"""
    E_SECTION_MIN_START_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_START_TIME
    r"""min start time ID"""
    E_SECTION_MIN_END_TIME = _connect.CTestProfilerTime_E_SECTION_MIN_END_TIME
    r"""min end time ID"""
    E_SECTION_MAX_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_TIME
    r"""max time ID"""
    E_SECTION_MAX_START_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_START_TIME
    r"""max start time ID"""
    E_SECTION_MAX_END_TIME = _connect.CTestProfilerTime_E_SECTION_MAX_END_TIME
    r"""max end time ID"""
    E_SECTION_TOTAL_TIME = _connect.CTestProfilerTime_E_SECTION_TOTAL_TIME
    r"""total time ID"""
    E_SECTION_AVERAGE_TIME = _connect.CTestProfilerTime_E_SECTION_AVERAGE_TIME
    r"""average time ID"""

    def __init__(self, *args):
        _connect.CTestProfilerTime_swiginit(self, _connect.new_CTestProfilerTime(*args))
    __swig_destroy__ = _connect.delete_CTestProfilerTime

    def createInstance(self, parent):
        return _connect.CTestProfilerTime_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestProfilerTime_cast(testBase)

    def getTime(self, profilerStatSectionId, idx):
        r"""
         Returns expected interval boundary for the given time type.

        :type profilerStatSectionId: int
        :param profilerStatSectionId: ID of profiler time section.
        :type idx: int
        :param idx: should be 0 for lower boundary, 1 for upper boundary
        """
        return _connect.CTestProfilerTime_getTime(self, profilerStatSectionId, idx)

    def setTime(self, profilerStatSectionId, time, idx):
        r"""Sets time for the given section."""
        return _connect.CTestProfilerTime_setTime(self, profilerStatSectionId, time, idx)

    @staticmethod
    def a2d(strNum):
        r"""
        Converts string to double.

        :type strNum: string
        :param strNum: string number, which may contain underscores for better readability,
                          and may have time unit appended: ns, us, ms, s. If there is no
                          unit appended, ns is assumed. Underscore is not allowed as the
                          first character.
        """
        return _connect.CTestProfilerTime_a2d(strNum)

# Register CTestProfilerTime in _connect:
_connect.CTestProfilerTime_swigregister(CTestProfilerTime)
class CTestProfilerStatistics(CTestBase):
    r"""
    This class stores expected profiler results for one area.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_AREA_NAME = _connect.CTestProfilerStatistics_E_SECTION_AREA_NAME
    E_SECTION_AREA_VALUE = _connect.CTestProfilerStatistics_E_SECTION_AREA_VALUE
    E_SECTION_NET_TIME = _connect.CTestProfilerStatistics_E_SECTION_NET_TIME
    r"""net time ID"""
    E_SECTION_GROSS_TIME = _connect.CTestProfilerStatistics_E_SECTION_GROSS_TIME
    r"""gross time ID"""
    E_SECTION_CALL_TIME = _connect.CTestProfilerStatistics_E_SECTION_CALL_TIME
    r"""call time ID"""
    E_SECTION_PERIOD_TIME = _connect.CTestProfilerStatistics_E_SECTION_PERIOD_TIME
    r"""period time ID"""
    E_SECTION_OUTSIDE_TIME = _connect.CTestProfilerStatistics_E_SECTION_OUTSIDE_TIME
    r"""outside time ID"""
    E_SECTION_HITS = _connect.CTestProfilerStatistics_E_SECTION_HITS
    E_SECTION_MIN_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_MIN_AREA_TIME
    E_SECTION_MAX_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_MAX_AREA_TIME
    E_SECTION_TOTAL_AREA_TIME = _connect.CTestProfilerStatistics_E_SECTION_TOTAL_AREA_TIME

    def __init__(self, *args):
        _connect.CTestProfilerStatistics_swiginit(self, _connect.new_CTestProfilerStatistics(*args))
    __swig_destroy__ = _connect.delete_CTestProfilerStatistics

    def createInstance(self, parent):
        return _connect.CTestProfilerStatistics_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestProfilerStatistics_cast(testBase)

    def getAreaName(self):
        r"""Returns area name."""
        return _connect.CTestProfilerStatistics_getAreaName(self)

    def getAreaValue(self):
        r"""Returns area value."""
        return _connect.CTestProfilerStatistics_getAreaValue(self)

    def getTime(self, sectionId, isConst):
        r"""Returns expected time interval for the given time scope."""
        return _connect.CTestProfilerStatistics_getTime(self, sectionId, isConst)

    def getHits(self, idx):
        r"""
        Returns limit for hits.

        :type idx: int
        :param idx: should be 0 for lower boundary, 1 for upper boundary
        """
        return _connect.CTestProfilerStatistics_getHits(self, idx)

    def isAreaValueSet(self):
        r"""
        Returns true, if value is set, false otherwise. Returns ``true`` after call to
        setAreaValue().
        """
        return _connect.CTestProfilerStatistics_isAreaValueSet(self)

    def isAreaValueNumber(self):
        r"""Returns true, if area value is set, _and_ it is a number."""
        return _connect.CTestProfilerStatistics_isAreaValueNumber(self)

    def setAreaName(self, areaName):
        r"""Sets area name."""
        return _connect.CTestProfilerStatistics_setAreaName(self, areaName)

    def setAreaValue(self, value):
        r"""Sets area value."""
        return _connect.CTestProfilerStatistics_setAreaValue(self, value)

    def clearAreaValue(self):
        r"""
        Marks area value as not set. If it is not set, statistics limits are used
        for all values not explicitly set in test specification. See YAML test
        spec, item ``value`` in ``profiler`` section for example.

        See also: isAreaValueSet()
        """
        return _connect.CTestProfilerStatistics_clearAreaValue(self)

    def setHits(self, limits, idx):
        r"""Sets hits number - how many times function was called or state variable changed."""
        return _connect.CTestProfilerStatistics_setHits(self, limits, idx)

    def getQualifiedAreaName(self, defaultDownloadFile):
        r"""
        Returns area name with default download file appended, if there is
        currently no download file specified in area name.
        """
        return _connect.CTestProfilerStatistics_getQualifiedAreaName(self, defaultDownloadFile)

    def getQualifiedAreaNameForStateVar(self, defaultDownloadFile):
        r"""
        Returns area name with default download file appended, if there is
        currently no download file specified in area name. For state variables
        '%' and area value are appended, if defined.
        """
        return _connect.CTestProfilerStatistics_getQualifiedAreaNameForStateVar(self, defaultDownloadFile)

    def createTestBase(self, section, lineNo):
        return _connect.CTestProfilerStatistics_createTestBase(self, section, lineNo)

# Register CTestProfilerStatistics in _connect:
_connect.CTestProfilerStatistics_swigregister(CTestProfilerStatistics)
class CTestCoverageResult(CTestBase):
    r"""This class contains coverage results."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_BYTES_ALL = _connect.CTestCoverageResult_E_SECTION_BYTES_ALL
    E_SECTION_LINES_ALL = _connect.CTestCoverageResult_E_SECTION_LINES_ALL
    E_SECTION_CONDITIONS_ALL = _connect.CTestCoverageResult_E_SECTION_CONDITIONS_ALL
    E_SECTION_COVERAGE_STATS_EXPECTED = _connect.CTestCoverageResult_E_SECTION_COVERAGE_STATS_EXPECTED
    E_SECTION_COVERAGE_STATS_MEASURED = _connect.CTestCoverageResult_E_SECTION_COVERAGE_STATS_MEASURED

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to parent or empty shared ptr.
        """
        _connect.CTestCoverageResult_swiginit(self, _connect.new_CTestCoverageResult(*args))
    __swig_destroy__ = _connect.delete_CTestCoverageResult

    def createInstance(self, parent):
        return _connect.CTestCoverageResult_createInstance(self, parent)

    def isMerged(self):
        r"""Overrides base method, always returns false, because results can't be merged."""
        return _connect.CTestCoverageResult_isMerged(self)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestCoverageResult_cast(testBase)

    def getExpectedCoverage(self, isConst):
        r"""Returns object containing expected coverage values."""
        return _connect.CTestCoverageResult_getExpectedCoverage(self, isConst)

    def getMeasuredCoverage(self, isConst):
        r"""Returns object containing measured coverage values."""
        return _connect.CTestCoverageResult_getMeasuredCoverage(self, isConst)

    def getMeasuredResults(self):
        r"""
        Deprecated: since 9.12.268 (2015-12). Call  getMeasuredCoverage() and getMeasured() instead.

        Returns measured data.
        """
        return _connect.CTestCoverageResult_getMeasuredResults(self)

    def getMeasured(self, section):
        r"""
        Returns measured value for the given section.
        :type section: int
        :param section: scalar ID from ESectionCoverageResult:
                   E_SECTION_BYTES_ALL, E_SECTION_LINES_ALL, E_SECTION_CONDITIONS_ALL.
        """
        return _connect.CTestCoverageResult_getMeasured(self, section)

    def isError(self):
        r"""Returns true, if any error of more specific errors occurred."""
        return _connect.CTestCoverageResult_isError(self)

    def isBytesExecutedError(self):
        r"""Returns true, if not enough bytes were executed."""
        return _connect.CTestCoverageResult_isBytesExecutedError(self)

    def isSourceLinesExecutedError(self):
        r"""Returns true, if not enough source lines were executed."""
        return _connect.CTestCoverageResult_isSourceLinesExecutedError(self)

    def isBranchesExecutedError(self):
        r"""Returns true, if not enough branches were executed."""
        return _connect.CTestCoverageResult_isBranchesExecutedError(self)

    def isBranchesTakenError(self):
        r"""Returns true, if not enough branches were taken."""
        return _connect.CTestCoverageResult_isBranchesTakenError(self)

    def isBranchesNotTakenError(self):
        r"""Returns true, if not enough branches were not taken."""
        return _connect.CTestCoverageResult_isBranchesNotTakenError(self)

    def isBranchesBothError(self):
        r"""Returns true, if not enough branches were executed both ways."""
        return _connect.CTestCoverageResult_isBranchesBothError(self)

# Register CTestCoverageResult in _connect:
_connect.CTestCoverageResult_swigregister(CTestCoverageResult)
class CTestTreeNode(CTestBase):
    r"""
    This interface defines common methods for CTestSpecification and CTestGroup
    classes, which are used in testIDEA UI.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestTreeNode_cast(testBase)

    def getChildren(self, isConst):
        return _connect.CTestTreeNode_getChildren(self, isConst)

    def getNoOfAllChildrenInHierarchy(self):
        r"""Returns the number of all children down the hierarchy."""
        return _connect.CTestTreeNode_getNoOfAllChildrenInHierarchy(self)

    def getParentNode(self):
        r"""
        Returns parent node or mull it there is no parent or it is not of correct type,
        for example it is CTestBench.
        """
        return _connect.CTestTreeNode_getParentNode(self)

    def toUIString(self):
        r"""
        Returns string containing data set in an object. It is intended for UI
        only and should not be parsed.
        """
        return _connect.CTestTreeNode_toUIString(self)

    def compare(self, testNode):
        r"""Returns true, if the given testSpec is the same object as this one."""
        return _connect.CTestTreeNode_compare(self, testNode)

    def hashCodeAsPtr(self):
        r"""
        Returns pointer value as hash code. This value can be used to
        identify test specification objects. Each object has its unique
        value.
        """
        return _connect.CTestTreeNode_hashCodeAsPtr(self)

    def addChildAndSetParent(self, idx, child):
        return _connect.CTestTreeNode_addChildAndSetParent(self, idx, child)

    def deleteChild(self, child):
        return _connect.CTestTreeNode_deleteChild(self, child)

    def hasChildren(self):
        return _connect.CTestTreeNode_hasChildren(self)

    def getId(self):
        return _connect.CTestTreeNode_getId(self)

    def getUILabel(self):
        return _connect.CTestTreeNode_getUILabel(self)

    def isGroup(self):
        return _connect.CTestTreeNode_isGroup(self)
    __swig_destroy__ = _connect.delete_CTestTreeNode

# Register CTestTreeNode in _connect:
_connect.CTestTreeNode_swigregister(CTestTreeNode)
class CTestGroup(CTestTreeNode):
    r"""
    This class defines group of test cases or other subgroups. It is
    intended to be used for grouping test cases per partition, module,
    function or custom criteria.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ECore = _connect.CTestGroup_ECore
    EPartition = _connect.CTestGroup_EPartition
    EModule = _connect.CTestGroup_EModule
    EFunction = _connect.CTestGroup_EFunction
    ECustom = _connect.CTestGroup_ECustom
    E_SECTION_GROUP_ID = _connect.CTestGroup_E_SECTION_GROUP_ID
    E_SECTION_IS_EXECUTE = _connect.CTestGroup_E_SECTION_IS_EXECUTE
    E_SECTION_DESCRIPTION = _connect.CTestGroup_E_SECTION_DESCRIPTION
    E_SECTION_FILTER = _connect.CTestGroup_E_SECTION_FILTER
    E_SECTION_MERGED_ANALYZER_FILE = _connect.CTestGroup_E_SECTION_MERGED_ANALYZER_FILE
    E_SECTION_CLOSE_ANALYZER_FILE = _connect.CTestGroup_E_SECTION_CLOSE_ANALYZER_FILE
    E_SECTION_COVERAGE_EXPORT = _connect.CTestGroup_E_SECTION_COVERAGE_EXPORT
    E_SECTION_COVERAGE_ALL_CODE_IN_GROUP = _connect.CTestGroup_E_SECTION_COVERAGE_ALL_CODE_IN_GROUP
    E_SECTION_COVERAGE_TEST_CASES_ONLY = _connect.CTestGroup_E_SECTION_COVERAGE_TEST_CASES_ONLY
    E_SECTION_GROUP_INIT_SCRIPT = _connect.CTestGroup_E_SECTION_GROUP_INIT_SCRIPT
    E_SECTION_GROUP_END_SCRIPT = _connect.CTestGroup_E_SECTION_GROUP_END_SCRIPT
    E_SECTION_CHILDREN = _connect.CTestGroup_E_SECTION_CHILDREN

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to parent or empty shared ptr.
        """
        _connect.CTestGroup_swiginit(self, _connect.new_CTestGroup(*args))
    __swig_destroy__ = _connect.delete_CTestGroup

    def createInstance(self, parent):
        return _connect.CTestGroup_createInstance(self, parent)

    def isMerged(self):
        r"""Overrides base method, always returns false, because groups can't be merged."""
        return _connect.CTestGroup_isMerged(self)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestGroup_cast(testBase)

    def getParentGroup(self):
        r"""Returns parent group or null if it has no parent or parent is not of type CTestGroup."""
        return _connect.CTestGroup_getParentGroup(self)

    def getContainerTestNode(self):
        return _connect.CTestGroup_getContainerTestNode(self)

    def getUILabel(self):
        r"""Returns label to be shown in testIDEA."""
        return _connect.CTestGroup_getUILabel(self)

    def isGroup(self):
        r"""Returns true, if this object is of type CTestGroup, false if it is CTestSpecification."""
        return _connect.CTestGroup_isGroup(self)

    def getId(self):
        r"""Returns group type.  Returns group name, for example download file name, source file name, ..."""
        return _connect.CTestGroup_getId(self)

    def getDescription(self):
        r"""Returns group description."""
        return _connect.CTestGroup_getDescription(self)

    def getFilter(self, isConst):
        r"""Returns filter of test cases for this group."""
        return _connect.CTestGroup_getFilter(self, isConst)

    def getMergedAnalyzerFileName(self):
        r"""Returns name of analyzer file, which contains merged coverage of all test cases in a group."""
        return _connect.CTestGroup_getMergedAnalyzerFileName(self)

    def isCloseAfterTest(self):
        r"""Returns true, if analyzer file should be closed in winIDEA after test."""
        return _connect.CTestGroup_isCloseAfterTest(self)

    def getCoverageExportConfig(self, isConst):
        r"""Returns coverage export parameters."""
        return _connect.CTestGroup_getCoverageExportConfig(self, isConst)

    def getCoverageStatForAllCodeInGroup(self, isConst):
        r"""
        Returns expected coverage statistics for all code in a group, for example
        if it is module group, for all code in a module.

        See also: getCoverageStatForTestCasesOnly
        """
        return _connect.CTestGroup_getCoverageStatForAllCodeInGroup(self, isConst)

    def getCoverageStatForTestCasesOnly(self, isConst):
        r"""
        Returns expected coverage for functions in test cases only.

        See also: getCoverageStatForTestCasesOnly
        """
        return _connect.CTestGroup_getCoverageStatForTestCasesOnly(self, isConst)

    def getScriptFunction(self, section, isConst):
        r"""
        if section == E_SECTION_GROUP_INIT_SCRIPT, this method
        eturns specification for script function to be called before execution of test
        cases start. 'init' script functions of all groups are called before execution
        of the first test case.

        if section == E_SECTION_GROUP_END_SCRIPT, this method
        returns specification for script function to be called after execution of test
        cases. 'end' script functions of all groups are called after execution of the last
        test case.
        """
        return _connect.CTestGroup_getScriptFunction(self, section, isConst)

    def getNoOfTestCasesInGroup(self):
        r"""Returns the number of test cases in this group and all child groups."""
        return _connect.CTestGroup_getNoOfTestCasesInGroup(self)

    def addChildAndSetParent(self, idx, child):
        r"""
        Adds given child to the list of children
        at the given index. Parent of the added child is set to 'this'!

        :type idx: int
        :param idx: advice where to put the child in the children list
                   If -1 or out of range, the child is added to the end of the list.
        """
        return _connect.CTestGroup_addChildAndSetParent(self, idx, child)

    def getChildren(self, isConst):
        return _connect.CTestGroup_getChildren(self, isConst)

    def hasChildren(self):
        return _connect.CTestGroup_hasChildren(self)

    def deleteChild(self, child):
        return _connect.CTestGroup_deleteChild(self, child)

    def hasTestSpecs(self):
        r"""Returns true, if there is at least one test case in this group."""
        return _connect.CTestGroup_hasTestSpecs(self)

    def clearTestSpecs(self):
        r"""Removes all test cases from this group."""
        return _connect.CTestGroup_clearTestSpecs(self)

    def isTestSpecOwner(self):
        return _connect.CTestGroup_isTestSpecOwner(self)

    def getOwnedTestSpec(self):
        return _connect.CTestGroup_getOwnedTestSpec(self)

    def getTestOwnerGroupsSize(self):
        return _connect.CTestGroup_getTestOwnerGroupsSize(self)

    def getTestOwnerGroup(self, idx):
        return _connect.CTestGroup_getTestOwnerGroup(self, idx)

    def isBelongsToFilterGroup(self):
        return _connect.CTestGroup_isBelongsToFilterGroup(self)

# Register CTestGroup in _connect:
_connect.CTestGroup_swigregister(CTestGroup)
TAG_GROUP_ID = cvar.TAG_GROUP_ID
TAG_GROUP_DESCRIPTION = cvar.TAG_GROUP_DESCRIPTION

class CTestResultBase(CTestBase):
    r"""Base class for test case and group results."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CTestResultBase

    def isError(self):
        r"""
        Returns true if any of possible errors occurred - expressions, profiler,
        coverage, or exception.
        """
        return _connect.CTestResultBase_isError(self)

    def isException(self):
        r"""
        Returns true, if group result could not be created because of an error
        during test execution.
        """
        return _connect.CTestResultBase_isException(self)

    def getExceptionString(self):
        r"""Returns exception message or empty string if there was no exception thrown."""
        return _connect.CTestResultBase_getExceptionString(self)

    def getResultComment(self):
        r"""
        Returns comment, which describes specific test run. This value is typically
        entered by user after test run and before saving test report.
        """
        return _connect.CTestResultBase_getResultComment(self)

    def isScriptError(self, *args):
        r"""
        *Overload 1:*
        Returns true, if there was error when executing script functions.

        |

        *Overload 2:*
        Returns true, if there was error when executing the given script function.
        """
        return _connect.CTestResultBase_isScriptError(self, *args)

    def isStackUsageError(self):
        r"""Returns true, if there was error in stack usage."""
        return _connect.CTestResultBase_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType):
        r"""
        Returns string returned by the given script function.
        If there was no error, an empty string is returned.
        """
        return _connect.CTestResultBase_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType):
        r"""Returns everything printed to std out by script function."""
        return _connect.CTestResultBase_getScriptOutput(self, scriptFunctionType)

    def appendScriptError(self, scriptFunctionType, errorDesc):
        return _connect.CTestResultBase_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType, outStr):
        return _connect.CTestResultBase_appendScriptOutput(self, scriptFunctionType, outStr)

# Register CTestResultBase in _connect:
_connect.CTestResultBase_swigregister(CTestResultBase)
CTestResultBase.SE_INIT_SEQ = _connect.cvar.CTestResultBase_SE_INIT_SEQ
CTestResultBase.SE_INIT_TARGET = _connect.cvar.CTestResultBase_SE_INIT_TARGET
CTestResultBase.SE_INIT_FUNC = _connect.cvar.CTestResultBase_SE_INIT_FUNC
CTestResultBase.SE_END_FUNC = _connect.cvar.CTestResultBase_SE_END_FUNC
CTestResultBase.SE_RESTORE_TARGET = _connect.cvar.CTestResultBase_SE_RESTORE_TARGET
CTestResultBase.SE_STUB = _connect.cvar.CTestResultBase_SE_STUB
CTestResultBase.SE_TEST_POINT = _connect.cvar.CTestResultBase_SE_TEST_POINT
CTestResultBase.SE_FILTER = _connect.cvar.CTestResultBase_SE_FILTER
CTestResultBase.SE_GROUP_INIT_FUNC = _connect.cvar.CTestResultBase_SE_GROUP_INIT_FUNC
CTestResultBase.SE_GROUP_END_FUNC = _connect.cvar.CTestResultBase_SE_GROUP_END_FUNC

class CProfilerTestResult(object):
    r"""
    This class can be used to store arbitrary information as key-value pairs.
    The order is preserved, which means that items are serialized in the same
    order as they are put into the container.
    If strings contain characters, which have special meaning in the output format,
    they have to be escaped or the appropriate ``add...()`` method used.
    Keys should contain alphanumeric characters and underscore '_' only.

         Removed, because this info was added to CTestReportConfig as userInfo of type
         CYAMLMap. This way serialization.deserialization to/from YAML was more consistent.

        class CSerializableInfo : public ISerializable
        {
        private:
            class StrStrPair {
            public:
                std::string m_key;
                std::string m_value;

                StrStrPair(const std::string &key, const std::string &value) :
                    m_key(key),
                    m_value(value) {}
            };

            std::vector<StrStrPair> m_infoVector;

        public:

    Default ctor. Do not use it from other languages than C++. Call createInstance()
    instead./
            CSerializableInfo() {}

    Adds key / value pair without any modifications. /
            void add(const std::string &key, const std::string &value);

    Writes object's data to report!. /
            void serialize(isys::IEmitterSPtr &emitter) const;

    This method converts pointer to derived class to base class. It is required
    for scripting languages, which can not perform such conversion automatically. /
            isys::ISerializableSPtr upcast(const isys::CSerializableInfoSPtr &ptr);

    Create a new instance of this class. /
            static isys::CSerializableInfoSPtr createInstance();
        };
    This class contains expected results of coverage test. All values are
    in range [0..1], where 1 means 100%.
          Shared pointer for CCoverageTestResult.
    This class stores result of profiler test. This class is not intended to be
    instantiated by clients. Call isys::CTestCase::getTestResults() or similar
    method in the scripting language wrapper to get test results.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ERR_NONE = _connect.CProfilerTestResult_ERR_NONE
    r"""no error"""
    ERR_MIN = _connect.CProfilerTestResult_ERR_MIN
    r"""error on lower boundary"""
    ERR_MAX = _connect.CProfilerTestResult_ERR_MAX
    r"""error on upper boundary"""
    ERR_BOTH = _connect.CProfilerTestResult_ERR_BOTH
    r"""
    used for data values without value specified,
    which means that multiple values
    map to the same specification, so both boundaries
    may cause error.
    """

    def __init__(self, *args):
        _connect.CProfilerTestResult_swiginit(self, _connect.new_CProfilerTestResult(*args))

    def isValueSet(self):
        r"""
        Returns true, if data value in the test specification was set. For function
        profiling it always returns false.
        """
        return _connect.CProfilerTestResult_isValueSet(self)

    def isResultSet(self):
        r"""Returns true, if result was set for this area."""
        return _connect.CProfilerTestResult_isResultSet(self)

    def getMeasuredResult(self):
        r"""Returns measured data, but only if isResultSet() returns true."""
        return _connect.CProfilerTestResult_getMeasuredResult(self)

    def isError(self):
        r"""
        Returns true, if any error occurred. Calls
        all ``validate...()`` methods.
        """
        return _connect.CProfilerTestResult_isError(self)

    def validateError(self, statsId, timeId):
        r"""Returns error status for the given time scope and time type."""
        return _connect.CProfilerTestResult_validateError(self, statsId, timeId)

    def validateAllTimes(self, prevError):
        r"""Returns error status for all time measurements."""
        return _connect.CProfilerTestResult_validateAllTimes(self, prevError)

    def validateTimeScopeForAllTimeTypes(self, statsId):
        r"""Returns error status for the given time scope for all time types."""
        return _connect.CProfilerTestResult_validateTimeScopeForAllTimeTypes(self, statsId)

    def validateTimeTypeForAllScopes(self, timeTypeId):
        r"""Returns error status for the given time type for all time scopes."""
        return _connect.CProfilerTestResult_validateTimeTypeForAllScopes(self, timeTypeId)

    def validateHits(self):
        r"""Checks for hits error."""
        return _connect.CProfilerTestResult_validateHits(self)

    def getMeasuredTime(self, statsId, timeId):
        r"""
        Returns the number of hits as string. If this is data area with multiple
        measurements (for multiple states), then string 'min / max' is returned.
        """
        return _connect.CProfilerTestResult_getMeasuredTime(self, statsId, timeId)

    def getMeasuredHits(self):
        r"""
        Returns the number of hits as string. If this is data area with multiple
        measurements (for multiple states), then string 'min / max' is returned.
        """
        return _connect.CProfilerTestResult_getMeasuredHits(self)

    def getExpectedResult(self):
        r"""Returns constraints as specified in test specification."""
        return _connect.CProfilerTestResult_getExpectedResult(self)

    def getValue(self):
        r"""
         Returns min time as specified in test specification.  Returns max time as specified in test specification.  Returns total time as specified in test specification.  Returns hits as specified in test specification.
        Returns value for this result. The value is valid only when isValueSet()
        returns true.
        """
        return _connect.CProfilerTestResult_getValue(self)

    def serialize(self, emitter):
        r"""Writes object data to destination object."""
        return _connect.CProfilerTestResult_serialize(self, emitter)

    def serializeErrorsOnly(self, emitter):
        r"""Writes object error data to destination object."""
        return _connect.CProfilerTestResult_serializeErrorsOnly(self, emitter)

    def toString(self):
        return _connect.CProfilerTestResult_toString(self)
    __swig_destroy__ = _connect.delete_CProfilerTestResult

# Register CProfilerTestResult in _connect:
_connect.CProfilerTestResult_swigregister(CProfilerTestResult)
class CLogResult(CTestBase):
    r"""
    This class stores results of ``log`` section. These values are
    not used for validating test, but for documentation purposes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_BEFORE_ASSIGN = _connect.CLogResult_E_SECTION_BEFORE_ASSIGN
    r"""expression was evaluated before assignment was made"""
    E_SECTION_AFTER_ASSIGN = _connect.CLogResult_E_SECTION_AFTER_ASSIGN
    r"""expression was evaluated after assignment was made"""

    def __init__(self, parent):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CLogResult_swiginit(self, _connect.new_CLogResult(parent))

    def createInstance(self, parent):
        return _connect.CLogResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CLogResult_cast(testBase)

    def serialize(self, emitter):
        return _connect.CLogResult_serialize(self, emitter)

    def add(self, expr, result, logType):
        r"""
        Add result of expression evaluation. Results should be added in the
        same order as expressions are specified in test spec.
        """
        return _connect.CLogResult_add(self, expr, result, logType)

    def getLog(self, expressions, results, logType):
        r"""
        Returns expressions and their evaluated values. Sizes of both vectors are
        the same after return.
        """
        return _connect.CLogResult_getLog(self, expressions, results, logType)
    __swig_destroy__ = _connect.delete_CLogResult

# Register CLogResult in _connect:
_connect.CLogResult_swigregister(CLogResult)
class CTestPointResult(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_TEST_POINT_ID = _connect.CTestPointResult_E_SECTION_TEST_POINT_ID
    E_SECTION_LOCATION = _connect.CTestPointResult_E_SECTION_LOCATION
    E_SECTION_EXEC_STATUS = _connect.CTestPointResult_E_SECTION_EXEC_STATUS
    E_SECTION_HIT_NO = _connect.CTestPointResult_E_SECTION_HIT_NO
    E_SECTION_STEP_IDX = _connect.CTestPointResult_E_SECTION_STEP_IDX
    E_SECTION_LOG_RESULT = _connect.CTestPointResult_E_SECTION_LOG_RESULT
    E_SECTION_SCRIPT_INFO_VAR = _connect.CTestPointResult_E_SECTION_SCRIPT_INFO_VAR
    E_SECTION_SCRIPT_RET_VAL = _connect.CTestPointResult_E_SECTION_SCRIPT_RET_VAL
    E_SECTION_EXPR_ERRORS = _connect.CTestPointResult_E_SECTION_EXPR_ERRORS
    EXECUTED = _connect.CTestPointResult_EXECUTED
    r"""test point was hit and assignments and verification were executed"""
    CONDITION_FALSE = _connect.CTestPointResult_CONDITION_FALSE
    r"""
    test point was hit, but condition was false, so assignments or
    verification were not executed
    """
    HIT_COUNT_FALSE = _connect.CTestPointResult_HIT_COUNT_FALSE
    r"""
    test point was hit, but hit count did not match, so assignments
    or verification were not executed
    """

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestPointResult_swiginit(self, _connect.new_CTestPointResult(*args))

    def createInstance(self, parent):
        return _connect.CTestPointResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestPointResult_cast(testBase)

    def serialize(self, emitter):
        return _connect.CTestPointResult_serialize(self, emitter)

    def isError(self):
        r"""
        Returns true, if there was script error, or any of the expected
        expressions evaluated to false.
        """
        return _connect.CTestPointResult_isError(self)

    def isExprError(self):
        r"""Returns true if at least one of expressions evaluated to false"""
        return _connect.CTestPointResult_isExprError(self)

    def isScriptError(self):
        r"""Returns true if script returned error description."""
        return _connect.CTestPointResult_isScriptError(self)

    def hasData(self):
        r"""
        Returns true, if any other data or error except hit number or
        step index is set. We don't want to save test point results
        if there are only hit number and step index set - this would mean
        a lot of data to save with little information value.
        """
        return _connect.CTestPointResult_hasData(self)

    def getExecStatus(self):
        r"""
        Returns execution status - test point or stub may be hit, but not
        executed due to condition or hit count.
        """
        return _connect.CTestPointResult_getExecStatus(self)

    def getLogResult(self, isConst):
        r"""Returns log result."""
        return _connect.CTestPointResult_getLogResult(self, isConst)

    def setLogResult(self, logResult):
        r"""Sets log result."""
        return _connect.CTestPointResult_setLogResult(self, logResult)

    def getId(self):
        r"""Returns test point ID or name of stubbed function."""
        return _connect.CTestPointResult_getId(self)

    def getLocation(self):
        r"""Returns test point location as string."""
        return _connect.CTestPointResult_getLocation(self)

    def getHitNo(self):
        return _connect.CTestPointResult_getHitNo(self)

    def getStepIdx(self):
        return _connect.CTestPointResult_getStepIdx(self)

    def getScriptInfoVar(self):
        return _connect.CTestPointResult_getScriptInfoVar(self)

    def getScriptRetVal(self):
        return _connect.CTestPointResult_getScriptRetVal(self)

    def getExpressionErrors(self, expressions, results):
        return _connect.CTestPointResult_getExpressionErrors(self, expressions, results)

    def setId(self, testPointId):
        r"""Sets test point ID of name of stubbed function."""
        return _connect.CTestPointResult_setId(self, testPointId)

    def setLocation(self, location):
        r"""Sets test point location as string. It is not used internally and can be any string."""
        return _connect.CTestPointResult_setLocation(self, location)

    def setExecStatus(self, execStatus):
        r"""Sets test point or stub execution status."""
        return _connect.CTestPointResult_setExecStatus(self, execStatus)

    def setHitNoAndStepIdx(self, hitNo, stepIdx):
        r"""Sets hit number for test point or stub and step index."""
        return _connect.CTestPointResult_setHitNoAndStepIdx(self, hitNo, stepIdx)

    def setScriptInfoVar(self, scriptOutput):
        r"""Sets information returned by script function called on test point or stub hit."""
        return _connect.CTestPointResult_setScriptInfoVar(self, scriptOutput)

    def setScriptRetVal(self, scriptError):
        r"""Sets return value of script function called on test point or stub hit."""
        return _connect.CTestPointResult_setScriptRetVal(self, scriptError)

    def addExpressionError(self, expr, result):
        r"""Sets error in expression evaluated on test point or stub hit."""
        return _connect.CTestPointResult_addExpressionError(self, expr, result)
    __swig_destroy__ = _connect.delete_CTestPointResult

# Register CTestPointResult in _connect:
_connect.CTestPointResult_swigregister(CTestPointResult)
class CStackUsageResult(CTestBase):
    r"""This class stores result for stack usage."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_USAGE_BEFORE_TEST = _connect.CStackUsageResult_E_SECTION_USAGE_BEFORE_TEST
    E_SECTION_TEST_IDEA_USAGE = _connect.CStackUsageResult_E_SECTION_TEST_IDEA_USAGE
    E_SECTION_APPLICATION_USAGE = _connect.CStackUsageResult_E_SECTION_APPLICATION_USAGE
    E_SECTION_MAX_EXPECTED_SIZE = _connect.CStackUsageResult_E_SECTION_MAX_EXPECTED_SIZE

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CStackUsageResult_swiginit(self, _connect.new_CStackUsageResult(*args))

    def createInstance(self, parent):
        return _connect.CStackUsageResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CStackUsageResult_cast(testBase)

    def isError(self):
        r"""Returns true, if more stack usage was used than expected."""
        return _connect.CStackUsageResult_isError(self)

    def getMaxExpectedSize(self):
        return _connect.CStackUsageResult_getMaxExpectedSize(self)

    def getUsageBeforeTest(self):
        return _connect.CStackUsageResult_getUsageBeforeTest(self)

    def getTestIDEAUsage(self):
        return _connect.CStackUsageResult_getTestIDEAUsage(self)

    def getApplicationUsage(self):
        return _connect.CStackUsageResult_getApplicationUsage(self)

    def setValues(self, minExpSize, maxExpSize, stackUsedBeforeTest, testUsage, appUsage):
        r"""
        Sets measured values of stack usage.
        :type minExpSize: int
        :param minExpSize: defines minimal expected stack size to be used, __currently__
                              __ignored__
        :type maxExpSize: int
        :param maxExpSize: defines maximal expected stack size to be used.
        :type stackUsedBeforeTest: int
        :param stackUsedBeforeTest: amount of stack used before test
        :type testUsage: int
        :param testUsage: amount of stack used for test, for example if test script
                             puts some data on stack before test.
        :type appUsage: int
        :param appUsage: amount of stack used by code under test
        """
        return _connect.CStackUsageResult_setValues(self, minExpSize, maxExpSize, stackUsedBeforeTest, testUsage, appUsage)
    __swig_destroy__ = _connect.delete_CStackUsageResult

# Register CStackUsageResult in _connect:
_connect.CStackUsageResult_swigregister(CStackUsageResult)
class CTestExprResult(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_EXPR_RESULT_EXPR = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_EXPR
    E_SECTION_EXPR_RESULT_SUBEXPRS = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_SUBEXPRS
    E_SECTION_EXPR_RESULT_IS_ERROR = _connect.CTestExprResult_E_SECTION_EXPR_RESULT_IS_ERROR

    def __init__(self, *args):
        _connect.CTestExprResult_swiginit(self, _connect.new_CTestExprResult(*args))

    def createInstance(self, parent):
        return _connect.CTestExprResult_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestExprResult_cast(testBase)

    def getExpression(self):
        r"""Returns expression, which was evaluated."""
        return _connect.CTestExprResult_getExpression(self)

    def getSubexpressions(self, isConst):
        r"""Returns mapping of subexpressions and their values."""
        return _connect.CTestExprResult_getSubexpressions(self, isConst)

    def isError(self):
        r"""Returns *true* if expression evaluated to *true*, *false* otherwise."""
        return _connect.CTestExprResult_isError(self)

    def toUIString(self):
        r"""Returns string with expression and indented subexpressions with values."""
        return _connect.CTestExprResult_toUIString(self)

    def setExpression(self, expression):
        r"""Sets expression, which was evaluated."""
        return _connect.CTestExprResult_setExpression(self, expression)

    def addSubexpression(self, subExpression, value):
        r"""Adds subexpression and its value."""
        return _connect.CTestExprResult_addSubexpression(self, subExpression, value)

    def setError(self, isError):
        r"""
        Sets expression result - if `isError` == false, expression evaluated to `true`,
        as expected.
        """
        return _connect.CTestExprResult_setError(self, isError)
    __swig_destroy__ = _connect.delete_CTestExprResult

# Register CTestExprResult in _connect:
_connect.CTestExprResult_swigregister(CTestExprResult)
class CTestResult(CTestResultBase):
    r"""
    This class stores results of test case run. Normally it is not intended to be
    instantiated by clients - call isys::CTestCase::getTestResult() or similar
    method in the scripting language wrapper to get test results. However, if you'd
    like to create testIDE-like reports with custom scripts, feel free to use it.

    For result analysis the simple method used in ``itest_sample.py`` is enough
    in most cases:








    Python example: _sample_link{itest,create_test_report}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_RESULT_COMMENT = _connect.CTestResult_E_SECTION_RESULT_COMMENT
    r"""
    comment user enters in tesIDEA to be saved to report.
    It should describe conditions for particular test run.
    """
    E_SECTION_DEFAULT_DOWNLOAD_FILE = _connect.CTestResult_E_SECTION_DEFAULT_DOWNLOAD_FILE
    E_SECTION_STUB_RESULTS = _connect.CTestResult_E_SECTION_STUB_RESULTS
    E_SECTION_TEST_POINT_RESULTS = _connect.CTestResult_E_SECTION_TEST_POINT_RESULTS
    E_SECTION_STACK_USAGE_RESULTS = _connect.CTestResult_E_SECTION_STACK_USAGE_RESULTS
    E_SECTION_TARGET_EXCEPTION = _connect.CTestResult_E_SECTION_TARGET_EXCEPTION
    E_SECTION_PRE_CONDITION = _connect.CTestResult_E_SECTION_PRE_CONDITION
    E_SECTION_ASSERT = _connect.CTestResult_E_SECTION_ASSERT
    E_SECTION_LOG = _connect.CTestResult_E_SECTION_LOG
    E_SECTION_DRY_RUN_ASSIGNMENTS = _connect.CTestResult_E_SECTION_DRY_RUN_ASSIGNMENTS
    E_SECTION_DIAGRAMS = _connect.CTestResult_E_SECTION_DIAGRAMS
    E_SECTION_SCRIPT_ERRORS = _connect.CTestResult_E_SECTION_SCRIPT_ERRORS
    E_SECTION_SCRIPT_OUTPUT = _connect.CTestResult_E_SECTION_SCRIPT_OUTPUT

    def __init__(self, *args):
        _connect.CTestResult_swiginit(self, _connect.new_CTestResult(*args))

    def createInstance(self, parent):
        return _connect.CTestResult_createInstance(self, parent)

    def getResultComment(self):
        r"""
        Returns comment, which describes specific test run. This value is typically
        entered by user after test run and before saving test report.
        """
        return _connect.CTestResult_getResultComment(self)

    def getDefaultDownloadFile(self):
        r"""
        Returns default download file name. It is set only when profiler was run
        during test.
        """
        return _connect.CTestResult_getDefaultDownloadFile(self)

    def getTestId(self):
        r"""Returns the testId."""
        return _connect.CTestResult_getTestId(self)

    def getFunction(self):
        r"""Returns the name of the function under test."""
        return _connect.CTestResult_getFunction(self)

    def getTestSpecification(self):
        r"""
        Returns test specification, which produced this result. Usually this is
        the merged test specification.
        """
        return _connect.CTestResult_getTestSpecification(self)

    def getProfilerExportFileName(self):
        r"""
        Returns name of the file, where profiler data was exported - this is
        real file name, without host variables (they were replaced with values
        before test execution and saved in this class).
        """
        return _connect.CTestResult_getProfilerExportFileName(self)

    def isError(self):
        r"""
        Returns true if any of possible errors occurred - expressions, profiler,
        coverage, exception, ...
        """
        return _connect.CTestResult_isError(self)

    def isException(self):
        r"""Returns true, if an exception was thrown."""
        return _connect.CTestResult_isException(self)

    def getExceptionString(self):
        r"""If ``isException()`` returns true, this method returns the message of the exception."""
        return _connect.CTestResult_getExceptionString(self)

    def isTargetException(self):
        r"""Returns true, if exception was thrown by function on the target."""
        return _connect.CTestResult_isTargetException(self)

    def isExpressionError(self):
        r"""
         Returns true, if target values after test run don't match
        expected values given in test specification (section 'expected').
        """
        return _connect.CTestResult_isExpressionError(self)

    def isPreConditionError(self):
        r"""Returns true, if conditions verified before test failed."""
        return _connect.CTestResult_isPreConditionError(self)

    def isTargetExceptionError(self):
        r"""
        Returns true, if exception was thrown on target, but it is not expected as
        test result, or it is expected as test result, but it was not thrown on
        the target.
        """
        return _connect.CTestResult_isTargetExceptionError(self)

    def isCodeCoverageError(self):
        r"""Returns true, if coverage results don't match the test specification requirements."""
        return _connect.CTestResult_isCodeCoverageError(self)

    def isProfilerCodeError(self):
        r"""Returns true, if profiler code results don't match the test specification requirements."""
        return _connect.CTestResult_isProfilerCodeError(self)

    def isProfilerDataError(self):
        r"""Returns true, if profiler data results don't match the test specification requirements."""
        return _connect.CTestResult_isProfilerDataError(self)

    def isScriptError(self, *args):
        r"""
        *Overload 1:*
        Returns true, if there was error when executing script functions.

        |

        *Overload 2:*
        Returns true, if there was error when executing the given script function.
        """
        return _connect.CTestResult_isScriptError(self, *args)

    def isTestPointError(self):
        r"""Returns true, if there was error in test points."""
        return _connect.CTestResult_isTestPointError(self)

    def isStubError(self):
        r"""Returns true, if there was error in stub."""
        return _connect.CTestResult_isStubError(self)

    def isStackUsageError(self):
        r"""Returns true, if there was error in stack usage."""
        return _connect.CTestResult_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType):
        r"""
        Returns string returned by the given script function.
        If there was no error, an empty string is returned.
        """
        return _connect.CTestResult_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType):
        r"""Returns everything printed to std out by script function."""
        return _connect.CTestResult_getScriptOutput(self, scriptFunctionType)

    def getPreConditionResults(self, isConst):
        r"""Returns list of precondition evaluations."""
        return _connect.CTestResult_getPreConditionResults(self, isConst)

    def getAssertResults(self, isConst):
        r"""Returns list of CTestExprResult -s, one item per assert expression."""
        return _connect.CTestResult_getAssertResults(self, isConst)

    def getLogResult(self, isConst):
        r"""Returns object containing logged values."""
        return _connect.CTestResult_getLogResult(self, isConst)

    def getCoverageResults(self, resultMap):
        r"""Returns all coverage results."""
        return _connect.CTestResult_getCoverageResults(self, resultMap)

    def getCoverageResultsWithError(self, resultMap):
        r"""Returns only those coverage results, which do match expected values."""
        return _connect.CTestResult_getCoverageResultsWithError(self, resultMap)

    def getProfilerCodeResult(self, areaName):
        r"""Returns profiler code result if exists, NULL otherwise."""
        return _connect.CTestResult_getProfilerCodeResult(self, areaName)

    def getProfilerCodeResults(self, resultMap):
        r"""Returns all profiler code results."""
        return _connect.CTestResult_getProfilerCodeResults(self, resultMap)

    def getProfilerDataResult(self, areaName):
        r"""Returns profiler data result without value set if exists, NULL otherwise."""
        return _connect.CTestResult_getProfilerDataResult(self, areaName)

    def getProfilerDataResults(self, resultMap):
        r"""Returns all profiler data results."""
        return _connect.CTestResult_getProfilerDataResults(self, resultMap)

    def serialize(self, *args):
        r"""
        *Overload 1:*
         Sends contents of this class to emitter.

        |

        *Overload 2:*

        Writes result to destination stream, which is usually associated with file.

        :type emitter: :py:class:`IEmitter`
        :param emitter: destination object for serialized data
        :type reportConfig: :py:class:`CTestReportConfig`
        :param reportConfig: report configuration. If set to NULL, default configuration
                                is used. If ``CTestReportConfig::setReportContents(RCONFIG_ERRORS_ONLY)``
                                is called, this call is identical to call serializeErrorsOnly() below.
        """
        return _connect.CTestResult_serialize(self, *args)

    def serializeErrorsOnly(self, emitter, reportConfig):
        r"""
        Writes errors to destination stream, which is usually associated with file.

        :type emitter: :py:class:`IEmitter`
        :param emitter: destination object for serialized data
        :type reportConfig: :py:class:`CTestReportConfig`
        :param reportConfig: report configuration. If set to NULL, default configuration
                                is used.
        """
        return _connect.CTestResult_serializeErrorsOnly(self, emitter, reportConfig)

    def toString(self):
        r"""
         Returns object's data as YAML string. This method is intended for debugging
        purposes only, do not parse the returned data!
        """
        return _connect.CTestResult_toString(self)

    def toUIString(self):
        r"""Returns string readable also as pure text, only errors are included."""
        return _connect.CTestResult_toUIString(self)

    def diffsToUIString(self, section):
        return _connect.CTestResult_diffsToUIString(self, section)

    def setTargetException(self, isTargetException):
        r"""
        Set to true, if exception on target occurred during test.
        See also: #setTargetExceptionStr
        """
        return _connect.CTestResult_setTargetException(self, isTargetException)

    def setResultComment(self, resultComment):
        r"""Set arbitrary text to appear in test report, for example test description or purpose."""
        return _connect.CTestResult_setResultComment(self, resultComment)

    def setLogResult(self, logResult):
        r"""Sets log result."""
        return _connect.CTestResult_setLogResult(self, logResult)

    def addExprResult(self, section, result):
        r"""
         Adds result of evaluated test expression.
        :type section: int
        :param section: should be CTestResult::E_SECTION_PRE_CONDITION, or
                   CTestResult::E_SECTION_ASSERT, if expression is evaluated
                   before or after test respectively.
        :type result: :py:class:`CTestExprResult`
        :param result: result to be added.
        """
        return _connect.CTestResult_addExprResult(self, section, result)

    def addStubResult(self, result):
        r"""Adds stub result."""
        return _connect.CTestResult_addStubResult(self, result)

    def addTestPointResult(self, result):
        r"""Adds test point result."""
        return _connect.CTestResult_addTestPointResult(self, result)

    def setStackUsageResult(self, stackUsageResult):
        r"""Sets Stack usage result."""
        return _connect.CTestResult_setStackUsageResult(self, stackUsageResult)

    def setTargetExceptionStr(self, targetException):
        r"""
        Sets description of target exception.
        See also: #setTargetException
        """
        return _connect.CTestResult_setTargetExceptionStr(self, targetException)

    def appendScriptError(self, scriptFunctionType, errorDesc):
        r"""Appends error message of script function."""
        return _connect.CTestResult_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType, outStr):
        r"""Appends stdout of script function."""
        return _connect.CTestResult_appendScriptOutput(self, scriptFunctionType, outStr)

    def getAnalyzerFileName(self):
        return _connect.CTestResult_getAnalyzerFileName(self)

    def getStubResults(self, isConst):
        return _connect.CTestResult_getStubResults(self, isConst)

    def getTestPointResults(self, isConst):
        return _connect.CTestResult_getTestPointResults(self, isConst)

    def getStackUsageResult(self, isConst):
        return _connect.CTestResult_getStackUsageResult(self, isConst)

    def setDefaultDownloadFile(self, defaultDlFileName):
        return _connect.CTestResult_setDefaultDownloadFile(self, defaultDlFileName)

    def setTestSpecification(self, testSpec):
        return _connect.CTestResult_setTestSpecification(self, testSpec)

    def addDryRunAssignment(self, varName, value):
        return _connect.CTestResult_addDryRunAssignment(self, varName, value)

    def addDiagram(self, imageFileName):
        return _connect.CTestResult_addDiagram(self, imageFileName)

    @staticmethod
    def funcType2PyVarName(scriptFunctionType):
        return _connect.CTestResult_funcType2PyVarName(scriptFunctionType)
    __swig_destroy__ = _connect.delete_CTestResult

# Register CTestResult in _connect:
_connect.CTestResult_swigregister(CTestResult)
class CTestGroupResult(CTestResultBase):
    r"""
    This class defines group of test cases or other subgroups. It is
    intended to be used for grouping test cases per partition, module,
    function or custom criteria.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_NO_OF_TEST_CASES_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_TEST_CASES_IN_GROUP
    E_NO_OF_FUNCTIONS_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_FUNCTIONS_IN_GROUP
    E_NO_OF_MODULES_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_MODULES_IN_GROUP
    E_NO_OF_PARTITIONS_IN_GROUP = _connect.CTestGroupResult_E_NO_OF_PARTITIONS_IN_GROUP
    E_EXCEPTION_MSG = _connect.CTestGroupResult_E_EXCEPTION_MSG
    E_PASSED_TCS = _connect.CTestGroupResult_E_PASSED_TCS
    E_FAILED_TCS = _connect.CTestGroupResult_E_FAILED_TCS
    E_ERROR_TCS = _connect.CTestGroupResult_E_ERROR_TCS
    E_PASSED_FUNCTIONS = _connect.CTestGroupResult_E_PASSED_FUNCTIONS
    E_FAILED_FUNCTIONS = _connect.CTestGroupResult_E_FAILED_FUNCTIONS
    E_ERROR_FUNCTIONS = _connect.CTestGroupResult_E_ERROR_FUNCTIONS
    E_PASSED_MODULES = _connect.CTestGroupResult_E_PASSED_MODULES
    E_FAILED_MODULES = _connect.CTestGroupResult_E_FAILED_MODULES
    E_ERROR_MODULES = _connect.CTestGroupResult_E_ERROR_MODULES
    E_PASSED_PARTITIONS = _connect.CTestGroupResult_E_PASSED_PARTITIONS
    E_FAILED_PARTITIONS = _connect.CTestGroupResult_E_FAILED_PARTITIONS
    E_ERROR_PARTITIONS = _connect.CTestGroupResult_E_ERROR_PARTITIONS
    E_FAILED_PRECOND = _connect.CTestGroupResult_E_FAILED_PRECOND
    E_FAILED_ASSERT = _connect.CTestGroupResult_E_FAILED_ASSERT
    E_FAILED_COVERAGE = _connect.CTestGroupResult_E_FAILED_COVERAGE
    E_FAILED_PROFILER_CODE = _connect.CTestGroupResult_E_FAILED_PROFILER_CODE
    E_FAILED_PROFILER_DATA = _connect.CTestGroupResult_E_FAILED_PROFILER_DATA
    E_FAILED_STUB = _connect.CTestGroupResult_E_FAILED_STUB
    E_FAILED_TEST_POINT = _connect.CTestGroupResult_E_FAILED_TEST_POINT
    E_FAILED_STACK_USAGE = _connect.CTestGroupResult_E_FAILED_STACK_USAGE
    E_FAILED_TARGET_EXCEPTIONS = _connect.CTestGroupResult_E_FAILED_TARGET_EXCEPTIONS
    E_SECTION_RESULT_COMMENT = _connect.CTestGroupResult_E_SECTION_RESULT_COMMENT
    E_SECTION_DEFAULT_DOWNLOAD_FILE = _connect.CTestGroupResult_E_SECTION_DEFAULT_DOWNLOAD_FILE
    E_SECTION_STACK_USAGE_RESULTS = _connect.CTestGroupResult_E_SECTION_STACK_USAGE_RESULTS
    E_SECTION_DIAGRAMS = _connect.CTestGroupResult_E_SECTION_DIAGRAMS
    E_MIN_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_MIN_TCS_FOR_FUNCTION
    E_AVG_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_AVG_TCS_FOR_FUNCTION
    E_MAX_TCS_FOR_FUNCTION = _connect.CTestGroupResult_E_MAX_TCS_FOR_FUNCTION
    E_FUNCTIONS_W_TEST_CASES = _connect.CTestGroupResult_E_FUNCTIONS_W_TEST_CASES
    E_MODULES_W_TEST_CASES = _connect.CTestGroupResult_E_MODULES_W_TEST_CASES
    E_PARTITIONS_W_TEST_CASES = _connect.CTestGroupResult_E_PARTITIONS_W_TEST_CASES
    E_SCRIPT_ERRORS = _connect.CTestGroupResult_E_SCRIPT_ERRORS
    E_SCRIPT_OUTPUT = _connect.CTestGroupResult_E_SCRIPT_OUTPUT
    E_TCS_PER_MODULE = _connect.CTestGroupResult_E_TCS_PER_MODULE
    E_TCS_PER_PARTITION = _connect.CTestGroupResult_E_TCS_PER_PARTITION
    E_CVRG_DOCUMENT = _connect.CTestGroupResult_E_CVRG_DOCUMENT
    E_CVRG_EXPORT_FILE = _connect.CTestGroupResult_E_CVRG_EXPORT_FILE
    E_CVRG_STAT_FOR_ALL_ITEMS = _connect.CTestGroupResult_E_CVRG_STAT_FOR_ALL_ITEMS
    E_CVRG_STAT_FOR_TESTED_ITEMS = _connect.CTestGroupResult_E_CVRG_STAT_FOR_TESTED_ITEMS
    E_SRC_LINE_CVRG = _connect.CTestGroupResult_E_SRC_LINE_CVRG
    E_FUNC_STATS = _connect.CTestGroupResult_E_FUNC_STATS

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to group which generate this result.
        """
        _connect.CTestGroupResult_swiginit(self, _connect.new_CTestGroupResult(*args))
    __swig_destroy__ = _connect.delete_CTestGroupResult

    def createInstance(self, parent):
        return _connect.CTestGroupResult_createInstance(self, parent)

    def isMerged(self):
        r"""Overrides base method, always returns false, because groups can't be merged."""
        return _connect.CTestGroupResult_isMerged(self)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestGroupResult_cast(testBase)

    def isException(self):
        r"""
        Returns true, if group result could not be created because of an error
        during test execution.
        """
        return _connect.CTestGroupResult_isException(self)

    def getExceptionString(self):
        r"""Returns exception message or empty string if there was no exception thrown."""
        return _connect.CTestGroupResult_getExceptionString(self)

    def isError(self):
        r"""Returns true, if coverage criteria in the group are not met."""
        return _connect.CTestGroupResult_isError(self)

    def isErrorInChildTestCases(self):
        r"""Returns true, if there was error in any child test case."""
        return _connect.CTestGroupResult_isErrorInChildTestCases(self)

    def isChildGroupError(self):
        r"""
        Returns true, if there was an error in any of the child groups. Only
        group criteria is taken into account, without test cases.
        """
        return _connect.CTestGroupResult_isChildGroupError(self)

    def getIntValue(self, section):
        r"""Returns value of the specified section."""
        return _connect.CTestGroupResult_getIntValue(self, section)

    def getResultComment(self):
        r"""Returns result comment."""
        return _connect.CTestGroupResult_getResultComment(self)

    def getDefaultDownloadFile(self):
        r"""Returns default download file."""
        return _connect.CTestGroupResult_getDefaultDownloadFile(self)

    def getStackUsageResult(self, isConst):
        r"""Returns max stack usage values of all children test cases."""
        return _connect.CTestGroupResult_getStackUsageResult(self, isConst)

    def getCoverageResultForTestedCode(self, isConst):
        r"""Returns coverage statistic for all functions, which have test cases."""
        return _connect.CTestGroupResult_getCoverageResultForTestedCode(self, isConst)

    def getCoverageResultForAllCode(self, isConst):
        r"""Returns coverage statistic for all functions in a group, including those without test cases."""
        return _connect.CTestGroupResult_getCoverageResultForAllCode(self, isConst)

    def getFunctionStatList(self, isConst):
        r"""Returns list of coverage statistics for functions in a group."""
        return _connect.CTestGroupResult_getFunctionStatList(self, isConst)

    def isScriptError(self, *args):
        r"""
        *Overload 1:*
        Returns true, if there was error when executing script functions.

        |

        *Overload 2:*
        Returns true, if there was error when executing the given script function.
        """
        return _connect.CTestGroupResult_isScriptError(self, *args)

    def isStackUsageError(self):
        return _connect.CTestGroupResult_isStackUsageError(self)

    def getScriptError(self, scriptFunctionType):
        r"""
        Returns string returned by the given script function.
        If there was no error, an empty string is returned.
        """
        return _connect.CTestGroupResult_getScriptError(self, scriptFunctionType)

    def getScriptOutput(self, scriptFunctionType):
        r"""Returns everything printed to std out by script function."""
        return _connect.CTestGroupResult_getScriptOutput(self, scriptFunctionType)

    def getFailedSections(self):
        r"""
        Returns human readable string with comma separated list of sections,
        which have failed at least in one test case.
        """
        return _connect.CTestGroupResult_getFailedSections(self)

    def appendScriptError(self, scriptFunctionType, errorDesc):
        return _connect.CTestGroupResult_appendScriptError(self, scriptFunctionType, errorDesc)

    def appendScriptOutput(self, scriptFunctionType, outStr):
        return _connect.CTestGroupResult_appendScriptOutput(self, scriptFunctionType, outStr)

    def toUIString(self):
        r"""Returns string readable also as pure text, only errors are included."""
        return _connect.CTestGroupResult_toUIString(self)

# Register CTestGroupResult in _connect:
_connect.CTestGroupResult_swigregister(CTestGroupResult)
class CTestGrpFuncStat(CTestBase):
    r"""This class contains statistics for all test cases for one function in a group."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_QUAL_FUNC_NAME = _connect.CTestGrpFuncStat_E_QUAL_FUNC_NAME
    E_TESTS_PASSED = _connect.CTestGrpFuncStat_E_TESTS_PASSED
    E_TESTS_FAILED = _connect.CTestGrpFuncStat_E_TESTS_FAILED
    E_TESTS_ERROR = _connect.CTestGrpFuncStat_E_TESTS_ERROR
    E_CVRG_BYTES_ALL = _connect.CTestGrpFuncStat_E_CVRG_BYTES_ALL
    E_CVRG_BYTES_EXECUTED = _connect.CTestGrpFuncStat_E_CVRG_BYTES_EXECUTED
    E_CVRG_COND_ALL = _connect.CTestGrpFuncStat_E_CVRG_COND_ALL
    E_CVRG_COND_FALSE = _connect.CTestGrpFuncStat_E_CVRG_COND_FALSE
    E_CVRG_COND_TRUE = _connect.CTestGrpFuncStat_E_CVRG_COND_TRUE
    E_CVRG_COND_BOTH = _connect.CTestGrpFuncStat_E_CVRG_COND_BOTH
    E_CVRG_EXECUTION_COUNT = _connect.CTestGrpFuncStat_E_CVRG_EXECUTION_COUNT

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: reference to group which generate this result.
        """
        _connect.CTestGrpFuncStat_swiginit(self, _connect.new_CTestGrpFuncStat(*args))

    def createInstance(self, parent):
        return _connect.CTestGrpFuncStat_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestGrpFuncStat_cast(testBase)

    def getNoOfTestCases(self):
        r"""Returns the number of executed test cases."""
        return _connect.CTestGrpFuncStat_getNoOfTestCases(self)

    def getQualFuncName(self):
        r"""Returns name of qualified function."""
        return _connect.CTestGrpFuncStat_getQualFuncName(self)

    def getCoverage(self, section):
        r"""Returns coverage info for the given section. Valid values are E_CVRG_..."""
        return _connect.CTestGrpFuncStat_getCoverage(self, section)
    __swig_destroy__ = _connect.delete_CTestGrpFuncStat

# Register CTestGrpFuncStat in _connect:
_connect.CTestGrpFuncStat_swigregister(CTestGrpFuncStat)
class IEmitter(object):
    r"""
    This interface defines methods to be implemented by concrete emitters.
    Emitters are classes, which receive data from data objects, and write
    it to the given stream in specific format. For example, isys::CXMLEmitter writes
    the data in XML format.

    This abstract class can be used from C++ only.

    _rst
    Example::
      CfileStreamSPtr xmlReportFileStream(new CFileStream("fullReport.xml"));
      IEmitterSPtr xmlReportEmitter = ic.EmitterFactory.createXmlEmitter(xmlReportFileStream);
      xmlReportEmitter.startStream('<?xml-stylesheet type="text/xsl" href="itestResult.xslt"?>\n');

      // add content
      xmlReportEmitter.startDocument(true);
      testResult_1.serialize(xmlReportEmitter);
      xmlReportEmitter.endDocument(true);

      xmlReportEmitter.startDocument(true);
      testResult_2.serialize(xmlReportEmitter);
      xmlReportEmitter.endDocument(true);

      xmlReportEmitter.endStream();
      xmlReportFileStream.close();
    _rst

    See also: isys::CYAMLEmitter and isys::CXMLEmitter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_IEmitter
    ETestReportConfig = _connect.IEmitter_ETestReportConfig
    ETestReportStatistics = _connect.IEmitter_ETestReportStatistics
    ETestReport = _connect.IEmitter_ETestReport
    LINE_NUM_NOT_SET = _connect.IEmitter_LINE_NUM_NOT_SET
    EYAML_ANY_STYLE = _connect.IEmitter_EYAML_ANY_STYLE
    r"""any style is allowed"""
    EYAML_FLOW_STYLE = _connect.IEmitter_EYAML_FLOW_STYLE
    r"""uses [] for sequences, {} for maps"""
    EYAML_BLOCK_STYLE = _connect.IEmitter_EYAML_BLOCK_STYLE
    r"""moves to next line"""

    def getIndent(self):
        r"""Returns indentation string added to each line of output."""
        return _connect.IEmitter_getIndent(self)

    def setIndent(self, indent):
        r"""Sets indentation string added to each line of output."""
        return _connect.IEmitter_setIndent(self, indent)

    def getLineNumber(self):
        r"""
        This method provides information about current line being written
                   to the file. Not all emitters may provide this information. If emitter
                   does not keep track of line numbers, this method should return LINE_NUM_NOT_SET.
                   Emitter may return the number of all lines (for example CCSVEmitter).
        """
        return _connect.IEmitter_getLineNumber(self)

    def getRow(self, row, rowIndex):
        r"""
        This method returns row for the given index. Not all emitters may
        implement this method - an exception is throw in such case.
        """
        return _connect.IEmitter_getRow(self, row, rowIndex)

    def setLineNumber(self, lineNumber):
        r"""
        Can be used to set current line number in cases, where emitter does not
        start at the beginning of the stream, or to disable line counting by
        setting 'lineNumber' to LINE_NUM_NOT_SET. This is also the default value,
        so to enable line counting, call this method with value >= 0.
        """
        return _connect.IEmitter_setLineNumber(self, lineNumber)

    def startStream(self, *args):
        r"""
        *Overload 1:*
         Initializes the output stream object.

        |

        *Overload 2:*

        Initializes the output stream object.

        :type userData: string
        :param userData: text written directly to output stream, bypassing the
                   underlying emitter. This can be used for writing comments or
                   preprocessing instructions.
        """
        return _connect.IEmitter_startStream(self, *args)

    def endStream(self):
        r"""
        Ends output stream. The output stream is NOT
        closed. Call this method after emitting is done.
        """
        return _connect.IEmitter_endStream(self)

    def startDocument(self, implicit):
        r"""
        Starts the document. This method should be called after startStream().

        :type implicit: boolean
        :param implicit: currently used by YAML emitter only. When true, the
                            document is emitted without the leading '---'.
        """
        return _connect.IEmitter_startDocument(self, implicit)

    def endDocument(self, implicit):
        r"""
        Ends the document.

        :type implicit: boolean
        :param implicit: if the document end indicator is implicit. It is
            considered as a stylistic parameter and may be ignored by the emitter.
            If true, YAML emitter adds terminating doc sequence: '...'
        """
        return _connect.IEmitter_endDocument(self, implicit)

    def escapeSpecialChars(self, data):
        r"""
        This method modifies the input string so that it is in proper syntax
        for scalars. See CYAMLEmitter::escapeSpecialChars()
        and CXMLEmitter::escapeSpecialChars().
        """
        return _connect.IEmitter_escapeSpecialChars(self, data)

    def flush(self):
        r"""Flush the accumulated characters to the output."""
        return _connect.IEmitter_flush(self)

    def mapStart(self, *args):
        return _connect.IEmitter_mapStart(self, *args)

    def writeMapEnd(self):
        return _connect.IEmitter_writeMapEnd(self)

    def mapEnd(self):
        return _connect.IEmitter_mapEnd(self)

    def sequenceStart(self, *args):
        return _connect.IEmitter_sequenceStart(self, *args)

    def sequenceEnd(self):
        return _connect.IEmitter_sequenceEnd(self)

    def writeSequenceEnd(self):
        return _connect.IEmitter_writeSequenceEnd(self)

    def writeString(self, yamlData):
        return _connect.IEmitter_writeString(self, yamlData)

    def writeText(self, text):
        r"""Writes unmodified text to output."""
        return _connect.IEmitter_writeText(self, text)

# Register IEmitter in _connect:
_connect.IEmitter_swigregister(IEmitter)
class ICStream(object):
    r"""
    This interface provides common methods for streams. It can be used
    from C++ only.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_ICStream

    def write(self, str):
        r"""
        Writes string to output. Use this method to add custom data to
        output file. However, take care to keep the file format valid,
        for example if it is XML file, to use tags consistently.
        """
        return _connect.ICStream_write(self, str)

    def close(self):
        r"""
        Closes the underlying stream. If this method is not called, not
        all data may be written to the output.
        """
        return _connect.ICStream_close(self)

# Register ICStream in _connect:
_connect.ICStream_swigregister(ICStream)
class CStringStream(ICStream):
    r"""
    This class writes data to string stream.

    Python example: _sample_link{itest,cumulative_coverage}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Creates object with empty string stream."""
        _connect.CStringStream_swiginit(self, _connect.new_CStringStream())

    def write(self, str):
        r"""
        Writes string to output. Use this method to add custom data to
        output file. However, take care to keep the file format valid,
        for example if it is XML file, to use tags consistently.
        """
        return _connect.CStringStream_write(self, str)

    def close(self):
        r"""
        Closes the underlying stream. If this method is not called, not
        all data may be written to the output.
        """
        return _connect.CStringStream_close(self)

    def getString(self):
        r"""Returns contents of this stream as a string."""
        return _connect.CStringStream_getString(self)
    __swig_destroy__ = _connect.delete_CStringStream

# Register CStringStream in _connect:
_connect.CStringStream_swigregister(CStringStream)
class CFileStream(ICStream):
    r"""
    This class should be used by client applications to create native
    file stream for emitter output.

    Python example: _sample_link{itest,cumulative_coverage}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fileName, isAppend=False):
        r"""
        Output will be written to file.

        :type fileName: string
        :param fileName: name of the output file
        :type isAppend: boolean, optional
        :param isAppend: if true, output is appended to the existing
                            contents of file. If false, the file contents
                            is erased.
        """
        _connect.CFileStream_swiginit(self, _connect.new_CFileStream(fileName, isAppend))
    __swig_destroy__ = _connect.delete_CFileStream

    def write(self, str):
        r"""
        Writes string to output. Use this method to add custom data to
        output file. However, take care to keep the file format valid,
        for example if it is XML file, to use tags consistently.
        """
        return _connect.CFileStream_write(self, str)

    def close(self):
        r"""
        Closes the underlying stream. If this method is not called, not
        all data may be written to the output.
        """
        return _connect.CFileStream_close(self)

# Register CFileStream in _connect:
_connect.CFileStream_swigregister(CFileStream)
class EmitterFactory(object):
    r"""
    This is a factory class for emitters. Emitters can be used to write
    iSYSTEM test results to file. See isys::CTestResult.

    Python example with coverage: _sample_link{itest,cumulative_coverage}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createYamlEmitter(stream):
        r"""Creates emitter for YAML format."""
        return _connect.EmitterFactory_createYamlEmitter(stream)

    @staticmethod
    def createXmlEmitter(stream):
        r"""Creates emitter for XML format."""
        return _connect.EmitterFactory_createXmlEmitter(stream)

    @staticmethod
    def createCSVEmitter(fileStream, separator, isHeaderLine):
        r"""Creates emitter for CSV format."""
        return _connect.EmitterFactory_createCSVEmitter(fileStream, separator, isHeaderLine)

    def __init__(self):
        _connect.EmitterFactory_swiginit(self, _connect.new_EmitterFactory())
    __swig_destroy__ = _connect.delete_EmitterFactory

# Register EmitterFactory in _connect:
_connect.EmitterFactory_swigregister(EmitterFactory)
class CXMLEmitter(IEmitter):
    r"""
    This class serializes test specification objects to XML format.

    See also: isys::IEmitter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""Creates emitter to write data to the given stream."""
        _connect.CXMLEmitter_swiginit(self, _connect.new_CXMLEmitter(*args))
    __swig_destroy__ = _connect.delete_CXMLEmitter

    def startStream(self, *args):
        r"""
        Use this method to add your specific data immediately
        after the first line. It is mainly intended for processing
        instructions, for example XSLT processing:

            startStream("'<?xml-stylesheet type="text/xsl" href="itestResult.xslt"?>\\n")
        """
        return _connect.CXMLEmitter_startStream(self, *args)

    def endStream(self):
        return _connect.CXMLEmitter_endStream(self)

    def startDocument(self, implicit):
        return _connect.CXMLEmitter_startDocument(self, implicit)

    def endDocument(self, implicit):
        return _connect.CXMLEmitter_endDocument(self, implicit)

    def startNode(self, *args):
        return _connect.CXMLEmitter_startNode(self, *args)

    def endNode(self, nodeName):
        return _connect.CXMLEmitter_endNode(self, nodeName)

    def flush(self):
        return _connect.CXMLEmitter_flush(self)

    def escapeSpecialChars(self, data):
        r"""
         Escapes predefined entities in XML. See
        http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
        """
        return _connect.CXMLEmitter_escapeSpecialChars(self, data)

    def writeString(self, data):
        return _connect.CXMLEmitter_writeString(self, data)

    def writeText(self, text):
        return _connect.CXMLEmitter_writeText(self, text)

    def mapStart(self, *args):
        return _connect.CXMLEmitter_mapStart(self, *args)

    def mapEnd(self):
        return _connect.CXMLEmitter_mapEnd(self)

    def sequenceStart(self, *args):
        return _connect.CXMLEmitter_sequenceStart(self, *args)

    def sequenceEnd(self):
        return _connect.CXMLEmitter_sequenceEnd(self)

    def writeMappingPair(self, *args):
        return _connect.CXMLEmitter_writeMappingPair(self, *args)

# Register CXMLEmitter in _connect:
_connect.CXMLEmitter_swigregister(CXMLEmitter)
class CTestSpecification(CTestTreeNode):
    r"""
    This class encapsulates all data required for one test. It
    is the top level class aggregating all other classes related to
    test specification. It may also contain children, which inherit
    parts of specification.

    Python example from ``cumulativeModuleCoverage.py``:

    \skipline runDerivedTests

    This class is directly or indirectly used in all test examples.
    <p>
    Python example with coverage: @py_sample_link{itest,cumulative_coverage}
    Python example with module coverage: @py_sample_link{itest,cumulative_module_coverage}
    Python example modifies function parameters: @py_sample_link{itest,itest_with_parameters}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ID = _connect.CTestSpecification_E_SECTION_ID
    E_SECTION_TEST_SCOPE = _connect.CTestSpecification_E_SECTION_TEST_SCOPE
    E_SECTION_BASE_ID = _connect.CTestSpecification_E_SECTION_BASE_ID
    E_SECTION_RUN = _connect.CTestSpecification_E_SECTION_RUN
    E_SECTION_IMPORTS = _connect.CTestSpecification_E_SECTION_IMPORTS
    E_SECTION_DESC = _connect.CTestSpecification_E_SECTION_DESC
    E_SECTION_TAGS = _connect.CTestSpecification_E_SECTION_TAGS
    E_SECTION_OPTIONS = _connect.CTestSpecification_E_SECTION_OPTIONS
    E_SECTION_PERSIST_VARS = _connect.CTestSpecification_E_SECTION_PERSIST_VARS
    E_SECTION_LOCALS = _connect.CTestSpecification_E_SECTION_LOCALS
    E_SECTION_INIT = _connect.CTestSpecification_E_SECTION_INIT
    E_SECTION_BEGIN_STOP_CONDITION = _connect.CTestSpecification_E_SECTION_BEGIN_STOP_CONDITION
    E_SECTION_END_STOP_CONDITION = _connect.CTestSpecification_E_SECTION_END_STOP_CONDITION
    E_SECTION_FUNC = _connect.CTestSpecification_E_SECTION_FUNC
    E_SECTION_TIMEOUT = _connect.CTestSpecification_E_SECTION_TIMEOUT
    E_SECTION_CORE_ID = _connect.CTestSpecification_E_SECTION_CORE_ID
    E_SECTION_INIT_TARGET = _connect.CTestSpecification_E_SECTION_INIT_TARGET
    E_SECTION_INITFUNC = _connect.CTestSpecification_E_SECTION_INITFUNC
    E_SECTION_ENDFUNC = _connect.CTestSpecification_E_SECTION_ENDFUNC
    E_SECTION_RESTORE_TARGET = _connect.CTestSpecification_E_SECTION_RESTORE_TARGET
    E_SECTION_STUBS = _connect.CTestSpecification_E_SECTION_STUBS
    E_SECTION_USER_STUBS = _connect.CTestSpecification_E_SECTION_USER_STUBS
    E_SECTION_TEST_POINTS = _connect.CTestSpecification_E_SECTION_TEST_POINTS
    E_SECTION_PRE_CONDITION = _connect.CTestSpecification_E_SECTION_PRE_CONDITION
    E_SECTION_ASSERT = _connect.CTestSpecification_E_SECTION_ASSERT
    E_SECTION_STACK_USAGE = _connect.CTestSpecification_E_SECTION_STACK_USAGE
    E_SECTION_LOG = _connect.CTestSpecification_E_SECTION_LOG
    E_SECTION_ANALYZER = _connect.CTestSpecification_E_SECTION_ANALYZER
    E_SECTION_HIL = _connect.CTestSpecification_E_SECTION_HIL
    E_SECTION_DRY_RUN = _connect.CTestSpecification_E_SECTION_DRY_RUN
    E_SECTION_DIAGRAMS = _connect.CTestSpecification_E_SECTION_DIAGRAMS
    E_SECTION_TESTS = _connect.CTestSpecification_E_SECTION_TESTS
    E_SECTION_PARAMS_PRIVATE = _connect.CTestSpecification_E_SECTION_PARAMS_PRIVATE
    E_SECTION_TRACE = _connect.CTestSpecification_E_SECTION_TRACE
    E_SECTION_COVERAGE = _connect.CTestSpecification_E_SECTION_COVERAGE
    E_SECTION_PROFILER = _connect.CTestSpecification_E_SECTION_PROFILER
    E_SECTION_EXPECT = _connect.CTestSpecification_E_SECTION_EXPECT
    E_UNIT_TEST = _connect.CTestSpecification_E_UNIT_TEST
    r"""
    function is tested, test starts with a function call
    and ends when the function returns
    """
    E_SYSTEM_TEST = _connect.CTestSpecification_E_SYSTEM_TEST
    r"""system is tested, test end is specified as breakpoint or timeout"""

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Should be used for root specification only.

        |

        *Overload 2:*
        Creates an empty instance with the given parent.
        """
        _connect.CTestSpecification_swiginit(self, _connect.new_CTestSpecification(*args))
    __swig_destroy__ = _connect.delete_CTestSpecification

    def getUILabel(self):
        r"""Returns label to be shown in testIDEA."""
        return _connect.CTestSpecification_getUILabel(self)

    def isGroup(self):
        r"""Returns true, if this object is of type CTestGroup, false if it is CTestSpecification."""
        return _connect.CTestSpecification_isGroup(self)

    def createInstance(self, parent):
        r"""
        Creates an empty instance of this class.

        :type parent: :py:class:`CTestBase`
        :param parent: must be of instance CTestSpecification, since other classes
                   can not be parents of CTestSpecification.
        """
        return _connect.CTestSpecification_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestSpecification_cast(testBase)

    def assign(self, testSpec):
        return _connect.CTestSpecification_assign(self, testSpec)

    def getContainerTestNode(self):
        r"""
        Always returns this. This method is overridden from CTestBase,
        and is used by other aggregated classes to find the container test spec,
        which is this.
        """
        return _connect.CTestSpecification_getContainerTestNode(self)

    def getParentTestSpecification(self):
        r"""Returns parent test specification or NULL, if this is the root specification."""
        return _connect.CTestSpecification_getParentTestSpecification(self)

    def getSourceLineNumber(self):
        r"""
         Returns number of the line in file, where this test spec is defined, or
        -1 if not set. This value is not valid, after test specification is moved
        to other location in test tree or pasted from clipboard. In such cases it
        shows the source, where the test specification WILL be saved.
        """
        return _connect.CTestSpecification_getSourceLineNumber(self)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestSpecification_isMerged(self)

    def isTestSpecification(self):
        r"""Always returns true. Needed because type info is lost with SWIG."""
        return _connect.CTestSpecification_isTestSpecification(self)

    def getCachedMergedTestSpec(self, *args):
        r"""
        *Overload 1:*

        If section is merged, returns cached merged test spec., which was set with
        setCachedMergedTestSpec(), else null is returned.
        Needed for optimization purposes.

        |

        *Overload 2:*

        Returns merged test spec, if set, null otherwise.
        """
        return _connect.CTestSpecification_getCachedMergedTestSpec(self, *args)

    def setCachedMergedTestSpec(self, mergedTestSpec):
        r"""
        Caches merged test spec. to be used in subsequent calls. Needed for
        optimization purposes.
        """
        return _connect.CTestSpecification_setCachedMergedTestSpec(self, mergedTestSpec)

    def getId(self):
        r"""Return true, if there is no data in test specification.  Returns test id as specified in tag **id**."""
        return _connect.CTestSpecification_getId(self)

    def getTestId(self):
        r"""Deprecated since Jan 2016. Use getId() instead."""
        return _connect.CTestSpecification_getTestId(self)

    def getBaseId(self):
        r"""
        Returns id of the parent. This tag is used only when test specifications
        are specified in the source code file, and is ignored otherwise.
        """
        return _connect.CTestSpecification_getBaseId(self)

    def getRunFlag(self):
        r"""
        Returns run flag. If value is E_TRUE or E_DEFAULT,
        test specification should be executed - it is not used just as a base class.
        """
        return _connect.CTestSpecification_getRunFlag(self)

    def getDescription(self):
        r"""Returns test description as specified in tag **description**."""
        return _connect.CTestSpecification_getDescription(self)

    def getTags(self, tags):
        r"""Returns test tags as specified in tag **tags**."""
        return _connect.CTestSpecification_getTags(self, tags)

    def getTestScope(self):
        r"""Returns test type - unit or system test."""
        return _connect.CTestSpecification_getTestScope(self)

    def getFunctionUnderTest(self, isConst):
        r"""Returns specification for the function under test."""
        return _connect.CTestSpecification_getFunctionUnderTest(self, isConst)

    def getTestTimeout(self):
        r"""
        Returns timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout. If this value is not specified,
        this method returns -1 (global timeout setting will be used).
        """
        return _connect.CTestSpecification_getTestTimeout(self)

    def getCoreId(self):
        r"""
        Returns ID of CPU core, where this test case should be executed,
        or empty string if core ID is not specified.
        """
        return _connect.CTestSpecification_getCoreId(self)

    def getPositionParams(self, params):
        r"""Returns function parameters specified in 'func:' section."""
        return _connect.CTestSpecification_getPositionParams(self, params)

    def hasPositionParams(self):
        r"""Returns true, if there are function parameters specified in 'func:' section."""
        return _connect.CTestSpecification_hasPositionParams(self)

    def getInitFunction(self, isConst):
        r"""
        Returns specification for the ``init`` function,
        which is called just before the function under test is
        executed.
        """
        return _connect.CTestSpecification_getInitFunction(self, isConst)

    def getEndFunction(self, isConst):
        r"""
        Returns specification for the ``end`` function,
        which is called immediately after the function under test is
        executed.
        """
        return _connect.CTestSpecification_getEndFunction(self, isConst)

    def getInitTargetFunction(self, isConst):
        r"""
        Returns specification for script function to be called before any test
        initialization is done. Use it to initialize target before test.
        """
        return _connect.CTestSpecification_getInitTargetFunction(self, isConst)

    def getRestoreTargetFunction(self, isConst):
        r"""
        Returns specification for script function to be called after test environment
        on the stack is destroyed. Use it to restore target state after test.
        """
        return _connect.CTestSpecification_getRestoreTargetFunction(self, isConst)

    def getStubs(self, isConst):
        r"""Returns stubs in another type of container."""
        return _connect.CTestSpecification_getStubs(self, isConst)

    def getStub(self, functionName):
        r"""Returns stub object for the given function."""
        return _connect.CTestSpecification_getStub(self, functionName)

    def getUserStubs(self, isConst):
        r"""
        Returns reference to list of all user stub specifications. New stubs
        can be added by adding them to the returned vector.
        """
        return _connect.CTestSpecification_getUserStubs(self, isConst)

    def getUserStub(self, functionName):
        r"""Returns user stub object for the given function."""
        return _connect.CTestSpecification_getUserStub(self, functionName)

    def getTestPoints(self, isConst):
        r"""
        Returns reference to list of all test point specifications. New
        test points can be added by adding them to the returned vector.
        """
        return _connect.CTestSpecification_getTestPoints(self, isConst)

    def getTestPoint(self, testPointId):
        r"""
        Returns test point object for the given id or NULL ptr if test
        point was not found.
        """
        return _connect.CTestSpecification_getTestPoint(self, testPointId)

    def getTestPointIdx(self, testPointId):
        r"""
        :rtype: int
        :return: index of test point in test points vector, or -1 if the test
            point with the given Id was not found.
        """
        return _connect.CTestSpecification_getTestPointIdx(self, testPointId)

    def assignTestPoints(self, src):
        r"""
        This method copies test points from src to this object. Original
        test points are removed.
        """
        return _connect.CTestSpecification_assignTestPoints(self, src)

    def removeStub(self, *args):
        r"""
        *Overload 1:*
         Removes stub.

        |

        *Overload 2:*

        Removes stub with the given function name.
        Returns stub index in a list, if stub was removed, -1 if the stub
        did not exist.
        """
        return _connect.CTestSpecification_removeStub(self, *args)

    def assignStubs(self, src):
        r"""This method copies stubs from src to this object. Original stubs are removed."""
        return _connect.CTestSpecification_assignStubs(self, src)

    def removeUserStub(self, functionName):
        r"""
        Removes user stub with the given function name.
        Returns stub index in a list, if stub was removed, -1 if the stub
        did not exist.
        """
        return _connect.CTestSpecification_removeUserStub(self, functionName)

    def assignUserStubs(self, src):
        r"""This method copies stubs from src to this object. Original stubs are removed."""
        return _connect.CTestSpecification_assignUserStubs(self, src)

    def assignOptions(self, src):
        r"""This method copies stubs from src to this object."""
        return _connect.CTestSpecification_assignOptions(self, src)

    def getLocalVariables(self, localVars):
        r"""
        Returns local variables specified as a map of
        ``[var name, var type]`` pairs.

        :type localVars: :py:class:`StrStrMap`
        :param localVars: map to receive local variables
        """
        return _connect.CTestSpecification_getLocalVariables(self, localVars)

    def getLocalVariablesKeys(self, vars):
        r"""
        Returns names of local variable in the same order as they were
        entered in test specification.
        """
        return _connect.CTestSpecification_getLocalVariablesKeys(self, vars)

    def getInitKeys(self, *args):
        r"""
        *Overload 1:*

        Returns vector with names of variables to be initialized.
        The vector contains variables in the same order in which they
        were inserted into internal map, and this is also the order
        that should be used for initialization.
        See also getInitValues().

        |

        *Overload 2:*
         Returns the same info as getInitKeys(), but with original quoting.
        """
        return _connect.CTestSpecification_getInitKeys(self, *args)

    def getInitValues(self, values):
        r"""
        Returns vector with values of variables to be initialized. Values
        are returned in the order which matches keys returned by getInitKeys().
        See also getInitKeys().
        """
        return _connect.CTestSpecification_getInitValues(self, values)

    def getInitMap(self, initMap):
        r"""
        Returns initialization assignments of local variables.
        Note: The order of assignments is not preserved! Use this method
        to get values of the known variables, but not to modify it and then
        use it for setting of assignments.

        :type initMap: :py:class:`StrStrMap`
        :param initMap: object to receive mapping data
        """
        return _connect.CTestSpecification_getInitMap(self, initMap)

    def getExpectedResults(self, expectedResults):
        r"""
        Deprecated: use getAssert() instead.

        Returns expected values, specified as a list of expressions.

        :type expectedResults: :py:class:`StrVector`
        :param expectedResults: StrVector to receive expected values
        """
        return _connect.CTestSpecification_getExpectedResults(self, expectedResults)

    def getPrecondition(self, isConst):
        r"""Returns object containing assertions to be verified *before* test start."""
        return _connect.CTestSpecification_getPrecondition(self, isConst)

    def getAssert(self, isConst):
        r"""Returns object containing assertions for test result."""
        return _connect.CTestSpecification_getAssert(self, isConst)

    def getLog(self, isConst):
        r"""
        Returns object containing expressions to be logged before test
        starts and when test ends.
        """
        return _connect.CTestSpecification_getLog(self, isConst)

    def getAnalyzer(self, isConst):
        r"""Returns analyzer configuration."""
        return _connect.CTestSpecification_getAnalyzer(self, isConst)

    def getTrace(self, isConst):
        r"""Deprecated: call getAnalyzer().getTrace() instead."""
        return _connect.CTestSpecification_getTrace(self, isConst)

    def getCoverage(self, isConst):
        r"""Deprecated: call getAnalyzer().getCoverage() instead."""
        return _connect.CTestSpecification_getCoverage(self, isConst)

    def getProfiler(self, isConst):
        r"""Deprecated: call getAnalyzer().getProfiler() instead."""
        return _connect.CTestSpecification_getProfiler(self, isConst)

    def getHIL(self, isConst):
        r"""Returns HIL configuration."""
        return _connect.CTestSpecification_getHIL(self, isConst)

    def getDryRun(self, isConst):
        r"""Returns Dry Run configuration."""
        return _connect.CTestSpecification_getDryRun(self, isConst)

    def getStackUsage(self, isConst):
        r"""Returns settings for stack usage."""
        return _connect.CTestSpecification_getStackUsage(self, isConst)

    def getPersistentVars(self, isConst):
        r"""Returns persistent variables."""
        return _connect.CTestSpecification_getPersistentVars(self, isConst)

    def getOptionKeys(self, *args):
        r"""
        *Overload 1:*
        Returns names of winIDEA options to be set. See also getOptionValues().

        |

        *Overload 2:*
        Returns names of winIDEA options to be set with original quoting.
        """
        return _connect.CTestSpecification_getOptionKeys(self, *args)

    def getOptionValues(self, values):
        r"""
        Returns values of winIDEA options to be set. They are in
        the same order as keys returned by getOptionKeys().
        """
        return _connect.CTestSpecification_getOptionValues(self, values)

    def getImports(self, isConst):
        r"""Returns reference to modifiable specification of imports."""
        return _connect.CTestSpecification_getImports(self, isConst)

    def getBeginStopCondition(self, isConst):
        r"""Returns stop condition to be used before system test for target initialization."""
        return _connect.CTestSpecification_getBeginStopCondition(self, isConst)

    def getEndStopCondition(self, isConst):
        r"""Returns stop condition to be used as system test termination."""
        return _connect.CTestSpecification_getEndStopCondition(self, isConst)

    def getDiagrams(self, isConst):
        return _connect.CTestSpecification_getDiagrams(self, isConst)

    def hasChildren(self):
        r"""Returns true, if there are derived test specifications."""
        return _connect.CTestSpecification_hasChildren(self)

    def getChildren(self, isConst):
        r"""Returns pointer to the list of derives test cases."""
        return _connect.CTestSpecification_getChildren(self, isConst)

    def getNoOfDerivedSpecs(self):
        r"""Returns the number of derived test specs."""
        return _connect.CTestSpecification_getNoOfDerivedSpecs(self)

    def getDerivedTestSpec(self, idx):
        r"""
        Returns derived test spec at the given index. The returned test specification
        contains only its own data, no data from base test specification is inherited
        with this call. To get a test specification with inherited data, which can be
        executed, call method ``merge()`` on the returned test specification object.

        :type idx: int
        :param idx: index to derived test specification. It should be
            and less than the value returned by ``getNoOfDerivedSpecs()``, and >= 0.

        :raises: IndexOutOfBoundsException if index is not valid.
        """
        return _connect.CTestSpecification_getDerivedTestSpec(self, idx)

    def findDerivedTestSpec(self, *args):
        r"""
        *Overload 1:*

        Returns index of the given test specification, or -1 if not found.
        Pointer equality is checked, only the first level is searched.

        |

        *Overload 2:*

        This method returns the first derived test specification with the given ID.
        It does not check if there are other derived test specs with the given ID.

        :type testId: string
        :param testId:
        :type recursiveLevel: int
        :param recursiveLevel: defines how deep in hierarchy the search should go.
            Usually it has value 0, which means only derived test specs of the
            containerTestSpec, or -1, which means infinite depth.
        :rtype: :py:class:`CTestSpecification`
        :return: test spec with the given ID or null, if no test spec was found
        """
        return _connect.CTestSpecification_findDerivedTestSpec(self, *args)

    def addDerivedTestSpec(self, idx, testSpec):
        r"""
        Adds given test specification to the list of derived specifications
        at the given index. Parent of the added test specification is NOT modified!
        Use this method when adding test specification to container test spec, not
        to parent in the model. For example, if user selects several distinct test specs
        in tree, a container test spec can be used to group all selected test specs
        together and then for example execute them. However, their parents MUST NOT be
        modified, because they are still members of the test tree!

        :type idx: int
        :param idx: advice where to put test spec in the derived test spec list
                   If -1 or out of range, the test spec is added to the end of the list.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: test specification to add.
        """
        return _connect.CTestSpecification_addDerivedTestSpec(self, idx, testSpec)

    def addChildAndSetParent(self, idx, testSpec):
        r"""
        Adds given test specification to the list of derived specifications
        at the given index. Parent of the added test specification is set to 'this'!
        Use this method when modifying test specification tree.

        :type idx: int
        :param idx: advice where to put test spec in the derived test spec list
                   If -1 or out of range, the test spec is added to the end of the list.

        :type testSpec: :py:class:`CTestTreeNode`
        :param testSpec: test specification to be added.
        """
        return _connect.CTestSpecification_addChildAndSetParent(self, idx, testSpec)

    def deleteAllDerivedTestSpecs(self):
        r"""Deletes all derived test specifications."""
        return _connect.CTestSpecification_deleteAllDerivedTestSpecs(self)

    def deleteDerivedTestSpec(self, idx):
        r"""Deletes test spec at the given index."""
        return _connect.CTestSpecification_deleteDerivedTestSpec(self, idx)

    def deleteChild(self, child):
        r"""
        Deletes the given derived test spec. Returns index of deleted test spec,
        if the spec was found and deleted, -1 if it was not found.
        """
        return _connect.CTestSpecification_deleteChild(self, child)

    def getWarnings(self):
        r"""
        If there were any warnings detected during parsing, this method returns
        non-empty string with description of warnings. It is recommended to
        call this method always after parsing.

        See also: CTestBench::getWarnings()
        """
        return _connect.CTestSpecification_getWarnings(self)

    def serializeMember(self, emitter, section):
        r"""
        Conditional comment: exclude_this_method
        Used by CTE export in testIDEA.
        """
        return _connect.CTestSpecification_serializeMember(self, emitter, section)

    def isEmptyExceptDerived(self):
        r"""
         End of conditional comment.
        Returns true, if test spec has no data, except derived test specs.
        This is used in GUI, which may hide the root test spec in such case.
        """
        return _connect.CTestSpecification_isEmptyExceptDerived(self)

    def merge(self):
        r"""
        This method merges all parent test specifications with this one.

        All sections, which are defined in parent test specifications and
        not in this test spec., are copied to the returned test specification.
        Original test specifications are not modified.


        :rtype: :py:class:`CTestSpecification`
        :return: new test specification with merged test sections.
        """
        return _connect.CTestSpecification_merge(self)

    def getMergedTestScope(self):
        r"""This method returns merged value of test scope section."""
        return _connect.CTestSpecification_getMergedTestScope(self)

    def isSectionEmpty(self, sectionId):
        return _connect.CTestSpecification_isSectionEmpty(self, sectionId)

    def isSectionMerged(self, sectionId):
        r"""
        This method returns true, if the section is defined in parent
        test spec, but not in this test spec. This rule is processed
        recursively for all parents. If a parent with non-empty section is
        found, this method returns true. This method does not take 'imports'
        section into account - see method isInheritSection().
        """
        return _connect.CTestSpecification_isSectionMerged(self, sectionId)

    def isInheritSection(self, sectionId):
        r"""
        This method returns true, if isSectionMerged() returns true, AND
        this section is marked as inherited in the 'imports' section.


        Rules for inheritance:

        | isInherit  | definedInBase |definedInDerived | isInheritSection | isEditable |
        | :--------: | :-----------: | :-------------: | :--------------: | :--------: |
        |     0      |      0        |       0         |        0         |   1        |
        |     0      |      0        |       1         |        0         |   1        |
        |     0      |      1        |       0         |        0         |   1        |
        |     0      |      1        |       1         |        0         |   1        |
        |            |               |                 |                  |            |
        |     1      |      0        |       0         |        0         |   1        |
        |     1      |      0        |       1         |        0         |   1        |
        |     1      |      1        |       0         |        1         |   0        |
        |     1      |      1        |       1         |        0         |   1        |
        |            |               |                 |                  |            |
        | from _imports_ |   isSectionMerged()        ||                  |            |
        """
        return _connect.CTestSpecification_isInheritSection(self, sectionId)

    def setMainMapStyle(self, mappingStyle):
        r"""
        Always sets mapping style to BLOCK. Because of YAML comments
        FLOW style is not allowed for instances of this class.
        """
        return _connect.CTestSpecification_setMainMapStyle(self, mappingStyle)

    def setTestId(self, testId):
        r"""Sets test id."""
        return _connect.CTestSpecification_setTestId(self, testId)

    def setBaseId(self, testId):
        r"""
        Sets parent id.
        See also: getParentId
        """
        return _connect.CTestSpecification_setBaseId(self, testId)

    def setRunFlag(self, isRun):
        r"""Sets run flag."""
        return _connect.CTestSpecification_setRunFlag(self, isRun)

    def setDescription(self, description):
        r"""Sets description."""
        return _connect.CTestSpecification_setDescription(self, description)

    def setTags(self, *args):
        r"""
        *Overload 1:*

        Deprecated: use setTags(StrVector)
        Sets tags.

        |

        *Overload 2:*

        Sets tags.
        """
        return _connect.CTestSpecification_setTags(self, *args)

    def setTestScope(self, testType):
        r"""Sets test type."""
        return _connect.CTestSpecification_setTestScope(self, testType)

    def setLocalVariables(self, yamlSpec):
        r"""
        Sets declarations of local variables used in test.

        :type yamlSpec: string
        :param yamlSpec: map of ``var_name``: ``var_type`` pairs in YAML format.
        """
        return _connect.CTestSpecification_setLocalVariables(self, yamlSpec)

    def setInitValues(self, yamlSpec):
        r"""
        Sets initialization values of variables used in test.

        :type yamlSpec: string
        :param yamlSpec: map of ``var_name``: ``init_value`` pairs in YAML format.
        """
        return _connect.CTestSpecification_setInitValues(self, yamlSpec)

    def setExpectedResults(self, expectedResults):
        r"""
        :type expectedResults: :py:class:`StrVector`
        :param expectedResults: vector of expected results.
        """
        return _connect.CTestSpecification_setExpectedResults(self, expectedResults)

    def setIdeOptions(self, yamlSpec):
        r"""
        Sets IDE options.

        :type yamlSpec: string
        :param yamlSpec: map of ``option_path``: ``option_value`` pairs in YAML format.
        """
        return _connect.CTestSpecification_setIdeOptions(self, yamlSpec)

    def setTestTimeout(self, timeout):
        r"""
        Sets timeout (in milliseconds), after which test execution is terminated.
        Value 0 means infinite timeout, value -1 means that timeout is not specified,
        and that global timeout setting will be used.
        """
        return _connect.CTestSpecification_setTestTimeout(self, timeout)

    def setCoreId(self, coreId):
        r"""Sets core ID where this test case should be executed."""
        return _connect.CTestSpecification_setCoreId(self, coreId)

    def validate(self):
        return _connect.CTestSpecification_validate(self)

    def getNoOfTests(self, isSkipAbstractTests):
        r"""
        Returns the number of tests in this test specification - counts
        this specification and all derived tests.

        :type isSkipAbstractTests: boolean
        :param isSkipAbstractTests: if true, abstract tests are not
            counted (tests with 'run' tag set to false) - the number of runnable
            tests is returned.
            Python example: _sample_link{itest,cumulative_coverage}
        """
        return _connect.CTestSpecification_getNoOfTests(self, isSkipAbstractTests)

    def clearEmptySections(self):
        r"""
        This method releases all sections, which contain no data (only
        empty strings). It can save some memory this way - it exists for
        optimization purposes, not functionality.
        """
        return _connect.CTestSpecification_clearEmptySections(self)

    def save(self, fileName, isAppend=False):
        r"""
        Writes test spec to the given file.

        :type fileName: string
        :param fileName: name of the file to write specification to
        :type isAppend: boolean, optional
        :param isAppend: if true, test spec is appended to the given file.
                            This is useful, if test spec must be inserted into the file -
                            caller copies the first part of the file, calls this method,
                            and finally copies the rest of the file.
        """
        return _connect.CTestSpecification_save(self, fileName, isAppend)

    @staticmethod
    def load(fileName, filePos=0):
        r"""
        Loads test specification from file.

        :type fileName: string
        :param fileName: name of the file to load.
        :type filePos: int, optional
        :param filePos: offset in file to start reading from.
        """
        return _connect.CTestSpecification_load(fileName, filePos)

    @staticmethod
    def parseTestSpec(yamlSpec):
        r"""
        Parses test specification in YAML format and returns new object
        containing the given information.
        This method is implemented for access from SWIG wrappers, which are not
        aware of ITestParserEventReceiver. C++ apps should use more generic
        parseYAML() method.

        :type yamlSpec: string
        :param yamlSpec: test spec. in YAML format

        Python example: _sample_link{itest,cumulative_coverage}
        Python example: _sample_link{itest,cumulative_module_coverage}
        """
        return _connect.CTestSpecification_parseTestSpec(yamlSpec)

    def clearMergedFilterInfo(self, isClearRecursively):
        r"""
        For optimization reasons test specification stores merged info
        during filtering. However, it is not automatically reset on
        test spec change (for example when setTestId() is called), so
        this method must be explicitly called before running tests with
        filtering. Otherwise stale data in cache will corrupt filtering.
        """
        return _connect.CTestSpecification_clearMergedFilterInfo(self, isClearRecursively)

# Register CTestSpecification in _connect:
_connect.CTestSpecification_swigregister(CTestSpecification)
class CTestStub(CTestBase):
    r"""
    This class contains specification for one stub. Since stubbed
    function will not be called, we have to specify its return
    values and other side effects. This information is stored in
    this class.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_STUBBED_FUNC = _connect.CTestStub_E_SECTION_STUBBED_FUNC
    E_SECTION_IS_ACTIVE = _connect.CTestStub_E_SECTION_IS_ACTIVE
    E_SECTION_IS_CUSTOM_ACTIVATION = _connect.CTestStub_E_SECTION_IS_CUSTOM_ACTIVATION
    E_SECTION_PARAM_NAMES = _connect.CTestStub_E_SECTION_PARAM_NAMES
    E_SECTION_RET_VAL_NAME = _connect.CTestStub_E_SECTION_RET_VAL_NAME
    E_SECTION_SCRIPT_FUNCTION = _connect.CTestStub_E_SECTION_SCRIPT_FUNCTION
    E_SECTION_HIT_LIMITS = _connect.CTestStub_E_SECTION_HIT_LIMITS
    E_SECTION_LOG = _connect.CTestStub_E_SECTION_LOG
    E_SECTION_ASSIGN_STEPS = _connect.CTestStub_E_SECTION_ASSIGN_STEPS
    E_SECTION_FUNC = _connect.CTestStub_E_SECTION_FUNC
    E_SECTION_ASSIGN = _connect.CTestStub_E_SECTION_ASSIGN
    E_SECTION_SCRIPT = _connect.CTestStub_E_SECTION_SCRIPT

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestStub_swiginit(self, _connect.new_CTestStub(*args))
    __swig_destroy__ = _connect.delete_CTestStub

    def createInstance(self, *args):
        return _connect.CTestStub_createInstance(self, *args)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestStub_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestStub_isMerged(self)

    def getFunctionName(self):
        r"""Returns the name of stubbed function."""
        return _connect.CTestStub_getFunctionName(self)

    def isActive(self):
        r"""Returns true, if stub is active during test execution."""
        return _connect.CTestStub_isActive(self)

    def getActive(self):
        r"""
         Returns string setting as specified in YAML file. Empty string
        means default setting.

        See also: isActive
        """
        return _connect.CTestStub_getActive(self)

    def isCustomActivation(self):
        r"""
        Returns true, if test point will not be activated before test execution,
        but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breakpoints available.
        """
        return _connect.CTestStub_isCustomActivation(self)

    def getRetValName(self):
        r"""Returns name assigned to the stub return value."""
        return _connect.CTestStub_getRetValName(self)

    def getParamNames(self, params):
        r"""Returns names of parameters assigned to stubbed function parameters."""
        return _connect.CTestStub_getParamNames(self, params)

    def getScriptFunctionName(self):
        r"""
        Returns the function to be called in the test
        suite, instead of the stubbed one on the target.
        This function may simulate side effects normally caused by the
        stubbed function.
        """
        return _connect.CTestStub_getScriptFunctionName(self)

    def getLogConfig(self, isConst):
        r"""Returns logging configuration."""
        return _connect.CTestStub_getLogConfig(self, isConst)

    def getHitLimits(self, isConst):
        r"""Returns hit limits."""
        return _connect.CTestStub_getHitLimits(self, isConst)

    def getAssignmentSteps(self, isConst):
        r"""Returns assignment steps."""
        return _connect.CTestStub_getAssignmentSteps(self, isConst)

    def setFunctionName(self, functionName):
        r"""Sets the name of the function to be stubbed."""
        return _connect.CTestStub_setFunctionName(self, functionName)

    def setActive(self, isActive):
        r"""
        If parameter is ``true``, then the stub is active during test execution.
        Otherwise it will be ignored - the function on the target is called.
        """
        return _connect.CTestStub_setActive(self, isActive)

    def setCustomActivation(self, isActive):
        r"""
        If parameter is ``true``, then the stub will not be activated before
        test execution, but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breskpoints available.
        """
        return _connect.CTestStub_setCustomActivation(self, isActive)

    def setRetValName(self, retValName):
        r"""Sets name assigned to the stub return value."""
        return _connect.CTestStub_setRetValName(self, retValName)

    def setScriptFunctionName(self, scriptFuncName):
        r"""Sets name assigned to the stub return value."""
        return _connect.CTestStub_setScriptFunctionName(self, scriptFuncName)

# Register CTestStub in _connect:
_connect.CTestStub_swigregister(CTestStub)
class CTestLocation(CTestBase):
    r"""
    This class defines location in source code. Location can be given
    either as line number in file, or line number in function.
    Line numbers in files are 1-based, because this convention
    is used by most text editors. Line numbers in function are 0-based,
    because it is easy to see the line number of zeroth function line
    in editor,
    and line number of the line where we want to set a test point, and
    simply subtract them. Furthermore, most developers in embedded
    world use C language, which is 0-based. 

    (Note: We can also find
    reasoning to have file line numbers 0-based or function relative
    line numbers 1-based, so whatever decision is made, it will be wrong
    from some other point of view.
    See also: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_RESOURCE_TYPE = _connect.CTestLocation_E_SECTION_RESOURCE_TYPE
    E_SECTION_RESOURCE_NAME = _connect.CTestLocation_E_SECTION_RESOURCE_NAME
    E_SECTION_SRC_FILE_LOCATION = _connect.CTestLocation_E_SECTION_SRC_FILE_LOCATION
    E_SECTION_LINE = _connect.CTestLocation_E_SECTION_LINE
    E_SECTION_IS_SEARCH = _connect.CTestLocation_E_SECTION_IS_SEARCH
    E_SECTION_LINES_RANGE = _connect.CTestLocation_E_SECTION_LINES_RANGE
    E_SECTION_SEARCH_CONTEXT = _connect.CTestLocation_E_SECTION_SEARCH_CONTEXT
    E_SECTION_MATCH_TYPE = _connect.CTestLocation_E_SECTION_MATCH_TYPE
    E_SECTION_PATTERN = _connect.CTestLocation_E_SECTION_PATTERN
    E_SECTION_LINE_OFFSET = _connect.CTestLocation_E_SECTION_LINE_OFFSET
    E_SECTION_NUM_STEPS = _connect.CTestLocation_E_SECTION_NUM_STEPS

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestLocation_swiginit(self, _connect.new_CTestLocation(*args))
    __swig_destroy__ = _connect.delete_CTestLocation

    def createInstance(self, parent):
        return _connect.CTestLocation_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestLocation_cast(testBase)

    def getRuntimeLocation(self):
        r"""
        Returns location as calculated during runtime - file name and
        line number. This information is available only after test execution,
        and is not stored to iyaml file. If runtime location has not been set yet,
        an empty string is returned.
        """
        return _connect.CTestLocation_getRuntimeLocation(self)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestLocation_isMerged(self)

    def getResourceType(self):
        r"""Returns type of resource for which location is given."""
        return _connect.CTestLocation_getResourceType(self)

    def getResourceName(self):
        r"""Returns name of resource where test point is located."""
        return _connect.CTestLocation_getResourceName(self)

    def getSrcFileLocation(self):
        r"""
        Returns location of source files - local host running test case
        or remote host running winIDEA.
        """
        return _connect.CTestLocation_getSrcFileLocation(self)

    def getLine(self):
        r"""
        Returns line number, where test point is set, or where
        search range starts (if pattern is defined). Lines for file
        are 1-based, while lines for function are 0 based and can also be
        negative.
        """
        return _connect.CTestLocation_getLine(self)

    def isSearch(self):
        r"""
        Returns true, if search is to be performed. Otherwise the line
        number returned by getLine() is used to set a test point.
        """
        return _connect.CTestLocation_isSearch(self)

    def getLinesRange(self):
        r"""
        Returns the number of lines, which are searched for pattern.
        Value 0 means till the end of file.
        """
        return _connect.CTestLocation_getLinesRange(self)

    def getSearchContext(self):
        r"""Returns search context for pattern."""
        return _connect.CTestLocation_getSearchContext(self)

    def getMatchingType(self):
        r"""Returns matching type for pattern."""
        return _connect.CTestLocation_getMatchingType(self)

    def getSearchPattern(self):
        r"""
        Returns search pattern. If this item is not defined (empty
        string is returned), then test point is located in line
        returned by ``getLine()``. No search is performed. Num lines,
        search context, and matching type are ignored.
        """
        return _connect.CTestLocation_getSearchPattern(self)

    def getLineOffset(self):
        r"""
        Returns the number of lines, which are added to line found by search
        pattern above.
        """
        return _connect.CTestLocation_getLineOffset(self)

    def getNumSteps(self):
        r"""
        Returns the number of single execution steps to be performed
        before logging/evaluations/assignments take place.
        """
        return _connect.CTestLocation_getNumSteps(self)

    def setRuntimeLocation(self, runtimeLocation):
        return _connect.CTestLocation_setRuntimeLocation(self, runtimeLocation)

    def setResourceType(self, resourceType):
        r"""Sets type of resource for which location is given."""
        return _connect.CTestLocation_setResourceType(self, resourceType)

    def setResourceName(self, resourceName):
        r"""Sets name of resource where test point is located."""
        return _connect.CTestLocation_setResourceName(self, resourceName)

    def setSrcFileLocation(self, srcFileLoc):
        r"""Sets source file location."""
        return _connect.CTestLocation_setSrcFileLocation(self, srcFileLoc)

    def setLine(self, lineNumber):
        r"""
        Sets line number, where test point is set, or where
        search range starts (if pattern is defined). Lines are 1-based.
        """
        return _connect.CTestLocation_setLine(self, lineNumber)

    def setSearch(self, isSearch):
        r"""
        Sets the way to determine line number for test point.

        :type isSearch: int
        :param isSearch: if ``E_FALSE`` or E_DEFAULT, no search is done -
            then line returned by getLine() is used as test point location.
        """
        return _connect.CTestLocation_setSearch(self, isSearch)

    def setLinesRange(self, numLines):
        r"""
        Sets the number of lines, which are searched for pattern.
        Value 0 means till the end of file.
        """
        return _connect.CTestLocation_setLinesRange(self, numLines)

    def setSearchContext(self, searchContext):
        r"""Sets search context for pattern."""
        return _connect.CTestLocation_setSearchContext(self, searchContext)

    def setMatchingType(self, matchingType):
        r"""Sets matching type for pattern."""
        return _connect.CTestLocation_setMatchingType(self, matchingType)

    def setSearchPattern(self, searchPattern):
        r"""
        Sets search pattern. If this item is not defined (empty
        string is specified), then test point is located in line
        returned by ``getLine()``. No search is performed. Num lines,
        search context, and matching type are ignored.

        :type searchPattern: string
        :param searchPattern: depending on the value of matching type (see
                   ``setMatchingType()`` ) this pattern represents either
                   exact text to be found or regular expression.
        """
        return _connect.CTestLocation_setSearchPattern(self, searchPattern)

    def setLineOffset(self, offset):
        r"""
        Sets the number of lines, which are added to line found by search
        pattern above. Use this setting when the actual line has no specific
        pattern to search for, while the line before it can be identified more
        reliably.
        """
        return _connect.CTestLocation_setLineOffset(self, offset)

    def setNumSteps(self, numSteps):
        r"""
        Sets the number of single execution steps (step over in source code)
        to be performed before logging/evaluations/assignments take place.
        This setting may be useful when we want to
        log/evaluate/assign a variable _after_ the
        current line is executed. May also be used when test point is set at
        function start, and we want to execute function prolog, so that local
        variables and parameters are visible.
        """
        return _connect.CTestLocation_setNumSteps(self, numSteps)

    def validate(self):
        r"""Validates consistency of data in object."""
        return _connect.CTestLocation_validate(self)

    def getLineDescription(self):
        r"""Returns adapter for this class, which can be used in CAddressController."""
        return _connect.CTestLocation_getLineDescription(self)

# Register CTestLocation in _connect:
_connect.CTestLocation_swigregister(CTestLocation)
class CTestPoint(CTestBase):
    r"""
    This class contains specification for test points.
    Test points are implemented as breakpoints at arbitrary points in
    executable, where test execution stops, expresisons can be
    evaluated to test target state, and variables modified to inject
    fault conditions. It is also possible to log values and include
    them to test reports.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_TEST_POINT_ID = _connect.CTestPoint_E_SECTION_TEST_POINT_ID
    E_SECTION_IS_ACTIVE = _connect.CTestPoint_E_SECTION_IS_ACTIVE
    E_SECTION_IS_CUSTOM_ACTIVATION = _connect.CTestPoint_E_SECTION_IS_CUSTOM_ACTIVATION
    E_SECTION_CONDITION_COUNT = _connect.CTestPoint_E_SECTION_CONDITION_COUNT
    E_SECTION_CONDITION_EXPR = _connect.CTestPoint_E_SECTION_CONDITION_EXPR
    E_SECTION_SCRIPT_FUNC = _connect.CTestPoint_E_SECTION_SCRIPT_FUNC
    E_SECTION_LOCATION = _connect.CTestPoint_E_SECTION_LOCATION
    E_SECTION_LOG = _connect.CTestPoint_E_SECTION_LOG
    E_SECTION_HIT_LIMITS = _connect.CTestPoint_E_SECTION_HIT_LIMITS
    E_SECTION_STEPS = _connect.CTestPoint_E_SECTION_STEPS

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestPoint_swiginit(self, _connect.new_CTestPoint(*args))
    __swig_destroy__ = _connect.delete_CTestPoint

    def createInstance(self, parent):
        return _connect.CTestPoint_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestPoint_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestPoint_isMerged(self)

    def getId(self):
        r"""Returns the test point id."""
        return _connect.CTestPoint_getId(self)

    def isActive(self):
        r"""Returns true, if test point is active during test execution."""
        return _connect.CTestPoint_isActive(self)

    def isCustomActivation(self):
        r"""
        Returns true, if test point will not be activated before test execution,
        but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breakpoints available.
        """
        return _connect.CTestPoint_isCustomActivation(self)

    def getConditionCount(self):
        r"""Returns condition count for test-point."""
        return _connect.CTestPoint_getConditionCount(self)

    def getConditionExpr(self):
        r"""Returns condition expression for test-point."""
        return _connect.CTestPoint_getConditionExpr(self)

    def getScriptFunctionName(self):
        r"""Returns script function to be called when test-point is hit."""
        return _connect.CTestPoint_getScriptFunctionName(self)

    def getLocation(self, isConst):
        r"""Returns location of test point."""
        return _connect.CTestPoint_getLocation(self, isConst)

    def getLogConfig(self, isConst):
        r"""Returns logging configuration."""
        return _connect.CTestPoint_getLogConfig(self, isConst)

    def getHitLimits(self, isConst):
        r"""Returns hit limits."""
        return _connect.CTestPoint_getHitLimits(self, isConst)

    def getSteps(self, isConst):
        r"""
        Returns list of objects, which contain information about expected
        values and modifications of variable to perform.
        """
        return _connect.CTestPoint_getSteps(self, isConst)

    def setId(self, testPointId):
        r"""Sets the test point id."""
        return _connect.CTestPoint_setId(self, testPointId)

    def setActive(self, isActive):
        r"""If parameter is ``true``, then the test point is active during test execution."""
        return _connect.CTestPoint_setActive(self, isActive)

    def setCustomActivation(self, isActive):
        r"""
        If parameter is ``true``, then the test point will not be activated before
        test execution, but during test execution from custom script. This
        functionality can be used when the order of test point hits is known, and
        there are not enough hardware breakpoints available.
        """
        return _connect.CTestPoint_setCustomActivation(self, isActive)

    def setConditionCount(self, conditionCount):
        r"""Sets condition count for test-point."""
        return _connect.CTestPoint_setConditionCount(self, conditionCount)

    def setConditionExpr(self, expr):
        r"""Sets condition expression for test-point."""
        return _connect.CTestPoint_setConditionExpr(self, expr)

    def setScriptFunc(self, scriptFunc):
        r"""Sets script function to be called when test-point is hit."""
        return _connect.CTestPoint_setScriptFunc(self, scriptFunc)

    def validate(self):
        r"""Validates consistency of data in object."""
        return _connect.CTestPoint_validate(self)

# Register CTestPoint in _connect:
_connect.CTestPoint_swigregister(CTestPoint)
class CTestMinMax(CTestBase):
    r"""
    This class is used where minumum and maximum limits of a value
    are specified.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_MIN = _connect.CTestMinMax_E_SECTION_MIN
    E_SECTION_MAX = _connect.CTestMinMax_E_SECTION_MAX

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestMinMax_swiginit(self, _connect.new_CTestMinMax(*args))

    def createInstance(self, *args):
        return _connect.CTestMinMax_createInstance(self, *args)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestMinMax_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestMinMax_isMerged(self)

    def getMin(self):
        r"""Returns lower value for limit."""
        return _connect.CTestMinMax_getMin(self)

    def getMax(self):
        r"""Returns upper value for limit."""
        return _connect.CTestMinMax_getMax(self)

    def setMin(self, value):
        r"""Sets lower value for limit."""
        return _connect.CTestMinMax_setMin(self, value)

    def setMax(self, value):
        r"""Sets upper value for limit."""
        return _connect.CTestMinMax_setMax(self, value)
    __swig_destroy__ = _connect.delete_CTestMinMax

# Register CTestMinMax in _connect:
_connect.CTestMinMax_swigregister(CTestMinMax)
class CTestLog(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_BEFORE = _connect.CTestLog_E_SECTION_BEFORE
    E_SECTION_AFTER = _connect.CTestLog_E_SECTION_AFTER

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestLog_swiginit(self, _connect.new_CTestLog(*args))
    __swig_destroy__ = _connect.delete_CTestLog

    def createInstance(self, parent):
        return _connect.CTestLog_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestLog_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestLog_isMerged(self)

    def getExpressions(self, section, isConst):
        r"""
        Returns expressions for the given section.

        :type section: int
        :param section: which expressions to return
        :type isConst: boolean
        :param isConst: if true, then returned sequence may not be modified.
        """
        return _connect.CTestLog_getExpressions(self, section, isConst)

# Register CTestLog in _connect:
_connect.CTestLog_swigregister(CTestLog)
class CTestEvalAssignStep(CTestBase):
    r"""This class defines stub assignments for one stub call."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_EXPECT = _connect.CTestEvalAssignStep_E_SECTION_EXPECT
    E_SECTION_ASSIGN = _connect.CTestEvalAssignStep_E_SECTION_ASSIGN
    E_SECTION_SCRIPT_PARAMS = _connect.CTestEvalAssignStep_E_SECTION_SCRIPT_PARAMS
    E_SECTION_NEXT_INDEX = _connect.CTestEvalAssignStep_E_SECTION_NEXT_INDEX

    def __init__(self, *args):
        _connect.CTestEvalAssignStep_swiginit(self, _connect.new_CTestEvalAssignStep(*args))
    __swig_destroy__ = _connect.delete_CTestEvalAssignStep

    def createInstance(self, parent):
        return _connect.CTestEvalAssignStep_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestEvalAssignStep_cast(testBase)

    def getStepIdx(self):
        r"""
        Returns index of the step to use on the next call.
        Negative values are indices from the end.
        If empty string is returned, the next step should be executed
        in the next call, unless the current step is the last step - in
        this case the last step is executed.
        """
        return _connect.CTestEvalAssignStep_getStepIdx(self)

    def setStepIdx(self, stepIdx):
        r"""
        Sets step index.
        See also: getStepIdx
        """
        return _connect.CTestEvalAssignStep_setStepIdx(self, stepIdx)

    def getExpectedExpressions(self, isConst):
        r"""Returns expressions, which should evaluate to true."""
        return _connect.CTestEvalAssignStep_getExpectedExpressions(self, isConst)

    def getAssignments(self, isConst):
        r"""Returns assignments to variables, registers, ..."""
        return _connect.CTestEvalAssignStep_getAssignments(self, isConst)

    def getScriptParams(self, isConst):
        r"""Returns parameters for script function."""
        return _connect.CTestEvalAssignStep_getScriptParams(self, isConst)

# Register CTestEvalAssignStep in _connect:
_connect.CTestEvalAssignStep_swigregister(CTestEvalAssignStep)
class CTestUserStub(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_STUBBED_FUNC_NAME = _connect.CTestUserStub_E_SECTION_STUBBED_FUNC_NAME
    E_SECTION_IS_ACTIVE = _connect.CTestUserStub_E_SECTION_IS_ACTIVE
    E_SECTION_REPLACEMENT_FUNC_NAME = _connect.CTestUserStub_E_SECTION_REPLACEMENT_FUNC_NAME

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Initializes new instance.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class. Used
                          only when parsing YAML declaration. Can be
                          specified as NULL if the object is not
                          initialized by parser.
        """
        _connect.CTestUserStub_swiginit(self, _connect.new_CTestUserStub(*args))
    __swig_destroy__ = _connect.delete_CTestUserStub

    def createInstance(self, parent):
        return _connect.CTestUserStub_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestUserStub_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestUserStub_isMerged(self)

    def getFunctionName(self):
        r"""Returns the name of stubbed function."""
        return _connect.CTestUserStub_getFunctionName(self)

    def isActive(self):
        r"""Returns true, if stub is active during test execution."""
        return _connect.CTestUserStub_isActive(self)

    def getReplacementFuncName(self):
        r"""
        Returns name of the function which will be called instead of the
        stubbed function.
        """
        return _connect.CTestUserStub_getReplacementFuncName(self)

    def setFunctionName(self, functionName):
        r"""Sets the name of the function to be stubbed."""
        return _connect.CTestUserStub_setFunctionName(self, functionName)

    def setActive(self, isActive):
        r"""
        If parameter is ``true``, then the stub is active during test execution.
        Otherwise it will be ignored - the function on the target is called.
        """
        return _connect.CTestUserStub_setActive(self, isActive)

    def setReplacementFuncName(self, replacementFuncName):
        r"""
        Sets name of the function to be called instead of the
        stubbed function.
        """
        return _connect.CTestUserStub_setReplacementFuncName(self, replacementFuncName)

# Register CTestUserStub in _connect:
_connect.CTestUserStub_swigregister(CTestUserStub)
class CTestHIL(CTestBase):
    r"""This class contains configuration for HIL."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_HIL_PARAMS = _connect.CTestHIL_E_SECTION_HIL_PARAMS

    def __init__(self, parent):
        _connect.CTestHIL_swiginit(self, _connect.new_CTestHIL(parent))
    __swig_destroy__ = _connect.delete_CTestHIL

    def createInstance(self, parent):
        return _connect.CTestHIL_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestHIL_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestHIL_isMerged(self)

    def getHILParamKeys(self, *args):
        r"""
        *Overload 1:*

        Returns vector with names of HIL parameters to be initialized.
        The vector contains the names in the same order in which they
        were inserted into internal map, and this is also the order
        that should be used for initialization.

        |

        *Overload 2:*

        Returns the same items as getHILParamKeys(), but with original quoting.
        """
        return _connect.CTestHIL_getHILParamKeys(self, *args)

    def getHILParamValues(self, values):
        r"""
        Returns vector with values of HIL parameters to be used for
        initialization. Values are returned in the order which
        matches keys returned by getHILParamKeys().
        """
        return _connect.CTestHIL_getHILParamValues(self, values)

    def getHILParamMap(self, params):
        r"""
        Returns assignments of HIL outputs in the same
        order as they were entered in stub specification.

        :type params: :py:class:`StrStrMap`
        :param params: object to receive mapping data
        """
        return _connect.CTestHIL_getHILParamMap(self, params)

    def setParam(self, key, value):
        return _connect.CTestHIL_setParam(self, key, value)

# Register CTestHIL in _connect:
_connect.CTestHIL_swigregister(CTestHIL)
class CTestStackUsage(CTestBase):
    r"""This class defines expected values for stack usage during test."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_MIN_SIZE = _connect.CTestStackUsage_E_SECTION_MIN_SIZE
    E_SECTION_MAX_SIZE = _connect.CTestStackUsage_E_SECTION_MAX_SIZE

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestStackUsage_swiginit(self, _connect.new_CTestStackUsage(*args))
    __swig_destroy__ = _connect.delete_CTestStackUsage

    def createInstance(self, parent):
        return _connect.CTestStackUsage_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestStackUsage_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestStackUsage_isMerged(self)

    def getMinUsedSize(self):
        r"""
        Returns min stack size - at least that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_getMinUsedSize(self)

    def getMaxUsedSize(self):
        r"""
        Returns max stack size - at most that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_getMaxUsedSize(self)

    def setMinUsedSize(self, minSize):
        r"""
        Sets max stack size - at most that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_setMinUsedSize(self, minSize)

    def setMaxUsedSize(self, maxSize):
        r"""
        Sets min stack size - at least that amount of stack is expected to
        be used during test.
        """
        return _connect.CTestStackUsage_setMaxUsedSize(self, maxSize)

# Register CTestStackUsage in _connect:
_connect.CTestStackUsage_swigregister(CTestStackUsage)
class CTestPersistentVars(CTestBase):
    r"""
    This section defines types and values of persistent variables. These
    variables exist on target between tests and can be used to preserve
    values from one test to be used in anoter test. It is also possible to
    specify persistent variables to be deleted.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_DECL = _connect.CTestPersistentVars_E_SECTION_DECL
    E_SECTION_DELETE = _connect.CTestPersistentVars_E_SECTION_DELETE
    E_SECTION_IS_DELETE_ALL = _connect.CTestPersistentVars_E_SECTION_IS_DELETE_ALL

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestVariables class.
        """
        _connect.CTestPersistentVars_swiginit(self, _connect.new_CTestPersistentVars(*args))
    __swig_destroy__ = _connect.delete_CTestPersistentVars

    def createInstance(self, parent):
        return _connect.CTestPersistentVars_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestPersistentVars_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestPersistentVars_isMerged(self)

    def isDeleteAll(self):
        return _connect.CTestPersistentVars_isDeleteAll(self)

    def setDeleteAll(self, isDeletaAll):
        return _connect.CTestPersistentVars_setDeleteAll(self, isDeletaAll)

# Register CTestPersistentVars in _connect:
_connect.CTestPersistentVars_swigregister(CTestPersistentVars)
class CTestHostVars(object):
    r"""
    This class contains variables, which are stored on host, not on target.
    Variables, which name starts with underscore (_) are reserved for
    internal usage.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    LIST_SEPARATOR = _connect.CTestHostVars_LIST_SEPARATOR

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor.

        |

        *Overload 2:*
        Copy constructor.
        """
        _connect.CTestHostVars_swiginit(self, _connect.new_CTestHostVars(*args))

    def setDirs(self, winIDEAWorkspace, iyamlDir, reportDir):
        r"""Sets directories useful for itest."""
        return _connect.CTestHostVars_setDirs(self, winIDEAWorkspace, iyamlDir, reportDir)

    def setDefaultCoreId(self, coreId):
        r"""
        Sets coreID to be used when core ID value in test case is empty.
        Alternatively you can specify ``envConfig`` in initTestCaseVars().
        """
        return _connect.CTestHostVars_setDefaultCoreId(self, coreId)

    @staticmethod
    def getDiagramFileName(testSpec, diagConfig):
        r"""
        Returns file name of a diagram, where all host vars are replaced with
        their values.
        """
        return _connect.CTestHostVars_getDiagramFileName(testSpec, diagConfig)

    def setValue(self, varName, varValue):
        r"""Sets variable value."""
        return _connect.CTestHostVars_setValue(self, varName, varValue)

    def getValue(self, varName):
        r"""Returns variable value."""
        return _connect.CTestHostVars_getValue(self, varName)

    def removeVar(self, varName):
        r"""Removes variable from internal map."""
        return _connect.CTestHostVars_removeVar(self, varName)

    def replaceHostVars(self, expression):
        r"""
        Replaces all host variables in input string with their values.
        Returns string with replacements.
        """
        return _connect.CTestHostVars_replaceHostVars(self, expression)

    @staticmethod
    def getHostVarsForAnalyzerFileName(hostVars):
        r"""Returns list of host variables available for analyzer file name."""
        return _connect.CTestHostVars_getHostVarsForAnalyzerFileName(hostVars)

    @staticmethod
    def getHostVarsForGroupAnalyzerFileName(hostVars):
        r"""Returns list of host variables available for group analyzer file name."""
        return _connect.CTestHostVars_getHostVarsForGroupAnalyzerFileName(hostVars)

    @staticmethod
    def getHostVarsForAutoTestId(hostVars, isIncludeCoreId, isForProposals):
        r"""Returns list of host variables available for test case ID."""
        return _connect.CTestHostVars_getHostVarsForAutoTestId(hostVars, isIncludeCoreId, isForProposals)

    def initEnvVars(self):
        r"""
        This method stores all environment variables of the process to
        this class. All environment variables get prefix `_env_`, so they
        can not collide with user variables.
        """
        return _connect.CTestHostVars_initEnvVars(self)

    def initCommonHostVars(self):
        r"""Initializes date, time, ISO time, user ID, and user name."""
        return _connect.CTestHostVars_initCommonHostVars(self)

    def initTestReportHostVars(self, wiWorkspaceDir, wiWorkspaceFile, defaultDlFile):
        r"""Initializes host vars used in test report output file name."""
        return _connect.CTestHostVars_initTestReportHostVars(self, wiWorkspaceDir, wiWorkspaceFile, defaultDlFile)

    def initSvnRevisionHostVar(self, workingCopyPath):
        r"""
        Initializes host var CTestHostVars::RESERVED_SVN_REVISION with
        current subversion number.

        :type workingCopyPath: string
        :param workingCopyPath: path to directory or file, on which svn info
                                   will be executed.
        """
        return _connect.CTestHostVars_initSvnRevisionHostVar(self, workingCopyPath)

    def initTestGroupVars(self, group, envConfig):
        r"""
        Initializes host variables from test group, for example ${_groupID}.
        If host variables with directories are needed, call setDirs() before
        this method.

        :type group: :py:class:`CTestGroup`
        :param group: the test group used to initialize variables
        :type envConfig: :py:class:`CTestEnvironmentConfig`
        :param envConfig: configuration used to get ID of core 0, if core
                             ID is not specified in the test case. Alternatively
                             you can specify default core ID by calling
                             setDefaultCoreId() before this method, and set this value to NULL.
        """
        return _connect.CTestHostVars_initTestGroupVars(self, group, envConfig)

    def initTestCaseVars(self, testSpec, envConfig):
        r"""
        Initializes host variables from test case, for example ${_testID}.
        If host variables with directories are needed, call setDirs() before
        this method.

        :type testSpec: :py:class:`CTestSpecification`
        :param testSpec: the test case used to initialize variables
        :type envConfig: :py:class:`CTestEnvironmentConfig`
        :param envConfig: configuration used to get ID of core 0, if core
                             ID is not specified in the test case. Alternatively
                             you can specify default core ID by calling
                             setDefaultCoreId() before this method, and set this value to NULL.
        """
        return _connect.CTestHostVars_initTestCaseVars(self, testSpec, envConfig)

    def initBatchVars(self):
        r"""Initializes host variables for batch of test cases, for example date and time."""
        return _connect.CTestHostVars_initBatchVars(self)

    @staticmethod
    def createDiagramVars(testSpec, diagConfig):
        r"""Creates instance of this class with host variables used in diagrams section."""
        return _connect.CTestHostVars_createDiagramVars(testSpec, diagConfig)

    @staticmethod
    def createTcAnalyzerFNameVars(testSpec):
        r"""Initializes host vars for test case analyzer file name."""
        return _connect.CTestHostVars_createTcAnalyzerFNameVars(testSpec)

    @staticmethod
    def createGrpAnalyzerFNameVars(testGroup):
        r"""Initializes host vars for group merged analyzer file name."""
        return _connect.CTestHostVars_createGrpAnalyzerFNameVars(testGroup)

    def toString(self):
        r"""
        Returns all host variables and their values as string.
        Use this method for debugging purposes only.
        """
        return _connect.CTestHostVars_toString(self)
    __swig_destroy__ = _connect.delete_CTestHostVars

# Register CTestHostVars in _connect:
_connect.CTestHostVars_swigregister(CTestHostVars)
CTestHostVars.RESERVED_ENV_PREFIX = _connect.cvar.CTestHostVars_RESERVED_ENV_PREFIX
CTestHostVars.RESERVED_GROUP_ID = _connect.cvar.CTestHostVars_RESERVED_GROUP_ID
CTestHostVars.RESERVED_PARTITION = _connect.cvar.CTestHostVars_RESERVED_PARTITION
CTestHostVars.RESERVED_MODULE = _connect.cvar.CTestHostVars_RESERVED_MODULE
CTestHostVars.RESERVED_TEST_ID = _connect.cvar.CTestHostVars_RESERVED_TEST_ID
CTestHostVars.RESERVED_TAGS = _connect.cvar.CTestHostVars_RESERVED_TAGS
CTestHostVars.RESERVED_FUNCTION = _connect.cvar.CTestHostVars_RESERVED_FUNCTION
CTestHostVars.RESERVED_PARAMS = _connect.cvar.CTestHostVars_RESERVED_PARAMS
CTestHostVars.RESERVED_CORE_ID = _connect.cvar.CTestHostVars_RESERVED_CORE_ID
CTestHostVars.RESERVED_USER = _connect.cvar.CTestHostVars_RESERVED_USER
CTestHostVars.RESERVED_DATE = _connect.cvar.CTestHostVars_RESERVED_DATE
CTestHostVars.RESERVED_TIME = _connect.cvar.CTestHostVars_RESERVED_TIME
CTestHostVars.RESERVED_ISO_TIME = _connect.cvar.CTestHostVars_RESERVED_ISO_TIME
CTestHostVars.RESERVED_UID = _connect.cvar.CTestHostVars_RESERVED_UID
CTestHostVars.RESERVED_BATCH_DATE = _connect.cvar.CTestHostVars_RESERVED_BATCH_DATE
CTestHostVars.RESERVED_BATCH_TIME = _connect.cvar.CTestHostVars_RESERVED_BATCH_TIME
CTestHostVars.RESERVED_BATCH_UID = _connect.cvar.CTestHostVars_RESERVED_BATCH_UID
CTestHostVars.RESERVED_DIAGRAM_TYPE = _connect.cvar.CTestHostVars_RESERVED_DIAGRAM_TYPE
CTestHostVars.RESERVED_WINIDEA_WORKSPACE_DIR = _connect.cvar.CTestHostVars_RESERVED_WINIDEA_WORKSPACE_DIR
CTestHostVars.RESERVED_WINIDEA_WORKSPACE_FILE = _connect.cvar.CTestHostVars_RESERVED_WINIDEA_WORKSPACE_FILE
CTestHostVars.RESERVED_DEFAULT_DL_DIR = _connect.cvar.CTestHostVars_RESERVED_DEFAULT_DL_DIR
CTestHostVars.RESERVED_DEFAULT_DL_FILE = _connect.cvar.CTestHostVars_RESERVED_DEFAULT_DL_FILE
CTestHostVars.RESERVED_IYAML_DIR = _connect.cvar.CTestHostVars_RESERVED_IYAML_DIR
CTestHostVars.RESERVED_REPORT_DIR = _connect.cvar.CTestHostVars_RESERVED_REPORT_DIR
CTestHostVars.RESERVED_NID = _connect.cvar.CTestHostVars_RESERVED_NID
CTestHostVars.RESERVED_DID = _connect.cvar.CTestHostVars_RESERVED_DID
CTestHostVars.RESERVED_UUID = _connect.cvar.CTestHostVars_RESERVED_UUID
CTestHostVars.RESERVED_SEQ = _connect.cvar.CTestHostVars_RESERVED_SEQ
CTestHostVars.RESERVED_FUNC_UNDER_TEST = _connect.cvar.CTestHostVars_RESERVED_FUNC_UNDER_TEST
CTestHostVars.RESERVED_SVN_REVISION = _connect.cvar.CTestHostVars_RESERVED_SVN_REVISION
CTestHostVars.RESERVED_CUSTOM_DIAGRAM_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_CUSTOM_DIAGRAM_POSTFIX
CTestHostVars.RESERVED_SEQUENCE_DIAGRAM_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_SEQUENCE_DIAGRAM_POSTFIX
CTestHostVars.RESERVED_FLOW_CHART_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_FLOW_CHART_POSTFIX
CTestHostVars.RESERVED_RUNTIME_CALL_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_RUNTIME_CALL_GRAPH_POSTFIX
CTestHostVars.RESERVED_STATIC_CALL_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_STATIC_CALL_GRAPH_POSTFIX
CTestHostVars.RESERVED_FLAME_GRAPH_POSTFIX = _connect.cvar.CTestHostVars_RESERVED_FLAME_GRAPH_POSTFIX

class CTestDryRun(CTestBase):
    r"""
    This class contains specification for dry run. Assignments stored in
    this class will be evaluated during dry run test and then copied to
    section Variables.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_ASSIGN = _connect.CTestDryRun_E_SECTION_ASSIGN
    E_SECTION_UPDATE_COVERAGE = _connect.CTestDryRun_E_SECTION_UPDATE_COVERAGE
    E_SECTION_UPDATE_PROFILER = _connect.CTestDryRun_E_SECTION_UPDATE_PROFILER
    E_SECTION_PROFILER_MULTIPLIER = _connect.CTestDryRun_E_SECTION_PROFILER_MULTIPLIER
    E_SECTION_PROFILER_OFFSET = _connect.CTestDryRun_E_SECTION_PROFILER_OFFSET

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Initializes new instance. Parent is not set.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestDryRun_swiginit(self, _connect.new_CTestDryRun(*args))
    __swig_destroy__ = _connect.delete_CTestDryRun

    def createInstance(self, parent):
        return _connect.CTestDryRun_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestDryRun_cast(testBase)

    def getAssignments(self, isConst):
        r"""Returns assignments to host variables."""
        return _connect.CTestDryRun_getAssignments(self, isConst)

    def isUpdateCoverage(self):
        r"""
        Returns true, if required coverage statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_isUpdateCoverage(self)

    def isUpdateProfiler(self):
        r"""
        Returns true, if required profiler statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_isUpdateProfiler(self)

    def getProfilerMultiplier(self):
        r"""
        Returns value used to adapt profiler expected value according to
        measured value: new_value = measured_value * multiplier + offset.
        """
        return _connect.CTestDryRun_getProfilerMultiplier(self)

    def getProfilerOffset(self):
        r"""
        Returns value used to adapt profiler expected value according to
        measured value: new_value = measured_value * multiplier + offset.
        """
        return _connect.CTestDryRun_getProfilerOffset(self)

    def setUpdateCoverage(self, isUpdate):
        r"""
        Set value to true, if required coverage statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_setUpdateCoverage(self, isUpdate)

    def setUpdateProfiler(self, isUpdate):
        r"""
        Set value to true, if required profiler statistics should be updated during
        dry run. Only items already defined in statistics will be modified.
        """
        return _connect.CTestDryRun_setUpdateProfiler(self, isUpdate)

# Register CTestDryRun in _connect:
_connect.CTestDryRun_swigregister(CTestDryRun)
class CTestDiagramConfig(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_DIAG_CFG_IS_ACTIVE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_IS_ACTIVE
    E_SECTION_DIAG_CFG_DIAG_TYPE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_DIAG_TYPE
    E_SECTION_DIAG_CFG_SCRIPT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_SCRIPT
    E_SECTION_DIAG_CFG_PARAMS = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_PARAMS
    E_SECTION_DIAG_CFG_OUT_FILE_NAME = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_OUT_FILE_NAME
    E_SECTION_DIAG_CFG_IS_ADD_TO_REPORT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_IS_ADD_TO_REPORT
    E_SECTION_DIAG_CFG_VIEWER_TYPE = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_VIEWER_TYPE
    E_SECTION_DIAG_CFG_DATA_FORMAT = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_DATA_FORMAT
    E_SECTION_DIAG_CFG_EXTERNAL_VIEWER = _connect.CTestDiagramConfig_E_SECTION_DIAG_CFG_EXTERNAL_VIEWER
    EFlowChart = _connect.CTestDiagramConfig_EFlowChart
    r"""flow chart based on assembly info"""
    ESequenceDiagram = _connect.CTestDiagramConfig_ESequenceDiagram
    r"""sequence diagram based on profiler recording"""
    ERuntimeCallGraph = _connect.CTestDiagramConfig_ERuntimeCallGraph
    r"""call graph based on profiler recording"""
    EStaticCallGraph = _connect.CTestDiagramConfig_EStaticCallGraph
    r"""call graph based on static information in download file"""
    EFlameGraph = _connect.CTestDiagramConfig_EFlameGraph
    r"""provides condensed call stack information"""
    ECustom = _connect.CTestDiagramConfig_ECustom
    r"""
    custom script is called, testIDEA waits until it returns.
    Use this option when script writes image to file. testIDEA
    also prints stdout and stderr in this case, which is useful in case of problems.
    """
    ECustomAsync = _connect.CTestDiagramConfig_ECustomAsync
    r"""
    custom script is called, testIDEA continues immediately.
    Use this option when Python script opens its own window
    with chart (calls matplotlib's show() method).
    """
    EMultipage = _connect.CTestDiagramConfig_EMultipage
    r"""
    open file in multipage editor window, one editor
    window per test case ID, one page (bottom tab) per diagram
    """
    ESinglePage = _connect.CTestDiagramConfig_ESinglePage
    r"""open file in editor window"""
    EExternal = _connect.CTestDiagramConfig_EExternal
    ENone = _connect.CTestDiagramConfig_ENone
    r"""
    do not open this file in viewer. In testIDEA output
    is shown below the table in section Diagrams on line
    selection
    """
    EByExtension = _connect.CTestDiagramConfig_EByExtension
    r"""display format is determined on extension: svg, csv, txt, png, jpg, jpeg, bmp"""
    EBitmap = _connect.CTestDiagramConfig_EBitmap
    r"""one of bitmap formats (jpg, bmp, ...)"""
    ESVG = _connect.CTestDiagramConfig_ESVG
    r"""SVG format"""

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestDiagrams class.
        """
        _connect.CTestDiagramConfig_swiginit(self, _connect.new_CTestDiagramConfig(*args))
    __swig_destroy__ = _connect.delete_CTestDiagramConfig

    def createInstance(self, parent):
        return _connect.CTestDiagramConfig_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestDiagramConfig_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestDiagramConfig_isMerged(self)

    def isActive(self):
        return _connect.CTestDiagramConfig_isActive(self)

    def getDiagramType(self):
        return _connect.CTestDiagramConfig_getDiagramType(self)

    def getViewerType(self):
        return _connect.CTestDiagramConfig_getViewerType(self)

    def getViewFormat(self):
        return _connect.CTestDiagramConfig_getViewFormat(self)

    def getScriptName(self):
        return _connect.CTestDiagramConfig_getScriptName(self)

    def getParameters(self, isConst):
        return _connect.CTestDiagramConfig_getParameters(self, isConst)

    def getOutputFileName(self):
        return _connect.CTestDiagramConfig_getOutputFileName(self)

    def isAddToReport(self):
        return _connect.CTestDiagramConfig_isAddToReport(self)

    def getExternalViewerName(self):
        return _connect.CTestDiagramConfig_getExternalViewerName(self)

    def getScriptCmdLineArgs(self, testSpec, outFile, profilerExportFile, dotExeDir, cmdLineArgs):
        return _connect.CTestDiagramConfig_getScriptCmdLineArgs(self, testSpec, outFile, profilerExportFile, dotExeDir, cmdLineArgs)

    def parsingEnd(self):
        return _connect.CTestDiagramConfig_parsingEnd(self)

# Register CTestDiagramConfig in _connect:
_connect.CTestDiagramConfig_swigregister(CTestDiagramConfig)
CTestDiagramConfig.SEQ_AND_CALL_DIAG_PY = _connect.cvar.CTestDiagramConfig_SEQ_AND_CALL_DIAG_PY
CTestDiagramConfig.STATIC_CALL_GRAPH_PY = _connect.cvar.CTestDiagramConfig_STATIC_CALL_GRAPH_PY
CTestDiagramConfig.FLOW_CHART_PY = _connect.cvar.CTestDiagramConfig_FLOW_CHART_PY
CTestDiagramConfig.FLAME_GRAPH_PY = _connect.cvar.CTestDiagramConfig_FLAME_GRAPH_PY

class CTestDiagrams(CTestBase):
    r"""This class contains configurations for all diagrams of one test-case."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_DIAG_IS_ACTIVE = _connect.CTestDiagrams_E_SECTION_DIAG_IS_ACTIVE
    E_SECTION_DIAG_CONFIGS = _connect.CTestDiagrams_E_SECTION_DIAG_CONFIGS

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default ctor.

        |

        *Overload 2:*

        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestSpecification class.
        """
        _connect.CTestDiagrams_swiginit(self, _connect.new_CTestDiagrams(*args))
    __swig_destroy__ = _connect.delete_CTestDiagrams

    def createInstance(self, parent):
        return _connect.CTestDiagrams_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestDiagrams_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestDiagrams_isMerged(self)

    def isActive(self):
        return _connect.CTestDiagrams_isActive(self)

    def getConfigurations(self, isConst):
        return _connect.CTestDiagrams_getConfigurations(self, isConst)

    def createTestBase(self, section, lineNo):
        return _connect.CTestDiagrams_createTestBase(self, section, lineNo)

# Register CTestDiagrams in _connect:
_connect.CTestDiagrams_swigregister(CTestDiagrams)
class CTestStopCondition(CTestBase):
    r"""
    This class defines stop condition for system tests. There exist
    three possibilities:

    - set breakpoint: target will stop on the breakpoint
    - set timeout: target will be stopped after the timeout
    - breakpoint after timeout: breakpoint will be set after the
                                specified timeout, and target will stop
                                when the breakpoint is hit

    This condition can be applied before system test to initialize the
    target, and as test termination condition.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_BREAKPOINT = _connect.CTestStopCondition_E_BREAKPOINT
    E_STOP = _connect.CTestStopCondition_E_STOP
    E_RT_EXPRESSION = _connect.CTestStopCondition_E_RT_EXPRESSION
    E_NO_RUN = _connect.CTestStopCondition_E_NO_RUN
    E_SECTION_STOP_TYPE = _connect.CTestStopCondition_E_SECTION_STOP_TYPE
    E_SECTION_TIMEOUT = _connect.CTestStopCondition_E_SECTION_TIMEOUT
    E_SECTION_RT_EXPRESSION = _connect.CTestStopCondition_E_SECTION_RT_EXPRESSION
    E_SECTION_BP_CONDITION_COUNT = _connect.CTestStopCondition_E_SECTION_BP_CONDITION_COUNT
    E_SECTION_BP_CONDITION_EXPR = _connect.CTestStopCondition_E_SECTION_BP_CONDITION_EXPR
    E_SECTION_BP_LOCATION = _connect.CTestStopCondition_E_SECTION_BP_LOCATION

    def __init__(self, *args):
        r"""
        Initializes new instance.

        :type parent: :py:class:`CTestBase`
        :param parent: an instance of parent CTestPoint class.
        """
        _connect.CTestStopCondition_swiginit(self, _connect.new_CTestStopCondition(*args))
    __swig_destroy__ = _connect.delete_CTestStopCondition

    def createInstance(self, parent):
        return _connect.CTestStopCondition_createInstance(self, parent)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestStopCondition_cast(testBase)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestStopCondition_isMerged(self)

    def getStopType(self):
        r"""Returns stop type."""
        return _connect.CTestStopCondition_getStopType(self)

    def getTimeout(self):
        r"""Returns timeout in milliseconds."""
        return _connect.CTestStopCondition_getTimeout(self)

    def getRtExpression(self):
        r"""Returns timeout in milliseconds."""
        return _connect.CTestStopCondition_getRtExpression(self)

    def getConditionCount(self):
        r"""Returns condition count for breakpoint."""
        return _connect.CTestStopCondition_getConditionCount(self)

    def getConditionExpr(self):
        r"""Returns condition expression for breakpoint."""
        return _connect.CTestStopCondition_getConditionExpr(self)

    def getBreakpointLocation(self, isConst):
        r"""Returns location of breakpoint."""
        return _connect.CTestStopCondition_getBreakpointLocation(self, isConst)

    def setStopType(self, stopType):
        r"""Sets stop type."""
        return _connect.CTestStopCondition_setStopType(self, stopType)

    def setTimeout(self, timeout):
        r"""Sets timeout in milliseconds."""
        return _connect.CTestStopCondition_setTimeout(self, timeout)

    def setConditionCount(self, conditionCount):
        r"""Sets condition count for test-point."""
        return _connect.CTestStopCondition_setConditionCount(self, conditionCount)

    def setConditionExpr(self, expr):
        r"""Sets condition expression for test-point."""
        return _connect.CTestStopCondition_setConditionExpr(self, expr)

    def setRtExpression(self, rtExpression):
        r"""Returns timeout in milliseconds."""
        return _connect.CTestStopCondition_setRtExpression(self, rtExpression)

    def createTestBase(self, section, lineNo):
        return _connect.CTestStopCondition_createTestBase(self, section, lineNo)

# Register CTestStopCondition in _connect:
_connect.CTestStopCondition_swigregister(CTestStopCondition)
class CTestImportSources(CTestBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    E_SECTION_IS_INHERIT = _connect.CTestImportSources_E_SECTION_IS_INHERIT
    E_SECTION_TEST_IDS = _connect.CTestImportSources_E_SECTION_TEST_IDS

    def __init__(self, *args):
        _connect.CTestImportSources_swiginit(self, _connect.new_CTestImportSources(*args))
    __swig_destroy__ = _connect.delete_CTestImportSources

    def createInstance(self, parent):
        return _connect.CTestImportSources_createInstance(self, parent)

    def createTestBase(self, section, lineNo):
        return _connect.CTestImportSources_createTestBase(self, section, lineNo)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestImportSources_isMerged(self)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestImportSources_cast(testBase)

    def isInheritance(self):
        r"""
        Returns true, if this section is inherited from base test
        specification, false otherwise.
        """
        return _connect.CTestImportSources_isInheritance(self)

    def setInheritance(self, inheritance):
        r"""
        Sets inheritance to the given value. Value E_INHERIT_DEFAULT
        removes setting from test spec.
        """
        return _connect.CTestImportSources_setInheritance(self, inheritance)

    def getImportedTestIds(self, isConst):
        return _connect.CTestImportSources_getImportedTestIds(self, isConst)

# Register CTestImportSources in _connect:
_connect.CTestImportSources_swigregister(CTestImportSources)
class CTestImports(CTestBase):
    r"""This class defines test case inheritance and aggregation."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.CTestImports_swiginit(self, _connect.new_CTestImports(*args))
    __swig_destroy__ = _connect.delete_CTestImports

    def createInstance(self, parent):
        return _connect.CTestImports_createInstance(self, parent)

    def createTestBase(self, section, lineNo):
        return _connect.CTestImports_createTestBase(self, section, lineNo)

    def isMerged(self):
        r"""
         Returns true, if the CTestSpecification section containing this
        object is merged.
        """
        return _connect.CTestImports_isMerged(self)

    @staticmethod
    def cast(testBase):
        r"""
        Casts the given object to this class. Returns NULL if input is NULL.

        :raises: IllegalArgumentException if input object is not instance of this class.
        """
        return _connect.CTestImports_cast(testBase)

    def getSectionSources(self, section, isConst):
        r"""Returns sources for inheritance and aggregation."""
        return _connect.CTestImports_getSectionSources(self, section, isConst)

# Register CTestImports in _connect:
_connect.CTestImports_swigregister(CTestImports)
class CSourceCodeFile(object):
    r"""
    This class handles parsing and writing of test specifications
    stored in special comments in C/C++ source code files.

    Because the natural order of functions may not be the natural order of
    base/derived test specifications, and developers do not like test tool
    to dictate the order of functions in a file, test specifications hierarchy
    is made more flexible. To achieve this flexibility, new tag 'baseId' has been
    added, which specifies the parent test spec, which may be defined in
    another comment.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _connect.delete_CSourceCodeFile

    def load(self, fileName):
        r"""
        Loads test specifications from the given source code file. Test
        specifications must be stored in a special C comments, which start with '/ *#'.
        """
        return _connect.CSourceCodeFile_load(self, fileName)

    def save(self, testBench):
        r"""
        Saves the file. It is caller's responsibility to verify if some other
        application has changed the file since it was loaded. Call the method
        ``hasFileChenged()`` to find out.
        """
        return _connect.CSourceCodeFile_save(self, testBench)

    def saveAs(self, fileName, testBench, forceOverwrite):
        r"""
        Saves the file with new name.

        :type forceOverwrite: boolean
        :param forceOverwrite: if true, overwrites any existing file. Call this method
            first by setting this parameter to false, and if false is returned, ask the user if
            he wants to overwrite. Only then set this parameter to true.

        :rtype: boolean
        :return: false if forceOverwrite was false and the file already exists, true otherwise.
        """
        return _connect.CSourceCodeFile_saveAs(self, fileName, testBench, forceOverwrite)

    def close(self):
        r"""
        Call this method to delete the temp file and make the object ready for new
        call to the ``load()`` method.
        """
        return _connect.CSourceCodeFile_close(self)

    def getErrors(self):
        r"""
        Call this method after saving the source file. If there were any
        errors, the file is still saved, but user may have to fix something,
        for example assign test IDs.
        """
        return _connect.CSourceCodeFile_getErrors(self)

    def assignCommentLocation(self, testSpec):
        r"""
        Assigns comment location of the given test spec. This method may be called
        when the 'testSpec' has been moved or inserted in the test tree. This way
        we can improve placement of test specifications into code comments,
        especially if many movements of neighboring test specifications are made back
        and forth.

        The algorithm:

        First the test specs on
        the same level are checked. If there are test specs preceding the given one,
        location of the predecessor's, which has location defined, is used. If there is no
        predecessor, location of the first successor with location defined is used. If neither
        successor with defined location exists, the parent's location is used. If also the
        parent's location is not defined, location of the 'testSpec' is set to NOT_SET.
        """
        return _connect.CSourceCodeFile_assignCommentLocation(self, testSpec)

    def __init__(self):
        _connect.CSourceCodeFile_swiginit(self, _connect.new_CSourceCodeFile())

# Register CSourceCodeFile in _connect:
_connect.CSourceCodeFile_swigregister(CSourceCodeFile)
class CYAMLUtil(object):
    r"""This class contains utility methods for handling of YAML data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def parseTestBase(yamlSpec, testBase):
        r"""
        Parses the given yaml spec to the given test base. It is caller's responsibility
        that yamlSpec contains serialized derived class of the given test base.
        """
        return _connect.CYAMLUtil_parseTestBase(yamlSpec, testBase)

    @staticmethod
    def parseTestBaseList(yamlSpec, parentTestBase, section):
        r"""
        Parses the given YAML string to the given section of the
        parentTestBase.
        """
        return _connect.CYAMLUtil_parseTestBaseList(yamlSpec, parentTestBase, section)

    @staticmethod
    def cto2ctb(src):
        r"""Casts CTestObjectSPtr to CTestBaseSPtr. Throws exception on failure."""
        return _connect.CYAMLUtil_cto2ctb(src)

    @staticmethod
    def cto2ctbl(src):
        r"""Casts CTestObjectSPtr to CTestBaseListSPtr. Throws exception on failure."""
        return _connect.CYAMLUtil_cto2ctbl(src)

    @staticmethod
    def isInstanceOfCtb(src):
        r"""Returns true, if src is instance of CTestBase."""
        return _connect.CYAMLUtil_isInstanceOfCtb(src)

    @staticmethod
    def isInstanceOfCtbList(src):
        r"""Returns true, if src is instance of CTestBaseList."""
        return _connect.CYAMLUtil_isInstanceOfCtbList(src)

    @staticmethod
    def strVector2Str(vec):
        r"""
        Returns string representing vector of strings separated by commas,
        without '[' and ']'.
        It is valid YAML string only if members of vector are properly quoted.
        See parameter 'isForEditor' in CTestSpecification::getParameters()
        regarding quoting.
        """
        return _connect.CYAMLUtil_strVector2Str(vec)

    @staticmethod
    def strStrMap2OrderedStr(mapping, keys, isFlowStyle):
        r"""
        Returns string representing mapping of strings in the order specified in ``keys``.
        No validation is done that all items from mapping have keys in ``keys`` parameter.

        It is valid YAML string only if members of mapping are properly quoted.
        See parameter 'isForEditor' in CTestSpecification::getLocalVariables()
        regarding quoting.

        :type mapping: :py:class:`StrStrMap`
        :param mapping: object containing data to be converted to string
        :type keys: :py:class:`StrVector`
        :param keys: vector with keys of mapping pairs to be added to string in
                        the same order as specified in this vector.
        :type isFlowStyle: boolean
        :param isFlowStyle: if true, result is in YAML flow style, with symbols {,}
        """
        return _connect.CYAMLUtil_strStrMap2OrderedStr(mapping, keys, isFlowStyle)

    @staticmethod
    def strVectorVector2Str(keys, values, isFlowStyle):
        r"""
        Returns string representing mapping of strings.
        It is valid YAML string only if members of mapping are properly quoted.

        :type isFlowStyle: boolean
        :param isFlowStyle: if true, result is in YAML flow style, with symbols {,}
        """
        return _connect.CYAMLUtil_strVectorVector2Str(keys, values, isFlowStyle)

    @staticmethod
    def strVector2Sequence(dest, section, items):
        r"""Copies items from StrVector to the given section in CTestBase."""
        return _connect.CYAMLUtil_strVector2Sequence(dest, section, items)

    @staticmethod
    def verifyLimitedScalar(yamlSpec, msg):
        r"""
        Deprecated: use verifyTestId() instead. This method uses YAML parser, which is
                    redundant step and may produce cryptic error messages if input is not
                    valid YAML scalar.
        This method may be used to verify, if the given string represents scalar
        with limited set of characters. Examples of such scalars are test IDs
        and tags.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyLimitedScalar(yamlSpec, msg)

    @staticmethod
    def getSymbolsAllowedTestId():
        r"""Returns string containing all symbols (non-alphanum) chars allowed in test ID or group ID."""
        return _connect.CYAMLUtil_getSymbolsAllowedTestId()

    @staticmethod
    def verifyTestId(testID, msg):
        r"""
        This method may be used to verify, if the given string represents scalar
        with limited set of characters. Examples of such scalars are test IDs
        and tags.
        Error description is returned in case of invalid entry, empty string otherwise.
        """
        return _connect.CYAMLUtil_verifyTestId(testID, msg)

    @staticmethod
    def verifyScalar(yamlSpec):
        r"""
        This method may be used to verify, if the given string represents YAML scalar.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyScalar(yamlSpec)

    @staticmethod
    def verifyList(yamlSpec):
        r"""
        This method may be used to verify, if the given string represents YAML list.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyList(yamlSpec)

    @staticmethod
    def verifyListOfLimitedScalars(yamlSpec, msg):
        r"""
        This method verifies, if all scalars in the list contain only allowed characters.
        See CLimitedScalarValidator for details.
        """
        return _connect.CYAMLUtil_verifyListOfLimitedScalars(yamlSpec, msg)

    @staticmethod
    def verifyMap(yamlSpec):
        r"""
        This method may be used to verify, if the given string represents YAML map.
        Exception with error description is thrown, if it is not.
        """
        return _connect.CYAMLUtil_verifyMap(yamlSpec)

    @staticmethod
    def isAllowedCharForTestId(c):
        r"""Returns true, if character is valid for testID."""
        return _connect.CYAMLUtil_isAllowedCharForTestId(c)

    @staticmethod
    def replaceInvalidChars(param):
        r"""Replaces characters, which are invalid in testID or file name with '_'."""
        return _connect.CYAMLUtil_replaceInvalidChars(param)

    @staticmethod
    def join(params, separator):
        r"""Joins list of strings to single string."""
        return _connect.CYAMLUtil_join(params, separator)

    @staticmethod
    def getCurrentISODate():
        r"""Returns current date in YYYY-MM-DD format."""
        return _connect.CYAMLUtil_getCurrentISODate()

    @staticmethod
    def getCurrentISOTime():
        r"""Returns current time in HH-MM-SS format."""
        return _connect.CYAMLUtil_getCurrentISOTime()

    def __init__(self):
        _connect.CYAMLUtil_swiginit(self, _connect.new_CYAMLUtil())
    __swig_destroy__ = _connect.delete_CYAMLUtil

# Register CYAMLUtil in _connect:
_connect.CYAMLUtil_swigregister(CYAMLUtil)
class CRemoteFileController(object):
    r"""
    This class can be used to access files located on host, where
    winIDEA is running. winIDEA instance is defined by connection manager
    provided in constructor.

    This class is intended to be used when script is running on other
    host than the one running winIDEA.

    **Important:** Complete file is copied to memory, so size of
    file to be read or written is limited by available computer memory.

    Python example: _sample_link{remote_file_ctrl,test_exists}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        _connect.CRemoteFileController_swiginit(self, _connect.new_CRemoteFileController(connectionMgr))
    __swig_destroy__ = _connect.delete_CRemoteFileController

    def exists(self, fileName):
        r"""
        Returns true, if remote file (on host running winIDEA) exists.

        Python example: _sample_link{remote_file_ctrl,test_exists}
        """
        return _connect.CRemoteFileController_exists(self, fileName)

    def remove(self, fileName):
        r"""
        Deletes remote file (on host running winIDEA).

        :rtype: boolean
        :return: true if the file was deleted, false if it didn't exist.

        Python example: _sample_link{remote_file_ctrl,test_remove}
        """
        return _connect.CRemoteFileController_remove(self, fileName)

    def readFromRemote(self, remoteSrcFile, localDestFile):
        r"""
        Reads remote file and saves it locally.

        :type localDestFile: string
        :param localDestFile: local file used for saving. If the file exists, it
                                 is overwritten.
        :type remoteSrcFile: string
        :param remoteSrcFile: remote file to be copied to local host.

        Python example: _sample_link{remote_file_ctrl,test_read_write}
        """
        return _connect.CRemoteFileController_readFromRemote(self, remoteSrcFile, localDestFile)

    def writeToRemote(self, localSrcFile, remoteDestFile):
        r"""
        Writes local file to remote host.

        :type localSrcFile: string
        :param localSrcFile: local file used as source.
        :type remoteDestFile: string
        :param remoteDestFile: remote file used as destination. If the file exists, it
                                 is overwritten.

        Python example: _sample_link{remote_file_ctrl,test_read_write}
        """
        return _connect.CRemoteFileController_writeToRemote(self, localSrcFile, remoteDestFile)

# Register CRemoteFileController in _connect:
_connect.CRemoteFileController_swigregister(CRemoteFileController)
class CCodeStoreItem(object):
    r"""
    This class describes one memory item. This class should not be
    instantiated by clients. Call CCodeStore.getItem() to get
    instance of this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, rspConnectionMgr):
        _connect.CCodeStoreItem_swiginit(self, _connect.new_CCodeStoreItem(rspConnectionMgr))
    __swig_destroy__ = _connect.delete_CCodeStoreItem

    def getAddress(self):
        r"""address of the item"""
        return _connect.CCodeStoreItem_getAddress(self)

    def getLastAddress(self):
        r"""last address covered by the item"""
        return _connect.CCodeStoreItem_getLastAddress(self)

    def getSize(self):
        r"""size of the item"""
        return _connect.CCodeStoreItem_getSize(self)

    def getAt(self, offset):
        r"""item data at offset"""
        return _connect.CCodeStoreItem_getAt(self, offset)

    def getData(self, rvData):
        r"""all data stored in this item"""
        return _connect.CCodeStoreItem_getData(self, rvData)

# Register CCodeStoreItem in _connect:
_connect.CCodeStoreItem_swigregister(CCodeStoreItem)
class CCodeStore(object):
    r"""
    This class is a container of multiple memory items.
    Each item is of type CCodeStoreItem

    __Note:__ This class has not been ported to Linux yet.

    Python example for saving memory to Motorola S format: _sample_link{data_ctrl,test_code_store}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, rspConnectionMgr):
        r"""
        Creates a new instance.

        :type rspConnectionMgr: :py:class:`ConnectionMgr`
        :param rspConnectionMgr: ConnectionMgr object
        """
        _connect.CCodeStore_swiginit(self, _connect.new_CCodeStore(rspConnectionMgr))
    __swig_destroy__ = _connect.delete_CCodeStore

    def clear(self):
        r"""Clears all items."""
        return _connect.CCodeStore_clear(self)

    def copy(self, rSrc):
        r"""
        Copies from another code store instance.
        Previous contents are cleared.

        :type rSrc: :py:class:`CCodeStore`
        :param rSrc: CCodeStore object to copy from
        """
        return _connect.CCodeStore_copy(self, rSrc)

    def load(self, dwFlags, rstrFileName, aOffset):
        r"""
        Load from a file.

        :type dwFlags: int
        :param dwFlags: for default behavior specify 0 for dwFlags, otherwise use ICodeCache::ESaveLoadFlags
        :type rstrFileName: string
        :param rstrFileName: path to the file to load from
        :type aOffset: int
        :param aOffset: offset to add to the code loaded from the file
        """
        return _connect.CCodeStore_load(self, dwFlags, rstrFileName, aOffset)

    def load1(self, dwFlags, rstrFileName, aOffset):
        r"""
        Load from a file. The same operation as load(), but this one returns
        format used in loading the file.

        :type dwFlags: int
        :param dwFlags: for default behavior specify 0 for dwFlags, otherwise use ICodeCache::ESaveLoadFlags
        :type rstrFileName: string
        :param rstrFileName: path to the file to load from
        :type aOffset: int
        :param aOffset: offset to add to the code loaded from the file

        :rtype: int
        :return: 
            - Format used in loading the file. See ICodeCache::ESaveLoadFlags, enums `lFormat...`
              for possible return values and associated format. In Python you can refer to them as
              `ic.ICodeCache.lFormatELF`, for example.
        """
        return _connect.CCodeStore_load1(self, dwFlags, rstrFileName, aOffset)

    def save(self, dwFlags, rstrFileName, aOffset):
        r"""
        Save to file.

        :type dwFlags: int
        :param dwFlags: use ICodeCache::ESaveLoadFlags to specify format. Only `lFormatMotorolaS`
                   `lFormatIntelHex` and `lFormatBinary` are supported.
                   Note: Gaps in the store are padded with 0h when saving to binary file.
        :type rstrFileName: string
        :param rstrFileName: path to the file to save to
        :type aOffset: int
        :param aOffset: offset to add to the code saved to the file. If format is binary,
                   then the offset determines the position in the store from where the saving
                   starts.
        """
        return _connect.CCodeStore_save(self, dwFlags, rstrFileName, aOffset)

    def insert(self, aAddress, vBuffer):
        r"""
        Inserts a new chunk of code.

        :type aAddress: int
        :param aAddress: address at which the new code is inserted
        :type vBuffer: std::vector< BYTE,std::allocator< BYTE > >
        :param vBuffer: code to insert
        """
        return _connect.CCodeStore_insert(self, aAddress, vBuffer)

    def insertWithAccessInfo(self, aAddress, vBuffer):
        r"""
        Inserts a new chunk of code, but only bytes, which have valid access.
        Use this method if data was obtaind by method CDataController::readMemory(),
        because only bytes, which have `ACCESS_OK` may be inserted into code cache.

        :type aAddress: int
        :param aAddress: address at which the new code is inserted
        :type vBuffer: std::vector< BYTE,std::allocator< BYTE > >
        :param vBuffer: code to insert in the first `vBuffer.size() / 2` bytes,
                            access info in the last half.
        """
        return _connect.CCodeStore_insertWithAccessInfo(self, aAddress, vBuffer)

    def exclude(self, aAddressExcl, aEndExcl):
        r"""
        Excludes a range.

        :type aAddressExcl: int
        :param aAddressExcl: start of range to exclude
        :type aEndExcl: int
        :param aEndExcl: last address of range to exclude
        """
        return _connect.CCodeStore_exclude(self, aAddressExcl, aEndExcl)

    def empty(self):
        r"""
        Returns true if container is empty.

        :rtype: boolean
        :return: 
            - true : container is empty
            - false: container is not empty
        """
        return _connect.CCodeStore_empty(self)

    def numItems(self):
        r"""
        Returns number of all items.

        :rtype: int
        :return: 
            - Number of items
        """
        return _connect.CCodeStore_numItems(self)

    def getItem(self, nIndex):
        r"""
        Returns item at index nIndex.

        :type nIndex: int
        :param nIndex: index of the element. Must be in range 0 .. numItems()-1

        :rtype: :py:class:`CCodeStoreItem`
        :return: 
            - Pointer to item
        """
        return _connect.CCodeStore_getItem(self, nIndex)

    def findItem(self, aAddress):
        r"""
        Finds an item in the requested range.

        :type aAddress: int
        :param aAddress: address which the found item covers

        :rtype: int
        :return: 
            - Index of the item
            - -1 - no item in the range
        """
        return _connect.CCodeStore_findItem(self, aAddress)

    def getBuffer(self, aAddress, vBuffer):
        r"""
        Obtains the code from the specified region.

        :type aAddress: int
        :param aAddress: address from which the code should be retrieved
        :type vBuffer: std::vector< BYTE,std::allocator< BYTE > >
        :param vBuffer: buffer which is filled with the code. Caller must
                   preallocate vBuffer to the size that should be retrieved.
                   For languages other than C++ use `vBuffer = isystem.connect.VectorBYTE(size)`.
        :rtype: int
        :return: 
            - number of locations filled
        """
        return _connect.CCodeStore_getBuffer(self, aAddress, vBuffer)

    def getTotal(self):
        r"""
        Returns total number of contained locations.

        :rtype: int
        :return: 
            - Number of contained locations
        """
        return _connect.CCodeStore_getTotal(self)

    def getRangeLo(self):
        r"""
        Returns lowest loaded location.

        :rtype: int
        :return: 
            - Lowest loaded location. 0 if empty
        """
        return _connect.CCodeStore_getRangeLo(self)

    def getRangeHi(self):
        r"""
        Returns highest loaded location.

        :rtype: int
        :return: 
            - Highest loaded location. 0 if empty
        """
        return _connect.CCodeStore_getRangeHi(self)

    def report(self, fileReport, append, format, maxInLine):
        r"""
        Creates a report to file

        :type fileReport: string
        :param fileReport: path to the report file
        :type append: boolean
        :param append: true to append, false to create a new file
        :type format: string
        :param format: for every single item, using %ADDR%, %SIZE%, %EADDR% and %DATA% macros. If empty, the default "A:%ADDR% S:%SIZE% D:%DATA%" is used
        :type maxInLine: int
        :param maxInLine: specifies maximum number of addresses reported in a line. Use 0 to report contiguous ranges in one line

        :rtype: boolean
        :return: 
            - true on success
        """
        return _connect.CCodeStore_report(self, fileReport, append, format, maxInLine)

    def reportDif(self, fileReport, append, format, maxInLine, rCC1, rCC2):
        r"""
        Creates a difference report to file

        :type fileReport: string
        :param fileReport: path to the report file
        :type append: boolean
        :param append: true to append, false to create a new file
        :type format: string
        :param format: for every single item, using %ADDR%, %SIZE%, %EADDR%, %DIF% and %DATA1%, %DATA2% macros. If empty, the default "A:%ADDR% S:%SIZE%\n  D1:%DATA1%\n  D2:%DATA2%" is used
        :type maxInLine: int
        :param maxInLine: specifies maximum number of addresses reported in a line. Use 0 to report contiguous ranges in one line
        :type rCC1: :py:class:`CCodeStore`
        :param rCC1: is the first reference code store from which this difference object was created
        :type rCC2: :py:class:`CCodeStore`
        :param rCC2: is the second reference code store from which this difference object was created

        :rtype: boolean
        :return: 
            - true on success
        """
        return _connect.CCodeStore_reportDif(self, fileReport, append, format, maxInLine, rCC1, rCC2)

# Register CCodeStore in _connect:
_connect.CCodeStore_swigregister(CCodeStore)
CANInjectedMsgType_DO_NOT_MODIFY = _connect.CANInjectedMsgType_DO_NOT_MODIFY
r"""do not modify message"""
CANInjectedMsgType_DATA = _connect.CANInjectedMsgType_DATA
r"""data message"""
CANInjectedMsgType_REQUEST = _connect.CANInjectedMsgType_REQUEST
r"""request message"""
CANTriggerMsgType_DO_NOT_MODIFY = _connect.CANTriggerMsgType_DO_NOT_MODIFY
r"""do not modify message"""
CANTriggerMsgType_BOTH = _connect.CANTriggerMsgType_BOTH
r"""both trigger message"""
CANTriggerMsgType_REQUEST = _connect.CANTriggerMsgType_REQUEST
r"""request trigger message"""
CANTriggerMsgType_DATA = _connect.CANTriggerMsgType_DATA
r"""data trigger message"""
class SCANTriggerMsgType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SCANTriggerMsgType_convert(key)

    def __init__(self):
        _connect.SCANTriggerMsgType_swiginit(self, _connect.new_SCANTriggerMsgType())
    __swig_destroy__ = _connect.delete_SCANTriggerMsgType

# Register SCANTriggerMsgType in _connect:
_connect.SCANTriggerMsgType_swigregister(SCANTriggerMsgType)
CANIDLength_DO_NOT_MODIFY = _connect.CANIDLength_DO_NOT_MODIFY
r"""do not modify ID"""
CANIDLength_STANDARD = _connect.CANIDLength_STANDARD
r"""standard ID length 11-bit"""
CANIDLength_EXTENDED = _connect.CANIDLength_EXTENDED
r"""extended ID length 29-bit"""
class SCANIDLength(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SCANIDLength_convert(key)

    def __init__(self):
        _connect.SCANIDLength_swiginit(self, _connect.new_SCANIDLength())
    __swig_destroy__ = _connect.delete_SCANIDLength

# Register SCANIDLength in _connect:
_connect.SCANIDLength_swigregister(SCANIDLength)
CANMode_CAN = _connect.CANMode_CAN
r"""CAN"""
CANMode_FD_ISO = _connect.CANMode_FD_ISO
r"""CAN FS ISO"""
CANMode_FD_BOSCH = _connect.CANMode_FD_BOSCH
r"""CAN FD BOSCH"""
class SCANModeConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SCANModeConverter_convert(key)

    def __init__(self):
        _connect.SCANModeConverter_swiginit(self, _connect.new_SCANModeConverter())
    __swig_destroy__ = _connect.delete_SCANModeConverter

# Register SCANModeConverter in _connect:
_connect.SCANModeConverter_swigregister(SCANModeConverter)
CANBaudrate_B_50_KBPS = _connect.CANBaudrate_B_50_KBPS
r"""50 Kbps"""
CANBaudrate_B_100_KBPS = _connect.CANBaudrate_B_100_KBPS
r"""1000 KBps"""
CANBaudrate_B_125_KBPS = _connect.CANBaudrate_B_125_KBPS
r"""125 Kbps"""
CANBaudrate_B_250_KBPS = _connect.CANBaudrate_B_250_KBPS
r"""250 Kbps"""
CANBaudrate_B_500_KBPS = _connect.CANBaudrate_B_500_KBPS
r"""5000 Kbps"""
CANBaudrate_B_1_MBPS = _connect.CANBaudrate_B_1_MBPS
r"""1 Mbps"""
class SCANBaudrateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SCANBaudrateConverter_convert(key)

    def __init__(self):
        _connect.SCANBaudrateConverter_swiginit(self, _connect.new_SCANBaudrateConverter())
    __swig_destroy__ = _connect.delete_SCANBaudrateConverter

# Register SCANBaudrateConverter in _connect:
_connect.SCANBaudrateConverter_swigregister(SCANBaudrateConverter)
CANFDBaudrate_B_50_KBPS = _connect.CANFDBaudrate_B_50_KBPS
r"""50 Kbps"""
CANFDBaudrate_B_100_KBPS = _connect.CANFDBaudrate_B_100_KBPS
r"""100 Kbps"""
CANFDBaudrate_B_125_KBPS = _connect.CANFDBaudrate_B_125_KBPS
r"""125 Kbps"""
CANFDBaudrate_B_250_KBPS = _connect.CANFDBaudrate_B_250_KBPS
r"""250 Kbps"""
CANFDBaudrate_B_500_KBPS = _connect.CANFDBaudrate_B_500_KBPS
r"""500 Kbps"""
CANFDBaudrate_B_1_MBPS = _connect.CANFDBaudrate_B_1_MBPS
r"""1 Mbps"""
CANFDBaudrate_B_2_MBPS = _connect.CANFDBaudrate_B_2_MBPS
r"""2 Mbps"""
CANFDBaudrate_B_4_MBPS = _connect.CANFDBaudrate_B_4_MBPS
r"""4 Mbps"""
CANFDBaudrate_B_8_MBPS = _connect.CANFDBaudrate_B_8_MBPS
r"""8 Mbps"""
class SCANFDBaudrateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SCANFDBaudrateConverter_convert(key)

    def __init__(self):
        _connect.SCANFDBaudrateConverter_swiginit(self, _connect.new_SCANFDBaudrateConverter())
    __swig_destroy__ = _connect.delete_SCANFDBaudrateConverter

# Register SCANFDBaudrateConverter in _connect:
_connect.SCANFDBaudrateConverter_swigregister(SCANFDBaudrateConverter)
TriState_DO_NOT_MODIFY = _connect.TriState_DO_NOT_MODIFY
r"""do not modify"""
TriState_FALSE_TS = _connect.TriState_FALSE_TS
r"""false selection"""
TriState_TRUE_TS = _connect.TriState_TRUE_TS
r"""true selection"""
class STriStateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.STriStateConverter_convert(key)

    def __init__(self):
        _connect.STriStateConverter_swiginit(self, _connect.new_STriStateConverter())
    __swig_destroy__ = _connect.delete_STriStateConverter

# Register STriStateConverter in _connect:
_connect.STriStateConverter_swigregister(STriStateConverter)
AInCompareCondition_DO_NOT_MODIFY = _connect.AInCompareCondition_DO_NOT_MODIFY
r"""do not modify selection"""
AInCompareCondition_LOWER_THAN = _connect.AInCompareCondition_LOWER_THAN
r"""lower than condition"""
AInCompareCondition_HIGHER_THAN = _connect.AInCompareCondition_HIGHER_THAN
r"""higher than condition"""
class AInCompareConditionConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.AInCompareConditionConverter_convert(key)

    def __init__(self):
        _connect.AInCompareConditionConverter_swiginit(self, _connect.new_AInCompareConditionConverter())
    __swig_destroy__ = _connect.delete_AInCompareConditionConverter

# Register AInCompareConditionConverter in _connect:
_connect.AInCompareConditionConverter_swigregister(AInCompareConditionConverter)
AInSamplingInterval_S_100_NS = _connect.AInSamplingInterval_S_100_NS
r"""100 nano seconds"""
AInSamplingInterval_S_1_US = _connect.AInSamplingInterval_S_1_US
r"""1 micro second"""
AInSamplingInterval_S_10_US = _connect.AInSamplingInterval_S_10_US
r"""10 micro seconds"""
AInSamplingInterval_S_100_US = _connect.AInSamplingInterval_S_100_US
r"""100 micro seconds"""
AInSamplingInterval_S_1_MS = _connect.AInSamplingInterval_S_1_MS
r"""1 mili second"""
AInSamplingInterval_S_10_MS = _connect.AInSamplingInterval_S_10_MS
r"""10 mili seconds"""
AInSamplingInterval_S_100_MS = _connect.AInSamplingInterval_S_100_MS
r"""100 mili seconds"""
AInSamplingInterval_S_1_S = _connect.AInSamplingInterval_S_1_S
r"""1 second"""
class AInSamplingIntervalConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.AInSamplingIntervalConverter_convert(key)

    def __init__(self):
        _connect.AInSamplingIntervalConverter_swiginit(self, _connect.new_AInSamplingIntervalConverter())
    __swig_destroy__ = _connect.delete_AInSamplingIntervalConverter

# Register AInSamplingIntervalConverter in _connect:
_connect.AInSamplingIntervalConverter_swigregister(AInSamplingIntervalConverter)
IODirection_IN_DIR = _connect.IODirection_IN_DIR
r"""input direction"""
IODirection_OUT_DIR = _connect.IODirection_OUT_DIR
r"""output direction"""
class IODirectionConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.IODirectionConverter_convert(key)

    def __init__(self):
        _connect.IODirectionConverter_swiginit(self, _connect.new_IODirectionConverter())
    __swig_destroy__ = _connect.delete_IODirectionConverter

# Register IODirectionConverter in _connect:
_connect.IODirectionConverter_swigregister(IODirectionConverter)
IOLevels_VL_1_8V = _connect.IOLevels_VL_1_8V
r"""1.8 volts"""
IOLevels_VL_2_5V = _connect.IOLevels_VL_2_5V
r"""2.5 volts"""
IOLevels_VL_3_3V = _connect.IOLevels_VL_3_3V
r"""3.3 volts"""
IOLevels_VL_5V = _connect.IOLevels_VL_5V
r"""5 volts"""
class IOLevelsConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.IOLevelsConverter_convert(key)

    def __init__(self):
        _connect.IOLevelsConverter_swiginit(self, _connect.new_IOLevelsConverter())
    __swig_destroy__ = _connect.delete_IOLevelsConverter

# Register IOLevelsConverter in _connect:
_connect.IOLevelsConverter_swigregister(IOLevelsConverter)
IOState_LOW = _connect.IOState_LOW
r"""low state"""
IOState_HIGH = _connect.IOState_HIGH
r"""high state"""
IOState_DO_NOT_MODIFY = _connect.IOState_DO_NOT_MODIFY
r"""do not modify state"""
class IOStateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.IOStateConverter_convert(key)

    def __init__(self):
        _connect.IOStateConverter_swiginit(self, _connect.new_IOStateConverter())
    __swig_destroy__ = _connect.delete_IOStateConverter

# Register IOStateConverter in _connect:
_connect.IOStateConverter_swigregister(IOStateConverter)
SPISamplePhase_DO_NOT_MODIFY = _connect.SPISamplePhase_DO_NOT_MODIFY
r"""do not modify phase"""
SPISamplePhase_FIRST_EDGE = _connect.SPISamplePhase_FIRST_EDGE
r"""first edge phase"""
SPISamplePhase_SECOND_EDGE = _connect.SPISamplePhase_SECOND_EDGE
r"""second edge phase"""
class SPISamplePhaseConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SPISamplePhaseConverter_convert(key)

    def __init__(self):
        _connect.SPISamplePhaseConverter_swiginit(self, _connect.new_SPISamplePhaseConverter())
    __swig_destroy__ = _connect.delete_SPISamplePhaseConverter

# Register SPISamplePhaseConverter in _connect:
_connect.SPISamplePhaseConverter_swigregister(SPISamplePhaseConverter)
SPICSName_DO_NOT_MODIFY = _connect.SPICSName_DO_NOT_MODIFY
r"""do not modify"""
SPICSName_CS0 = _connect.SPICSName_CS0
r"""chip select 0"""
SPICSName_CS1 = _connect.SPICSName_CS1
r"""chip select 1"""
SPICSName_CS2 = _connect.SPICSName_CS2
r"""chip select 2"""
SPICSName_CS3 = _connect.SPICSName_CS3
r"""chip select 3"""
class SPICSNameConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SPICSNameConverter_convert(key)

    def __init__(self):
        _connect.SPICSNameConverter_swiginit(self, _connect.new_SPICSNameConverter())
    __swig_destroy__ = _connect.delete_SPICSNameConverter

# Register SPICSNameConverter in _connect:
_connect.SPICSNameConverter_swigregister(SPICSNameConverter)
SPIDataStream_DO_NOT_MODIFY = _connect.SPIDataStream_DO_NOT_MODIFY
r"""do not modify stream"""
SPIDataStream_MISO = _connect.SPIDataStream_MISO
r"""MISO data stream"""
SPIDataStream_MOSI = _connect.SPIDataStream_MOSI
r"""MOSI data stream"""
class SPIDataStreamConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SPIDataStreamConverter_convert(key)

    def __init__(self):
        _connect.SPIDataStreamConverter_swiginit(self, _connect.new_SPIDataStreamConverter())
    __swig_destroy__ = _connect.delete_SPIDataStreamConverter

# Register SPIDataStreamConverter in _connect:
_connect.SPIDataStreamConverter_swigregister(SPIDataStreamConverter)
SPIDataEndian_DO_NOT_MODIFY = _connect.SPIDataEndian_DO_NOT_MODIFY
r"""do not modify"""
SPIDataEndian_ISYS_LITTLE_ENDIAN = _connect.SPIDataEndian_ISYS_LITTLE_ENDIAN
r"""little endian"""
SPIDataEndian_ISYS_BIG_ENDIAN = _connect.SPIDataEndian_ISYS_BIG_ENDIAN
r"""big endian"""
class SPIDataEndianConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SPIDataEndianConverter_convert(key)

    def __init__(self):
        _connect.SPIDataEndianConverter_swiginit(self, _connect.new_SPIDataEndianConverter())
    __swig_destroy__ = _connect.delete_SPIDataEndianConverter

# Register SPIDataEndianConverter in _connect:
_connect.SPIDataEndianConverter_swigregister(SPIDataEndianConverter)
LINBaudrate_B_2400_BPS = _connect.LINBaudrate_B_2400_BPS
r"""2400 bps"""
LINBaudrate_B_9600_BPS = _connect.LINBaudrate_B_9600_BPS
r"""96000 bps"""
LINBaudrate_B_19200_BPS = _connect.LINBaudrate_B_19200_BPS
r"""19200 bps"""
LINBaudrate_B_20000_BPS = _connect.LINBaudrate_B_20000_BPS
r"""20000 bps"""
class LINBaudrateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.LINBaudrateConverter_convert(key)

    def __init__(self):
        _connect.LINBaudrateConverter_swiginit(self, _connect.new_LINBaudrateConverter())
    __swig_destroy__ = _connect.delete_LINBaudrateConverter

# Register LINBaudrateConverter in _connect:
_connect.LINBaudrateConverter_swigregister(LINBaudrateConverter)
IORecordMode_NONE = _connect.IORecordMode_NONE
r"""none record mode"""
IORecordMode_INPUTS = _connect.IORecordMode_INPUTS
r"""inputs record mode"""
IORecordMode_ALL = _connect.IORecordMode_ALL
r"""all record mode"""
class IORecordModeConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.IORecordModeConverter_convert(key)

    def __init__(self):
        _connect.IORecordModeConverter_swiginit(self, _connect.new_IORecordModeConverter())
    __swig_destroy__ = _connect.delete_IORecordModeConverter

# Register IORecordModeConverter in _connect:
_connect.IORecordModeConverter_swigregister(IORecordModeConverter)
IOTriggerSignalState_ANY = _connect.IOTriggerSignalState_ANY
r"""any signal state"""
IOTriggerSignalState_LOW = _connect.IOTriggerSignalState_LOW
r"""low signal state"""
IOTriggerSignalState_HIGH = _connect.IOTriggerSignalState_HIGH
r"""high signal state"""
class IOTriggerSignalStateConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.IOTriggerSignalStateConverter_convert(key)

    def __init__(self):
        _connect.IOTriggerSignalStateConverter_swiginit(self, _connect.new_IOTriggerSignalStateConverter())
    __swig_destroy__ = _connect.delete_IOTriggerSignalStateConverter

# Register IOTriggerSignalStateConverter in _connect:
_connect.IOTriggerSignalStateConverter_swigregister(IOTriggerSignalStateConverter)
IOPatternType_DO_NOT_MODIFY = _connect.IOPatternType_DO_NOT_MODIFY
r"""do not modify"""
IOPatternType_SINGLE_SHOT = _connect.IOPatternType_SINGLE_SHOT
r"""single shot"""
IOPatternType_CONTINUOUS = _connect.IOPatternType_CONTINUOUS
r"""continuous"""
class IOPatternTypeConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.IOPatternTypeConverter_convert(key)

    def __init__(self):
        _connect.IOPatternTypeConverter_swiginit(self, _connect.new_IOPatternTypeConverter())
    __swig_destroy__ = _connect.delete_IOPatternTypeConverter

# Register IOPatternTypeConverter in _connect:
_connect.IOPatternTypeConverter_swigregister(IOPatternTypeConverter)
PowerSenseShunt_SHUNT_1_OHM = _connect.PowerSenseShunt_SHUNT_1_OHM
r"""1 ohm"""
PowerSenseShunt_SHUNT_0_26_OHM = _connect.PowerSenseShunt_SHUNT_0_26_OHM
r"""0.26 ohm"""
PowerSenseShunt_SHUNT_0_11_OHM = _connect.PowerSenseShunt_SHUNT_0_11_OHM
r"""0.11 ohm"""
class PowerSenseShuntConverter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.PowerSenseShuntConverter_convert(key)

    def __init__(self):
        _connect.PowerSenseShuntConverter_swiginit(self, _connect.new_PowerSenseShuntConverter())
    __swig_destroy__ = _connect.delete_PowerSenseShuntConverter

# Register PowerSenseShuntConverter in _connect:
_connect.PowerSenseShuntConverter_swigregister(PowerSenseShuntConverter)
class DIOBankChannelIndex(object):
    r"""FNet digital input output channel index."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bankIndex = property(_connect.DIOBankChannelIndex_bankIndex_get, _connect.DIOBankChannelIndex_bankIndex_set, doc=r"""bank index""")
    channelIndex = property(_connect.DIOBankChannelIndex_channelIndex_get, _connect.DIOBankChannelIndex_channelIndex_set, doc=r"""channel index""")

    def __init__(self):
        _connect.DIOBankChannelIndex_swiginit(self, _connect.new_DIOBankChannelIndex())
    __swig_destroy__ = _connect.delete_DIOBankChannelIndex

# Register DIOBankChannelIndex in _connect:
_connect.DIOBankChannelIndex_swigregister(DIOBankChannelIndex)
class PowerSenseParameters(object):
    r"""FNet power sense parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    voltage = property(_connect.PowerSenseParameters_voltage_get, _connect.PowerSenseParameters_voltage_set, doc=r"""voltage""")
    current = property(_connect.PowerSenseParameters_current_get, _connect.PowerSenseParameters_current_set, doc=r"""current""")
    power = property(_connect.PowerSenseParameters_power_get, _connect.PowerSenseParameters_power_set, doc=r"""power""")

    def __init__(self):
        _connect.PowerSenseParameters_swiginit(self, _connect.new_PowerSenseParameters())
    __swig_destroy__ = _connect.delete_PowerSenseParameters

# Register PowerSenseParameters in _connect:
_connect.PowerSenseParameters_swigregister(PowerSenseParameters)
class SFNetGlobals(object):
    r"""FNet global constant."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DO_NOT_MODIFY = _connect.SFNetGlobals_DO_NOT_MODIFY
    r"""do not modify constant"""

    def __init__(self):
        _connect.SFNetGlobals_swiginit(self, _connect.new_SFNetGlobals())
    __swig_destroy__ = _connect.delete_SFNetGlobals

# Register SFNetGlobals in _connect:
_connect.SFNetGlobals_swigregister(SFNetGlobals)
class FNetCommons(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def isHexString(value):
        return _connect.FNetCommons_isHexString(value)

    def __init__(self):
        _connect.FNetCommons_swiginit(self, _connect.new_FNetCommons())
    __swig_destroy__ = _connect.delete_FNetCommons

# Register FNetCommons in _connect:
_connect.FNetCommons_swigregister(FNetCommons)
class CCANOpInjMsgConfig(object):
    r"""CAN inject message configuration class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCANOpInjMsgConfig_swiginit(self, _connect.new_CCANOpInjMsgConfig())
    __swig_destroy__ = _connect.delete_CCANOpInjMsgConfig
    idLength = property(_connect.CCANOpInjMsgConfig_idLength_get, _connect.CCANOpInjMsgConfig_idLength_set, doc=r"""CAN ID length selection""")
    id = property(_connect.CCANOpInjMsgConfig_id_get, _connect.CCANOpInjMsgConfig_id_set, doc=r"""message id as string, valid input 0x20, 33""")
    fd = property(_connect.CCANOpInjMsgConfig_fd_get, _connect.CCANOpInjMsgConfig_fd_set, doc=r"""CAN FD selection""")
    brs = property(_connect.CCANOpInjMsgConfig_brs_get, _connect.CCANOpInjMsgConfig_brs_set, doc=r"""CAN BRS (bit rate switch) selection""")
    esi = property(_connect.CCANOpInjMsgConfig_esi_get, _connect.CCANOpInjMsgConfig_esi_set, doc=r"""CAN ESI (error state indicator) selection""")
    injectedMsgType = property(_connect.CCANOpInjMsgConfig_injectedMsgType_get, _connect.CCANOpInjMsgConfig_injectedMsgType_set, doc=r"""CAN injected message type""")
    data = property(_connect.CCANOpInjMsgConfig_data_get, _connect.CCANOpInjMsgConfig_data_set, doc=r"""CAN data""")

# Register CCANOpInjMsgConfig in _connect:
_connect.CCANOpInjMsgConfig_swigregister(CCANOpInjMsgConfig)
class CCANOpConfig(object):
    r"""CAN operation configuration class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCANOpConfig_swiginit(self, _connect.new_CCANOpConfig())
    __swig_destroy__ = _connect.delete_CCANOpConfig
    idLength = property(_connect.CCANOpConfig_idLength_get, _connect.CCANOpConfig_idLength_set, doc=r"""CAN ID length selection""")
    id = property(_connect.CCANOpConfig_id_get, _connect.CCANOpConfig_id_set, doc=r"""message id as string, valid input 0x20, 33""")
    mask = property(_connect.CCANOpConfig_mask_get, _connect.CCANOpConfig_mask_set, doc=r"""mask configuration""")
    triggerMsgType = property(_connect.CCANOpConfig_triggerMsgType_get, _connect.CCANOpConfig_triggerMsgType_set, doc=r"""CAN trigger message type""")

# Register CCANOpConfig in _connect:
_connect.CCANOpConfig_swigregister(CCANOpConfig)
class CFNetController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr):
        _connect.CFNetController_swiginit(self, _connect.new_CFNetController(connectionMgr))
    __swig_destroy__ = _connect.delete_CFNetController

    def createCounterController(self, *args):
        r"""
        Returns new instance of CFNetCounterController.
        :type identifier: string, optional
        :param identifier: unique network identifier string (example: "Root.COUNTER1")
        """
        return _connect.CFNetController_createCounterController(self, *args)

    def createDIOController(self, identifier):
        return _connect.CFNetController_createDIOController(self, identifier)

    def createSPIController(self, identifier):
        return _connect.CFNetController_createSPIController(self, identifier)

    def createAOutController(self, identifier):
        return _connect.CFNetController_createAOutController(self, identifier)

    def createAInController(self, identifier):
        return _connect.CFNetController_createAInController(self, identifier)

    def createPowerSenseController(self, *args):
        return _connect.CFNetController_createPowerSenseController(self, *args)

    def createCANController(self, identifier):
        return _connect.CFNetController_createCANController(self, identifier)

    def createLINController(self, identifier):
        return _connect.CFNetController_createLINController(self, identifier)

    def injectTrigger(self, triggerIndex):
        return _connect.CFNetController_injectTrigger(self, triggerIndex)

    def getListOfConnectedNodes(self, nodes):
        return _connect.CFNetController_getListOfConnectedNodes(self, nodes)

    def getNodeAttributes(self, nodeName, raiseException=False):
        return _connect.CFNetController_getNodeAttributes(self, nodeName, raiseException)

    def getTriggerIndex(self, triggerName):
        return _connect.CFNetController_getTriggerIndex(self, triggerName)

    def applyOperation(self):
        return _connect.CFNetController_applyOperation(self)

    def stopOperation(self):
        return _connect.CFNetController_stopOperation(self)

    def restartOperation(self):
        return _connect.CFNetController_restartOperation(self)

# Register CFNetController in _connect:
_connect.CFNetController_swigregister(CFNetController)
class CFNetBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetBase_swiginit(self, _connect.new_CFNetBase(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetBase

    def getNodeName(self):
        return _connect.CFNetBase_getNodeName(self)

    def getNetworkName(self):
        return _connect.CFNetBase_getNetworkName(self)

    def getIdentifier(self):
        return _connect.CFNetBase_getIdentifier(self)

    def setQualifierEnableRecordOnStart(self, state):
        return _connect.CFNetBase_setQualifierEnableRecordOnStart(self, state)

    def setQualifierEnableOnTriggerIndex(self, triggerIndex):
        return _connect.CFNetBase_setQualifierEnableOnTriggerIndex(self, triggerIndex)

    def setQualifierDisableOnTriggerIndex(self, triggerIndex):
        return _connect.CFNetBase_setQualifierDisableOnTriggerIndex(self, triggerIndex)

    def getCfgChannelBaseString(self, channelIndex):
        return _connect.CFNetBase_getCfgChannelBaseString(self, channelIndex)

    def setChannelName(self, channelIndex, name):
        return _connect.CFNetBase_setChannelName(self, channelIndex, name)

    def getChannelName(self, channelIndex):
        return _connect.CFNetBase_getChannelName(self, channelIndex)

    def getOpChannelBaseString(self, channelIndex):
        return _connect.CFNetBase_getOpChannelBaseString(self, channelIndex)

    def stripUnits(self, expression):
        return _connect.CFNetBase_stripUnits(self, expression)

    def getIOpenBaseUrl(self):
        return _connect.CFNetBase_getIOpenBaseUrl(self)

    def getHILCtrl(self):
        return _connect.CFNetBase_getHILCtrl(self)

    def getIDECtrl(self):
        return _connect.CFNetBase_getIDECtrl(self)

# Register CFNetBase in _connect:
_connect.CFNetBase_swigregister(CFNetBase)
class CCounterOperationConfig(object):
    r"""FNet counter configuration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CCounterOperationConfig_swiginit(self, _connect.new_CCounterOperationConfig())
    __swig_destroy__ = _connect.delete_CCounterOperationConfig
    countOnTimeUs = property(_connect.CCounterOperationConfig_countOnTimeUs_get, _connect.CCounterOperationConfig_countOnTimeUs_set, doc=r"""interval for counter increment in microseconds""")
    incrementEventTriggerIndex = property(_connect.CCounterOperationConfig_incrementEventTriggerIndex_get, _connect.CCounterOperationConfig_incrementEventTriggerIndex_set, doc=r"""timer trigger index in range from 0 to 10""")
    onCounterIncrementTriggerIndex = property(_connect.CCounterOperationConfig_onCounterIncrementTriggerIndex_get, _connect.CCounterOperationConfig_onCounterIncrementTriggerIndex_set, doc=r"""trigger index in range from 0 to 10""")
    startActive = property(_connect.CCounterOperationConfig_startActive_get, _connect.CCounterOperationConfig_startActive_set, doc=r"""if enabled, counter starts at session start""")
    restartOnTriggerIndex = property(_connect.CCounterOperationConfig_restartOnTriggerIndex_get, _connect.CCounterOperationConfig_restartOnTriggerIndex_set, doc=r"""trigger index in range from 0 to 10""")
    suspendOnTriggerIndex = property(_connect.CCounterOperationConfig_suspendOnTriggerIndex_get, _connect.CCounterOperationConfig_suspendOnTriggerIndex_set, doc=r"""trigger index in range from 0 to 10""")
    resumeOnTriggerIndex = property(_connect.CCounterOperationConfig_resumeOnTriggerIndex_get, _connect.CCounterOperationConfig_resumeOnTriggerIndex_set, doc=r"""trigger index in range from 0 to 10""")
    enableCounterLimit = property(_connect.CCounterOperationConfig_enableCounterLimit_get, _connect.CCounterOperationConfig_enableCounterLimit_set, doc=r"""if enabled, configured trigger and action is executed once limit is reached""")
    counterLimit = property(_connect.CCounterOperationConfig_counterLimit_get, _connect.CCounterOperationConfig_counterLimit_set, doc=r"""counter limit value""")
    onLimitTriggerIndex = property(_connect.CCounterOperationConfig_onLimitTriggerIndex_get, _connect.CCounterOperationConfig_onLimitTriggerIndex_set, doc=r"""trigger index in range from 0 to 10""")
    onLimitRestart = property(_connect.CCounterOperationConfig_onLimitRestart_get, _connect.CCounterOperationConfig_onLimitRestart_set, doc=r"""if enabled, counter is restarted once limit is reached""")
    onCounterChangesRecord = property(_connect.CCounterOperationConfig_onCounterChangesRecord_get, _connect.CCounterOperationConfig_onCounterChangesRecord_set, doc=r"""if enabled, this channel counter changes are recorded (respects counter recording qualifier settings)""")

# Register CCounterOperationConfig in _connect:
_connect.CCounterOperationConfig_swigregister(CCounterOperationConfig)
class CFNetCounterOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spCounterCtrl):
        _connect.CFNetCounterOperationController_swiginit(self, _connect.new_CFNetCounterOperationController(spCounterCtrl))
    __swig_destroy__ = _connect.delete_CFNetCounterOperationController

    def enableCounter(self, channelIndex, isEnabled):
        return _connect.CFNetCounterOperationController_enableCounter(self, channelIndex, isEnabled)

    def configureCounter(self, channelIndex, counterConfig):
        return _connect.CFNetCounterOperationController_configureCounter(self, channelIndex, counterConfig)

# Register CFNetCounterOperationController in _connect:
_connect.CFNetCounterOperationController_swigregister(CFNetCounterOperationController)
class CFNetCounterControlController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spCounterCtrl):
        _connect.CFNetCounterControlController_swiginit(self, _connect.new_CFNetCounterControlController(spCounterCtrl))
    __swig_destroy__ = _connect.delete_CFNetCounterControlController

    def isChannelActive(self, channelIndex):
        return _connect.CFNetCounterControlController_isChannelActive(self, channelIndex)

    def resetChannel(self, channelIndex):
        return _connect.CFNetCounterControlController_resetChannel(self, channelIndex)

    def resetAllChannels(self):
        return _connect.CFNetCounterControlController_resetAllChannels(self)

    def resetActiveChannels(self):
        return _connect.CFNetCounterControlController_resetActiveChannels(self)

    def suspendChannel(self, channelIndex):
        return _connect.CFNetCounterControlController_suspendChannel(self, channelIndex)

    def suspendAllChannels(self):
        return _connect.CFNetCounterControlController_suspendAllChannels(self)

    def resumeChannel(self, channelIndex):
        return _connect.CFNetCounterControlController_resumeChannel(self, channelIndex)

    def resumeAllChannels(self):
        return _connect.CFNetCounterControlController_resumeAllChannels(self)

    def getCounterValue(self, channelIndex):
        return _connect.CFNetCounterControlController_getCounterValue(self, channelIndex)

    def getTriggerCounterValue(self, triggerIndex):
        return _connect.CFNetCounterControlController_getTriggerCounterValue(self, triggerIndex)

    def resetTriggerCounterValue(self, triggerIndex):
        return _connect.CFNetCounterControlController_resetTriggerCounterValue(self, triggerIndex)

# Register CFNetCounterControlController in _connect:
_connect.CFNetCounterControlController_swigregister(CFNetCounterControlController)
class CFNetCounterController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetCounterController_swiginit(self, _connect.new_CFNetCounterController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetCounterController

    def getMaxChannelsCount(self):
        return _connect.CFNetCounterController_getMaxChannelsCount(self)

    def getTriggerIndex(self, channelIndex):
        return _connect.CFNetCounterController_getTriggerIndex(self, channelIndex)

    def setTriggerIndex(self, channelIndex, trigger):
        return _connect.CFNetCounterController_setTriggerIndex(self, channelIndex, trigger)

    def op(self):
        return _connect.CFNetCounterController_op(self)

    def ctrl(self):
        return _connect.CFNetCounterController_ctrl(self)

# Register CFNetCounterController in _connect:
_connect.CFNetCounterController_swigregister(CFNetCounterController)
class CFNetSPIConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spSPICtrl):
        _connect.CFNetSPIConfigurationController_swiginit(self, _connect.new_CFNetSPIConfigurationController(spSPICtrl))
    __swig_destroy__ = _connect.delete_CFNetSPIConfigurationController

    def getNetworkDescriptionFile(self, descriptionFiles):
        return _connect.CFNetSPIConfigurationController_getNetworkDescriptionFile(self, descriptionFiles)

    def setNetworkDescriptionFile(self, descriptionFiles):
        return _connect.CFNetSPIConfigurationController_setNetworkDescriptionFile(self, descriptionFiles)

    def enableSPI(self, isEnabled):
        return _connect.CFNetSPIConfigurationController_enableSPI(self, isEnabled)

    def configureChipSelectActiveState(self, activeState):
        return _connect.CFNetSPIConfigurationController_configureChipSelectActiveState(self, activeState)

    def configureSamplingPhase(self, samplingPhase):
        return _connect.CFNetSPIConfigurationController_configureSamplingPhase(self, samplingPhase)

    def configureClockIdleState(self, clockIdleState):
        return _connect.CFNetSPIConfigurationController_configureClockIdleState(self, clockIdleState)

# Register CFNetSPIConfigurationController in _connect:
_connect.CFNetSPIConfigurationController_swigregister(CFNetSPIConfigurationController)
class CSPIOperationConfig(object):
    r"""SPI configuration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CSPIOperationConfig_swiginit(self, _connect.new_CSPIOperationConfig())
    __swig_destroy__ = _connect.delete_CSPIOperationConfig
    triggerIndex = property(_connect.CSPIOperationConfig_triggerIndex_get, _connect.CSPIOperationConfig_triggerIndex_set, doc=r"""trigger index in range from 0 to 10.""")
    csName = property(_connect.CSPIOperationConfig_csName_get, _connect.CSPIOperationConfig_csName_set, doc=r"""device enable pin selection""")
    stream = property(_connect.CSPIOperationConfig_stream_get, _connect.CSPIOperationConfig_stream_set, doc=r"""data stream type""")
    offset = property(_connect.CSPIOperationConfig_offset_get, _connect.CSPIOperationConfig_offset_set, doc=r"""integer in range from 0 to 1023""")
    size = property(_connect.CSPIOperationConfig_size_get, _connect.CSPIOperationConfig_size_set, doc=r"""integer in range from 1 to 32""")
    bitOrder = property(_connect.CSPIOperationConfig_bitOrder_get, _connect.CSPIOperationConfig_bitOrder_set, doc=r"""type of data encoding""")
    valueHex = property(_connect.CSPIOperationConfig_valueHex_get, _connect.CSPIOperationConfig_valueHex_set, doc=r"""string of a hex value, without '0x'""")
    maskHex = property(_connect.CSPIOperationConfig_maskHex_get, _connect.CSPIOperationConfig_maskHex_set, doc=r"""string of a hex value, without '0x'""")

# Register CSPIOperationConfig in _connect:
_connect.CSPIOperationConfig_swigregister(CSPIOperationConfig)
class CFNetSPIOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spSPICtrl):
        _connect.CFNetSPIOperationController_swiginit(self, _connect.new_CFNetSPIOperationController(spSPICtrl))
    __swig_destroy__ = _connect.delete_CFNetSPIOperationController

    def enableRecordingAllMessages(self, isEnabled):
        return _connect.CFNetSPIOperationController_enableRecordingAllMessages(self, isEnabled)

    def enableRecording(self, slotIndex, isEnabled):
        return _connect.CFNetSPIOperationController_enableRecording(self, slotIndex, isEnabled)

    def configureComparator(self, slotIndex, spiOpConfig):
        return _connect.CFNetSPIOperationController_configureComparator(self, slotIndex, spiOpConfig)

# Register CFNetSPIOperationController in _connect:
_connect.CFNetSPIOperationController_swigregister(CFNetSPIOperationController)
class CFNetSPIController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetSPIController_swiginit(self, _connect.new_CFNetSPIController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetSPIController

    def cfg(self):
        return _connect.CFNetSPIController_cfg(self)

    def op(self):
        return _connect.CFNetSPIController_op(self)

# Register CFNetSPIController in _connect:
_connect.CFNetSPIController_swigregister(CFNetSPIController)
class CFNetAOutConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spAOutCtrl):
        _connect.CFNetAOutConfigurationController_swiginit(self, _connect.new_CFNetAOutConfigurationController(spAOutCtrl))
    __swig_destroy__ = _connect.delete_CFNetAOutConfigurationController

    def showChannel(self, channelIndex, isShow):
        return _connect.CFNetAOutConfigurationController_showChannel(self, channelIndex, isShow)

    def setChannelName(self, channelIndex, name):
        return _connect.CFNetAOutConfigurationController_setChannelName(self, channelIndex, name)

    def getChannelName(self, channelIndex):
        return _connect.CFNetAOutConfigurationController_getChannelName(self, channelIndex)

    def setChannelInitialValue(self, channelIndex, value):
        return _connect.CFNetAOutConfigurationController_setChannelInitialValue(self, channelIndex, value)

# Register CFNetAOutConfigurationController in _connect:
_connect.CFNetAOutConfigurationController_swigregister(CFNetAOutConfigurationController)
class CFNetAOutOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spAOutCtrl):
        _connect.CFNetAOutOperationController_swiginit(self, _connect.new_CFNetAOutOperationController(spAOutCtrl))
    __swig_destroy__ = _connect.delete_CFNetAOutOperationController

    def setActionTrigger(self, channelIndex, actionIndex, triggerIndex):
        return _connect.CFNetAOutOperationController_setActionTrigger(self, channelIndex, actionIndex, triggerIndex)

    def setActionTriggerLevel(self, channelIndex, actionIndex, level):
        return _connect.CFNetAOutOperationController_setActionTriggerLevel(self, channelIndex, actionIndex, level)

# Register CFNetAOutOperationController in _connect:
_connect.CFNetAOutOperationController_swigregister(CFNetAOutOperationController)
class CFNetAOutControlController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spAOutCtrl):
        _connect.CFNetAOutControlController_swiginit(self, _connect.new_CFNetAOutControlController(spAOutCtrl))
    __swig_destroy__ = _connect.delete_CFNetAOutControlController

    def writeChannel(self, channelIndex, value):
        return _connect.CFNetAOutControlController_writeChannel(self, channelIndex, value)

    def readChannel(self, channelIndex):
        return _connect.CFNetAOutControlController_readChannel(self, channelIndex)

# Register CFNetAOutControlController in _connect:
_connect.CFNetAOutControlController_swigregister(CFNetAOutControlController)
class CFNetAOutController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetAOutController_swiginit(self, _connect.new_CFNetAOutController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetAOutController

    def cfg(self):
        return _connect.CFNetAOutController_cfg(self)

    def op(self):
        return _connect.CFNetAOutController_op(self)

    def ctrl(self):
        return _connect.CFNetAOutController_ctrl(self)

# Register CFNetAOutController in _connect:
_connect.CFNetAOutController_swigregister(CFNetAOutController)
AInAverage_AVG_4 = _connect.AInAverage_AVG_4
AInAverage_AVG_8 = _connect.AInAverage_AVG_8
AInAverage_AVG_16 = _connect.AInAverage_AVG_16
class SAInAverage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def convert(key):
        return _connect.SAInAverage_convert(key)

    def __init__(self):
        _connect.SAInAverage_swiginit(self, _connect.new_SAInAverage())
    __swig_destroy__ = _connect.delete_SAInAverage

# Register SAInAverage in _connect:
_connect.SAInAverage_swigregister(SAInAverage)
class CFNetAInConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spAInCtrl):
        _connect.CFNetAInConfigurationController_swiginit(self, _connect.new_CFNetAInConfigurationController(spAInCtrl))
    __swig_destroy__ = _connect.delete_CFNetAInConfigurationController

    def showChannel(self, channelIndex, isShow):
        return _connect.CFNetAInConfigurationController_showChannel(self, channelIndex, isShow)

    def setChannelName(self, channelIndex, name):
        return _connect.CFNetAInConfigurationController_setChannelName(self, channelIndex, name)

    def getChannelName(self, channelIndex):
        return _connect.CFNetAInConfigurationController_getChannelName(self, channelIndex)

    def setMultiplier(self, channelIndex, multiplier):
        return _connect.CFNetAInConfigurationController_setMultiplier(self, channelIndex, multiplier)

    def getMultiplier(self, channelIndex):
        return _connect.CFNetAInConfigurationController_getMultiplier(self, channelIndex)

    def setAveraging(self, isEnabled, averageSamples):
        return _connect.CFNetAInConfigurationController_setAveraging(self, isEnabled, averageSamples)

    def getAveraging(self):
        return _connect.CFNetAInConfigurationController_getAveraging(self)

# Register CFNetAInConfigurationController in _connect:
_connect.CFNetAInConfigurationController_swigregister(CFNetAInConfigurationController)
class CFNetAInOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spAInCtrl):
        _connect.CFNetAInOperationController_swiginit(self, _connect.new_CFNetAInOperationController(spAInCtrl))
    __swig_destroy__ = _connect.delete_CFNetAInOperationController

    def enableRecording(self, channelIndex, isEnabled):
        return _connect.CFNetAInOperationController_enableRecording(self, channelIndex, isEnabled)

    def setSampligInterval(self, interval):
        return _connect.CFNetAInOperationController_setSampligInterval(self, interval)

    def setTriggerAction(self, channelIndex, slotIndex, triggerIndex, condition, level):
        return _connect.CFNetAInOperationController_setTriggerAction(self, channelIndex, slotIndex, triggerIndex, condition, level)

    def disableTriggerAction(self, channelIndex, slotIndex):
        return _connect.CFNetAInOperationController_disableTriggerAction(self, channelIndex, slotIndex)

# Register CFNetAInOperationController in _connect:
_connect.CFNetAInOperationController_swigregister(CFNetAInOperationController)
class CFNetAInControlController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spAInCtrl):
        _connect.CFNetAInControlController_swiginit(self, _connect.new_CFNetAInControlController(spAInCtrl))
    __swig_destroy__ = _connect.delete_CFNetAInControlController

    def readChannel(self, channelIndex):
        return _connect.CFNetAInControlController_readChannel(self, channelIndex)

# Register CFNetAInControlController in _connect:
_connect.CFNetAInControlController_swigregister(CFNetAInControlController)
class CFNetAInController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetAInController_swiginit(self, _connect.new_CFNetAInController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetAInController

    def cfg(self):
        return _connect.CFNetAInController_cfg(self)

    def op(self):
        return _connect.CFNetAInController_op(self)

    def ctrl(self):
        return _connect.CFNetAInController_ctrl(self)

# Register CFNetAInController in _connect:
_connect.CFNetAInController_swigregister(CFNetAInController)
class CFNetPowerSenseConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spPowerSenseCtrl):
        _connect.CFNetPowerSenseConfigurationController_swiginit(self, _connect.new_CFNetPowerSenseConfigurationController(spPowerSenseCtrl))
    __swig_destroy__ = _connect.delete_CFNetPowerSenseConfigurationController

    def setShuntValue(self, value):
        return _connect.CFNetPowerSenseConfigurationController_setShuntValue(self, value)

    def setAveraging(self, averageSamples):
        return _connect.CFNetPowerSenseConfigurationController_setAveraging(self, averageSamples)

    def enablePowerSense(self, isEnabled):
        return _connect.CFNetPowerSenseConfigurationController_enablePowerSense(self, isEnabled)

# Register CFNetPowerSenseConfigurationController in _connect:
_connect.CFNetPowerSenseConfigurationController_swigregister(CFNetPowerSenseConfigurationController)
class CFNetPowerSenseControlController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spPowerSenseCtrl):
        _connect.CFNetPowerSenseControlController_swiginit(self, _connect.new_CFNetPowerSenseControlController(spPowerSenseCtrl))
    __swig_destroy__ = _connect.delete_CFNetPowerSenseControlController

    def getPower(self):
        return _connect.CFNetPowerSenseControlController_getPower(self)

    def getVoltageCurrentPower(self, parameters):
        return _connect.CFNetPowerSenseControlController_getVoltageCurrentPower(self, parameters)

# Register CFNetPowerSenseControlController in _connect:
_connect.CFNetPowerSenseControlController_swigregister(CFNetPowerSenseControlController)
class CFNetPowerSenseController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, ainIdentifier):
        _connect.CFNetPowerSenseController_swiginit(self, _connect.new_CFNetPowerSenseController(connectionMgr, ainIdentifier))
    __swig_destroy__ = _connect.delete_CFNetPowerSenseController

    def getAInCtrl(self):
        return _connect.CFNetPowerSenseController_getAInCtrl(self)

    def cfg(self):
        return _connect.CFNetPowerSenseController_cfg(self)

    def ctrl(self):
        return _connect.CFNetPowerSenseController_ctrl(self)

# Register CFNetPowerSenseController in _connect:
_connect.CFNetPowerSenseController_swigregister(CFNetPowerSenseController)
class CFNetCANConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spCANCtrl):
        _connect.CFNetCANConfigurationController_swiginit(self, _connect.new_CFNetCANConfigurationController(spCANCtrl))
    __swig_destroy__ = _connect.delete_CFNetCANConfigurationController

    def getNetworkDescriptionFile(self, descriptionFiles):
        return _connect.CFNetCANConfigurationController_getNetworkDescriptionFile(self, descriptionFiles)

    def setNetworkDescriptionFile(self, descriptionFiles):
        return _connect.CFNetCANConfigurationController_setNetworkDescriptionFile(self, descriptionFiles)

    def getMode(self):
        return _connect.CFNetCANConfigurationController_getMode(self)

    def setMode(self, mode):
        return _connect.CFNetCANConfigurationController_setMode(self, mode)

    def enableMsgInjection(self, isEnabled):
        return _connect.CFNetCANConfigurationController_enableMsgInjection(self, isEnabled)

    def setArbitrationPhase(self, baudrate, bitSamplingPointPercent=70):
        return _connect.CFNetCANConfigurationController_setArbitrationPhase(self, baudrate, bitSamplingPointPercent)

    def setFDDataPhase(self, baudrate, bitSamplingPointPercent=70):
        return _connect.CFNetCANConfigurationController_setFDDataPhase(self, baudrate, bitSamplingPointPercent)

# Register CFNetCANConfigurationController in _connect:
_connect.CFNetCANConfigurationController_swigregister(CFNetCANConfigurationController)
class CFNetCANOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spCANCtrl):
        _connect.CFNetCANOperationController_swiginit(self, _connect.new_CFNetCANOperationController(spCANCtrl))
    __swig_destroy__ = _connect.delete_CFNetCANOperationController

    def enableRecordingAllMessages(self, isEnabled):
        return _connect.CFNetCANOperationController_enableRecordingAllMessages(self, isEnabled)

    def enableRecording(self, slotIndex, isEnabled):
        return _connect.CFNetCANOperationController_enableRecording(self, slotIndex, isEnabled)

    def setTrigger(self, slotIndex, triggerIndex):
        return _connect.CFNetCANOperationController_setTrigger(self, slotIndex, triggerIndex)

    def configureComparator(self, slotIndex, canOpConfig):
        return _connect.CFNetCANOperationController_configureComparator(self, slotIndex, canOpConfig)

    def enableTriggerOnError(self, isEnabled):
        return _connect.CFNetCANOperationController_enableTriggerOnError(self, isEnabled)

    def setTriggerOnError(self, triggerIndex):
        return _connect.CFNetCANOperationController_setTriggerOnError(self, triggerIndex)

    def enableInjectedMsgRecord(self, isEnabled):
        return _connect.CFNetCANOperationController_enableInjectedMsgRecord(self, isEnabled)

    def setActionTrigger(self, slotIndex, triggerIndex):
        return _connect.CFNetCANOperationController_setActionTrigger(self, slotIndex, triggerIndex)

    def configureInjectedMsgAction(self, slotIndex, msgConfig):
        return _connect.CFNetCANOperationController_configureInjectedMsgAction(self, slotIndex, msgConfig)

# Register CFNetCANOperationController in _connect:
_connect.CFNetCANOperationController_swigregister(CFNetCANOperationController)
class CFNetCANControlController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spCANCtrl):
        _connect.CFNetCANControlController_swiginit(self, _connect.new_CFNetCANControlController(spCANCtrl))
    __swig_destroy__ = _connect.delete_CFNetCANControlController

    def injectMsg(self, msgConfig):
        return _connect.CFNetCANControlController_injectMsg(self, msgConfig)

# Register CFNetCANControlController in _connect:
_connect.CFNetCANControlController_swigregister(CFNetCANControlController)
class CFNetCANController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetCANController_swiginit(self, _connect.new_CFNetCANController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetCANController

    def convertInjectedMessageTypeToBool(self, message):
        return _connect.CFNetCANController_convertInjectedMessageTypeToBool(self, message)

    def cfg(self):
        return _connect.CFNetCANController_cfg(self)

    def op(self):
        return _connect.CFNetCANController_op(self)

    def ctrl(self):
        return _connect.CFNetCANController_ctrl(self)

# Register CFNetCANController in _connect:
_connect.CFNetCANController_swigregister(CFNetCANController)
class CFNetDIOConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spDIOCtrl):
        _connect.CFNetDIOConfigurationController_swiginit(self, _connect.new_CFNetDIOConfigurationController(spDIOCtrl))
    __swig_destroy__ = _connect.delete_CFNetDIOConfigurationController

    def setInputBankConfiguration(self, bankIndex, voltage):
        return _connect.CFNetDIOConfigurationController_setInputBankConfiguration(self, bankIndex, voltage)

    def setOutputBankConfiguration(self, bankIndex, voltage, initialState):
        return _connect.CFNetDIOConfigurationController_setOutputBankConfiguration(self, bankIndex, voltage, initialState)

    def showBank(self, bankIndex, isShow):
        return _connect.CFNetDIOConfigurationController_showBank(self, bankIndex, isShow)

    def showChannel(self, bankIndex, channelIndex, isShow):
        return _connect.CFNetDIOConfigurationController_showChannel(self, bankIndex, channelIndex, isShow)

    def setChannelName(self, bankIndex, channelIndex, name):
        return _connect.CFNetDIOConfigurationController_setChannelName(self, bankIndex, channelIndex, name)

    def getChannelName(self, bankIndex, channelIndex):
        return _connect.CFNetDIOConfigurationController_getChannelName(self, bankIndex, channelIndex)

    def getBankAndChannelIndex(self, channelName, bankChannelIndex):
        return _connect.CFNetDIOConfigurationController_getBankAndChannelIndex(self, channelName, bankChannelIndex)

# Register CFNetDIOConfigurationController in _connect:
_connect.CFNetDIOConfigurationController_swigregister(CFNetDIOConfigurationController)
class CFNetDIOOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spDIOCtrl):
        _connect.CFNetDIOOperationController_swiginit(self, _connect.new_CFNetDIOOperationController(spDIOCtrl))
    __swig_destroy__ = _connect.delete_CFNetDIOOperationController

    def setRecordMode(self, mode):
        return _connect.CFNetDIOOperationController_setRecordMode(self, mode)

    def setTrigger(self, comparatorIndex, triggerIndex):
        return _connect.CFNetDIOOperationController_setTrigger(self, comparatorIndex, triggerIndex)

    def setTriggerSignalState(self, comparatorIndex, bankIndex, channelIndex, state):
        return _connect.CFNetDIOOperationController_setTriggerSignalState(self, comparatorIndex, bankIndex, channelIndex, state)

    def setActionTrigger(self, slotIndex, actionTriggerIndex):
        return _connect.CFNetDIOOperationController_setActionTrigger(self, slotIndex, actionTriggerIndex)

    def setAction(self, slotIndex, state, bankIndex, channelIndex):
        return _connect.CFNetDIOOperationController_setAction(self, slotIndex, state, bankIndex, channelIndex)

    def setPatternChannels(self, slotIndex, channels):
        return _connect.CFNetDIOOperationController_setPatternChannels(self, slotIndex, channels)

    def setPattern(self, slotIndex, patternType, pattern):
        return _connect.CFNetDIOOperationController_setPattern(self, slotIndex, patternType, pattern)

    def setPatternTriggers(self, slotIndex, startActive, startOnTriggerIndex, stopOnTriggerIndex, bStopImmediately):
        return _connect.CFNetDIOOperationController_setPatternTriggers(self, slotIndex, startActive, startOnTriggerIndex, stopOnTriggerIndex, bStopImmediately)

# Register CFNetDIOOperationController in _connect:
_connect.CFNetDIOOperationController_swigregister(CFNetDIOOperationController)
class CFNetDIOControlController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spDIOCtrl):
        _connect.CFNetDIOControlController_swiginit(self, _connect.new_CFNetDIOControlController(spDIOCtrl))
    __swig_destroy__ = _connect.delete_CFNetDIOControlController

    def setChannelState(self, bankIndex, channelIndex, state):
        return _connect.CFNetDIOControlController_setChannelState(self, bankIndex, channelIndex, state)

    def toggleChannelState(self, bankIndex, channelIndex):
        return _connect.CFNetDIOControlController_toggleChannelState(self, bankIndex, channelIndex)

    def setBankChannelsState(self, bankIndex, channelsStates):
        return _connect.CFNetDIOControlController_setBankChannelsState(self, bankIndex, channelsStates)

    def getChannelState(self, bankIndex, channelIndex):
        return _connect.CFNetDIOControlController_getChannelState(self, bankIndex, channelIndex)

    def getBankChannelsState(self, bankIndex):
        return _connect.CFNetDIOControlController_getBankChannelsState(self, bankIndex)

# Register CFNetDIOControlController in _connect:
_connect.CFNetDIOControlController_swigregister(CFNetDIOControlController)
class CFNetDIOController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetDIOController_swiginit(self, _connect.new_CFNetDIOController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetDIOController

    def cfg(self):
        return _connect.CFNetDIOController_cfg(self)

    def op(self):
        return _connect.CFNetDIOController_op(self)

    def ctrl(self):
        return _connect.CFNetDIOController_ctrl(self)

    def getBankBaseString(self, bankIndex):
        return _connect.CFNetDIOController_getBankBaseString(self, bankIndex)

    def getMappedChannelIndex(self, bankIndex, channelIndex):
        return _connect.CFNetDIOController_getMappedChannelIndex(self, bankIndex, channelIndex)

    def getMaxNumberOfBanks(self):
        return _connect.CFNetDIOController_getMaxNumberOfBanks(self)

    def getMaxNumberOfChannels(self):
        return _connect.CFNetDIOController_getMaxNumberOfChannels(self)

# Register CFNetDIOController in _connect:
_connect.CFNetDIOController_swigregister(CFNetDIOController)
class CLINOperationConfig(object):
    r"""LIN configuration class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _connect.CLINOperationConfig_swiginit(self, _connect.new_CLINOperationConfig())
    __swig_destroy__ = _connect.delete_CLINOperationConfig
    triggerIndex = property(_connect.CLINOperationConfig_triggerIndex_get, _connect.CLINOperationConfig_triggerIndex_set, doc=r"""trigger index in range from 0 to 10.""")
    idValueHex = property(_connect.CLINOperationConfig_idValueHex_get, _connect.CLINOperationConfig_idValueHex_set, doc=r"""string of a hex value, without '0x'""")
    maskHex = property(_connect.CLINOperationConfig_maskHex_get, _connect.CLINOperationConfig_maskHex_set, doc=r"""string of a hex value, without '0x'""")

# Register CLINOperationConfig in _connect:
_connect.CLINOperationConfig_swigregister(CLINOperationConfig)
class CFNetLINConfigurationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spLINCtrl):
        _connect.CFNetLINConfigurationController_swiginit(self, _connect.new_CFNetLINConfigurationController(spLINCtrl))
    __swig_destroy__ = _connect.delete_CFNetLINConfigurationController

    def getNetworkDescriptionFile(self, descriptionFiles):
        return _connect.CFNetLINConfigurationController_getNetworkDescriptionFile(self, descriptionFiles)

    def setNetworkDescriptionFile(self, descriptionFiles):
        return _connect.CFNetLINConfigurationController_setNetworkDescriptionFile(self, descriptionFiles)

    def setBaudrate(self, baudrate):
        return _connect.CFNetLINConfigurationController_setBaudrate(self, baudrate)

# Register CFNetLINConfigurationController in _connect:
_connect.CFNetLINConfigurationController_swigregister(CFNetLINConfigurationController)
class CFNetLINOperationController(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spLINCtrl):
        _connect.CFNetLINOperationController_swiginit(self, _connect.new_CFNetLINOperationController(spLINCtrl))
    __swig_destroy__ = _connect.delete_CFNetLINOperationController

    def enableRecordingAllMessages(self, isEnabled):
        return _connect.CFNetLINOperationController_enableRecordingAllMessages(self, isEnabled)

    def enableRecording(self, slotIndex, isEnabled):
        return _connect.CFNetLINOperationController_enableRecording(self, slotIndex, isEnabled)

    def configureComparator(self, slotIndex, linOpConfig):
        return _connect.CFNetLINOperationController_configureComparator(self, slotIndex, linOpConfig)

    def enableTriggerOnWakeUp(self, isEnabled):
        return _connect.CFNetLINOperationController_enableTriggerOnWakeUp(self, isEnabled)

    def setTriggerOnWakeUp(self, triggerIndex):
        return _connect.CFNetLINOperationController_setTriggerOnWakeUp(self, triggerIndex)

# Register CFNetLINOperationController in _connect:
_connect.CFNetLINOperationController_swigregister(CFNetLINOperationController)
class CFNetLINController(CFNetBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, identifier):
        _connect.CFNetLINController_swiginit(self, _connect.new_CFNetLINController(connectionMgr, identifier))
    __swig_destroy__ = _connect.delete_CFNetLINController

    def cfg(self):
        return _connect.CFNetLINController_cfg(self)

    def op(self):
        return _connect.CFNetLINController_op(self)

# Register CFNetLINController in _connect:
_connect.CFNetLINController_swigregister(CFNetLINController)
class CFNetIPCtrl(object):
    r"""
    Base class for FNet IP-controllers.



    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetIPCtrl_swiginit(self, _connect.new_CFNetIPCtrl(spConnectionMgr, rURLs))

    def op_qualifier_enable(self, nFTrigEnable):
        r"""
        Enables the trigger

        :type nFTrigEnable: uint8_t
        :param nFTrigEnable:   set 0 for none, 1-10 inclusive for the specific trigger
        """
        return _connect.CFNetIPCtrl_op_qualifier_enable(self, nFTrigEnable)

    def op_qualifier_disable(self, nFTrigDisable):
        r"""
        Disables the trigger

        :type nFTrigDisable: uint8_t
        :param nFTrigDisable:  set 0 for none, 1-10 inclusive for the specific trigger
        """
        return _connect.CFNetIPCtrl_op_qualifier_disable(self, nFTrigDisable)

    def op_qualifier_enable_on_start(self, bEnableFromStart):
        r"""
        Enables the trigger from start

        :type bEnableFromStart: boolean
        :param bEnableFromStart: enable recording when it occurs
        """
        return _connect.CFNetIPCtrl_op_qualifier_enable_on_start(self, bEnableFromStart)

    def op_set_qualifier(self, bEnableFromStart, nFTrigEnable, nFTrigDisable):
        r"""
        :type bEnableFromStart: boolean
        :param bEnableFromStart: recording is enabled at session start
        :type nFTrigEnable: uint8_t
        :param nFTrigEnable:     set 0 for none, 1-10 inclusive for the specific trigger
        :type nFTrigDisable: uint8_t
        :param nFTrigDisable:    set 0 for none, 1-10 inclusive for the specific trigger
        """
        return _connect.CFNetIPCtrl_op_set_qualifier(self, bEnableFromStart, nFTrigEnable, nFTrigDisable)
    __swig_destroy__ = _connect.delete_CFNetIPCtrl

# Register CFNetIPCtrl in _connect:
_connect.CFNetIPCtrl_swigregister(CFNetIPCtrl)
class COptionFNetCfg(COptionController):
    r"""FNet option controller"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetCfg_swiginit(self, _connect.new_COptionFNetCfg(connectionMgr, rstrBaseURL))
    __swig_destroy__ = _connect.delete_COptionFNetCfg

# Register COptionFNetCfg in _connect:
_connect.COptionFNetCfg_swigregister(COptionFNetCfg)
class COptionFNetOp(COptionController):
    r"""FNet Options"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetOp_swiginit(self, _connect.new_COptionFNetOp(connectionMgr, rstrBaseURL))
    __swig_destroy__ = _connect.delete_COptionFNetOp

# Register COptionFNetOp in _connect:
_connect.COptionFNetOp_swigregister(COptionFNetOp)
class COptionFNetDIOCfg(COptionFNetCfg):
    r"""FNet DIO configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetDIOCfg_swiginit(self, _connect.new_COptionFNetDIOCfg(connectionMgr, rstrBaseURL))

    def set_bank(self, nBank, bOutput, dThreshold):
        r"""
        configures a DIO bank
        :type nBank: uint8_t
        :param nBank:        bank to configure
        :type bOutput: boolean
        :param bOutput:      true to set bank as output, false as input
        :type dThreshold: float
        :param dThreshold:   threshold voltage level
        """
        return _connect.COptionFNetDIOCfg_set_bank(self, nBank, bOutput, dThreshold)

    def set_channel(self, nChannel, strName, bShow, bInitialHi):
        r"""
        :type nChannel: uint8_t
        :param nChannel:     channel to configure
        :type strName: string
        :param strName:      name for the channel
        :type bShow: boolean
        :param bShow:        show it in HIL and Analyzer
        :type bInitialHi: boolean
        :param bInitialHi:   true to set initial state to High, false to Low. Applicable only for Output channels
        """
        return _connect.COptionFNetDIOCfg_set_channel(self, nChannel, strName, bShow, bInitialHi)

    def get_channel_name(self, nChannel):
        r"""
        returns name of channel

        :type nChannel: uint8_t
        :param nChannel:     channel index
        :rtype: string
        :return: string name of channel
        """
        return _connect.COptionFNetDIOCfg_get_channel_name(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetDIOCfg

# Register COptionFNetDIOCfg in _connect:
_connect.COptionFNetDIOCfg_swigregister(COptionFNetDIOCfg)
class COptionFNetDIOComparatorOp(COptionController):
    r"""FNet DIO comparator operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetDIOComparatorOp_swiginit(self, _connect.new_COptionFNetDIOComparatorOp(connectionMgr, rstrBaseURL))

    def set_FTrig(self, nFTrig):
        r"""
        Set trigger.
        :type nFTrig: uint8_t
        :param nFTrig:  FTrigger index to act upon, 0 to disable
        """
        return _connect.COptionFNetDIOComparatorOp_set_FTrig(self, nFTrig)

    def set_channel_state(self, nChannel, bHi):
        r"""
        Set signal value to activate trigger.
        :type nChannel: uint8_t
        :param nChannel: channel index
        :type bHi: boolean
        :param bHi:      true to trigger on High state, false to Low
        """
        return _connect.COptionFNetDIOComparatorOp_set_channel_state(self, nChannel, bHi)

    def set_channel_ignore(self, nChannel):
        r"""
        Specified channel is ignored in trigger generation
        :type nChannel: uint8_t
        :param nChannel: channel index
        """
        return _connect.COptionFNetDIOComparatorOp_set_channel_ignore(self, nChannel)

    def set_channel_ignore_all(self):
        r"""Sets all channels to ignored state"""
        return _connect.COptionFNetDIOComparatorOp_set_channel_ignore_all(self)
    __swig_destroy__ = _connect.delete_COptionFNetDIOComparatorOp

# Register COptionFNetDIOComparatorOp in _connect:
_connect.COptionFNetDIOComparatorOp_swigregister(COptionFNetDIOComparatorOp)
EOperation_SINGLE_SHOT = _connect.EOperation_SINGLE_SHOT
r"""single shot"""
EOperation_CONTINUOUS = _connect.EOperation_CONTINUOUS
r"""continuous"""
class COptionFNetDIOPatternOp(COptionController):
    r"""FNet DIO pattern operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetDIOPatternOp_swiginit(self, _connect.new_COptionFNetDIOPatternOp(connectionMgr, rstrBaseURL))

    def set_channels(self, rvChannels):
        r"""
        Sets channels which are participate in this pattern. Only OUT channels can be set.
        :type rvChannels: :py:class:`IntVector`
        :param rvChannels:
        """
        return _connect.COptionFNetDIOPatternOp_set_channels(self, rvChannels)

    def set_operation(self, eOperation):
        r"""
        Set operation mode
        :type eOperation: int
        :param eOperation:
        """
        return _connect.COptionFNetDIOPatternOp_set_operation(self, eOperation)

    def set_pattern(self, rstrPattern):
        r"""
        Set DIO pattern, a sequence of frames, separated by ';'.Each frame consists
        of state(binary)and duration(default us), separated by ','.
        binary state - length must fit number of specified pattern channels. For example,
        if 3 channels are specified, binary state must be 3 digits long: "01x"
        duration - duration of this binary state. By default in "us", but "ns", "us", "ms"
        and "s" units are also supported. Example pattern string:"001,140; xx0,10; 1xx,50ms; 001,100us"
        :type rstrPattern: string
        :param rstrPattern: pattern string
        """
        return _connect.COptionFNetDIOPatternOp_set_pattern(self, rstrPattern)

    def set_start(self, nFTrig, bStartActive):
        r"""
        Specifies FTrigger event to start on and initial state
        :type nFTrig: uint8_t
        :param nFTrig:        FTrigger index to act upon, 0 to disable
        :type bStartActive: boolean
        :param bStartActive:
        """
        return _connect.COptionFNetDIOPatternOp_set_start(self, nFTrig, bStartActive)

    def set_stop(self, nFTrig, bStopImmediately):
        r"""
        Specifies FTrigger event to stop on and whether to terminate the current run immediately
        :type nFTrig: uint8_t
        :param nFTrig:            FTrigger index to act upon, 0 to disable
        :type bStopImmediately: boolean
        :param bStopImmediately:
        """
        return _connect.COptionFNetDIOPatternOp_set_stop(self, nFTrig, bStopImmediately)
    __swig_destroy__ = _connect.delete_COptionFNetDIOPatternOp

# Register COptionFNetDIOPatternOp in _connect:
_connect.COptionFNetDIOPatternOp_swigregister(COptionFNetDIOPatternOp)
ERecord_NONE = _connect.ERecord_NONE
r"""none record mode"""
ERecord_INPUTS = _connect.ERecord_INPUTS
r"""inputs record mode"""
ERecord_ALL = _connect.ERecord_ALL
r"""all record mode"""
class COptionFNetDIOOp(COptionFNetOp):
    r"""FNet DIO operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetDIOOp_swiginit(self, _connect.new_COptionFNetDIOOp(connectionMgr, rstrBaseURL))

    def opt_comparator(self, nIndex):
        r"""
        :type nIndex: uint8_t
        :param nIndex: DIO trigger index
        :rtype: :py:class:`COptionFNetDIOComparatorOp`
        :return: CFNetDIOOption_op_trigger option controller through which the trigger components are accessed
        """
        return _connect.COptionFNetDIOOp_opt_comparator(self, nIndex)

    def opt_pattern(self, nIndex):
        r"""
        :type nIndex: uint8_t
        :param nIndex: DIO pattern index
        :rtype: :py:class:`COptionFNetDIOPatternOp`
        :return: CFNetDIOOption_op_pattern option controller through which the pattern components are accessed
        """
        return _connect.COptionFNetDIOOp_opt_pattern(self, nIndex)

    def set_record(self, eRecord):
        r"""
        Set record mode.
        :type eRecord: int
        :param eRecord: recording mode
        """
        return _connect.COptionFNetDIOOp_set_record(self, eRecord)

    def set_action(self, nAction, nFTrig, nChannel, bHi):
        r"""
        configures action comparator

        :type nAction: uint8_t
        :param nAction:  index of action comparator
        :type nFTrig: uint8_t
        :param nFTrig:   FTrigger to act upon, 0 to disable
        :type nChannel: uint8_t
        :param nChannel: channel to assert upon nFTrig
        :type bHi: boolean
        :param bHi:      true to set the channel High, false to Low
        """
        return _connect.COptionFNetDIOOp_set_action(self, nAction, nFTrig, nChannel, bHi)
    __swig_destroy__ = _connect.delete_COptionFNetDIOOp

# Register COptionFNetDIOOp in _connect:
_connect.COptionFNetDIOOp_swigregister(COptionFNetDIOOp)
class SFNetDIOInfo(object):
    r"""Some basic DIO info"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_nNumBanks = property(_connect.SFNetDIOInfo_m_nNumBanks_get, _connect.SFNetDIOInfo_m_nNumBanks_set, doc=r"""number of banks""")
    m_nNumChannels = property(_connect.SFNetDIOInfo_m_nNumChannels_get, _connect.SFNetDIOInfo_m_nNumChannels_set, doc=r"""number of channels in each bank""")

    def __init__(self):
        _connect.SFNetDIOInfo_swiginit(self, _connect.new_SFNetDIOInfo())
    __swig_destroy__ = _connect.delete_SFNetDIOInfo

# Register SFNetDIOInfo in _connect:
_connect.SFNetDIOInfo_swigregister(SFNetDIOInfo)
class CFNetDIOCtrl(CFNetIPCtrl):
    r"""
    FNet Digital Input/Output controller.



    Python example: _sample_link{fnet,fnet_dio}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetDIOCtrl_swiginit(self, _connect.new_CFNetDIOCtrl(spConnectionMgr, rURLs))

    def info(self):
        r"""
        Returns information about the DIO IP
        :rtype: :py:class:`SFNetDIOInfo`
        :return: SFNetDIOInfo {m_nNumBanks, m_nNumChannels}
        """
        return _connect.CFNetDIOCtrl_info(self)

    def cfg(self):
        r"""
        Returns DIO Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetDIOCfg`
        :return: COptionFNetDIOCfg
        """
        return _connect.CFNetDIOCtrl_cfg(self)

    def op(self):
        r"""
        Returns DIO Option controller used for setting operation
        :rtype: :py:class:`COptionFNetDIOOp`
        :return: COptionFNetDIOOp
        """
        return _connect.CFNetDIOCtrl_op(self)

    def ctrl_set_channel(self, *args):
        r"""
        *Overload 1:*

        Set pin state of chosen channel
        :type nChannel: uint8_t
        :param nChannel:
        :type bHi: boolean
        :param bHi:      true to set the channel High, false to Low
            You can only set pin state if channel's bank is configured as output, otherwise
            this function call has no effect.

        |

        *Overload 2:*

        Set pin state of chosen channel
        :type rstrChannelName: string
        :param rstrChannelName:
        :type bHi: boolean
        :param bHi:      true to set the channel High, false to Low
            You can only set pin state if channel's bank is configured as output, otherwise
            this function call has no effect.
        """
        return _connect.CFNetDIOCtrl_ctrl_set_channel(self, *args)

    def ctrl_get_channel(self, *args):
        r"""
        *Overload 1:*

        Get pin state of chosen channel
        :type nChannel: uint8_t
        :param nChannel:
        :rtype: boolean
        :return: bool channel state, true if High, false if Low

        |

        *Overload 2:*

        Get pin state of chosen channel
        :type rstrChannelName: string
        :param rstrChannelName:
        :rtype: boolean
        :return: bool channel state, true if High, false if Low
        """
        return _connect.CFNetDIOCtrl_ctrl_get_channel(self, *args)

    def ctrl_start_pattern(self, nPatternIndex):
        r"""
        Starts the specified pattern
        :type nPatternIndex: uint8_t
        :param nPatternIndex:
        """
        return _connect.CFNetDIOCtrl_ctrl_start_pattern(self, nPatternIndex)

    def ctrl_stop_pattern(self, nPatternIndex):
        r"""
        Stops the specified pattern
        :type nPatternIndex: uint8_t
        :param nPatternIndex:
        """
        return _connect.CFNetDIOCtrl_ctrl_stop_pattern(self, nPatternIndex)
    __swig_destroy__ = _connect.delete_CFNetDIOCtrl

# Register CFNetDIOCtrl in _connect:
_connect.CFNetDIOCtrl_swigregister(CFNetDIOCtrl)
class COptionFNetmDIOCfg(COptionFNetCfg):
    r"""FNet mDIO configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetmDIOCfg_swiginit(self, _connect.new_COptionFNetmDIOCfg(spConnectionMgr, rstrBaseURL))

    def set_voltage(self, dVoltage):
        r"""
        :type dVoltage: float
        :param dVoltage:    voltage value to set to
        """
        return _connect.COptionFNetmDIOCfg_set_voltage(self, dVoltage)

    def set_channel_out(self, nChannel, strName, bShow, bInitialHi):
        r"""
        :type nChannel: uint8_t
        :param nChannel:     channel to configure
        :type strName: string
        :param strName:      name for the channel
        :type bShow: boolean
        :param bShow:        show it in HIL and Analyzer
        :type bInitialHi: boolean
        :param bInitialHi:   true to set initial state to High, false to Low. Applicable only for Output channels
        """
        return _connect.COptionFNetmDIOCfg_set_channel_out(self, nChannel, strName, bShow, bInitialHi)

    def set_channel_in(self, nChannel, strName, bShow):
        r"""
        :type nChannel: uint8_t
        :param nChannel:     channel to configure
        :type strName: string
        :param strName:      name for the channel
        :type bShow: boolean
        :param bShow:        show it in HIL and Analyzer
        """
        return _connect.COptionFNetmDIOCfg_set_channel_in(self, nChannel, strName, bShow)

    def get_channel_name(self, nChannel):
        r"""
        :type nChannel: uint8_t
        :param nChannel:   channel index
        :rtype: string
        :return: string     name of the channel
        """
        return _connect.COptionFNetmDIOCfg_get_channel_name(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetmDIOCfg

# Register COptionFNetmDIOCfg in _connect:
_connect.COptionFNetmDIOCfg_swigregister(COptionFNetmDIOCfg)
class COptionFNetmDIOComparatorOp(COptionController):
    r"""F mDIO comparator operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetmDIOComparatorOp_swiginit(self, _connect.new_COptionFNetmDIOComparatorOp(connectionMgr, rstrBaseURL))

    def set_FTrig(self, nFTrig):
        r"""
        Set trigger.
        :type nFTrig: uint8_t
        :param nFTrig: FTrigger index to act upon, 0 to disable
        """
        return _connect.COptionFNetmDIOComparatorOp_set_FTrig(self, nFTrig)

    def set_channel_state(self, nChannel, bHi):
        r"""
        Set signal value to activate trigger.
        :type nChannel: uint8_t
        :param nChannel: channel index
        :type bHi: boolean
        :param bHi:      true to trigger on High state, false to Low
        """
        return _connect.COptionFNetmDIOComparatorOp_set_channel_state(self, nChannel, bHi)

    def set_channel_ignore(self, nChannel):
        r"""
        Specified channel is ignored in trigger generation
        :type nChannel: uint8_t
        :param nChannel: channel index
        """
        return _connect.COptionFNetmDIOComparatorOp_set_channel_ignore(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetmDIOComparatorOp

# Register COptionFNetmDIOComparatorOp in _connect:
_connect.COptionFNetmDIOComparatorOp_swigregister(COptionFNetmDIOComparatorOp)
class COptionFNetmDIOPatternOp(COptionController):
    r"""FNet mDIO pattern operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetmDIOPatternOp_swiginit(self, _connect.new_COptionFNetmDIOPatternOp(connectionMgr, rstrBaseURL))

    def set_channels(self, rvChannels):
        r"""
        Sets channels which are participate in this pattern. Only OUT channels can be set.
        :type rvChannels: :py:class:`IntVector`
        :param rvChannels:
        """
        return _connect.COptionFNetmDIOPatternOp_set_channels(self, rvChannels)

    def set_operation(self, eOperation):
        r"""
        Set operation mode
        :type eOperation: int
        :param eOperation:
        """
        return _connect.COptionFNetmDIOPatternOp_set_operation(self, eOperation)

    def set_pattern(self, rstrPattern):
        r"""
        Set mDIO pattern, a sequence of frames, separated by ';'.Each frame consists
        of state(binary)and duration(default us), separated by ','.
        binary state - length must fit number of specified pattern channels. For example,
        if 3 channels are specified, binary state must be 3 digits long: "01x"
        duration - duration of this binary state. By default in "us", but "ns", "us", "ms"
        and "s" units are also supported. Example pattern string:"001,140; xx0,10; 1xx,50ms; 001,100us"
        :type rstrPattern: string
        :param rstrPattern: pattern string
        """
        return _connect.COptionFNetmDIOPatternOp_set_pattern(self, rstrPattern)

    def set_start(self, nFTrig, bStartActive):
        r"""
        Specifies FTrigger event to start on and initial state
        :type nFTrig: uint8_t
        :param nFTrig:       FTrigger index to act upon, 0 to disable
        :type bStartActive: boolean
        :param bStartActive:
        """
        return _connect.COptionFNetmDIOPatternOp_set_start(self, nFTrig, bStartActive)

    def set_stop(self, nFTrig, bStopImmediately):
        r"""
        Specifies FTrigger event to stop on and whether to terminate the current run immediately
        :type nFTrig: uint8_t
        :param nFTrig:            FTrigger index to act upon, 0 to disable
        :type bStopImmediately: boolean
        :param bStopImmediately:
        """
        return _connect.COptionFNetmDIOPatternOp_set_stop(self, nFTrig, bStopImmediately)

    def set_continuous(self, bContinuous):
        r"""
        Set continuous mode on/off
        :type bContinuous: boolean
        :param bContinuous:
        """
        return _connect.COptionFNetmDIOPatternOp_set_continuous(self, bContinuous)

    def set_action(self, nFTrigStart, bStartActive, nFTrigStop, bStopImmediately):
        r"""
        Specifies FTrigger event to start on, initial state, FTrigger event to stop on and whether to stop immediately
        :type nFTrigStart: uint8_t
        :param nFTrigStart:       FTrigger index to act upon, 0 to disable
        :type bStartActive: boolean
        :param bStartActive:
        :type nFTrigStop: uint8_t
        :param nFTrigStop:       FTrigger index to act upon, 0 to disable
        :type bStopImmediately: boolean
        :param bStopImmediately:
        """
        return _connect.COptionFNetmDIOPatternOp_set_action(self, nFTrigStart, bStartActive, nFTrigStop, bStopImmediately)
    __swig_destroy__ = _connect.delete_COptionFNetmDIOPatternOp

# Register COptionFNetmDIOPatternOp in _connect:
_connect.COptionFNetmDIOPatternOp_swigregister(COptionFNetmDIOPatternOp)
class COptionFNetmDIOOp(COptionFNetOp):
    r"""CFNet mDIO operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetmDIOOp_swiginit(self, _connect.new_COptionFNetmDIOOp(spConnectionMgr, rstrBaseURL))

    def opt_comparator(self, nIndex):
        r"""
        :type nIndex: uint8_t
        :param nIndex: mDIO trigger index
        :rtype: :py:class:`COptionFNetmDIOComparatorOp`
        :return: CFNetDIOOption_op_trigger option controller through which the trigger components are accessed
        """
        return _connect.COptionFNetmDIOOp_opt_comparator(self, nIndex)

    def opt_pattern(self, nIndex):
        r"""
        :type nIndex: uint8_t
        :param nIndex: mDIO pattern index
        :rtype: :py:class:`COptionFNetmDIOPatternOp`
        :return: CFNetmDIOOption_op_pattern option controller through which the pattern components are accessed
        """
        return _connect.COptionFNetmDIOOp_opt_pattern(self, nIndex)

    def set_record(self, eRecord):
        r"""
        Set record mode.
        :type eRecord: int
        :param eRecord: recording mode
        """
        return _connect.COptionFNetmDIOOp_set_record(self, eRecord)

    def set_action(self, nAction, nFTrig, nChannel, bHi):
        r"""
        configures action comparator

        :type nAction: uint8_t
        :param nAction:  index of action comparator
        :type nFTrig: uint8_t
        :param nFTrig:   FTrigger index to act upon, 0 to disable
        :type nChannel: uint8_t
        :param nChannel: channel to assert upon nFTrig
        :type bHi: boolean
        :param bHi:      true to set the channel High, false to Low
        """
        return _connect.COptionFNetmDIOOp_set_action(self, nAction, nFTrig, nChannel, bHi)
    __swig_destroy__ = _connect.delete_COptionFNetmDIOOp

# Register COptionFNetmDIOOp in _connect:
_connect.COptionFNetmDIOOp_swigregister(COptionFNetmDIOOp)
class CFNetmDIOCtrl(CFNetIPCtrl):
    r"""
    FNet mini Digital Input/Output controller (mDIO_AP).



    Python example: _sample_link{fnet,fnet_mdio}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetmDIOCtrl_swiginit(self, _connect.new_CFNetmDIOCtrl(spConnectionMgr, rURLs))

    def cfg(self):
        r"""
        Returns mDIO Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetmDIOCfg`
        :return: COptionFNetmDIOCfg
        """
        return _connect.CFNetmDIOCtrl_cfg(self)

    def op(self):
        r"""
        Returns mDIO Option controller used for setting operation
        :rtype: :py:class:`COptionFNetmDIOOp`
        :return: COptionFNetmDIOOp
        """
        return _connect.CFNetmDIOCtrl_op(self)

    def ctrl_set_channel(self, *args):
        r"""
        *Overload 1:*

        Set pin state of chosen channel
        :type nChannel: uint8_t
        :param nChannel:
        :type bHi: boolean
        :param bHi:      true to set the channel High, false to Low
            You can only set pin state if channel's bank is configured as output, otherwise
            this function call has no effect.

        |

        *Overload 2:*

        Set pin state of chosen channel
        :type rstrChannelName: string
        :param rstrChannelName:
        :type bHi: boolean
        :param bHi:      true to set the channel High, false to Low
            You can only set pin state if channel's bank is configured as output, otherwise
            this function call has no effect.
        """
        return _connect.CFNetmDIOCtrl_ctrl_set_channel(self, *args)

    def ctrl_get_channel(self, *args):
        r"""
        *Overload 1:*

        Get pin state of chosen channel
        :type nChannel: uint8_t
        :param nChannel:
        :rtype: boolean
        :return: bool channel state, true if High, false if Low

        |

        *Overload 2:*

        Get pin state of chosen channel
        :type rstrChannelName: string
        :param rstrChannelName:
        :rtype: boolean
        :return: bool channel state, true if High, false if Low
        """
        return _connect.CFNetmDIOCtrl_ctrl_get_channel(self, *args)

    def ctrl_start_pattern(self, nPatternIndex):
        r"""
        Starts the specified pattern
        :type nPatternIndex: uint8_t
        :param nPatternIndex:
        """
        return _connect.CFNetmDIOCtrl_ctrl_start_pattern(self, nPatternIndex)

    def ctrl_stop_pattern(self, nPatternIndex):
        r"""
        Stops the specified pattern
        :type nPatternIndex: uint8_t
        :param nPatternIndex:
        """
        return _connect.CFNetmDIOCtrl_ctrl_stop_pattern(self, nPatternIndex)
    __swig_destroy__ = _connect.delete_CFNetmDIOCtrl

# Register CFNetmDIOCtrl in _connect:
_connect.CFNetmDIOCtrl_swigregister(CFNetmDIOCtrl)
class COptionFNetAINCfg(COptionFNetCfg):
    r"""FNet AIN configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetAINCfg_swiginit(self, _connect.new_COptionFNetAINCfg(connectionMgr, rstrBaseURL))

    def set_averager(self, nNumSample):
        r"""
        Configure a number of average samples. If different than any of the values in SFNetAINInfo::m_vnAverageSamples
        then it will be set to the next bigger value.

        :type nNumSample: uint8_t
        :param nNumSample:  value to set number of samples to. Value 0 will disable the averager
        """
        return _connect.COptionFNetAINCfg_set_averager(self, nNumSample)

    def power_measurement_disable(self):
        r"""Disable power measurement option"""
        return _connect.COptionFNetAINCfg_power_measurement_disable(self)

    def power_measurement_enable(self, dShunt):
        r"""
        Enable power measurement option and set resistance value (Ohm)

        :type dShunt: float
        :param dShunt:     sets resistance value
        """
        return _connect.COptionFNetAINCfg_power_measurement_enable(self, dShunt)

    def set_channel(self, nChannel, strName, bShow, dMultiply):
        r"""
        Configure a channel in one call

        :type nChannel: uint8_t
        :param nChannel:   channel to configure
        :type strName: string
        :param strName:    name for the channel
        :type bShow: boolean
        :param bShow:      show it int the HIL monitor and Analyzer
        :type dMultiply: float
        :param dMultiply:  multiply measured value with this factor
        """
        return _connect.COptionFNetAINCfg_set_channel(self, nChannel, strName, bShow, dMultiply)

    def get_channel_name(self, nChannel):
        r"""
        Get channel name

        :type nChannel: uint8_t
        :param nChannel:  channel index
        :rtype: string
        :return: string   channel name
        """
        return _connect.COptionFNetAINCfg_get_channel_name(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetAINCfg

# Register COptionFNetAINCfg in _connect:
_connect.COptionFNetAINCfg_swigregister(COptionFNetAINCfg)
class COptionFNetAINChannelOp(COptionController):
    r"""FNet AIN channel operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetAINChannelOp_swiginit(self, _connect.new_COptionFNetAINChannelOp(connectionMgr, rstrBaseURL))

    def set_record(self, bRecord):
        r"""
        :type bRecord: boolean
        :param bRecord: true to record this channel
        """
        return _connect.COptionFNetAINChannelOp_set_record(self, bRecord)

    def set_comparator(self, nComparator, nFTrig, bHigherThan, dVoltage):
        r"""
        configures channel's comparator

        :type nComparator: uint8_t
        :param nComparator:  comparator index
        :type nFTrig: uint8_t
        :param nFTrig:       FTrigger to generate on compare match, 0 disables compare
        :type bHigherThan: boolean
        :param bHigherThan:  true to compare when measured voltage is higher than dVoltage, false for lower
        :type dVoltage: float
        :param dVoltage:     voltage to compare against
        """
        return _connect.COptionFNetAINChannelOp_set_comparator(self, nComparator, nFTrig, bHigherThan, dVoltage)

    def get_channel_level(self, nComparator):
        r"""
        Gets comparator's voltage level

        :type nComparator: uint8_t
        :param nComparator:  channel index to return voltage level from
        :rtype: float
        :return: double       voltage level for specific comparator
        """
        return _connect.COptionFNetAINChannelOp_get_channel_level(self, nComparator)
    __swig_destroy__ = _connect.delete_COptionFNetAINChannelOp

# Register COptionFNetAINChannelOp in _connect:
_connect.COptionFNetAINChannelOp_swigregister(COptionFNetAINChannelOp)
class COptionFNetAINOp(COptionFNetOp):
    r"""FNet AIN operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetAINOp_swiginit(self, _connect.new_COptionFNetAINOp(connectionMgr, rstrBaseURL))

    def set_sampling_interval(self, dSeconds):
        r"""
        :type dSeconds: float
        :param dSeconds: time interval to sample the AIN channel
        """
        return _connect.COptionFNetAINOp_set_sampling_interval(self, dSeconds)

    def opt_channel(self, nChannel):
        r"""
        :type nChannel: uint8_t
        :param nChannel: channel index
        :rtype: :py:class:`COptionFNetAINChannelOp`
        :return: COptionFNetAINChannelOp option controller through which the channel components are accessed
        """
        return _connect.COptionFNetAINOp_opt_channel(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetAINOp

# Register COptionFNetAINOp in _connect:
_connect.COptionFNetAINOp_swigregister(COptionFNetAINOp)
class SFNetAINInfo(object):
    r"""Some basic info about AIN"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_nNumChannels = property(_connect.SFNetAINInfo_m_nNumChannels_get, _connect.SFNetAINInfo_m_nNumChannels_set, doc=r"""number of channels""")
    m_vnAvgSampleOptions = property(_connect.SFNetAINInfo_m_vnAvgSampleOptions_get, _connect.SFNetAINInfo_m_vnAvgSampleOptions_set, doc=r"""average sample options""")

    def __init__(self):
        _connect.SFNetAINInfo_swiginit(self, _connect.new_SFNetAINInfo())
    __swig_destroy__ = _connect.delete_SFNetAINInfo

# Register SFNetAINInfo in _connect:
_connect.SFNetAINInfo_swigregister(SFNetAINInfo)
class CFNetAINCtrl(CFNetIPCtrl):
    r"""
    FNet Analog Input controller.



    Python example: _sample_link{fnet,fnet_ain}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetAINCtrl_swiginit(self, _connect.new_CFNetAINCtrl(spConnectionMgr, rURLs))

    def info(self):
        r"""
        Returns information about the AIN IP
        :rtype: :py:class:`SFNetAINInfo`
        :return: SFNetAINInfo
        """
        return _connect.CFNetAINCtrl_info(self)

    def cfg(self):
        r"""
        Returns AIN Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetAINCfg`
        :return: COptionFNetAINCfg
        """
        return _connect.CFNetAINCtrl_cfg(self)

    def op(self):
        r"""
        Returns AIN Option controller used for setting operation
        :rtype: :py:class:`COptionFNetAINOp`
        :return: COptionFNetAINOp
        """
        return _connect.CFNetAINCtrl_op(self)

    def ctrl_get_channel(self, nChannel):
        r"""
        Get voltage level of chosen channel and comparator
        :type nChannel: uint8_t
        :param nChannel:
        :rtype: float
        :return: double, measured voltage
        """
        return _connect.CFNetAINCtrl_ctrl_get_channel(self, nChannel)
    __swig_destroy__ = _connect.delete_CFNetAINCtrl

# Register CFNetAINCtrl in _connect:
_connect.CFNetAINCtrl_swigregister(CFNetAINCtrl)
class COptionFNetAOUTCfg(COptionFNetCfg):
    r"""FNet AOUT configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetAOUTCfg_swiginit(self, _connect.new_COptionFNetAOUTCfg(connectionMgr, rstrBaseURL))

    def set_channel(self, nChannel, strName, bShow, dInitial):
        r"""
        Configure a channel in one call
        :type nChannel: uint8_t
        :param nChannel:   channel to configure
        :type strName: string
        :param strName:    name for the channel
        :type bShow: boolean
        :param bShow:      show it in the HIL monitor and Analyzer
        :type dInitial: float
        :param dInitial:   initial voltage value
        """
        return _connect.COptionFNetAOUTCfg_set_channel(self, nChannel, strName, bShow, dInitial)

    def get_channel_name(self, nChannel):
        r"""
        Get channel name
        :type nChannel: uint8_t
        :param nChannel:  channel index
        :rtype: string
        :return: string   channel name
        """
        return _connect.COptionFNetAOUTCfg_get_channel_name(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetAOUTCfg

# Register COptionFNetAOUTCfg in _connect:
_connect.COptionFNetAOUTCfg_swigregister(COptionFNetAOUTCfg)
class COptionFNetAOUTChannelOp(COptionController):
    r"""FNet AOUT channel operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetAOUTChannelOp_swiginit(self, _connect.new_COptionFNetAOUTChannelOp(connectionMgr, rstrBaseURL))

    def set_action(self, nAction, nFTrig, dLevel):
        r"""Configures the channel."""
        return _connect.COptionFNetAOUTChannelOp_set_action(self, nAction, nFTrig, dLevel)
    __swig_destroy__ = _connect.delete_COptionFNetAOUTChannelOp

# Register COptionFNetAOUTChannelOp in _connect:
_connect.COptionFNetAOUTChannelOp_swigregister(COptionFNetAOUTChannelOp)
class COptionFNetAOUTOp(COptionFNetOp):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetAOUTOp_swiginit(self, _connect.new_COptionFNetAOUTOp(spConnectionMgr, rstrBaseURL))

    def opt_channel(self, nChannel):
        r"""
        :type nChannel: uint8_t
        :param nChannel: channel index
        :rtype: :py:class:`COptionFNetAOUTChannelOp`
        :return: COptionFNetAOUTChannelOp option controller through which the channel components are accessed
        """
        return _connect.COptionFNetAOUTOp_opt_channel(self, nChannel)
    __swig_destroy__ = _connect.delete_COptionFNetAOUTOp

# Register COptionFNetAOUTOp in _connect:
_connect.COptionFNetAOUTOp_swigregister(COptionFNetAOUTOp)
class CFNetAOUTCtrl(CFNetIPCtrl):
    r"""
    FNet Analog Output controller.



    Python example: _sample_link{fnet,fnet_aout}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetAOUTCtrl_swiginit(self, _connect.new_CFNetAOUTCtrl(spConnectionMgr, rURLs))

    def cfg(self):
        r"""
        Returns AOUT Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetAOUTCfg`
        :return: COptionFNetAOUTCfg
        """
        return _connect.CFNetAOUTCtrl_cfg(self)

    def op(self):
        r"""
        Returns AOUT Option controller used for setting operation
        :rtype: :py:class:`COptionFNetAOUTOp`
        :return: COptionFNetAOUTOp
        """
        return _connect.CFNetAOUTCtrl_op(self)

    def ctrl_set_channel(self, *args):
        r"""
        *Overload 1:*

        Sets voltage to channel and returns what it was successfuly changed to
        :type nChannel: uint8_t
        :param nChannel: index of channel to change
        :type dLevel: float
        :param dLevel:   value to set channel voltage to
        :rtype: float
        :return: double  level that the channel was set to

        |

        *Overload 2:*

        Sets voltage to channel and returns what it was successfuly changed to
        :type rstrChannelName: string
        :param rstrChannelName: channel name to change
        :type dLevel: float
        :param dLevel:          value to set channel voltage to
        :rtype: float
        :return: double         level that the channel was set to
        """
        return _connect.CFNetAOUTCtrl_ctrl_set_channel(self, *args)

    def ctrl_read_channel(self, nChannel):
        r"""
        Gets voltage level from channel
        :type nChannel: uint8_t
        :param nChannel: channel index to read voltage from
        :rtype: float
        :return: double  channel voltage read
        """
        return _connect.CFNetAOUTCtrl_ctrl_read_channel(self, nChannel)
    __swig_destroy__ = _connect.delete_CFNetAOUTCtrl

# Register CFNetAOUTCtrl in _connect:
_connect.CFNetAOUTCtrl_swigregister(CFNetAOUTCtrl)
ECAN_CAN = _connect.ECAN_CAN
r"""CAN (Mode)"""
ECAN_CAN_FD_ISO = _connect.ECAN_CAN_FD_ISO
r"""CAN FS ISO (Mode)"""
ECAN_CAN_FD_BOSCH = _connect.ECAN_CAN_FD_BOSCH
r"""CAN FD BOSCH (Mode)"""
ECAN_Standard = _connect.ECAN_Standard
r"""standard ID length 11-bit (Length)"""
ECAN_Extended = _connect.ECAN_Extended
r"""extended ID length 29-bit (Length)"""
ECAN_Both = _connect.ECAN_Both
r"""both trigger message (Msg type)"""
ECAN_Request = _connect.ECAN_Request
r"""request trigger message (Msg type)"""
ECAN_Data = _connect.ECAN_Data
r"""data trigger message (Msg type)"""
class COptionFNetCANCfg(COptionFNetCfg):
    r"""FNet CAN configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetCANCfg_swiginit(self, _connect.new_COptionFNetCANCfg(connectionMgr, rstrBaseURL))

    def set_mode(self, eMode):
        r"""
        Changes the CAN Mode in configurations
        :type eMode: int
        :param eMode: enum type to change to
        """
        return _connect.COptionFNetCANCfg_set_mode(self, eMode)

    def set_allow_injection(self, bInjectionAllowed):
        r"""
        Configures whether an injection is allowed or not
        :type bInjectionAllowed: boolean
        :param bInjectionAllowed: true to allow injection, false otherwise
        """
        return _connect.COptionFNetCANCfg_set_allow_injection(self, bInjectionAllowed)

    def set_arbitration(self, nBaudrate_kbps, nBitSamplingPoint):
        r"""
        Sets arbitration to desired value
        :type nBaudrate_kbps: int
        :param nBaudrate_kbps:    rate to be transfered at (measurement - kb/s)
        :type nBitSamplingPoint: int
        :param nBitSamplingPoint: sample on which to determine if it is a logic zero (dominant) or logic one (recessive) (measurement - %)
        """
        return _connect.COptionFNetCANCfg_set_arbitration(self, nBaudrate_kbps, nBitSamplingPoint)

    def set_FD_data_phase(self, nBaudrate_kbps, nBitSamplingPoint):
        r"""
        Sets FD Data Phase to desired value. Only available if CAN mode is set to CAN_FD_xxx
        :type nBaudrate_kbps: int
        :param nBaudrate_kbps:    rate to be transfered at (measurement - kb/s)
        :type nBitSamplingPoint: int
        :param nBitSamplingPoint: sample on which to determine if it is a logic zero (dominant) or logic one (recessive) (measurement - %)
        """
        return _connect.COptionFNetCANCfg_set_FD_data_phase(self, nBaudrate_kbps, nBitSamplingPoint)

    def get_name(self):
        r"""
        Get name
        :rtype: string
        :return: string name
        """
        return _connect.COptionFNetCANCfg_get_name(self)
    __swig_destroy__ = _connect.delete_COptionFNetCANCfg

# Register COptionFNetCANCfg in _connect:
_connect.COptionFNetCANCfg_swigregister(COptionFNetCANCfg)
class COptionFNetCANOp(COptionFNetOp):
    r"""FNet CAN operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetCANOp_swiginit(self, _connect.new_COptionFNetCANOp(spConnectionMgr, rstrBaseURL))

    def set_record_all_received(self, bRecord):
        r"""
        Controls whether to record all received messages
        :type bRecord: boolean
        :param bRecord: if ``true`` all of the received messages will be recorded
        """
        return _connect.COptionFNetCANOp_set_record_all_received(self, bRecord)

    def set_error(self, bRecord, nFTrig):
        r"""
        Configure an error in one call
        :type bRecord: boolean
        :param bRecord: if ``true`` then it will record error message on specific trigger
        :type nFTrig: uint8_t
        :param nFTrig:  FTrigger index to act upon, 0 to disable
        """
        return _connect.COptionFNetCANOp_set_error(self, bRecord, nFTrig)

    def set_comparator(self, nComparator, bRecord, nFTrig, eLength, nID, nMask, eType):
        r"""
        Configure a comparator in one call
        :type nComparator: uint8_t
        :param nComparator:     comparator index
        :type bRecord: boolean
        :param bRecord:         if ``true`` then it will record messages
        :type nFTrig: uint8_t
        :param nFTrig:          FTrigger index to act upon, 0 to disable
        :type eLength: int
        :param eLength:         enum option for ID length
        :type nID: int
        :param nID:             id value to set to in HEX
        :type nMask: int
        :param nMask:           mask to apply in HEX
        :type eType: int
        :param eType: on what type of messages should the trigger be evoked
        """
        return _connect.COptionFNetCANOp_set_comparator(self, nComparator, bRecord, nFTrig, eLength, nID, nMask, eType)

    def set_record_all_injected(self, bRecord):
        r"""
        Controls whether to record all injected messages
        :type bRecord: boolean
        :param bRecord: if ``true`` all of the injected messages will be recorded
        """
        return _connect.COptionFNetCANOp_set_record_all_injected(self, bRecord)

    def set_action(self, nAction, nFTrig, eLength, nID, bFD, bBRS, bESI, bRequest, rstrData):
        r"""
        Configure an action in one call
        :type nAction: uint8_t
        :param nAction:   index in range from 0 - 3
        :type nFTrig: uint8_t
        :param nFTrig:    index in range from 0 - 10
        :type eLength: int
        :param eLength:   enum option for ID length
        :type nID: int
        :param nID:       id value to set to in HEX
        :type bFD: boolean
        :param bFD:       ``true`` use FD mode
        :type bBRS: boolean
        :param bBRS:      ``true`` to send CAN-FD packet, ``false`` to use CAN (FD mode only).
        :type bESI: boolean
        :param bESI:      ``true`` to send CAN-FD packet with Bit Rate Switching (FD mode only).
        :type bRequest: boolean
        :param bRequest:  ``true`` to send in recessive mode, ``false`` to use error passive flag (FD mode only).
        :type rstrData: string
        :param rstrData:  inject data format: Hexadecimal encoded values of bytes which are sent in order given.
        """
        return _connect.COptionFNetCANOp_set_action(self, nAction, nFTrig, eLength, nID, bFD, bBRS, bESI, bRequest, rstrData)
    __swig_destroy__ = _connect.delete_COptionFNetCANOp

# Register COptionFNetCANOp in _connect:
_connect.COptionFNetCANOp_swigregister(COptionFNetCANOp)
class CFNetCANCtrl(CFNetIPCtrl):
    r"""
    FNet Controller Area Network controller.



    Python example: _sample_link{fnet,fnet_can}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetCANCtrl_swiginit(self, _connect.new_CFNetCANCtrl(spConnectionMgr, rURLs))

    def cfg(self):
        r"""
        Returns CAN Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetCANCfg`
        :return: COptionFNetCANCfg
        """
        return _connect.CFNetCANCtrl_cfg(self)

    def op(self):
        r"""
        Returns CAN Option controller used for setting operation
        :rtype: :py:class:`COptionFNetCANOp`
        :return: COptionFNetCANOp
        """
        return _connect.CFNetCANCtrl_op(self)

    def ctrl_inject(self, eLength, nID, bFD, bBRS, bESI, bRequest, rstrData):
        r"""
        Injects the CAN message on CAN bus with specified parameters
        :type eLength: int
        :param eLength:  length of the message
        :type nID: int
        :param nID:      ID
        :type bFD: boolean
        :param bFD:      set to send CAN FD packet (FD mode only)
        :type bBRS: boolean
        :param bBRS:     set to send CAN FD packet with Bit Rate Switching (FD mode only)
        :type bESI: boolean
        :param bESI:     set to send in recessive mode (FD mode only)
        :type bRequest: boolean
        :param bRequest: message type: ``true`` for Request, ``false`` for Data
        :type rstrData: string
        :param rstrData: CAN data
        """
        return _connect.CFNetCANCtrl_ctrl_inject(self, eLength, nID, bFD, bBRS, bESI, bRequest, rstrData)
    __swig_destroy__ = _connect.delete_CFNetCANCtrl

# Register CFNetCANCtrl in _connect:
_connect.CFNetCANCtrl_swigregister(CFNetCANCtrl)
class COptionFNetLINCfg(COptionFNetCfg):
    r"""FNet LIN configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetLINCfg_swiginit(self, _connect.new_COptionFNetLINCfg(connectionMgr, rstrBaseURL))

    def set_name(self, rstrName):
        r"""
        Changes the name in configuration
        :type rstrName: string
        :param rstrName: new name
        """
        return _connect.COptionFNetLINCfg_set_name(self, rstrName)

    def set_baudrate_bps(self, nBaudrate_bps):
        r"""
        Sets baudrate to desired value
        :type nBaudrate_bps: int
        :param nBaudrate_bps: rate to be transfered at (measurement - b/s)
        """
        return _connect.COptionFNetLINCfg_set_baudrate_bps(self, nBaudrate_bps)

    def add_description_file(self, rstrPath):
        r"""
        Sets a LIN Description File
        :type rstrPath: string
        :param rstrPath: path to ldf file
        """
        return _connect.COptionFNetLINCfg_add_description_file(self, rstrPath)

    def get_name(self):
        r"""
        Get name
        :rtype: string
        :return: string name
        """
        return _connect.COptionFNetLINCfg_get_name(self)
    __swig_destroy__ = _connect.delete_COptionFNetLINCfg

# Register COptionFNetLINCfg in _connect:
_connect.COptionFNetLINCfg_swigregister(COptionFNetLINCfg)
class COptionFNetLINOp(COptionFNetOp):
    r"""FNet LIN operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetLINOp_swiginit(self, _connect.new_COptionFNetLINOp(spConnectionMgr, rstrBaseURL))

    def set_record_all(self, bRecord):
        r"""
        Controls whether to record all received messages
        :type bRecord: boolean
        :param bRecord: if ``true`` all of the received messages will be recorded
        """
        return _connect.COptionFNetLINOp_set_record_all(self, bRecord)

    def set_wakeup(self, bRecord, nFTrig):
        r"""
        Configure a Wake_up comparator in one call
        :type bRecord: boolean
        :param bRecord: if ``true`` then it will record error message on specific trigger
        :type nFTrig: uint8_t
        :param nFTrig:  FTrigger index to act upon, 0 to disable
        """
        return _connect.COptionFNetLINOp_set_wakeup(self, bRecord, nFTrig)

    def set_comparator(self, nComparator, bRecord, nFTrig, nID, nMask):
        r"""
        Configure a comparator in one call
        :type nComparator: uint8_t
        :param nComparator:     comparator index
        :type bRecord: boolean
        :param bRecord:         if ``true`` then it will record messages
        :type nFTrig: uint8_t
        :param nFTrig:          index in range from 0 - 10
        :type nID: int
        :param nID:             id value to set to in HEX
        :type nMask: int
        :param nMask:           mask to apply in HEX
        """
        return _connect.COptionFNetLINOp_set_comparator(self, nComparator, bRecord, nFTrig, nID, nMask)
    __swig_destroy__ = _connect.delete_COptionFNetLINOp

# Register COptionFNetLINOp in _connect:
_connect.COptionFNetLINOp_swigregister(COptionFNetLINOp)
class CFNetLINCtrl(CFNetIPCtrl):
    r"""
    FNet Local Interconnect Network controller.



    Python example: _sample_link{fnet,fnet_lin}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetLINCtrl_swiginit(self, _connect.new_CFNetLINCtrl(spConnectionMgr, rURLs))

    def cfg(self):
        r"""
        Returns LIN Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetLINCfg`
        :return: COptionFNetLINCfg
        """
        return _connect.CFNetLINCtrl_cfg(self)

    def op(self):
        r"""
        Returns LIN Option controller used for setting operation
        :rtype: :py:class:`COptionFNetLINOp`
        :return: COptionFNetLINOp
        """
        return _connect.CFNetLINCtrl_op(self)
    __swig_destroy__ = _connect.delete_CFNetLINCtrl

# Register CFNetLINCtrl in _connect:
_connect.CFNetLINCtrl_swigregister(CFNetLINCtrl)
class COptionFNetCounterCfg(COptionFNetCfg):
    r"""FNet Counter configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetCounterCfg_swiginit(self, _connect.new_COptionFNetCounterCfg(connectionMgr, rstrBaseURL))
    __swig_destroy__ = _connect.delete_COptionFNetCounterCfg

# Register COptionFNetCounterCfg in _connect:
_connect.COptionFNetCounterCfg_swigregister(COptionFNetCounterCfg)
class COptionFNetCounterChannelOp(COptionController):
    r"""FNet Counter channel operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        r"""
        Instantiates object.

        :type connectionMgr: :py:class:`ConnectionMgr`
        :param connectionMgr: class which maintains connection to winIDEA.
                   Connection must be established before this call.
        :type rstrBaseURL: string
        :param rstrBaseURL: configuration node URL, for example /IDE/Debug.DownloadFiles
                    In winIDEA see Help->Display Option...
        """
        _connect.COptionFNetCounterChannelOp_swiginit(self, _connect.new_COptionFNetCounterChannelOp(connectionMgr, rstrBaseURL))

    def set_count_on(self, bCount, nPeriod_us, nFEvent):
        r"""
        Sets the counter and increase periodically or when an event happens
        :type bCount: boolean
        :param bCount:     set it on/off
        :type nPeriod_us: int
        :param nPeriod_us: period to increase the counter
        :type nFEvent: uint8_t
        :param nFEvent:    increase also if the specific event happens
        """
        return _connect.COptionFNetCounterChannelOp_set_count_on(self, bCount, nPeriod_us, nFEvent)

    def set_on_increment(self, nFTrig):
        r"""
        Set event on which the counter will increase
        :type nFTrig: uint8_t
        :param nFTrig: event index from 0 - 10; 0 will not increase the counter on any event
        """
        return _connect.COptionFNetCounterChannelOp_set_on_increment(self, nFTrig)

    def set_active(self, bStartActive, nFTrigRestart, nFTrigSuspend, nFTrigResume):
        r"""
        Sets some of the start/stop options for the counter
        :type bStartActive: boolean
        :param bStartActive:  set to true to start active
        :type nFTrigRestart: uint8_t
        :param nFTrigRestart: FTrigger index to act upon, 0 to disable
        :type nFTrigSuspend: uint8_t
        :param nFTrigSuspend: FTrigger index to act upon, 0 to disable
        :type nFTrigResume: uint8_t
        :param nFTrigResume:  FTrigger index to act upon, 0 to disable
        """
        return _connect.COptionFNetCounterChannelOp_set_active(self, bStartActive, nFTrigRestart, nFTrigSuspend, nFTrigResume)

    def set_limit(self, bLimit, nLimit, nFTrig, bRestart):
        r"""
        Configures the counter behavior when reaching the limit
        :type bLimit: boolean
        :param bLimit:   enables or disables the limit
        :type nLimit: int
        :param nLimit:   limit value
        :type nFTrig: uint8_t
        :param nFTrig:   FTrigger index to act upon, 0 to disable
        :type bRestart: boolean
        :param bRestart: set auto-restart
        """
        return _connect.COptionFNetCounterChannelOp_set_limit(self, bLimit, nLimit, nFTrig, bRestart)

    def set_record(self, bOnChange):
        r"""
        Record the changes
        :type bOnChange: boolean
        :param bOnChange: set to true if you want to record the changes
        """
        return _connect.COptionFNetCounterChannelOp_set_record(self, bOnChange)
    __swig_destroy__ = _connect.delete_COptionFNetCounterChannelOp

# Register COptionFNetCounterChannelOp in _connect:
_connect.COptionFNetCounterChannelOp_swigregister(COptionFNetCounterChannelOp)
class COptionFNetCounterOp(COptionFNetOp):
    r"""FNet Counter operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetCounterOp_swiginit(self, _connect.new_COptionFNetCounterOp(spConnectionMgr, rstrBaseURL))

    def opt_channel(self, nIndex):
        r"""
        :type nIndex: uint8_t
        :param nIndex: trigger index
        :rtype: :py:class:`COptionFNetCounterChannelOp`
        :return: SPOptionFNetCounterChannelOp option controller through which the trigger components are accessed
        """
        return _connect.COptionFNetCounterOp_opt_channel(self, nIndex)
    __swig_destroy__ = _connect.delete_COptionFNetCounterOp

# Register COptionFNetCounterOp in _connect:
_connect.COptionFNetCounterOp_swigregister(COptionFNetCounterOp)
class SChannelStatus(object):
    r"""Holds channel status when `CFNetCounterCtrl::ctrl_get_status()` is called"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_nCount = property(_connect.SChannelStatus_m_nCount_get, _connect.SChannelStatus_m_nCount_set, doc=r"""count value""")
    m_bActive = property(_connect.SChannelStatus_m_bActive_get, _connect.SChannelStatus_m_bActive_set, doc=r"""active status""")

    def __init__(self):
        _connect.SChannelStatus_swiginit(self, _connect.new_SChannelStatus())
    __swig_destroy__ = _connect.delete_SChannelStatus

# Register SChannelStatus in _connect:
_connect.SChannelStatus_swigregister(SChannelStatus)
class CFNetCounterCtrl(CFNetIPCtrl):
    r"""
    FNet Counter controller



    Python example: _sample_link{fnet,fnet_counter}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetCounterCtrl_swiginit(self, _connect.new_CFNetCounterCtrl(spConnectionMgr, rURLs))

    def op(self):
        r"""
        Returns Counter option controller used for setting operation
        :rtype: :py:class:`COptionFNetCounterOp`
        :return: COptionFNetCounterOp
        """
        return _connect.CFNetCounterCtrl_op(self)

    def ctrl_get_FTrig_count(self, nFTrig):
        r"""
        Returns value of a counter of a chosen trigger. This counter is incremented each time
        trigger is injected or asserted by other networks.
        :type nFTrig: uint8_t
        :param nFTrig:   trigger index in range from 0 to 15.
        :rtype: int
        :return: uint32_t counter value
        """
        return _connect.CFNetCounterCtrl_ctrl_get_FTrig_count(self, nFTrig)

    def ctrl_reset_FTrig_count(self, nFTrig):
        r"""
        Resets the counter for specified trigger
        :type nFTrig: uint8_t
        :param nFTrig: trigger index in range from 0 to 15 inclusive
        """
        return _connect.CFNetCounterCtrl_ctrl_reset_FTrig_count(self, nFTrig)

    def ctrl_reset(self, nChannel):
        r"""
        Resets the counter for specified channel
        :type nChannel: uint8_t
        :param nChannel: channel index from 0 to 3 inclusive
        """
        return _connect.CFNetCounterCtrl_ctrl_reset(self, nChannel)

    def ctrl_suspend(self, nChannel):
        r"""
        Suspends the specified channel
        :type nChannel: uint8_t
        :param nChannel: channel index from 0 to 3 inclusive
        """
        return _connect.CFNetCounterCtrl_ctrl_suspend(self, nChannel)

    def ctrl_resume(self, nChannel):
        r"""
        Resumes the specified channel
        :type nChannel: uint8_t
        :param nChannel: channel index from 0 to 3 inclusive
        """
        return _connect.CFNetCounterCtrl_ctrl_resume(self, nChannel)

    def ctrl_get_status(self, nChannel):
        r"""
        Gets status for the channel
        :type nChannel: uint8_t
        :param nChannel:       channel index from 0 to 3 inclusive
        :rtype: :py:class:`SChannelStatus`
        :return: SChannelStatus struct that holds status data for specified channel
        """
        return _connect.CFNetCounterCtrl_ctrl_get_status(self, nChannel)
    __swig_destroy__ = _connect.delete_CFNetCounterCtrl

# Register CFNetCounterCtrl in _connect:
_connect.CFNetCounterCtrl_swigregister(CFNetCounterCtrl)
class COptionFNetSPIOp(COptionFNetOp):
    r"""FNet SPI operation"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rstrBaseURL):
        _connect.COptionFNetSPIOp_swiginit(self, _connect.new_COptionFNetSPIOp(spConnectionMgr, rstrBaseURL))

    def set_record_all(self, bRecord):
        r"""
        Controls whether to record all received messages
        :type bRecord: boolean
        :param bRecord: if ``true`` all of the received messages will be recorded
        """
        return _connect.COptionFNetSPIOp_set_record_all(self, bRecord)

    def set_comparator(self, nComparator, bRecord, nFTrig, nCS, bMOSI, nOffset, nSize, bBigEndian, nValue, nMask):
        r"""
        Configure a comparator in one call
        :type nComparator: uint8_t
        :param nComparator:     comparator index
        :type bRecord: boolean
        :param bRecord:         if ``true`` then it will record messages
        :type nFTrig: uint8_t
        :param nFTrig:          index in range from 0 - 10
        :type nCS: uint8_t
        :param nCS:             chip select index (0-3)
        :type bMOSI: boolean
        :param bMOSI:           true to set MOSI, false to set MISO
        :type nOffset: int
        :param nOffset:         offset number
        :type nSize: int
        :param nSize:           size number
        :type bBigEndian: boolean
        :param bBigEndian:      true to set big endian, false to set little endian
        :type nValue: int
        :param nValue:          value in HEX
        :type nMask: int
        :param nMask:           mask to apply in HEX
        """
        return _connect.COptionFNetSPIOp_set_comparator(self, nComparator, bRecord, nFTrig, nCS, bMOSI, nOffset, nSize, bBigEndian, nValue, nMask)
    __swig_destroy__ = _connect.delete_COptionFNetSPIOp

# Register COptionFNetSPIOp in _connect:
_connect.COptionFNetSPIOp_swigregister(COptionFNetSPIOp)
class COptionFNetSPICfg(COptionFNetCfg):
    r"""FNet SPI configuration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, connectionMgr, rstrBaseURL):
        _connect.COptionFNetSPICfg_swiginit(self, _connect.new_COptionFNetSPICfg(connectionMgr, rstrBaseURL))

    def set_enabled(self, bEnabled):
        r"""
        Enables the SPI
        :type bEnabled: boolean
        :param bEnabled:
        """
        return _connect.COptionFNetSPICfg_set_enabled(self, bEnabled)

    def set_operation(self, bCSActiveHigh, bSamplingOnSecondEdge, bClockIdleHigh):
        r"""
        Sets the config parameters
        :type bCSActiveHigh: boolean
        :param bCSActiveHigh:         true will set it to High, false to Low
        :type bSamplingOnSecondEdge: boolean
        :param bSamplingOnSecondEdge: set to true for sampling on second edge, false for sampling on first edge
        :type bClockIdleHigh: boolean
        :param bClockIdleHigh:        true will set it to High, false to Low
        """
        return _connect.COptionFNetSPICfg_set_operation(self, bCSActiveHigh, bSamplingOnSecondEdge, bClockIdleHigh)

    def set_name(self, rstrName):
        r"""
        Sets the name of the network
        :type rstrName: string
        :param rstrName: desired name
        """
        return _connect.COptionFNetSPICfg_set_name(self, rstrName)

    def add_description_file(self, rstrPath):
        r"""
        Sets a SPI Description File
        :type rstrPath: string
        :param rstrPath: path to file
        """
        return _connect.COptionFNetSPICfg_add_description_file(self, rstrPath)

    def get_name(self):
        r"""
        Get name
        :rtype: string
        :return: string name
        """
        return _connect.COptionFNetSPICfg_get_name(self)
    __swig_destroy__ = _connect.delete_COptionFNetSPICfg

# Register COptionFNetSPICfg in _connect:
_connect.COptionFNetSPICfg_swigregister(COptionFNetSPICfg)
class CFNetSPICtrl(CFNetIPCtrl):
    r"""
    FNet Serial Peripheral Interface controller



    Python example: _sample_link{fnet,fnet_spi}
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr, rURLs):
        _connect.CFNetSPICtrl_swiginit(self, _connect.new_CFNetSPICtrl(spConnectionMgr, rURLs))

    def cfg(self):
        r"""
        Returns SPI Option controller used for setting configuration
        :rtype: :py:class:`COptionFNetSPICfg`
        :return: COptionFNetSPICfg configuration controller
        """
        return _connect.CFNetSPICtrl_cfg(self)

    def op(self):
        r"""
        Returns SPI option controller used for setting operation
        :rtype: :py:class:`COptionFNetSPIOp`
        :return: CFOptionFNetSPIOp option controller
        """
        return _connect.CFNetSPICtrl_op(self)
    __swig_destroy__ = _connect.delete_CFNetSPICtrl

# Register CFNetSPICtrl in _connect:
_connect.CFNetSPICtrl_swigregister(CFNetSPICtrl)
class SNodeInfo(object):
    r"""FNet controller."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_strNodeName = property(_connect.SNodeInfo_m_strNodeName_get, _connect.SNodeInfo_m_strNodeName_set)
    ENodeType_Root = _connect.SNodeInfo_ENodeType_Root
    ENodeType_Hub = _connect.SNodeInfo_ENodeType_Hub
    ENodeType_ADIO = _connect.SNodeInfo_ENodeType_ADIO
    ENodeType_CANLIN = _connect.SNodeInfo_ENodeType_CANLIN
    ENodeType_AP = _connect.SNodeInfo_ENodeType_AP
    m_eNodeType = property(_connect.SNodeInfo_m_eNodeType_get, _connect.SNodeInfo_m_eNodeType_set)
    m_vIPInfo = property(_connect.SNodeInfo_m_vIPInfo_get, _connect.SNodeInfo_m_vIPInfo_set, doc=r"""returned only for configured node. JU: create template mapping in IConnectSIG.i""")
    m_dwSerialNumber = property(_connect.SNodeInfo_m_dwSerialNumber_get, _connect.SNodeInfo_m_dwSerialNumber_set, doc=r"""returned only for connected node""")

    def __init__(self):
        _connect.SNodeInfo_swiginit(self, _connect.new_SNodeInfo())
    __swig_destroy__ = _connect.delete_SNodeInfo

# Register SNodeInfo in _connect:
_connect.SNodeInfo_swigregister(SNodeInfo)
class CFNetCtrl(object):
    r"""
    FNet controller through which you get all of the FNet nodes


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, spConnectionMgr):
        _connect.CFNetCtrl_swiginit(self, _connect.new_CFNetCtrl(spConnectionMgr))

    def mDIO(self, rstrID):
        r"""
        Returns new instance of CFNetmDIOCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My AP.mDIO1" or "CAN box.Airbag")
        """
        return _connect.CFNetCtrl_mDIO(self, rstrID)

    def DIO(self, rstrID):
        r"""
        Returns new instance of CFNetDIOCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My ADIO.DIO" or "CAN box.Airbag")
        """
        return _connect.CFNetCtrl_DIO(self, rstrID)

    def AIN(self, rstrID):
        r"""
        Returns new instance of CFNetAINCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My ADIO.AIN1" or "ADIO box.Scope")
        """
        return _connect.CFNetCtrl_AIN(self, rstrID)

    def AOUT(self, rstrID):
        r"""
        Returns new instance of CFNetAOUTCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My ADIO.AOUT1" or "ADIO box.Scope")
        """
        return _connect.CFNetCtrl_AOUT(self, rstrID)

    def CAN(self, rstrID):
        r"""
        Returns new instance of CFNetCANCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My CAN2LIN2.CAN1" or "ADIO box.Scope")
        """
        return _connect.CFNetCtrl_CAN(self, rstrID)

    def LIN(self, rstrID):
        r"""
        Returns new instance of CFNetLINCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My CAN2LIN2.LIN1" or "ADIO box.Scope")
        """
        return _connect.CFNetCtrl_LIN(self, rstrID)

    def COUNTER(self, rstrID):
        r"""
        Returns new instance of CFNetCounterCtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My Root.COUNTER" or "ADIO box.Scope")
        """
        return _connect.CFNetCtrl_COUNTER(self, rstrID)

    def SPI(self, rstrID):
        r"""
        Returns new instance of CFNetSPICtrl.
        :type rstrID: string
        :param rstrID: the IP identifier, constructed from <FNode name>.<IP Name>(example: "My ADIO.SPI1" or "ADIO box.Scope")
        """
        return _connect.CFNetCtrl_SPI(self, rstrID)

    def get_configured_nodes(self, rvNodes):
        r"""
        Returns all configured FNet nodes. Communication to the BlueBox must be established
        :type rvNodes: std::vector< isys::SNodeInfo,std::allocator< isys::SNodeInfo > >
        :param rvNodes: connected nodes list
        """
        return _connect.CFNetCtrl_get_configured_nodes(self, rvNodes)

    def get_connected_nodes(self, rvNodes):
        r"""
        Returns all currently connected FNet nodes. Communication to the BlueBox must be established
        :type rvNodes: std::vector< isys::SNodeInfo,std::allocator< isys::SNodeInfo > >
        :param rvNodes: connected nodes list
        """
        return _connect.CFNetCtrl_get_connected_nodes(self, rvNodes)

    def op_apply(self):
        r"""
        Performs the sequence of: stop, reapply operation configuration, restart FNet operation.
        Raises exception if FNet operation fails.
        """
        return _connect.CFNetCtrl_op_apply(self)

    def op_stop(self):
        r"""
        Stop FNet operation on all available nodes.
        Raises exception if FNet operation fails.
        """
        return _connect.CFNetCtrl_op_stop(self)

    def op_restart(self):
        r"""
        Apply FNet configurations and restart internal state of all available
        nodes, without breaking communication with debugger.
        Raises exception if FNet operation fails.
        """
        return _connect.CFNetCtrl_op_restart(self)

    def ctrl_inject_trigger(self, nFTrig):
        r"""
        Manually generate (inject) specified FTrigger.
        :type nFTrig: uint8_t
        :param nFTrig: in range from 1 to 10
        """
        return _connect.CFNetCtrl_ctrl_inject_trigger(self, nFTrig)
    __swig_destroy__ = _connect.delete_CFNetCtrl

# Register CFNetCtrl in _connect:
_connect.CFNetCtrl_swigregister(CFNetCtrl)
class Ssymbol_FQN(object):
    r"""This structure contains components of a qualified symbol name."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    strSymbolQN = property(_connect.Ssymbol_FQN_strSymbolQN_get, _connect.Ssymbol_FQN_strSymbolQN_set)
    strNamespace = property(_connect.Ssymbol_FQN_strNamespace_get, _connect.Ssymbol_FQN_strNamespace_set)
    strNaked = property(_connect.Ssymbol_FQN_strNaked_get, _connect.Ssymbol_FQN_strNaked_set)
    strSignature = property(_connect.Ssymbol_FQN_strSignature_get, _connect.Ssymbol_FQN_strSignature_set)
    strFile = property(_connect.Ssymbol_FQN_strFile_get, _connect.Ssymbol_FQN_strFile_set)
    strFunc = property(_connect.Ssymbol_FQN_strFunc_get, _connect.Ssymbol_FQN_strFunc_set)
    strInstance = property(_connect.Ssymbol_FQN_strInstance_get, _connect.Ssymbol_FQN_strInstance_set)
    strPartition = property(_connect.Ssymbol_FQN_strPartition_get, _connect.Ssymbol_FQN_strPartition_set)
    strProcess = property(_connect.Ssymbol_FQN_strProcess_get, _connect.Ssymbol_FQN_strProcess_set)
    strModifier = property(_connect.Ssymbol_FQN_strModifier_get, _connect.Ssymbol_FQN_strModifier_set)
    eFile = _connect.Ssymbol_FQN_eFile
    r"""`<file>#`"""
    eFunc = _connect.Ssymbol_FQN_eFunc
    r"""`<func>##`"""
    eInstance = _connect.Ssymbol_FQN_eInstance
    r"""`<instance>###`"""
    eNamespace = _connect.Ssymbol_FQN_eNamespace
    r"""`<namespace>`"""
    eNaked = _connect.Ssymbol_FQN_eNaked
    r"""`<naked>`"""
    eSignature = _connect.Ssymbol_FQN_eSignature
    r"""`<signature>`"""
    ePartition = _connect.Ssymbol_FQN_ePartition
    r"""`,,<partition>`"""
    eProcess = _connect.Ssymbol_FQN_eProcess
    r"""`,,,<process>`"""
    eModifier = _connect.Ssymbol_FQN_eModifier
    r"""`,<modifier>`"""
    eSymbol = _connect.Ssymbol_FQN_eSymbol
    eSymbolQN = _connect.Ssymbol_FQN_eSymbolQN
    eSymbolFQN = _connect.Ssymbol_FQN_eSymbolFQN
    eFull = _connect.Ssymbol_FQN_eFull

    def __repr__(self):
        return _connect.Ssymbol_FQN___repr__(self)

    def __init__(self):
        _connect.Ssymbol_FQN_swiginit(self, _connect.new_Ssymbol_FQN())
    __swig_destroy__ = _connect.delete_Ssymbol_FQN

# Register Ssymbol_FQN in _connect:
_connect.Ssymbol_FQN_swigregister(Ssymbol_FQN)
class SVersion(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Major = property(_connect.SVersion_Major_get, _connect.SVersion_Major_set)
    Minor = property(_connect.SVersion_Minor_get, _connect.SVersion_Minor_set)
    Build = property(_connect.SVersion_Build_get, _connect.SVersion_Build_set)
    BuildSub = property(_connect.SVersion_BuildSub_get, _connect.SVersion_BuildSub_set)
    SCCRev = property(_connect.SVersion_SCCRev_get, _connect.SVersion_SCCRev_set)

    def __init__(self, byMajor=0, byMinor=0, wBuild=0, byBuildSub=0, dwSCCRev=0):
        _connect.SVersion_swiginit(self, _connect.new_SVersion(byMajor, byMinor, wBuild, byBuildSub, dwSCCRev))

    def toString(self, bAddSCCRev=False):
        r"""Returns string representation of this class, for example "9.17.110"."""
        return _connect.SVersion_toString(self, bAddSCCRev)

    def Compare(self, *args):
        return _connect.SVersion_Compare(self, *args)
    __swig_destroy__ = _connect.delete_SVersion

# Register SVersion in _connect:
_connect.SVersion_swigregister(SVersion)
Access_OK = _connect.Access_OK
Access_Fail = _connect.Access_Fail
EAccessBatchResult_OK = _connect.EAccessBatchResult_OK
EAccessBatchResult_Fail = _connect.EAccessBatchResult_Fail
EAccessBatchResult_Timeout = _connect.EAccessBatchResult_Timeout
EAccessBatchResult_Abort = _connect.EAccessBatchResult_Abort
EAccessBatchResult_BadParam = _connect.EAccessBatchResult_BadParam
class SIN(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_daItems = property(_connect.SIN_m_daItems_get, _connect.SIN_m_daItems_set)
    m_dwTimeout_us = property(_connect.SIN_m_dwTimeout_us_get, _connect.SIN_m_dwTimeout_us_set)

    def set_timeout_us(self, dwTimeout_us):
        return _connect.SIN_set_timeout_us(self, dwTimeout_us)

    def read_T(self, *args):
        return _connect.SIN_read_T(self, *args)

    def write_T(self, *args):
        return _connect.SIN_write_T(self, *args)

    def fill_T(self, *args):
        return _connect.SIN_fill_T(self, *args)

    def poll_T(self, *args):
        return _connect.SIN_poll_T(self, *args)

    def FTrig(self, nTrig):
        return _connect.SIN_FTrig(self, nTrig)

    def __init__(self):
        _connect.SIN_swiginit(self, _connect.new_SIN())
    __swig_destroy__ = _connect.delete_SIN

# Register SIN in _connect:
_connect.SIN_swigregister(SIN)
class SOUT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_eResult = property(_connect.SOUT_m_eResult_get, _connect.SOUT_m_eResult_set)
    m_daItems = property(_connect.SOUT_m_daItems_get, _connect.SOUT_m_daItems_set)

    def __init__(self):
        _connect.SOUT_swiginit(self, _connect.new_SOUT())
    __swig_destroy__ = _connect.delete_SOUT

# Register SOUT in _connect:
_connect.SOUT_swigregister(SOUT)
class CAddress(object):
    r"""Struct containing address info. used original for iOPEN"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_aAddress = property(_connect.CAddress_m_aAddress_get, _connect.CAddress_m_aAddress_set, doc=r"""offset""")
    m_iArea = property(_connect.CAddress_m_iArea_get, _connect.CAddress_m_iArea_set, doc=r"""
    area as specified in CDebugInterface::GetRegisterAreaInfo,
    -1 for register, -2 for number
    """)
    m_byProcess = property(_connect.CAddress_m_byProcess_get, _connect.CAddress_m_byProcess_set, doc=r"""index of the (virtual) process""")
    m_byReserved = property(_connect.CAddress_m_byReserved_get, _connect.CAddress_m_byReserved_set, doc=r"""reserved, should be zero""")

    def __init__(self):
        _connect.CAddress_swiginit(self, _connect.new_CAddress())
    __swig_destroy__ = _connect.delete_CAddress

# Register CAddress in _connect:
_connect.CAddress_swigregister(CAddress)
class SValue(object):
    r"""Contains union of possible values."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MAX_INT_BITS = _connect.SValue_MAX_INT_BITS
    MAX_FLT_BITS = _connect.SValue_MAX_FLT_BITS

    def __init__(self):
        _connect.SValue_swiginit(self, _connect.new_SValue())
    __swig_destroy__ = _connect.delete_SValue

# Register SValue in _connect:
_connect.SValue_swigregister(SValue)
class SType(object):
    r"""Contains type info and size."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tUndefined = _connect.SType_tUndefined
    r"""undefined type"""
    tUnsigned = _connect.SType_tUnsigned
    r"""unsigned integral type"""
    tSigned = _connect.SType_tSigned
    r"""signed integral type"""
    tFloat = _connect.SType_tFloat
    r"""floating point type"""
    tAddress = _connect.SType_tAddress
    r"""address type"""
    tCompound = _connect.SType_tCompound
    r"""compound type, for example struct"""
    m_byType = property(_connect.SType_m_byType_get, _connect.SType_m_byType_set, doc=r"""type of variable, see SType::EType for possible values""")
    m_byBitSize = property(_connect.SType_m_byBitSize_get, _connect.SType_m_byBitSize_set, doc=r"""size of variable in bits""")

    def __init__(self):
        _connect.SType_swiginit(self, _connect.new_SType())
    __swig_destroy__ = _connect.delete_SType

# Register SType in _connect:
_connect.SType_swigregister(SType)
class SType2(SType):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    t2Regular = _connect.SType2_t2Regular
    r"""no extra type information available"""
    t2BitField = _connect.SType2_t2BitField
    r"""this is a bit field, m_dw1 specifies size and m_dw2 offset within container integer"""
    t2Enum = _connect.SType2_t2Enum
    t2Struct = _connect.SType2_t2Struct
    t2Union = _connect.SType2_t2Union
    t2Class = _connect.SType2_t2Class
    t2Pointer = _connect.SType2_t2Pointer
    t2Reference = _connect.SType2_t2Reference
    t2Array = _connect.SType2_t2Array
    r"""m_dw1 = dimension"""
    t2Function = _connect.SType2_t2Function
    m_byType2 = property(_connect.SType2_m_byType2_get, _connect.SType2_m_byType2_set)
    m_byReserved = property(_connect.SType2_m_byReserved_get, _connect.SType2_m_byReserved_set)
    m_dw1 = property(_connect.SType2_m_dw1_get, _connect.SType2_m_dw1_set)
    m_dw2 = property(_connect.SType2_m_dw2_get, _connect.SType2_m_dw2_set)

    def __init__(self):
        _connect.SType2_swiginit(self, _connect.new_SType2())
    __swig_destroy__ = _connect.delete_SType2

# Register SType2 in _connect:
_connect.SType2_swigregister(SType2)
endianLittle = _connect.endianLittle
endianBig = _connect.endianBig
class CCPUInfo(object):
    r"""Contains CPU family and variant."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cpu_8051 = _connect.CCPUInfo_cpu_8051
    r"""8051 family"""
    cpu_RISCV = _connect.CCPUInfo_cpu_RISCV
    r"""RISCV family"""
    cpu_Xtensa = _connect.CCPUInfo_cpu_Xtensa
    r"""Tensilica Xtensa DSP"""
    cpu_ARC = _connect.CCPUInfo_cpu_ARC
    r"""ARC family"""
    cpu_x86 = _connect.CCPUInfo_cpu_x86
    r"""x86"""
    cpu_TIDSP = _connect.CCPUInfo_cpu_TIDSP
    r"""TI DSP"""
    cpu_PowerPC = _connect.CCPUInfo_cpu_PowerPC
    r"""PowerPC family"""
    cpu_ARM = _connect.CCPUInfo_cpu_ARM
    r"""ARM family"""
    cpu_V850 = _connect.CCPUInfo_cpu_V850
    r"""V850 family"""
    cpu_78k = _connect.CCPUInfo_cpu_78k
    cpu_TPU = _connect.CCPUInfo_cpu_TPU
    r"""TPU"""
    cpu_TriCore = _connect.CCPUInfo_cpu_TriCore
    r"""TriCore family"""
    cpu_GTM = _connect.CCPUInfo_cpu_GTM
    r"""GTM"""
    cpu_SPT = _connect.CCPUInfo_cpu_SPT
    r"""SPT"""
    cpu_Num = _connect.CCPUInfo_cpu_Num
    cpu_Generic = _connect.CCPUInfo_cpu_Generic
    r"""generic CPU"""
    m_wCPU = property(_connect.CCPUInfo_m_wCPU_get, _connect.CCPUInfo_m_wCPU_set, doc=r"""Contains CPU family.""")
    v8051_8051 = _connect.CCPUInfo_v8051_8051
    r"""8051"""
    v8051_Num = _connect.CCPUInfo_v8051_Num
    vPowerPC_4xx = _connect.CCPUInfo_vPowerPC_4xx
    r"""4xx"""
    vPowerPC_5xx = _connect.CCPUInfo_vPowerPC_5xx
    vPowerPC_6xx = _connect.CCPUInfo_vPowerPC_6xx
    vPowerPC_7xx = _connect.CCPUInfo_vPowerPC_7xx
    vPowerPC_8xx = _connect.CCPUInfo_vPowerPC_8xx
    vPowerPC_G5 = _connect.CCPUInfo_vPowerPC_G5
    vPowerPC_G3 = _connect.CCPUInfo_vPowerPC_G3
    vPowerPC_Num = _connect.CCPUInfo_vPowerPC_Num
    svPowerPC_e200z0 = _connect.CCPUInfo_svPowerPC_e200z0
    svPowerPC_e200z0H = _connect.CCPUInfo_svPowerPC_e200z0H
    svPowerPC_e200z0Hn2 = _connect.CCPUInfo_svPowerPC_e200z0Hn2
    svPowerPC_e200z1 = _connect.CCPUInfo_svPowerPC_e200z1
    svPowerPC_e200z210 = _connect.CCPUInfo_svPowerPC_e200z210
    svPowerPC_e200z215 = _connect.CCPUInfo_svPowerPC_e200z215
    svPowerPC_e200z225 = _connect.CCPUInfo_svPowerPC_e200z225
    svPowerPC_e200z3 = _connect.CCPUInfo_svPowerPC_e200z3
    svPowerPC_e200z335 = _connect.CCPUInfo_svPowerPC_e200z335
    svPowerPC_e200z4 = _connect.CCPUInfo_svPowerPC_e200z4
    svPowerPC_e200z420 = _connect.CCPUInfo_svPowerPC_e200z420
    svPowerPC_e200z4201n3 = _connect.CCPUInfo_svPowerPC_e200z4201n3
    svPowerPC_e200z4204n3 = _connect.CCPUInfo_svPowerPC_e200z4204n3
    svPowerPC_e200z425 = _connect.CCPUInfo_svPowerPC_e200z425
    svPowerPC_e200z448n3 = _connect.CCPUInfo_svPowerPC_e200z448n3
    svPowerPC_e200z6 = _connect.CCPUInfo_svPowerPC_e200z6
    svPowerPC_e200z6vle = _connect.CCPUInfo_svPowerPC_e200z6vle
    svPowerPC_e200z650 = _connect.CCPUInfo_svPowerPC_e200z650
    svPowerPC_e200z7 = _connect.CCPUInfo_svPowerPC_e200z7
    svPowerPC_e200z720 = _connect.CCPUInfo_svPowerPC_e200z720
    svPowerPC_e200z7260 = _connect.CCPUInfo_svPowerPC_e200z7260
    svPowerPC_e200z759n3 = _connect.CCPUInfo_svPowerPC_e200z759n3
    vARM_v3 = _connect.CCPUInfo_vARM_v3
    r"""ARM v3"""
    vARM_v4T = _connect.CCPUInfo_vARM_v4T
    vARM_v5TE = _connect.CCPUInfo_vARM_v5TE
    vARM_v5TEJ = _connect.CCPUInfo_vARM_v5TEJ
    vARM_v6 = _connect.CCPUInfo_vARM_v6
    vARM_v7A = _connect.CCPUInfo_vARM_v7A
    r"""Cortex A  architecture version"""
    vARM_v7R = _connect.CCPUInfo_vARM_v7R
    r"""Cortex R  architecture version"""
    vARM_v7M = _connect.CCPUInfo_vARM_v7M
    r"""Cortex M3 architecture version"""
    vARM_v6M = _connect.CCPUInfo_vARM_v6M
    r"""Cortex M0 and M1 architecture version"""
    vARM_v8A = _connect.CCPUInfo_vARM_v8A
    r"""
    As per ARM an A suffix means that core has VMSA (MMU present)
    Currently in winIDEA ARMv8A indicates AArch64 (and AArch32 but we assume AArch32 won't be used) capable core.
    So we use this info in m_wVariant to select AArch64 disassembler and 64bit core register set.
    """
    vARM_v8R = _connect.CCPUInfo_vARM_v8R
    r"""
    As per ARM an R suffix means that core has PMSA (MPU instead MMU)
    Currently in winIDEA ARMv8R indicates AArch32 only core (there is no clear statement that it can't be AArch64 capable).
    We use this info in m_wVariant to select ARMv7 disassembler and ARMv7 register set.
    """
    vARM_v8M = _connect.CCPUInfo_vARM_v8M
    vARM_Num = _connect.CCPUInfo_vARM_Num
    svARM_CortexMask = _connect.CCPUInfo_svARM_CortexMask
    svARM_CortexProfileMask = _connect.CCPUInfo_svARM_CortexProfileMask
    svARM_64 = _connect.CCPUInfo_svARM_64
    svARM_CortexM = _connect.CCPUInfo_svARM_CortexM
    svARM_CortexM0 = _connect.CCPUInfo_svARM_CortexM0
    svARM_CortexM1 = _connect.CCPUInfo_svARM_CortexM1
    svARM_CortexM3 = _connect.CCPUInfo_svARM_CortexM3
    svARM_CortexM4 = _connect.CCPUInfo_svARM_CortexM4
    svARM_CortexM7 = _connect.CCPUInfo_svARM_CortexM7
    svARM_CortexM23 = _connect.CCPUInfo_svARM_CortexM23
    svARM_CortexM33 = _connect.CCPUInfo_svARM_CortexM33
    svARM_CortexM35P = _connect.CCPUInfo_svARM_CortexM35P
    svARM_CortexM55 = _connect.CCPUInfo_svARM_CortexM55
    svARM_CortexM85 = _connect.CCPUInfo_svARM_CortexM85
    svARM_CortexR = _connect.CCPUInfo_svARM_CortexR
    svARM_CortexR4 = _connect.CCPUInfo_svARM_CortexR4
    svARM_CortexR5 = _connect.CCPUInfo_svARM_CortexR5
    svARM_CortexR7 = _connect.CCPUInfo_svARM_CortexR7
    svARM_CortexR8 = _connect.CCPUInfo_svARM_CortexR8
    svARM_CortexR52 = _connect.CCPUInfo_svARM_CortexR52
    svARM_CortexR82 = _connect.CCPUInfo_svARM_CortexR82
    svARM_CortexA = _connect.CCPUInfo_svARM_CortexA
    svARM_CortexA5 = _connect.CCPUInfo_svARM_CortexA5
    svARM_CortexA7 = _connect.CCPUInfo_svARM_CortexA7
    svARM_CortexA8 = _connect.CCPUInfo_svARM_CortexA8
    svARM_CortexA9 = _connect.CCPUInfo_svARM_CortexA9
    svARM_CortexA12 = _connect.CCPUInfo_svARM_CortexA12
    svARM_CortexA15 = _connect.CCPUInfo_svARM_CortexA15
    svARM_CortexA17 = _connect.CCPUInfo_svARM_CortexA17
    svARM_CortexA32 = _connect.CCPUInfo_svARM_CortexA32
    svARM_CortexA34 = _connect.CCPUInfo_svARM_CortexA34
    svARM_CortexA35 = _connect.CCPUInfo_svARM_CortexA35
    svARM_CortexA53 = _connect.CCPUInfo_svARM_CortexA53
    svARM_CortexA55 = _connect.CCPUInfo_svARM_CortexA55
    svARM_CortexA57 = _connect.CCPUInfo_svARM_CortexA57
    svARM_CortexA65 = _connect.CCPUInfo_svARM_CortexA65
    svARM_CortexA72 = _connect.CCPUInfo_svARM_CortexA72
    svARM_CortexA73 = _connect.CCPUInfo_svARM_CortexA73
    svARM_CortexA75 = _connect.CCPUInfo_svARM_CortexA75
    svARM_CortexA76 = _connect.CCPUInfo_svARM_CortexA76
    svARM_CortexA77 = _connect.CCPUInfo_svARM_CortexA77
    svARM_CortexA78 = _connect.CCPUInfo_svARM_CortexA78
    svARM_CortexA510 = _connect.CCPUInfo_svARM_CortexA510
    svARM_CortexA710 = _connect.CCPUInfo_svARM_CortexA710
    svARM_CortexA715 = _connect.CCPUInfo_svARM_CortexA715
    svARM_CortexA720 = _connect.CCPUInfo_svARM_CortexA720
    sARMv8_EL0 = _connect.CCPUInfo_sARMv8_EL0
    r"""v8"""
    sARMv8_EL1 = _connect.CCPUInfo_sARMv8_EL1
    sARMv8_EL2 = _connect.CCPUInfo_sARMv8_EL2
    sARMv8_EL3 = _connect.CCPUInfo_sARMv8_EL3
    sARMv8_ELMask = _connect.CCPUInfo_sARMv8_ELMask
    sARMv8_Secure = _connect.CCPUInfo_sARMv8_Secure
    sARMv7_PL0 = _connect.CCPUInfo_sARMv7_PL0
    r"""v7"""
    sARMv7_PL1 = _connect.CCPUInfo_sARMv7_PL1
    sARMv7_PL2 = _connect.CCPUInfo_sARMv7_PL2
    sARMv7_ELMask = _connect.CCPUInfo_sARMv7_ELMask
    sARMv7_Secure = _connect.CCPUInfo_sARMv7_Secure
    vV850_V850G3K = _connect.CCPUInfo_vV850_V850G3K
    vV850_V850G3M = _connect.CCPUInfo_vV850_V850G3M
    vV850_RH850G4 = _connect.CCPUInfo_vV850_RH850G4
    vV850_RH850G4KH = _connect.CCPUInfo_vV850_RH850G4KH
    vV850_Num = _connect.CCPUInfo_vV850_Num
    veTPU = _connect.CCPUInfo_veTPU
    vTPU_Num = _connect.CCPUInfo_vTPU_Num
    veGTM = _connect.CCPUInfo_veGTM
    vGTM_Num = _connect.CCPUInfo_vGTM_Num
    vTriCore13 = _connect.CCPUInfo_vTriCore13
    r"""TriCore13"""
    vTriCore16 = _connect.CCPUInfo_vTriCore16
    vTriCore16E = _connect.CCPUInfo_vTriCore16E
    vTriCore16P = _connect.CCPUInfo_vTriCore16P
    vTriCore162P = _connect.CCPUInfo_vTriCore162P
    vTriCore18 = _connect.CCPUInfo_vTriCore18
    vTriCore_Num = _connect.CCPUInfo_vTriCore_Num
    vRX = _connect.CCPUInfo_vRX
    vRX_Num = _connect.CCPUInfo_vRX_Num
    vRISCV_RV32I = _connect.CCPUInfo_vRISCV_RV32I
    r"""RV32I"""
    vRISCV_RV32E = _connect.CCPUInfo_vRISCV_RV32E
    vRISCV_RV64I = _connect.CCPUInfo_vRISCV_RV64I
    vRISCV_RV128I = _connect.CCPUInfo_vRISCV_RV128I
    vRISCV_Num = _connect.CCPUInfo_vRISCV_Num
    vARC_EV7x = _connect.CCPUInfo_vARC_EV7x
    vARC_EM5 = _connect.CCPUInfo_vARC_EM5
    vARC_Num = _connect.CCPUInfo_vARC_Num
    vXtensa_XtensaLX = _connect.CCPUInfo_vXtensa_XtensaLX
    vXtensa_XtensaNX = _connect.CCPUInfo_vXtensa_XtensaNX
    vXtensa_Num = _connect.CCPUInfo_vXtensa_Num
    vx86 = _connect.CCPUInfo_vx86
    vx64 = _connect.CCPUInfo_vx64
    vx86_Num = _connect.CCPUInfo_vx86_Num
    v78k_RL78 = _connect.CCPUInfo_v78k_RL78
    v78k_Num = _connect.CCPUInfo_v78k_Num
    vSPT_v1 = _connect.CCPUInfo_vSPT_v1
    vSPT_v2 = _connect.CCPUInfo_vSPT_v2
    vSPT_v2_5 = _connect.CCPUInfo_vSPT_v2_5
    vSPT_v2_8 = _connect.CCPUInfo_vSPT_v2_8
    vSPT_v3_1 = _connect.CCPUInfo_vSPT_v3_1
    vSPT_v3_5 = _connect.CCPUInfo_vSPT_v3_5
    vSPT_v3_4 = _connect.CCPUInfo_vSPT_v3_4
    vSPT_v3_8 = _connect.CCPUInfo_vSPT_v3_8
    vSPT_Num = _connect.CCPUInfo_vSPT_Num
    vTIDSP_C7xx = _connect.CCPUInfo_vTIDSP_C7xx
    vTIDSP_C28x = _connect.CCPUInfo_vTIDSP_C28x
    vTIDSP_C29x = _connect.CCPUInfo_vTIDSP_C29x
    vTIDSP_Num = _connect.CCPUInfo_vTIDSP_Num
    m_wVariant = property(_connect.CCPUInfo_m_wVariant_get, _connect.CCPUInfo_m_wVariant_set, doc=r"""Contains CPU variant ID.""")
    m_wSubVariant = property(_connect.CCPUInfo_m_wSubVariant_get, _connect.CCPUInfo_m_wSubVariant_set, doc=r"""Contains CPU subvariant ID.""")
    EEndianOverride_Default = _connect.CCPUInfo_EEndianOverride_Default
    EEndianOverride_Little = _connect.CCPUInfo_EEndianOverride_Little
    EEndianOverride_Big = _connect.CCPUInfo_EEndianOverride_Big
    m_eEndianOverride = property(_connect.CCPUInfo_m_eEndianOverride_get, _connect.CCPUInfo_m_eEndianOverride_set)
    fRISCV_M = _connect.CCPUInfo_fRISCV_M
    r"""RISCV_M"""
    fRISCV_A = _connect.CCPUInfo_fRISCV_A
    fRISCV_F = _connect.CCPUInfo_fRISCV_F
    fRISCV_D = _connect.CCPUInfo_fRISCV_D
    fRISCV_Q = _connect.CCPUInfo_fRISCV_Q
    fRISCV_L = _connect.CCPUInfo_fRISCV_L
    fRISCV_C = _connect.CCPUInfo_fRISCV_C
    fRISCV_B = _connect.CCPUInfo_fRISCV_B
    fRISCV_J = _connect.CCPUInfo_fRISCV_J
    fRISCV_T = _connect.CCPUInfo_fRISCV_T
    fRISCV_P = _connect.CCPUInfo_fRISCV_P
    fRISCV_PULP = _connect.CCPUInfo_fRISCV_PULP
    fRISCV_V = _connect.CCPUInfo_fRISCV_V
    fRISCV_N = _connect.CCPUInfo_fRISCV_N
    fRISCV_H = _connect.CCPUInfo_fRISCV_H
    fRISCV_ZiCSR = _connect.CCPUInfo_fRISCV_ZiCSR
    fRISCV_Zifencei = _connect.CCPUInfo_fRISCV_Zifencei
    fRISCV_Zam = _connect.CCPUInfo_fRISCV_Zam
    fRISCV_Ztso = _connect.CCPUInfo_fRISCV_Ztso
    fRISCV_AndesPerformance = _connect.CCPUInfo_fRISCV_AndesPerformance
    fRISCV_AndesCoDense = _connect.CCPUInfo_fRISCV_AndesCoDense
    fRISCV_AndesINT4VectorLoad = _connect.CCPUInfo_fRISCV_AndesINT4VectorLoad
    fRISCV_AndesScalarBFLOAT16Conversion = _connect.CCPUInfo_fRISCV_AndesScalarBFLOAT16Conversion
    fRISCV_AndesVectorBFLOAT16Conversion = _connect.CCPUInfo_fRISCV_AndesVectorBFLOAT16Conversion
    fRISCV_AndesDSP = _connect.CCPUInfo_fRISCV_AndesDSP
    fRISCV_Zba = _connect.CCPUInfo_fRISCV_Zba
    fRISCV_Zbb = _connect.CCPUInfo_fRISCV_Zbb
    fRISCV_Zbc = _connect.CCPUInfo_fRISCV_Zbc
    fRISCV_Zbs = _connect.CCPUInfo_fRISCV_Zbs
    fRISCV_Zcb = _connect.CCPUInfo_fRISCV_Zcb
    fRISCV_Zcmp = _connect.CCPUInfo_fRISCV_Zcmp
    fRISCV_Zcmt = _connect.CCPUInfo_fRISCV_Zcmt
    fRISCV_Zbkb = _connect.CCPUInfo_fRISCV_Zbkb
    fRISCV_Zbkc = _connect.CCPUInfo_fRISCV_Zbkc
    fRISCV_Zbkx = _connect.CCPUInfo_fRISCV_Zbkx
    fRISCV_Zknd = _connect.CCPUInfo_fRISCV_Zknd
    fRISCV_Zkne = _connect.CCPUInfo_fRISCV_Zkne
    fRISCV_Zknh = _connect.CCPUInfo_fRISCV_Zknh
    fRISCV_Zksed = _connect.CCPUInfo_fRISCV_Zksed
    fRISCV_Zksh = _connect.CCPUInfo_fRISCV_Zksh
    fRISCV_Zicbom = _connect.CCPUInfo_fRISCV_Zicbom
    fRISCV_Zicboz = _connect.CCPUInfo_fRISCV_Zicboz
    fRISCV_Zicbop = _connect.CCPUInfo_fRISCV_Zicbop
    fRISCV_Zfbfmin = _connect.CCPUInfo_fRISCV_Zfbfmin
    EFeature_TriCore_Virtualization = _connect.CCPUInfo_EFeature_TriCore_Virtualization
    EFeature_PPC_fCACHE_HARVARD = _connect.CCPUInfo_EFeature_PPC_fCACHE_HARVARD
    EFeature_PPC_fCACHE_INSTR_ONLY = _connect.CCPUInfo_EFeature_PPC_fCACHE_INSTR_ONLY
    EFeature_PPC_fCACHE_UNIFIED = _connect.CCPUInfo_EFeature_PPC_fCACHE_UNIFIED
    EFeature_PPC_fCACHE_NONE = _connect.CCPUInfo_EFeature_PPC_fCACHE_NONE
    MAX_FEATURES = _connect.CCPUInfo_MAX_FEATURES
    m_adwFeatures = property(_connect.CCPUInfo_m_adwFeatures_get, _connect.CCPUInfo_m_adwFeatures_set)

    def SetFeature(self, nFeature, bSet):
        return _connect.CCPUInfo_SetFeature(self, nFeature, bSet)

    def IsFeature(self, nFeature):
        r"""Returns true, if feature is present."""
        return _connect.CCPUInfo_IsFeature(self, nFeature)
    m_strExtension = property(_connect.CCPUInfo_m_strExtension_get, _connect.CCPUInfo_m_strExtension_set)

    def __init__(self):
        _connect.CCPUInfo_swiginit(self, _connect.new_CCPUInfo())
    __swig_destroy__ = _connect.delete_CCPUInfo

# Register CCPUInfo in _connect:
_connect.CCPUInfo_swigregister(CCPUInfo)
mempMode0 = _connect.mempMode0
mempMode1 = _connect.mempMode1
mempNum = _connect.mempNum
mempISANum = _connect.mempISANum
mempISAMask = _connect.mempISAMask
mempISA0 = _connect.mempISA0
mempISA1 = _connect.mempISA1
mempISA2 = _connect.mempISA2
mempISA3 = _connect.mempISA3
cpumodeAll = _connect.cpumodeAll
maCODE31 = _connect.maCODE31
r"""CODE memory space"""
maDATA31 = _connect.maDATA31
r"""DATA memory space"""
maIDATA31 = _connect.maIDATA31
r"""IDATA memory space"""
maBDATA31 = _connect.maBDATA31
r"""BDATA memory space"""
maXDATA31 = _connect.maXDATA31
r"""XDATA memory space"""
maPDATA31 = _connect.maPDATA31
r"""PDATA memory space"""
maSFR31 = _connect.maSFR31
r"""SFR memory space"""
mempModePowerPCVLE = _connect.mempModePowerPCVLE
mempISA_PPC_PPC = _connect.mempISA_PPC_PPC
mempISA_PPC_VLE = _connect.mempISA_PPC_VLE
maVirtualPowerPC = _connect.maVirtualPowerPC
r"""default memory space"""
maPPhysicalPowerPC = _connect.maPPhysicalPowerPC
r"""for SDK compatibility"""
maSPRPowerPC = _connect.maSPRPowerPC
r"""Special Purpose Registers, use mtspr"""
maDCRPowerPC = _connect.maDCRPowerPC
r"""Device Control Registers, use mtdcr"""
maTLBPowerPC = _connect.maTLBPowerPC
r"""TLB Entries, use tlbre/tlbwe"""
maPMRPowerPC = _connect.maPMRPowerPC
r"""Performance Monitor registers"""
mempModeARMThumb = _connect.mempModeARMThumb
mempISA_ARM_A32 = _connect.mempISA_ARM_A32
mempISA_ARM_T = _connect.mempISA_ARM_T
mempISA_ARM_A64 = _connect.mempISA_ARM_A64
cpumodeUser = _connect.cpumodeUser
cpumodeFIQ = _connect.cpumodeFIQ
cpumodeIRQ = _connect.cpumodeIRQ
cpumodeSupervisor = _connect.cpumodeSupervisor
cpumodeAbortMode = _connect.cpumodeAbortMode
cpumodeSystem = _connect.cpumodeSystem
cpumodeUndefined = _connect.cpumodeUndefined
maVirtualARM = _connect.maVirtualARM
r"""current virtual access"""
maIPA_ARM = _connect.maIPA_ARM
r"""non-secure intermediate PA"""
maCPARM = _connect.maCPARM
r"""Coprocessor access"""
maVFPARM = _connect.maVFPARM
r"""floating point, 32-bit MAU"""
maSP_ARM = _connect.maSP_ARM
r"""secure physical (same value as old maPhysicalARM)"""
maNP_ARM = _connect.maNP_ARM
r"""non-secure physical"""
maEL1S_ARM = _connect.maEL1S_ARM
r"""virtual EL1 secure"""
maEL1N_ARM = _connect.maEL1N_ARM
r"""virtual EL1 non-secure"""
maEL2N_ARM = _connect.maEL2N_ARM
r"""virtual EL2 non-secure"""
maEL3S_ARM = _connect.maEL3S_ARM
r"""virtual EL3 secure"""
maSCP_ARM = _connect.maSCP_ARM
r"""CP_ARM secure"""
maNCP_ARM = _connect.maNCP_ARM
r"""CP_ARM non-secure"""
maCPARM_Index = _connect.maCPARM_Index
r"""address is an index into a table of AArch registers"""
maPL1S_ARM = _connect.maPL1S_ARM
r"""virtual PL1 secure"""
maPL1N_ARM = _connect.maPL1N_ARM
r"""virtual PL1 non-secure"""
maPL2N_ARM = _connect.maPL2N_ARM
r"""virtual PL2 non-secure"""
maPhysicalV850 = _connect.maPhysicalV850
r"""default memory area"""
maSysRegV850 = _connect.maSysRegV850
r"""system register access"""
maSCMTPU = _connect.maSCMTPU
maSPRAMTPU = _connect.maSPRAMTPU
maVirtualGTM = _connect.maVirtualGTM
maVirtualTriCore = _connect.maVirtualTriCore
r"""default memory area"""
maPhysicalTriCore = _connect.maPhysicalTriCore
r"""for SDK compatibility"""
maVirtualSPT = _connect.maVirtualSPT
maOP_RAM = _connect.maOP_RAM
maTW_RAM = _connect.maTW_RAM
maVirtualRISCV = _connect.maVirtualRISCV
maVFPRISCV = _connect.maVFPRISCV
maCSRRISCV = _connect.maCSRRISCV
maVirtualARC = _connect.maVirtualARC
r"""default memory area"""
maAuxilliaryARC = _connect.maAuxilliaryARC
r"""AUX registers"""
maVV_ARC = _connect.maVV_ARC
r"""vector registers"""
maVP_ARC = _connect.maVP_ARC
r"""vector predicates"""
maVirtualx86 = _connect.maVirtualx86
maVirtualXtensa = _connect.maVirtualXtensa
r"""Default memory area"""
maSpecialRegistersXtensa = _connect.maSpecialRegistersXtensa
r"""Special registers"""
maUserRegistersXtensa = _connect.maUserRegistersXtensa
r"""User  registers"""
maARx = _connect.maARx
r"""Absolute registers"""
maPhysical78k = _connect.maPhysical78k
maER78k = _connect.maER78k
maVirtualTIDSP = _connect.maVirtualTIDSP
maCPUTIDSP = _connect.maCPUTIDSP
maCodeTIC28x = _connect.maCodeTIC28x
maDataTIC28x = _connect.maDataTIC28x
maIOTIC28x = _connect.maIOTIC28x
maPeripheralTIC28x = _connect.maPeripheralTIC28x
maVirtualTIC29x = _connect.maVirtualTIC29x
MAX_MEMORY_AREAS = _connect.MAX_MEMORY_AREAS
class IConnectUMI(object):
    r"""This interface defines methods for controlling UMI devices"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxOperation = _connect.IConnectUMI_ndxOperation
    ndxNum = _connect.IConnectUMI_ndxNum
    wOpWrite = _connect.IConnectUMI_wOpWrite
    r"""write the data/file"""
    wOpRead = _connect.IConnectUMI_wOpRead
    r"""read the data"""
    wOpFlush = _connect.IConnectUMI_wOpFlush
    r"""program the device from the intermediate cache"""
    wOpErase = _connect.IConnectUMI_wOpErase
    r"""erase the specified region"""
    wOpVerify = _connect.IConnectUMI_wOpVerify
    r"""device contents are compared to cache"""
    wOpBlankCheck = _connect.IConnectUMI_wOpBlankCheck
    r"""device contents are compared to the empty value"""
    wOpSecure = _connect.IConnectUMI_wOpSecure
    r"""secure the device/sector"""
    wOpUnsecure = _connect.IConnectUMI_wOpUnsecure
    r"""unsecure secure the device/sector"""
    wOpSecureCheck = _connect.IConnectUMI_wOpSecureCheck
    r"""check if security is set on device/sector"""
    wOpReadHASH = _connect.IConnectUMI_wOpReadHASH
    r"""read the murmur hash of the data"""
    wOpReadPgmState = _connect.IConnectUMI_wOpReadPgmState
    r"""reads current device programed state"""
    wOpGetLastError = _connect.IConnectUMI_wOpGetLastError
    r"""reads last error message"""
    wOpFill = _connect.IConnectUMI_wOpFill
    r"""fill device with empty value"""
    wOpGetID = _connect.IConnectUMI_wOpGetID
    r"""get device ID"""
    wOpMask = _connect.IConnectUMI_wOpMask
    r"""mask to extract the operation mode from dwFlags"""
    wScopeDevice = _connect.IConnectUMI_wScopeDevice
    r"""the operation scope is entire device, otherwise aAddress and aSize are used"""
    wCheckIfOpAvailable = _connect.IConnectUMI_wCheckIfOpAvailable
    r"""check only of operation is available"""
    wProgDevice = _connect.IConnectUMI_wProgDevice
    r"""program the data into device immediately"""
    wProgCache = _connect.IConnectUMI_wProgCache
    r"""program the data into intermediate cache"""
    wProgMask = _connect.IConnectUMI_wProgMask
    r"""mask to extract the program mode from dwFlags"""
    wOverrideSafety = _connect.IConnectUMI_wOverrideSafety
    r"""perform operation even if it is disabled in configuration (e.g. Erase)"""
    wFileFormatAuto = _connect.IConnectUMI_wFileFormatAuto
    r"""auto detect file format"""
    wFileFormatBin = _connect.IConnectUMI_wFileFormatBin
    r"""binary format"""
    wFileFormatS = _connect.IConnectUMI_wFileFormatS
    r"""Motorola S"""
    wFileFormatHex = _connect.IConnectUMI_wFileFormatHex
    r"""Intel Hex"""
    wFileFormatMask = _connect.IConnectUMI_wFileFormatMask
    r"""mask to extract the format from dwFlags"""

    def Operation(self, dwFlags, dwDevice, aAddress, aSize, pbyData, pszFileName):
        r"""
        Writes data to the device or intermediate cache


        :type dwFlags: int
        :param dwFlags: EOperationFlags
        :type dwDevice: int
        :param dwDevice: index of the UMI device
        :type aAddress: int
        :param aAddress: address to write/read/hash/erase/secure or offset to add to the address in the file
        :type aSize: int
        :param aSize: size of the data to write/read/hash/erase/secure, ignored if file is programmed
        :type pbyData: BYTE
        :param pbyData: pointer to the buffer to be written, read, receive HASH or file to load
        :type pszFileName: string
        :param pszFileName: path to the file to program
        """
        return _connect.IConnectUMI_Operation(self, dwFlags, dwDevice, aAddress, aSize, pbyData, pszFileName)
    HASH_SIZE = _connect.IConnectUMI_HASH_SIZE
    __swig_destroy__ = _connect.delete_IConnectUMI

# Register IConnectUMI in _connect:
_connect.IConnectUMI_swigregister(IConnectUMI)
c_max_bits_per_MAU = cvar.c_max_bits_per_MAU
c_max_bytes_per_MAU = cvar.c_max_bytes_per_MAU
IID_IConnectUMI = cvar.IID_IConnectUMI

indxEclipse = _connect.indxEclipse
class SInfo(object):
    r"""This struct contains general target info."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwNumRegisters = property(_connect.SInfo_m_dwNumRegisters_get, _connect.SInfo_m_dwNumRegisters_set, doc=r"""the number of registers on the target""")

    def __init__(self):
        _connect.SInfo_swiginit(self, _connect.new_SInfo())
    __swig_destroy__ = _connect.delete_SInfo

# Register SInfo in _connect:
_connect.SInfo_swigregister(SInfo)
IID_IConnectEclipse = cvar.IID_IConnectEclipse

class SRegisterInfo(object):
    r"""This structure contains information about register."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_szRegName = property(_connect.SRegisterInfo_m_szRegName_get, _connect.SRegisterInfo_m_szRegName_set, doc=r"""register name, for example 'R0'""")
    m_Type = property(_connect.SRegisterInfo_m_Type_get, _connect.SRegisterInfo_m_Type_set, doc=r"""register type, usually unsignd int""")

    def __init__(self):
        _connect.SRegisterInfo_swiginit(self, _connect.new_SRegisterInfo())
    __swig_destroy__ = _connect.delete_SRegisterInfo

# Register SRegisterInfo in _connect:
_connect.SRegisterInfo_swigregister(SRegisterInfo)
class IDisassemblyLine(object):
    r"""This interface provides information about one disassembly line."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Address(self):
        r"""Returns address of disassembly line."""
        return _connect.IDisassemblyLine_Address(self)

    def OpCode(self):
        r"""Returns disassembly op code."""
        return _connect.IDisassemblyLine_OpCode(self)

    def OpCodeArgs(self):
        r"""Returns disassembly op code arguments."""
        return _connect.IDisassemblyLine_OpCodeArgs(self)

    def FileName(self):
        r"""Returns the name of the source file, which generated this disassembly line."""
        return _connect.IDisassemblyLine_FileName(self)

    def LineNumber(self):
        r"""Returns the source line number in the source file, which generated this disassembly line."""
        return _connect.IDisassemblyLine_LineNumber(self)

    def FunctionName(self):
        r"""Returns the name of the function, to which this disassembly line belongs to"""
        return _connect.IDisassemblyLine_FunctionName(self)

    def FunctionOffset(self):
        
        return _connect.IDisassemblyLine_FunctionOffset(self)

    def IsBranch(self):
        r"""Returns true if the op-code is a branch"""
        return _connect.IDisassemblyLine_IsBranch(self)

    def IsCall(self):
        r"""Returns true if the op-code is a call"""
        return _connect.IDisassemblyLine_IsCall(self)

    def IsIndirect(self):
        r"""Returns true if the op-code is an indirect branch. BranchTarget is not valid"""
        return _connect.IDisassemblyLine_IsIndirect(self)

    def IsConditional(self):
        r"""Returns true if the op-code is conditional"""
        return _connect.IDisassemblyLine_IsConditional(self)

    def Length(self):
        r"""Returns the length of the op-code"""
        return _connect.IDisassemblyLine_Length(self)

    def BranchTarget(self):
        r"""Returns the (direct)branch target address"""
        return _connect.IDisassemblyLine_BranchTarget(self)

    def Flags(self):
        r"""
        Returns instruction NDisassemble::EINST_Flags. Prefer calling `IsBranch(), IsCall(), ...`
        methods instead of this one.
        """
        return _connect.IDisassemblyLine_Flags(self)

    def INST_TYPE(self):
        r"""Returns instruction NDisassemble::EINST_TYPE."""
        return _connect.IDisassemblyLine_INST_TYPE(self)

    def INST_TYPE_CPU(self):
        r"""Returns instruction NDisassemble::EINST_TYPE_CPU."""
        return _connect.IDisassemblyLine_INST_TYPE_CPU(self)
    __swig_destroy__ = _connect.delete_IDisassemblyLine

# Register IDisassemblyLine in _connect:
_connect.IDisassemblyLine_swigregister(IDisassemblyLine)
class IDisassemblyBlock(object):
    r"""
    This interface provides disassembly information. To get one block
    of disassembly information, call IConnectEclipse::GetDisassemblySrc()
    or IConnectEclipse::GetDisassemblyAdr().


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Lines(self):
        r"""Returns the vector of disassembly lines: IVector <iEclipse::IDisassemblyLine>."""
        return _connect.IDisassemblyBlock_Lines(self)
    __swig_destroy__ = _connect.delete_IDisassemblyBlock

# Register IDisassemblyBlock in _connect:
_connect.IDisassemblyBlock_swigregister(IDisassemblyBlock)
class IVariable(object):
    r"""This interface provides information about a program variable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        r"""
        Returns variable name without any decoration (module, partition, ...),
        for example 'iCounter'.
        """
        return _connect.IVariable_Name(self)

    def QualifiedName(self):
        r"""
        Returns variable qualified name used for display. This name is not fully
        qualified, but depends on setting in winiDEA (for example just enough decorated
        to be unique).
        """
        return _connect.IVariable_QualifiedName(self)

    def TypeName(self):
        r"""Returns variable type name."""
        return _connect.IVariable_TypeName(self)

    def NumBytes(self):
        r"""Reserved, currently always returns 0."""
        return _connect.IVariable_NumBytes(self)
    tSimple = _connect.IVariable_tSimple
    r"""simple type"""
    tPointer = _connect.IVariable_tPointer
    r"""pointer"""
    tReference = _connect.IVariable_tReference
    r"""reference"""
    tArray = _connect.IVariable_tArray
    r"""array"""
    tStruct = _connect.IVariable_tStruct
    r"""structure"""
    tUnion = _connect.IVariable_tUnion
    r"""union"""
    tClass = _connect.IVariable_tClass
    r"""class"""
    tFunction = _connect.IVariable_tFunction
    r"""function"""

    def Type(self):
        r"""Returns variable type, as enumeration type IVariable::EType."""
        return _connect.IVariable_Type(self)

    def ArrayDimension(self):
        r"""Returns array dimension for arrays, 0 for all other variables."""
        return _connect.IVariable_ArrayDimension(self)

    def Module(self):
        r"""Returns index of the module, where the variable is located."""
        return _connect.IVariable_Module(self)

    def Scope(self):
        r"""
         Returns variable scope - e.g. class name.
        Since: 9.11.26
        """
        return _connect.IVariable_Scope(self)

    def ArrayFirstElement(self):
        r"""
         Returns first element index. 0 for C arrays.
        Since: 9.12.102
        """
        return _connect.IVariable_ArrayFirstElement(self)

    def MemArea(self):
        r"""
         Returns the memory area
        Since: 9.12.171
        """
        return _connect.IVariable_MemArea(self)

    def Address(self):
        r"""
         Returns the starting address
        Since: 9.12.171
        """
        return _connect.IVariable_Address(self)

    def Size(self):
        r"""
         Returns the size
        Since: 9.12.171
        """
        return _connect.IVariable_Size(self)

    def GetIType(self):
        r"""
         Returns extended type info
        Since: 9.12.268
        """
        return _connect.IVariable_GetIType(self)
    __swig_destroy__ = _connect.delete_IVariable

# Register IVariable in _connect:
_connect.IVariable_swigregister(IVariable)
class ICallee(object):
    r"""This interface provides information about a callee - a function called from a certain point."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CallSite(self):
        r"""Address of call instruction."""
        return _connect.ICallee_CallSite(self)

    def DirectCall(self):
        r"""true if the call is a direct call."""
        return _connect.ICallee_DirectCall(self)

    def Callee(self):
        r"""Address of the called function."""
        return _connect.ICallee_Callee(self)
    __swig_destroy__ = _connect.delete_ICallee

# Register ICallee in _connect:
_connect.ICallee_swigregister(ICallee)
class ICaller(object):
    r"""This interface provides information about a caller - a function/address which calls a certain point/function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CallSite(self):
        r"""Address of call instruction."""
        return _connect.ICaller_CallSite(self)
    __swig_destroy__ = _connect.delete_ICaller

# Register ICaller in _connect:
_connect.ICaller_swigregister(ICaller)
class IFunction(object):
    r"""This interface provides information about a function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        r"""
        Returns function name without any decoration (module, partition, ...),
        for example 'max'.
        """
        return _connect.IFunction_Name(self)

    def Scope(self):
        r"""Returns function scope - e.g. class name."""
        return _connect.IFunction_Scope(self)

    def ReturnTypeName(self):
        r"""Returns function's return type."""
        return _connect.IFunction_ReturnTypeName(self)

    def Module(self):
        r"""Returns index of the module, where the function is located."""
        return _connect.IFunction_Module(self)

    def Parameters(self):
        r"""
         Returns the list of parameters.
        Since: 9.10.100
        """
        return _connect.IFunction_Parameters(self)

    def Variables(self):
        r"""
         Returns the list of local variables.
        Since: 9.12.98
        """
        return _connect.IFunction_Variables(self)

    def QualifiedName(self):
        r"""
        Returns function qualified name used for display. This name is not fully
        qualified, but depends on setting in winiDEA (for example just enough decorated
        to be unique).

        Since: 9.12.163
        """
        return _connect.IFunction_QualifiedName(self)

    def MemArea(self):
        r"""
         Returns the memory area
        Since: 9.12.171
        """
        return _connect.IFunction_MemArea(self)

    def Address(self):
        r"""
         Returns the starting address
        Since: 9.12.171
        """
        return _connect.IFunction_Address(self)

    def Size(self):
        r"""
         Returns the size
        Since: 9.12.171
        """
        return _connect.IFunction_Size(self)

    def SignatureName(self):
        r"""
         Returns the signature name - qualified with parameters
        Since: 9.12.194
        """
        return _connect.IFunction_SignatureName(self)

    def HasVarParams(self):
        r"""
         Returns true if function accepts variable number of parameters
        Since: 9.12.270
        """
        return _connect.IFunction_HasVarParams(self)

    def Callees(self):
        r"""
         Returns the list of callees
        Since: 9.12.272
        """
        return _connect.IFunction_Callees(self)

    def Callers(self):
        r"""
         Returns the list of callers
        Since: 9.12.272
        """
        return _connect.IFunction_Callers(self)
    __swig_destroy__ = _connect.delete_IFunction

# Register IFunction in _connect:
_connect.IFunction_swigregister(IFunction)
class IType(object):
    r"""
    This interface provides information about a type.
    Since: 9.11.15
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeName(self):
        r"""Returns name of type."""
        return _connect.IType_TypeName(self)

    def Type(self):
        r"""Returns type of type."""
        return _connect.IType_Type(self)
    __swig_destroy__ = _connect.delete_IType

# Register IType in _connect:
_connect.IType_swigregister(IType)
class ITypedef(object):
    r"""
    This interface provides information about a typedef.
    Since: 9.11.15
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        r"""Returns name of typedef"""
        return _connect.ITypedef_Name(self)

    def TypeName(self):
        r"""Returns name of type"""
        return _connect.ITypedef_TypeName(self)
    __swig_destroy__ = _connect.delete_ITypedef

# Register ITypedef in _connect:
_connect.ITypedef_swigregister(ITypedef)
class IMacro(object):
    r"""
    This interface provides information about a Macro.
    Since: 9.12.128
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        r"""Returns name of Macro"""
        return _connect.IMacro_Name(self)

    def Value(self):
        r"""Returns value of macro"""
        return _connect.IMacro_Value(self)
    __swig_destroy__ = _connect.delete_IMacro

# Register IMacro in _connect:
_connect.IMacro_swigregister(IMacro)
class IInstruction(object):
    r"""
    This interface provides information about an instruction
    Since: 9.12.171
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    flFlowSequential = _connect.IInstruction_flFlowSequential
    r"""sequential instruction"""
    flFlowDirectJump = _connect.IInstruction_flFlowDirectJump
    r"""a direct change of flow. m_aJumpTarget is valid"""
    flFlowIndirectJump = _connect.IInstruction_flFlowIndirectJump
    r"""an indirect change of flow"""
    flFlowMask = _connect.IInstruction_flFlowMask
    flConditional = _connect.IInstruction_flConditional
    r"""instruction is conditional"""
    flCall = _connect.IInstruction_flCall
    r"""call to a routine which will return and resume execution after this instruction"""
    flRelative = _connect.IInstruction_flRelative
    r"""valid for flFlowDirectJump - if code is offset, the m_aJumpTarget will be offset too. original m_aJumpTarget is NOT relative to m_aAddress, but is already real jump target"""
    flWrite = _connect.IInstruction_flWrite
    r"""execution of opcode will generate a write access"""
    flRead = _connect.IInstruction_flRead
    r"""execution of opcode will generate a read access"""

    def OpCode(self):
        r"""returns op-code string. A tab character is used to separate op-code from arguments"""
        return _connect.IInstruction_OpCode(self)

    def Address(self):
        r"""returns Address of instruction"""
        return _connect.IInstruction_Address(self)

    def JumpTarget(self):
        r"""returns JumpTarget of instruction"""
        return _connect.IInstruction_JumpTarget(self)

    def Size(self):
        r"""returns length of instruction in MAUs"""
        return _connect.IInstruction_Size(self)

    def Flags(self):
        r"""returns flXXXX masked flags"""
        return _connect.IInstruction_Flags(self)

    def MemAccessSize(self):
        r"""for flWrite|flRead size of access in MAUs"""
        return _connect.IInstruction_MemAccessSize(self)
    __swig_destroy__ = _connect.delete_IInstruction

# Register IInstruction in _connect:
_connect.IInstruction_swigregister(IInstruction)
class IStackFrame(object):
    r"""This interface provides information about a stack frame."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Address(self):
        r"""Returns address of a stack frame."""
        return _connect.IStackFrame_Address(self)

    def MemoryArea(self):
        r"""Returns memory area of a stack frame."""
        return _connect.IStackFrame_MemoryArea(self)

    def FileName(self):
        r"""Returns name of file, where the execution point is located."""
        return _connect.IStackFrame_FileName(self)

    def LineNumber(self):
        r"""Returns the source code line number, where the execution point is located."""
        return _connect.IStackFrame_LineNumber(self)

    def FunctionName(self):
        r"""Returns the name of a function. Deprecated: use Function()"""
        return _connect.IStackFrame_FunctionName(self)

    def Variables(self):
        r"""Returns local variables of this stack frame."""
        return _connect.IStackFrame_Variables(self)

    def Arguments(self):
        r"""Returns function arguments. Deprecated: use Function()"""
        return _connect.IStackFrame_Arguments(self)

    def Function(self):
        r"""
         Returns function information. Can return NULL if no function is found at the call site Address
        Since: 9.11.35
        """
        return _connect.IStackFrame_Function(self)

    def Partition(self):
        r"""
         Returns Partition index.
        Since: 9.12.34
        """
        return _connect.IStackFrame_Partition(self)
    __swig_destroy__ = _connect.delete_IStackFrame

# Register IStackFrame in _connect:
_connect.IStackFrame_swigregister(IStackFrame)
class IStackFrameInfo(object):
    r"""This interface provides access to stack frames."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def StackFrames(self):
        r"""Returns a list of the current stack frames."""
        return _connect.IStackFrameInfo_StackFrames(self)
    __swig_destroy__ = _connect.delete_IStackFrameInfo

# Register IStackFrameInfo in _connect:
_connect.IStackFrameInfo_swigregister(IStackFrameInfo)
class IExpressionType(object):
    r"""
    This interface provides information about expressions. Use method
    IEclipse::GetExpressionType() to get instance of this interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Expression(self):
        r"""Returns information about expression."""
        return _connect.IExpressionType_Expression(self)

    def Children(self):
        r"""
        Returns children of an expression as IVector <iEclipse::IVariable>.
             For example, if expression refers
             to structure, members of the structure are returned.
        """
        return _connect.IExpressionType_Children(self)
    __swig_destroy__ = _connect.delete_IExpressionType

# Register IExpressionType in _connect:
_connect.IExpressionType_swigregister(IExpressionType)
class IModule(object):
    r"""This interface provides information about a module."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        r"""Returns the name of a module, for example 'main.c'."""
        return _connect.IModule_Name(self)

    def Path(self):
        r"""Returns the path of the module and module name, for example 'src\common\main.c'."""
        return _connect.IModule_Path(self)
    __swig_destroy__ = _connect.delete_IModule

# Register IModule in _connect:
_connect.IModule_swigregister(IModule)
class IGlobals(object):
    r"""
    This interface provides information about global members of a program.
    Use method IConnectEclipse::GetGlobals() to get isntance of object with
    this interface. Only information requested by flags of function
    IConnectEclipse::GetGlobals() is available. For example:

    IConnectEclipse::GetGlobals(gvfVariables, ...)

    After this call only IGlobals::Variables() will return data, other
    calls will return empty vectors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Variables(self):
        r"""Returns the list of global variables."""
        return _connect.IGlobals_Variables(self)

    def Labels(self):
        r"""Returns the list of global labels."""
        return _connect.IGlobals_Labels(self)

    def Modules(self):
        r"""Returns the list of modules (source files, which generate code)."""
        return _connect.IGlobals_Modules(self)

    def Functions(self):
        r"""Returns the list of functions."""
        return _connect.IGlobals_Functions(self)

    def Types(self):
        r"""
         Returns the list of types
        Since: 9.11.15
        """
        return _connect.IGlobals_Types(self)

    def Typedefs(self):
        r"""
         Returns the list of typedefs
        Since: 9.11.15
        """
        return _connect.IGlobals_Typedefs(self)

    def Macros(self):
        r"""
         Returns the list of macros
        Since: 9.12.128
        """
        return _connect.IGlobals_Macros(self)

    def Instructions(self):
        r"""
         Returns the list of instructions
        Since: 9.12.171
        """
        return _connect.IGlobals_Instructions(self)
    __swig_destroy__ = _connect.delete_IGlobals

# Register IGlobals in _connect:
_connect.IGlobals_swigregister(IGlobals)
class IPartition(object):
    r"""
    This interface provides information about partition. Partitions are
    download files (for example elf files). Call method IConnectEclipse::GetConfiguration
    to get instance of interface IConfiguration, which provides information
    about partitions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        r"""Returns partition name."""
        return _connect.IPartition_Name(self)

    def Path(self):
        r"""Returns partition path."""
        return _connect.IPartition_Path(self)
    __swig_destroy__ = _connect.delete_IPartition

# Register IPartition in _connect:
_connect.IPartition_swigregister(IPartition)
class IConfiguration(object):
    r"""
    This interface provides info about program configuration. Call
    method IEclipse::GetConfiguration() to get instance of this interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Partitions(self):
        r"""
        Returns vector of all partitions (download files) in the program
        as IVector <iEclipse::IPartition>.
        """
        return _connect.IConfiguration_Partitions(self)
    __swig_destroy__ = _connect.delete_IConfiguration

# Register IConfiguration in _connect:
_connect.IConfiguration_swigregister(IConfiguration)
class ISFRValueMap(object):
    r"""This interface provides value of a SFR."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def String(self):
        r"""Returns SFR's value as a string, for example names of bits."""
        return _connect.ISFRValueMap_String(self)

    def Value(self):
        r"""Returns SFR's value."""
        return _connect.ISFRValueMap_Value(self)

    def Description(self):
        r"""Returns description for this value."""
        return _connect.ISFRValueMap_Description(self)
    __swig_destroy__ = _connect.delete_ISFRValueMap

# Register ISFRValueMap in _connect:
_connect.ISFRValueMap_swigregister(ISFRValueMap)
class ISFR(object):
    r"""This interface provides information about SFR."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Handle(self):
        r"""
        Returns SFR handle. Use this handle to obtain value in calls
             to IConnectEclipse::SFRValue().
        """
        return _connect.ISFR_Handle(self)

    def HasValue(self):
        r"""If 0 (`FALSE`) is returned, it's a SFR group."""
        return _connect.ISFR_HasValue(self)

    def Name(self):
        r"""Returns name of a SFR or SFR group."""
        return _connect.ISFR_Name(self)

    def BitSize(self):
        r"""Returns size of a SFR in bits."""
        return _connect.ISFR_BitSize(self)
    pRead = _connect.ISFR_pRead
    r"""we can read the register"""
    pWrite = _connect.ISFR_pWrite
    r"""we can write to the register"""
    pSubReg = _connect.ISFR_pSubReg
    r"""sub-field of a parent register"""
    pFloat = _connect.ISFR_pFloat
    r"""it is a floating point register"""

    def Properties(self):
        r"""Returns SFR properties. See enumeration ISFR::EProperties."""
        return _connect.ISFR_Properties(self)

    def ValueMaps(self):
        r"""Returns mappings of values to descriptive strings."""
        return _connect.ISFR_ValueMaps(self)

    def SFRs(self):
        r"""If this is a SFR group, this method returns its children as IVector <iEclipse::ISFR>."""
        return _connect.ISFR_SFRs(self)

    def Description(self):
        r"""Returns SFR description string."""
        return _connect.ISFR_Description(self)

    def Address(self):
        r"""Returns SFR address."""
        return _connect.ISFR_Address(self)

    def BitOffset(self):
        r"""Returns SFR bit offset from parent."""
        return _connect.ISFR_BitOffset(self)
    __swig_destroy__ = _connect.delete_ISFR

# Register ISFR in _connect:
_connect.ISFR_swigregister(ISFR)
class ICPUSFR(object):
    r"""
    This interface provides SFRs. Call method IEclipse::GetCPUSFR() to get
    instance of this interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CPUName(self):
        r"""Returns name of a CPU."""
        return _connect.ICPUSFR_CPUName(self)

    def SFRs(self):
        r"""Returns the list of SFRs as IVector <iEclipse::ISFR>."""
        return _connect.ICPUSFR_SFRs(self)

    def Property(self):
        r"""Returns the list of requested properties as IVector <iEclipse::IProperty>."""
        return _connect.ICPUSFR_Property(self)
    __swig_destroy__ = _connect.delete_ICPUSFR

# Register ICPUSFR in _connect:
_connect.ICPUSFR_swigregister(ICPUSFR)
sName = cvar.sName
iBitsPerMAU = cvar.iBitsPerMAU
iStart = cvar.iStart
iEnd = cvar.iEnd

class IConnectEclipse(object):
    r"""
    This interface is intended for iSYSTEM's implementation of Eclipse
    debugger. It is accessible only from C++ and Java wrapper of
    isystem.connect.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ndxGetInfo = _connect.IConnectEclipse_ndxGetInfo
    ndxGetRegisterInfo = _connect.IConnectEclipse_ndxGetRegisterInfo
    ndxGetDisassemblySrc = _connect.IConnectEclipse_ndxGetDisassemblySrc
    ndxGetDisassemblyAdr = _connect.IConnectEclipse_ndxGetDisassemblyAdr
    ndxGetStackFrameInfo = _connect.IConnectEclipse_ndxGetStackFrameInfo
    ndxSetStackFrameContext = _connect.IConnectEclipse_ndxSetStackFrameContext
    ndxGetExpressionType = _connect.IConnectEclipse_ndxGetExpressionType
    ndxGetGlobals = _connect.IConnectEclipse_ndxGetGlobals
    ndxGetConfiguration = _connect.IConnectEclipse_ndxGetConfiguration
    ndxGetCPUSFR = _connect.IConnectEclipse_ndxGetCPUSFR
    ndxSFRValue = _connect.IConnectEclipse_ndxSFRValue
    ndxRemoteFileOperation = _connect.IConnectEclipse_ndxRemoteFileOperation
    ndxNum = _connect.IConnectEclipse_ndxNum

    def GetInfo(self, dwFlags, pInfo):
        r"""
        Obtains general info about the target, not provided with other methods.

        :type dwFlags: int
        :param dwFlags: must be zero
        :type pInfo: :py:class:`SInfo`
        :param pInfo: pointer to the buffer info will be stored to
        """
        return _connect.IConnectEclipse_GetInfo(self, dwFlags, pInfo)

    def GetRegisterInfo(self, dwFlags, dwRegister, pInfo):
        r"""
        Provides info about a register. Only main registers can be accessed
        by this method. Use GetCPUSFR() and SFRValue() to access SFRs.

        :type dwFlags: int
        :param dwFlags: must be zero
        :type dwRegister: int
        :param dwRegister: register index. Call GetInfo() to get the number
                   of registers on the target. Index should be in range [0 .. SInfo.m_dwNumRegisters - 1]
        :type pInfo: :py:class:`SRegisterInfo`
        :param pInfo: pointer to the buffer info will be stored to

        :rtype: int
        :return: E_INVALIDARG if nRegister is too large
        """
        return _connect.IConnectEclipse_GetRegisterInfo(self, dwFlags, dwRegister, pInfo)
    dfSymNone = _connect.IConnectEclipse_dfSymNone
    r"""values only, for example 'bl 400002D4'"""
    dfSymSymbols = _connect.IConnectEclipse_dfSymSymbols
    r"""symbols only, for example 'bl targetInit'"""
    dfSymSymbolsAndValues = _connect.IConnectEclipse_dfSymSymbolsAndValues
    r"""symbols with values, for example 'bl targetInit (400002D4)'"""
    dfSymMask = _connect.IConnectEclipse_dfSymMask
    r"""mask"""
    dfNextNone = _connect.IConnectEclipse_dfNextNone
    r"""no NextInstruction is required"""
    dfNextImm = _connect.IConnectEclipse_dfNextImm
    r"""NextInstruction for immediate encoded targets required"""
    dfNextAll = _connect.IConnectEclipse_dfNextAll
    r"""NextInstruction for all instructions requires"""
    dfNextMask = _connect.IConnectEclipse_dfNextMask
    r"""mask"""
    sfiActiveFrameOnly = _connect.IConnectEclipse_sfiActiveFrameOnly
    r"""
    if this flag is set, then only the active frame
    is returned. This speeds up stack retrieval
    signifcantly.
    """
    sfiAbsolutePath = _connect.IConnectEclipse_sfiAbsolutePath
    r"""return absolute paths in IStackFrame"""

    def SetStackFrameContext(self, dwFlags, dwContext):
        r"""
        Sets active stack frame. Variables of the selected stack frame are
        available for evaluator (methods DataController::evaluate() and
        DataController::mofify()).

        :type dwFlags: int
        :param dwFlags: reserved, should be 0
        :type dwContext: int
        :param dwContext: index of the stack frame to be selected
        """
        return _connect.IConnectEclipse_SetStackFrameContext(self, dwFlags, dwContext)
    gvfVariables = _connect.IConnectEclipse_gvfVariables
    r"""retrieve global variables"""
    gvfLabels = _connect.IConnectEclipse_gvfLabels
    r"""retrieve labels"""
    gvfModules = _connect.IConnectEclipse_gvfModules
    r"""retrieve modules (source files, which generate code)"""
    gvfFunctions = _connect.IConnectEclipse_gvfFunctions
    r"""retrieve functions"""
    gvfTypes = _connect.IConnectEclipse_gvfTypes
    r"""retrieve types"""
    gvfTypedefs = _connect.IConnectEclipse_gvfTypedefs
    r"""retrieve typedefs"""
    gvfMacros = _connect.IConnectEclipse_gvfMacros
    r"""retrieve typedefs"""
    gvfInstructions = _connect.IConnectEclipse_gvfInstructions
    r"""retrieve instructions"""
    gvfMask = _connect.IConnectEclipse_gvfMask
    r"""the mask for gvf flags"""
    gvfSortAddress = _connect.IConnectEclipse_gvfSortAddress
    r"""sort returned items by address"""
    gvfSortName = _connect.IConnectEclipse_gvfSortName
    r"""sort returned items by name"""
    gvfSortMask = _connect.IConnectEclipse_gvfSortMask
    r"""the mask for gvfSort flags"""
    gvfPartitionSpecify = _connect.IConnectEclipse_gvfPartitionSpecify
    r"""use dwPartition"""
    gvfPartitionDefault = _connect.IConnectEclipse_gvfPartitionDefault
    r"""use winIDEA default debug partition"""
    gvfPartitionCurrent = _connect.IConnectEclipse_gvfPartitionCurrent
    r"""use winIDEA current partition"""
    gvfPartitionMask = _connect.IConnectEclipse_gvfPartitionMask
    r"""mask for gvfPartition flags"""
    gcsSFRs = _connect.IConnectEclipse_gcsSFRs
    r"""provide SFRs in the rpICPUSFR, via ICPUSFR::SFRs"""
    gcsGPRs = _connect.IConnectEclipse_gcsGPRs
    r"""provide GPRs in the rpICPUSFR, via ICPUSFR::Property /GPRs"""
    gcsAreas = _connect.IConnectEclipse_gcsAreas
    r"""provide SFRs in the rpICPUSFR, via ICPUSFR::Property /Areas"""
    svRead = _connect.IConnectEclipse_svRead
    r"""read value"""
    svWrite = _connect.IConnectEclipse_svWrite
    r"""set value"""
    svWriteThenRead = _connect.IConnectEclipse_svWriteThenRead
    r"""sometime the read value is not the same as the written one"""
    svNoRefresh = _connect.IConnectEclipse_svNoRefresh
    r"""do not refresh IDE after write"""
    svErrorInfo = _connect.IConnectEclipse_svErrorInfo
    r"""provide error info"""

    def SFRValue(self, dwFlags, dwHandle, rValue, pszError, dwErrorLen):
        r"""
        Reads and writes values of SFRs.

        :type dwFlags: int
        :param dwFlags: see ESFRValue for possible values. Flags svNoRefresh and
                   svErrorInfo may be ORed with other flags.
        :type dwHandle: int
        :param dwHandle: handle of the SFR. Use method GetCPUSFR() to get handles
                   of SFRs.
        :type rValue: :py:class:`SValue`
        :param rValue: SFR value
        :type pszError: string
        :param pszError: error desrription
        :type dwErrorLen: int
        :param dwErrorLen: length of error description
        """
        return _connect.IConnectEclipse_SFRValue(self, dwFlags, dwHandle, rValue, pszError, dwErrorLen)
    rfoExists = _connect.IConnectEclipse_rfoExists
    r"""check existence. S_OK if exists, S_FALSE if not"""
    rfoDelete = _connect.IConnectEclipse_rfoDelete
    r"""Delete the file. S_OK if successful, S_FALSE if it didn't exist, E_FAIL if operation failed"""
    rfoRead = _connect.IConnectEclipse_rfoRead
    r"""reads the file, contents returned in pIBuffer"""
    rfoWrite = _connect.IConnectEclipse_rfoWrite
    r"""writes the file, contents passed in pIBuffer"""
    rfoOpMask = _connect.IConnectEclipse_rfoOpMask
    r"""mask to extract operation from dwFlags"""

    def RemoteFileOperation(self, dwFlags, pszFileName, rdwP1, rdwP2, pIBuffer):
        r"""
        Operates on a file

        :type dwFlags: int
        :param dwFlags: see rfoXXXX for possible values.
        :type pszFileName: string
        :param pszFileName: path to the file as seen by the server side
        :type rdwP1: int
        :param rdwP1: reserved SBZ
        :type rdwP2: int
        :param rdwP2: reserved SBZ
        :type pIBuffer: IBuffer
        :param pIBuffer: buffer object, must be allocated by the caller for Read (empty, filled by server) and Write Operations
        """
        return _connect.IConnectEclipse_RemoteFileOperation(self, dwFlags, pszFileName, rdwP1, rdwP2, pIBuffer)
    __swig_destroy__ = _connect.delete_IConnectEclipse

# Register IConnectEclipse in _connect:
_connect.IConnectEclipse_swigregister(IConnectEclipse)
class IProperty(object):
    r"""Structure containing tree of key/value pairs."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Key(self):
        r"""Returns name of the property."""
        return _connect.IProperty_Key(self)

    def Value(self):
        r"""Returns a string property."""
        return _connect.IProperty_Value(self)

    def Properties(self):
        r"""Returns sub properties."""
        return _connect.IProperty_Properties(self)
    __swig_destroy__ = _connect.delete_IProperty

# Register IProperty in _connect:
_connect.IProperty_swigregister(IProperty)
class CPropertyWrapper(object):
    r"""Wrapper for IProperty interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pIProperty):
        _connect.CPropertyWrapper_swiginit(self, _connect.new_CPropertyWrapper(pIProperty))

    def IsValid(self):
        r"""
        Returns true, if this object contains valid data (pointer to wrapped
        interface is not NULL).
        """
        return _connect.CPropertyWrapper_IsValid(self)

    def Find(self, pszKey):
        r"""Returns pointer to sub-property pszKey or NULL if not found."""
        return _connect.CPropertyWrapper_Find(self, pszKey)

    def Key(self):
        r"""Returns key of this property."""
        return _connect.CPropertyWrapper_Key(self)

    def Value(self):
        r"""Returns value of this property."""
        return _connect.CPropertyWrapper_Value(self)

    def PropertyValue(self, pszKey):
        r"""Returns value of a sub-property pszKey or NULL if not found."""
        return _connect.CPropertyWrapper_PropertyValue(self, pszKey)

    def NumProperties(self):
        r"""Returns the number of sub-properties."""
        return _connect.CPropertyWrapper_NumProperties(self)

    def Property(self, dwIndex):
        r"""Returns wrapper for sub-property, can be invalid."""
        return _connect.CPropertyWrapper_Property(self, dwIndex)
    __swig_destroy__ = _connect.delete_CPropertyWrapper

# Register CPropertyWrapper in _connect:
_connect.CPropertyWrapper_swigregister(CPropertyWrapper)
class IMenuItem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    tItem = _connect.IMenuItem_tItem
    tMenu = _connect.IMenuItem_tMenu
    tSeparator = _connect.IMenuItem_tSeparator

    def Type(self):
        return _connect.IMenuItem_Type(self)

    def Name(self):
        r"""Returns tItem or tMenu name."""
        return _connect.IMenuItem_Name(self)

    def Command(self):
        r"""Returns the command for the tItem."""
        return _connect.IMenuItem_Command(self)
    stateEnabled = _connect.IMenuItem_stateEnabled
    r"""Returns the state for the tItem."""
    stateChecked = _connect.IMenuItem_stateChecked
    stateDialogBox = _connect.IMenuItem_stateDialogBox
    r"""command will open dialog box"""

    def State(self):
        return _connect.IMenuItem_State(self)

    def MenuItems(self):
        r"""Returns the men subitems."""
        return _connect.IMenuItem_MenuItems(self)
    __swig_destroy__ = _connect.delete_IMenuItem

# Register IMenuItem in _connect:
_connect.IMenuItem_swigregister(IMenuItem)
class IMenuStructure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Root(self):
        return _connect.IMenuStructure_Root(self)

    def RootItem(self):
        return _connect.IMenuStructure_RootItem(self)
    __swig_destroy__ = _connect.delete_IMenuStructure

# Register IMenuStructure in _connect:
_connect.IMenuStructure_swigregister(IMenuStructure)
EMMUType_none = _connect.EMMUType_none
EMMUType_z1 = _connect.EMMUType_z1
EMMUType_z3 = _connect.EMMUType_z3
EMMUType_z4 = _connect.EMMUType_z4
EMMUType_z6 = _connect.EMMUType_z6
EMMUType_z7 = _connect.EMMUType_z7
class STLBEntry(object):
    r"""Contains TLB entries."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwMAS1 = property(_connect.STLBEntry_m_dwMAS1_get, _connect.STLBEntry_m_dwMAS1_set, doc=r"""MAS1""")
    m_dwMAS2 = property(_connect.STLBEntry_m_dwMAS2_get, _connect.STLBEntry_m_dwMAS2_set, doc=r"""MAS2""")
    m_dwMAS3 = property(_connect.STLBEntry_m_dwMAS3_get, _connect.STLBEntry_m_dwMAS3_set, doc=r"""MAS3""")
    m_dwMAS4 = property(_connect.STLBEntry_m_dwMAS4_get, _connect.STLBEntry_m_dwMAS4_set, doc=r"""MAS4, currently 0""")
    m_dwMAS6 = property(_connect.STLBEntry_m_dwMAS6_get, _connect.STLBEntry_m_dwMAS6_set, doc=r"""MAS5, currently 0""")

    def __init__(self):
        _connect.STLBEntry_swiginit(self, _connect.new_STLBEntry())
    __swig_destroy__ = _connect.delete_STLBEntry

# Register STLBEntry in _connect:
_connect.STLBEntry_swigregister(STLBEntry)
class SVariantData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_ulSize = property(_connect.SVariantData_m_ulSize_get, _connect.SVariantData_m_ulSize_set, doc=r"""size of the data structure""")

    def __init__(self):
        _connect.SVariantData_swiginit(self, _connect.new_SVariantData())
    __swig_destroy__ = _connect.delete_SVariantData

# Register SVariantData in _connect:
_connect.SVariantData_swigregister(SVariantData)
ofValNone = _connect.ofValNone
r"""operation other than set or get is performed"""
ofValString = _connect.ofValString
r"""single option, string type value"""
ofValInt = _connect.ofValInt
r"""single option, integer type value"""
ofValFloat = _connect.ofValFloat
r"""single option, float type value"""
ofValStringInt = _connect.ofValStringInt
r"""single option, string type, but string is int encoded for int types. No enum or TRUE/FALSE are used"""
ofValBuffer = _connect.ofValBuffer
r"""all options. pszOption not used, pszString is source/destination"""
ofValNode = _connect.ofValNode
r"""all options. pszOption is URL to the data node to be ser-des'd. JSON encode"""
ofValMask = _connect.ofValMask
ofDestIDE = _connect.ofDestIDE
r"""destination is the global IDE"""
ofDestDocument = _connect.ofDestDocument
r"""destination is a document"""
ofDestIOPEN = _connect.ofDestIOPEN
r"""destination is isystem.open plugin"""
ofDestPlugin = _connect.ofDestPlugin
r"""destination is isystem.plugin plugin"""
ofDestAuto = _connect.ofDestAuto
r"""destination is decoded from first /<dest>/ item"""
ofDestMask = _connect.ofDestMask
r"""destination mask"""
ofSet = _connect.ofSet
r"""set the option"""
ofGet = _connect.ofGet
r"""retrieve the option"""
ofAdd = _connect.ofAdd
r"""Add an item to a dynamic data, at index SOptionValue.m_dwInteger (-1 for append)"""
ofRemove = _connect.ofRemove
r"""remove an item from dynamic data, at index SOptionValue.m_dwInteger (-1 to remove all)"""
ofGetSize = _connect.ofGetSize
r"""return size of static or dynamic array in SOptionValue.m_dwInteger"""
ofCall = _connect.ofCall
r"""
    pszOption specifies the function path, SOptionValue.m_pszStringIn the input parameters, SOptionValue.m_pszStringOut the output parameters
    in/out parameters are encoded as a sequence of <name1>:<value1>, .., <nameN>:<valueN>
    """
ofGetType = _connect.ofGetType
r"""return type of container (IDataDescriptor::EContainer) in SOptionValue.m_dwInteger"""
ofGetEnum = _connect.ofGetEnum
r"""
    return enum values in SOptionValue.m_pszStringOut, format "<name1>":<value1>, .., "<nameN>":<valueN>>
    SOptionValue.m_dwInteger will be set to 1 if the URL is an enum, 0 otherwise
    """
ofMask = _connect.ofMask
r"""mask to extract set/get/add/remove option"""
ofCommit = _connect.ofCommit
r"""
    commit the options configured - this should be
    the ultimate call after a one or more ofSet calls. This
    flag should be ORed wit hone of ofDest... flags.
    Parameters ``pszScope`` and ``pszOption`` of IConnectIDE3::Option()
    may be NULL, while ``pValue`` should be initialized to 0, except
    out buffer, which receives error description in case of error.
    """
ofGetDescriptor = _connect.ofGetDescriptor
r"""get the data descriptor. returned in SOptionValue.m_pIDescriptor"""
ofGetMenu = _connect.ofGetMenu
r"""get the menu structure"""
ofGetObjectMask = _connect.ofGetObjectMask
r"""mask for getting objects (descriptor, menu)"""
ofUseDescriptor = _connect.ofUseDescriptor
r"""use the SOptionValue.m_pIDescriptor on input"""
ofReservedBit0 = _connect.ofReservedBit0
ofReservedBit1 = _connect.ofReservedBit1
ofReservedMask = _connect.ofReservedMask
r"""mask for reserved bits which can be used for internal purpose"""
ofExact = _connect.ofExact
r"""set this option exactly - no side effects (adjusting other options) should take place"""
OPTION_URL_DestIDE = _connect.OPTION_URL_DestIDE
r"""
    Example for using data creation

    SOptionValue OV; SVariantData_SetSize_ZeroInit(OV);
    // create a copy of data for "Analyzer Setup"
    LPCSTR pszDataName = "Analyzer Setup";
    pIXXX->Option(ofDataCreate | ofGetDescriptor, pszDataName, &OV);
    // remember descriptor
    IDescriptor * pID = OV.m_pIDescriptor;

    // manipulate data
    // ensure descriptor from copy of data
    OV.m_pIDescriptor = pID;
    pIXXX->Option(ofUseDescriptor | ofSet | ofValInt, "...", &OV);
    ...

    // release descriptor
    pID->Release();

    // apply data
    pIXXX->Option(ofDataApply,    pszDataName, &OV);

    // discard data
    pIXXX->Option(ofDataDestroy,  pszDataName, &OV);
    """
OPTION_URL_DestDocument = _connect.OPTION_URL_DestDocument
OPTION_URL_DestIOPEN = _connect.OPTION_URL_DestIOPEN
OPTION_URL_DestPlugin = _connect.OPTION_URL_DestPlugin
DD_INF_SEPARATOR = _connect.DD_INF_SEPARATOR
DD_INF_TOKEN_LEADER = _connect.DD_INF_TOKEN_LEADER
DD_INF_FILE_FILTER = _connect.DD_INF_FILE_FILTER
DD_INF_FILE_DEFEXT = _connect.DD_INF_FILE_DEFEXT
DD_INF_GUI = _connect.DD_INF_GUI
DD_INF_VALUE_FORMAT = _connect.DD_INF_VALUE_FORMAT
DD_INF_OPTIONS_ID = _connect.DD_INF_OPTIONS_ID
DD_INF_GUI_DATA = _connect.DD_INF_GUI_DATA
DD_INF_GUI_SHORT = _connect.DD_INF_GUI_SHORT
DD_INF_FILE_FOLDER = _connect.DD_INF_FILE_FOLDER
DD_INF_HELP = _connect.DD_INF_HELP
DD_INF_KEY_ALT = _connect.DD_INF_KEY_ALT
DD_INF_RGB_T = _connect.DD_INF_RGB_T
DD_INF_RGB_B = _connect.DD_INF_RGB_B
DD_INF_GUI_SHORTCUT = _connect.DD_INF_GUI_SHORTCUT
optDisabled = _connect.optDisabled
r"""this item is currently not available"""
optRDOnly = _connect.optRDOnly
r"""this item can not be modified"""
optHidden = _connect.optHidden
r"""not shown in dumps"""
optNoSerialize = _connect.optNoSerialize
r"""do not serialize this item"""
optHex = _connect.optHex
r"""integer preferred display is hex. string with this flag indicates that it has binary content which should be hex encoded for display/serdes"""
optBitField = _connect.optBitField
r"""the data consumes only a part of the specified underlying type. bitoffset and bitsize are given with optBitFieldOffs and optBitFiledSize. values within underlying type are treated as 'value'. e.g. values for offset 2 are {0, 1, 2, 3,...}"""
optValueSet = _connect.optValueSet
r"""this data object is immediately followed by a bool which will be set to true following any ofSet operation"""
optBitMask = _connect.optBitMask
r"""same as optBitField, but the values within underlying type are treated as 'mask'. e.g. values for offset 2 are {0, 4, 8, C,...}"""
optBitFieldMask = _connect.optBitFieldMask
r"""for probing if bit extraction is applicable"""
optReserved16 = _connect.optReserved16
optReserved17 = _connect.optReserved17
optReserved18 = _connect.optReserved18
optDebug = _connect.optDebug
r"""used or debugging"""
optBitFieldSize_Pos = _connect.optBitFieldSize_Pos
r"""for optBitField, size of the field starts at this bit in the options"""
optBitFieldSize_Num = _connect.optBitFieldSize_Num
r"""for optBitField, this many bits are used for bitfield size (e.g. supports 64 bits)"""
optBitFieldOffs_Pos = _connect.optBitFieldOffs_Pos
r"""for optBitField, offs of the field starts at this bit in the options"""
optBitFieldOffs_Num = _connect.optBitFieldOffs_Num
r"""for optBitField, this many bits are used for bitfield offs (e.g. supports 64 bits)"""
optKindDefault = _connect.optKindDefault
r"""no special meaning"""
optKindFilePath = _connect.optKindFilePath
r"""
    the string value is a file path, allow file browsing.
    DD_INF_FILE_FILTER parameter in Info is the file type string for dialog selection. e.g. "Readme File"DD_INF_FILE_FILTER"Text files(*.txt)|*.txt|All files (*.*)|*.*||"
    DD_INF_FILE_DEFEXT parameter in Info is the file default extension. e.g. "Readme File"DD_INF_FILE_FILTER"Text files(*.txt)|*.txt|All files (*.*)|*.*||"DD_INF_FILE_DEFEXT"txt"
    use optMiscValMask to obtain a reference path to which this path should be kept relative
    """
optKindFilePath_Open = _connect.optKindFilePath_Open
r"""create file open dialog, if not set create file save dialog"""
optKindFilePath_Overwrite = _connect.optKindFilePath_Overwrite
r"""display overwrite prompt"""
optKindFilePath_RelMask = _connect.optKindFilePath_RelMask
r"""relative path mask"""
optKindFilePath_RelWorkspace = _connect.optKindFilePath_RelWorkspace
r"""keep path relative to workspace"""
optKindFilePath_RelEXE = _connect.optKindFilePath_RelEXE
r"""keep path relative to executable"""
optKindFilePath_RelMacro = _connect.optKindFilePath_RelMacro
r"""attempt relative conversion to a macro"""
optKindSymbol = _connect.optKindSymbol
r"""the string value is a symbol expression, allow symbol browsing"""
optKindColor = _connect.optKindColor
r"""the 32-bit int is a RGB value, allow color browsing"""
optKindFont = _connect.optKindFont
r"""the string value is a font face, allow font browsing"""
optKindFolder = _connect.optKindFolder
r"""
    the string value is a folder path, allow folder browsing.
    use optMiscValMask to obtain a reference path to which this path should be kept relative
    """
optKindUser = _connect.optKindUser
r"""reserved for user extensions"""
optKindMask = _connect.optKindMask
r"""mask to extract the 'kind'"""
optMiscValMask = _connect.optMiscValMask
r"""mask to extract the Kind specific options"""

def BitFieldSize(ulOptions):
    return _connect.BitFieldSize(ulOptions)

def BitFieldOffs(ulOptions):
    return _connect.BitFieldOffs(ulOptions)
class IEnumMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Value(self):
        return _connect.IEnumMap_Value(self)

    def Name(self):
        return _connect.IEnumMap_Name(self)

    def Info(self):
        return _connect.IEnumMap_Info(self)

    def Options(self):
        return _connect.IEnumMap_Options(self)
    __swig_destroy__ = _connect.delete_IEnumMap

# Register IEnumMap in _connect:
_connect.IEnumMap_swigregister(IEnumMap)
optLegacy = cvar.optLegacy

class IItemDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Name(self):
        return _connect.IItemDescriptor_Name(self)

    def DataDescriptor(self):
        return _connect.IItemDescriptor_DataDescriptor(self)

    def Dimension(self):
        r"""0 for no array"""
        return _connect.IItemDescriptor_Dimension(self)

    def ArrayIndex(self):
        r"""
        a static array can have symbolic array indexes
        Valid only for arrays 0 != Dimension(), returns NULL otherwise.
        """
        return _connect.IItemDescriptor_ArrayIndex(self)

    def Info(self):
        r"""text description"""
        return _connect.IItemDescriptor_Info(self)

    def Options(self):
        r"""additional info EOptions"""
        return _connect.IItemDescriptor_Options(self)

    def EnumOptions(self, pIEnumMap):
        r"""returns Options of the pIEnumMap"""
        return _connect.IItemDescriptor_EnumOptions(self, pIEnumMap)

    def Offset(self):
        r"""offset from start of structure"""
        return _connect.IItemDescriptor_Offset(self)

    def Data(self):
        r"""pointer to start of variable in memory"""
        return _connect.IItemDescriptor_Data(self)

    def VariableDescriptors(self):
        return _connect.IItemDescriptor_VariableDescriptors(self)
    __swig_destroy__ = _connect.delete_IItemDescriptor

# Register IItemDescriptor in _connect:
_connect.IItemDescriptor_swigregister(IItemDescriptor)
class IDataDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    tbool = _connect.IDataDescriptor_tbool
    tBOOL = _connect.IDataDescriptor_tBOOL
    tINT = _connect.IDataDescriptor_tINT
    tUINT = _connect.IDataDescriptor_tUINT
    tFLOAT = _connect.IDataDescriptor_tFLOAT
    tENUM = _connect.IDataDescriptor_tENUM
    tSTRUCT = _connect.IDataDescriptor_tSTRUCT
    tSTRING = _connect.IDataDescriptor_tSTRING
    r"""char [Size]"""
    tstdString = _connect.IDataDescriptor_tstdString
    r"""std::string"""
    tSPath = _connect.IDataDescriptor_tSPath
    r"""isys::SPath"""
    tIDataBase = _connect.IDataDescriptor_tIDataBase
    r"""IDataBase *"""

    def Type(self):
        return _connect.IDataDescriptor_Type(self)

    def type_name(self):
        return _connect.IDataDescriptor_type_name(self)

    def Size(self):
        r"""size in MAUs"""
        return _connect.IDataDescriptor_Size(self)

    def Struct(self):
        return _connect.IDataDescriptor_Struct(self)

    def Enum(self):
        r"""
        Returns mapping of available enum values.
        Valid only when type is tENUM.
        Returns NULL otherwise.
        """
        return _connect.IDataDescriptor_Enum(self)
    cNone = _connect.IDataDescriptor_cNone
    r"""regular data object as specified in EType"""
    cIDArray = _connect.IDataDescriptor_cIDArray
    r"""EType defines the type of object kept in an IDArray* container"""

    def Container(self):
        r"""type of the container keeping the elements"""
        return _connect.IDataDescriptor_Container(self)
    __swig_destroy__ = _connect.delete_IDataDescriptor

# Register IDataDescriptor in _connect:
_connect.IDataDescriptor_swigregister(IDataDescriptor)
class IDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VariableDescriptors(self):
        return _connect.IDescriptor_VariableDescriptors(self)
    __swig_destroy__ = _connect.delete_IDescriptor

# Register IDescriptor in _connect:
_connect.IDescriptor_swigregister(IDescriptor)

def PathSeparator(c):
    return _connect.PathSeparator(c)

def ValueSeparator(c):
    return _connect.ValueSeparator(c)

def OptionSeparator(c):
    return _connect.OptionSeparator(c)
class ICodeCache(object):
    r"""This interface maintains multiple memory item"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    cfNoData = _connect.ICodeCache_cfNoData
    r"""do not copy data"""
    cfData = _connect.ICodeCache_cfData
    r"""copy data"""
    dtEqual = _connect.ICodeCache_dtEqual
    r"""this part was in both and was equal"""
    dtNotIn1 = _connect.ICodeCache_dtNotIn1
    r"""this part was not in first ICodeCache"""
    dtNotIn2 = _connect.ICodeCache_dtNotIn2
    r"""this part was not in second ICodeCache"""
    dtDif = _connect.ICodeCache_dtDif
    r"""this part was in both, but content differs"""
    dfReportEqual = _connect.ICodeCache_dfReportEqual
    r"""report locations with equal contents"""
    dfReportNotIn1 = _connect.ICodeCache_dfReportNotIn1
    r"""report locations that are not in first ICodeCache"""
    dfReportNotIn2 = _connect.ICodeCache_dfReportNotIn2
    r"""report locations that are not in second ICodeCache"""
    dfReportDif = _connect.ICodeCache_dfReportDif
    r"""report locations with different contents"""
    dfReportAllDif = _connect.ICodeCache_dfReportAllDif
    r"""report all differing locations and missing in one or other"""
    dfReportAll = _connect.ICodeCache_dfReportAll
    r"""report everything"""
    sfAddressSize4 = _connect.ICodeCache_sfAddressSize4
    r"""save 32-bit addresses"""
    sfAddressSize8 = _connect.ICodeCache_sfAddressSize8
    r"""save 64-bit addresses"""
    sfAddressMask = _connect.ICodeCache_sfAddressMask
    sfData = _connect.ICodeCache_sfData
    r"""serialize data"""
    sfMAUSize = _connect.ICodeCache_sfMAUSize
    r"""serialize also MAUSize - not included per default in legacy saves"""
    lFormatAuto = _connect.ICodeCache_lFormatAuto
    r"""automatically detect file type"""
    lFormatMotorolaS = _connect.ICodeCache_lFormatMotorolaS
    r"""use MotorolaS format"""
    lFormatIntelHex = _connect.ICodeCache_lFormatIntelHex
    r"""use Intel hex format"""
    lFormatBinary = _connect.ICodeCache_lFormatBinary
    r"""use binary format"""
    lFormatELF = _connect.ICodeCache_lFormatELF
    r"""use ELF format"""
    lFormatPE = _connect.ICodeCache_lFormatPE
    r"""use Portable executable format"""
    lFormatMask = _connect.ICodeCache_lFormatMask
    lAllowOverlap = _connect.ICodeCache_lAllowOverlap
    r"""tolerate overlaps when loading"""
    lSaveBytes10 = _connect.ICodeCache_lSaveBytes10
    r"""when saving save 0x10 bytes per line"""
    lSaveBytes20 = _connect.ICodeCache_lSaveBytes20
    r"""when saving save 0x20 bytes per line"""
    lSaveBytes40 = _connect.ICodeCache_lSaveBytes40
    r"""when saving save 0x40 bytes per line"""
    lSaveBytes80 = _connect.ICodeCache_lSaveBytes80
    r"""when saving save 0x80 bytes per line"""
    lSaveBytesMask = _connect.ICodeCache_lSaveBytesMask
    lOptionELF_Addr_PH_Virtual = _connect.ICodeCache_lOptionELF_Addr_PH_Virtual
    r"""use ELF ProgramHeader virtual as load address"""
    lOptionELF_Addr_PH_Physical = _connect.ICodeCache_lOptionELF_Addr_PH_Physical
    r"""use ELF ProgramHeader physical as load address"""
    lOptionELF_Addr_Mask = _connect.ICodeCache_lOptionELF_Addr_Mask
    r"""mask for Elf Address"""
    lOptionELF_IgnoreZeros = _connect.ICodeCache_lOptionELF_IgnoreZeros
    r"""ignore headers with zero content"""
    lOptionMask = _connect.ICodeCache_lOptionMask
    E_OPEN = _connect.ICodeCache_E_OPEN
    E_FORMAT = _connect.ICodeCache_E_FORMAT
    E_OVERLAPPING = _connect.ICodeCache_E_OVERLAPPING
    E_ADDRESSRANGE = _connect.ICodeCache_E_ADDRESSRANGE
    E_NOTSUPPORTED = _connect.ICodeCache_E_NOTSUPPORTED
    rfTypeNormal = _connect.ICodeCache_rfTypeNormal
    r"""report contents"""
    rfTypeDif = _connect.ICodeCache_rfTypeDif
    r"""the object contains dif between m_pICC1 and m_pICC2 - report dif"""
    rfTypeMask = _connect.ICodeCache_rfTypeMask
    r"""mask for report type"""
    rfAppend = _connect.ICodeCache_rfAppend
    r"""append to file rather than overwrite"""
    rfAlign = _connect.ICodeCache_rfAlign
    r"""align addresses to m_dwMaxMAUsPerLine"""

    def Report(self, dwFlags, pszFileName, rReport):
        r"""
         Generate report.
        :type dwFlags: int
        :param dwFlags: flags. use EReportFlags
        :type pszFileName: string
        :param pszFileName: path to the report file
        :type rReport: ICodeCache::SReport
        :param rReport: save format configuration
        """
        return _connect.ICodeCache_Report(self, dwFlags, pszFileName, rReport)

    def Offset(self, aOffset):
        r"""
        offset all records


        :type aOffset: TCC_ADDRESS
        :param aOffset: amount to offset
        """
        return _connect.ICodeCache_Offset(self, aOffset)
    EParam_AI_OK = _connect.ICodeCache_EParam_AI_OK
    EParam_AI_FAIL = _connect.ICodeCache_EParam_AI_FAIL

    def set_param(self, eParam, dwValue):
        r"""
         Sets parameter.
        :type eParam: int
        :param eParam: parameter to set
        :type dwValue: int
        :param dwValue: vaue of parameter
        """
        return _connect.ICodeCache_set_param(self, eParam, dwValue)

    def get_param(self, eParam):
        r"""
         Returns parameter value.
        :type eParam: int
        :param eParam: parameter to get
        """
        return _connect.ICodeCache_get_param(self, eParam)
    __swig_destroy__ = _connect.delete_ICodeCache

# Register ICodeCache in _connect:
_connect.ICodeCache_swigregister(ICodeCache)
cDefaultPathSeparator = cvar.cDefaultPathSeparator
cDefaultValueSeparator = cvar.cDefaultValueSeparator
cDefaultOptionSeparator = cvar.cDefaultOptionSeparator

class SBatchAccessHeader(object):
    r"""Defines the number, type and timeframe of access to perform."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flWantTimeStamp = _connect.SBatchAccessHeader_flWantTimeStamp
    r"""return time stamp of every access"""
    flAbortIfTooSlow = _connect.SBatchAccessHeader_flAbortIfTooSlow
    r"""if interval and item times can not be kept, abort batch"""
    flRealTime = _connect.SBatchAccessHeader_flRealTime
    r"""use real-time access"""
    flStopResume = _connect.SBatchAccessHeader_flStopResume
    r"""stop to perform the operation then resume"""
    baDomainDefault = _connect.SBatchAccessHeader_baDomainDefault
    r"""execute the access in the default domain"""
    baDomainHost = _connect.SBatchAccessHeader_baDomainHost
    r"""execute the access in the PC host domain"""
    baDomainEmulator = _connect.SBatchAccessHeader_baDomainEmulator
    r"""execute the access in the emulator domain"""
    baDomainMask = _connect.SBatchAccessHeader_baDomainMask
    m_dwFlags = property(_connect.SBatchAccessHeader_m_dwFlags_get, _connect.SBatchAccessHeader_m_dwFlags_set, doc=r"""flags""")
    m_dwNumItems = property(_connect.SBatchAccessHeader_m_dwNumItems_get, _connect.SBatchAccessHeader_m_dwNumItems_set, doc=r"""
    number of items in arrays ``pBatchAccessItems`` and
    ``pBatchAccessItemResult`` given as parameters
    to IConnectDebug2::BatchAccess()
    """)
    m_dwNumRuns = property(_connect.SBatchAccessHeader_m_dwNumRuns_get, _connect.SBatchAccessHeader_m_dwNumRuns_set, doc=r"""how many times should the batch be repeated""")
    m_qwStartAtTime = property(_connect.SBatchAccessHeader_m_qwStartAtTime_get, _connect.SBatchAccessHeader_m_qwStartAtTime_set, doc=r"""absolute time for batch start. 0 for immediate start""")
    m_qwRunInterval = property(_connect.SBatchAccessHeader_m_qwRunInterval_get, _connect.SBatchAccessHeader_m_qwRunInterval_set, doc=r"""microseconds for interval repeat. 0 for immediate repeat""")

    def __init__(self):
        _connect.SBatchAccessHeader_swiginit(self, _connect.new_SBatchAccessHeader())
    __swig_destroy__ = _connect.delete_SBatchAccessHeader

# Register SBatchAccessHeader in _connect:
_connect.SBatchAccessHeader_swigregister(SBatchAccessHeader)
class SBatchAccessItem(object):
    r"""Defines the type and time of an individual access."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MAX_DATA_SIZE = _connect.SBatchAccessItem_MAX_DATA_SIZE
    flRead = _connect.SBatchAccessItem_flRead
    r"""read by default"""
    flWrite = _connect.SBatchAccessItem_flWrite
    r"""write by default"""
    flTimeOffsetRel = _connect.SBatchAccessItem_flTimeOffsetRel
    r"""if set, the m_qwTimeOffset is considered to previous item (in case of first item to the begin of interval)"""
    flAccessSizeAuto = _connect.SBatchAccessItem_flAccessSizeAuto
    r"""access size enforcement. flAccessSizeAuto lets the debugger pick the most appropriate size"""
    flAccessSize1MAU = _connect.SBatchAccessItem_flAccessSize1MAU
    r"""access size enforcement"""
    flAccessSize2MAU = _connect.SBatchAccessItem_flAccessSize2MAU
    r"""access size enforcement"""
    flAccessSize4MAU = _connect.SBatchAccessItem_flAccessSize4MAU
    r"""access size enforcement"""
    flAccessSize8MAU = _connect.SBatchAccessItem_flAccessSize8MAU
    r"""access size enforcement"""
    flAccessSizeMask = _connect.SBatchAccessItem_flAccessSizeMask
    m_byFlags = property(_connect.SBatchAccessItem_m_byFlags_get, _connect.SBatchAccessItem_m_byFlags_set, doc=r"""flags""")
    m_bySize = property(_connect.SBatchAccessItem_m_bySize_get, _connect.SBatchAccessItem_m_bySize_set, doc=r"""MAU Size""")
    m_byMemArea = property(_connect.SBatchAccessItem_m_byMemArea_get, _connect.SBatchAccessItem_m_byMemArea_set, doc=r"""memory area""")
    m_byReserved = property(_connect.SBatchAccessItem_m_byReserved_get, _connect.SBatchAccessItem_m_byReserved_set, doc=r"""reserved, should be 0""")
    m_aAddress = property(_connect.SBatchAccessItem_m_aAddress_get, _connect.SBatchAccessItem_m_aAddress_set, doc=r"""address""")
    m_abyData = property(_connect.SBatchAccessItem_m_abyData_get, _connect.SBatchAccessItem_m_abyData_set, doc=r"""data""")
    m_qwTimeOffset = property(_connect.SBatchAccessItem_m_qwTimeOffset_get, _connect.SBatchAccessItem_m_qwTimeOffset_set, doc=r"""
    time offset in microsec from the beginning of the interval (flag flTimeOffsetRel is not set) or
    prev item (flag flTimeOffsetRel is set). 0 for immediately after prev item.
    """)

    def __init__(self):
        _connect.SBatchAccessItem_swiginit(self, _connect.new_SBatchAccessItem())
    __swig_destroy__ = _connect.delete_SBatchAccessItem

# Register SBatchAccessItem in _connect:
_connect.SBatchAccessItem_swigregister(SBatchAccessItem)
class SBatchAccessItemResult(object):
    r"""
    Pointer to an array of objects that will receive the results of
    every individual access.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    resOK = _connect.SBatchAccessItemResult_resOK
    r"""access OK"""
    resAccess = _connect.SBatchAccessItemResult_resAccess
    r"""access failure"""
    resTimeout = _connect.SBatchAccessItemResult_resTimeout
    r"""access not performed due to to timeout"""
    m_byResult = property(_connect.SBatchAccessItemResult_m_byResult_get, _connect.SBatchAccessItemResult_m_byResult_set, doc=r"""result""")
    m_abyData = property(_connect.SBatchAccessItemResult_m_abyData_get, _connect.SBatchAccessItemResult_m_abyData_set, doc=r"""result data""")
    m_qwTimeStamp = property(_connect.SBatchAccessItemResult_m_qwTimeStamp_get, _connect.SBatchAccessItemResult_m_qwTimeStamp_set, doc=r"""absolute time stamp, microseconds""")

    def __init__(self):
        _connect.SBatchAccessItemResult_swiginit(self, _connect.new_SBatchAccessItemResult())
    __swig_destroy__ = _connect.delete_SBatchAccessItemResult

# Register SBatchAccessItemResult in _connect:
_connect.SBatchAccessItemResult_swigregister(SBatchAccessItemResult)
class SProfilerStartingPoint(object):
    r"""Specifies the trigger condition."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eAnything = _connect.SProfilerStartingPoint_eAnything
    r"""start immediately"""
    eExecution = _connect.SProfilerStartingPoint_eExecution
    r"""execution from a specified address"""
    m_aAddress = property(_connect.SProfilerStartingPoint_m_aAddress_get, _connect.SProfilerStartingPoint_m_aAddress_set, doc=r"""used for eRead, eWrite, eRW""")
    m_byEvent = property(_connect.SProfilerStartingPoint_m_byEvent_get, _connect.SProfilerStartingPoint_m_byEvent_set, doc=r"""trigger event, see SProfilerStartingPoint::EEvent""")
    m_byMemArea = property(_connect.SProfilerStartingPoint_m_byMemArea_get, _connect.SProfilerStartingPoint_m_byMemArea_set, doc=r"""memory area of ``m_aAddress``""")

    def __init__(self):
        _connect.SProfilerStartingPoint_swiginit(self, _connect.new_SProfilerStartingPoint())
    __swig_destroy__ = _connect.delete_SProfilerStartingPoint

# Register SProfilerStartingPoint in _connect:
_connect.SProfilerStartingPoint_swigregister(SProfilerStartingPoint)
acquTrace = _connect.acquTrace
acquDAQ = _connect.acquDAQ
acquSampling = _connect.acquSampling
acquPostProcess = _connect.acquPostProcess
acquNetwork = _connect.acquNetwork
acquSWAT = _connect.acquSWAT
acq_NUM = _connect.acq_NUM
ePPPCInspectors = _connect.ePPPCInspectors
ePPPCCPULoad = _connect.ePPPCCPULoad
ePPPDependencies = _connect.ePPPDependencies
ePPPC_NUM = _connect.ePPPC_NUM
edaqFastest = _connect.edaqFastest
edaqNormal = _connect.edaqNormal
edaqSlow = _connect.edaqSlow
vtState = _connect.vtState
r"""a state variable - limited number of states"""
vtLSB_Exit_Entry = _connect.vtLSB_Exit_Entry
r"""deprecated."""
vtZero_Exit_Entry = _connect.vtZero_Exit_Entry
r"""zero indicates exit from current area (activation/deactivation)"""
vtRegular = _connect.vtRegular
r"""regular variable. history is not kept for every individual value"""
vtSampling = _connect.vtSampling
r"""sampling variable, shows count % for each state"""
pdvdHex = _connect.pdvdHex
pdvdDec = _connect.pdvdDec
pdvdBin = _connect.pdvdBin
hValueInvalid = _connect.hValueInvalid
r"""invalid value handle"""
hpInvalid = _connect.hpInvalid
r"""invalid handle"""
plNone = _connect.plNone
r"""non context object"""
plTask = _connect.plTask
r"""task level context"""
plIRQ_Lowest = _connect.plIRQ_Lowest
r"""lowest level IRQ"""
plIRQ_Highest = _connect.plIRQ_Highest
r"""highest level IRQ"""
plApplication = _connect.plApplication
r"""application"""
plRunnable = _connect.plRunnable
r"""runnable object"""
plSignal = _connect.plSignal
r"""special OS signaling / EProfilerOSSignal"""
plSpecial = _connect.plSpecial
r"""special"""
plSpinlock = _connect.plSpinlock
r"""Spinlocks"""
plServiceTrace = _connect.plServiceTrace
r"""ServiceTrace"""
plSWAT = _connect.plSWAT
r"""SWAT"""
plNum = _connect.plNum
possUnknown = _connect.possUnknown
r"""unknown signal"""
possContextRET = _connect.possContextRET
r"""return from current context to previously preempted context"""
possContextRET_OS = _connect.possContextRET_OS
r"""return from current context to OS scheduler"""
class SProfilerHistory(object):
    r"""
    Contains profiler history.

    *SProfilerHistory::m_dwValue* will hold values as by *EValue* enum for all
    execution areas (*afTypeFunction*, *afTypeRoutine*) and for data areas
    (*afTypeVariable*, *afTypeRegion*) of type *vtState*,
    *vtLSB_Exit_Entry*, *vtZero_Exit_Entry* if history is obtained with
    *rfFilterValue*. For *vtRegular* or data areas obtained without
    *rfFilterValue*, the value holds the value written to the object.

    The first item for any history will always be on time 0. This item is inserted
    explicitly. If histories for all areas are retrieved, the first item will have handle
    value *hpInvalid*.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_dwHandle = property(_connect.SProfilerHistory_m_dwHandle_get, _connect.SProfilerHistory_m_dwHandle_set, doc=r"""handle of the area for which this history is for""")
    m_dwValue = property(_connect.SProfilerHistory_m_dwValue_get, _connect.SProfilerHistory_m_dwValue_set, doc=r"""
    contains information about recorded event:
    - for functions see SProfilerHistory::EValue
    - for variables it contains:
      - variable's value, if *IConnectProfiler::rfAllAreas* flag is used
      - state, if *IConnectProfiler::rfFilterValue | IConnectProfiler::rfByHandle*
        is used; when the value changes to filter value, *m_dwValue* is set to
        *valExecActive | 1* (0x80000001), when it changes to other value,
        *m_dwValue* is set to *valExecInactive (0)*
    """)
    m_qwTime = property(_connect.SProfilerHistory_m_qwTime_get, _connect.SProfilerHistory_m_qwTime_set, doc=r"""hit time in nanoseconds""")
    valExecEntry = _connect.SProfilerHistory_valExecEntry
    r"""the area (function) entered"""
    valExecSuspend = _connect.SProfilerHistory_valExecSuspend
    r"""the area (function) called another function"""
    valExecResume = _connect.SProfilerHistory_valExecResume
    r"""the area (function) resumed from another function call"""
    valExecExit = _connect.SProfilerHistory_valExecExit
    r"""the area (function) exited"""

    def __init__(self):
        _connect.SProfilerHistory_swiginit(self, _connect.new_SProfilerHistory())
    __swig_destroy__ = _connect.delete_SProfilerHistory

# Register SProfilerHistory in _connect:
_connect.SProfilerHistory_swigregister(SProfilerHistory)
class SProfilerEncode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    eNone = _connect.SProfilerEncode_eNone
    r"""no special encoding"""
    eStop_Start_Id_LSB = _connect.SProfilerEncode_eStop_Start_Id_LSB
    r"""
    a series of data
    stop bit located at first MSB bit
    start bit located at second MSB bit
    ID is encoded in m_byParam1 bits starting at third MSB bit
    data encoding is LSB
    """
    eStop_Start_MSB_Id = _connect.SProfilerEncode_eStop_Start_MSB_Id
    r"""
    a series of data
    stop bit located at first MSB bit
    start bit located at second MSB bit
    ID is encoded in m_byParam1 bits located in LSB bits of the stop packet
    data encoding is MSB
    """
    eSync_Toggle_MSB_Id = _connect.SProfilerEncode_eSync_Toggle_MSB_Id
    r"""
    a series of data
    MSB 10 = start, 11 = stop, 00 & 01 toggle for data values
    ID is encoded in m_byParam1 bits located in LSB bits of the stop packet
    data encoding is MSB
    """
    eMSB_Id = _connect.SProfilerEncode_eMSB_Id
    r"""
    a single data packet,
    ID is encoded in m_byParam1 bits located in LSB bits of the stop packet
    """
    eNum = _connect.SProfilerEncode_eNum
    m_byEncode = property(_connect.SProfilerEncode_m_byEncode_get, _connect.SProfilerEncode_m_byEncode_set, doc=r"""EEncode""")
    m_byParam1 = property(_connect.SProfilerEncode_m_byParam1_get, _connect.SProfilerEncode_m_byParam1_set, doc=r"""additional parameter1 for encoding""")
    m_byParam2 = property(_connect.SProfilerEncode_m_byParam2_get, _connect.SProfilerEncode_m_byParam2_set, doc=r"""additional parameter2 for encoding""")
    m_byParam3 = property(_connect.SProfilerEncode_m_byParam3_get, _connect.SProfilerEncode_m_byParam3_set, doc=r"""additional parameter3 for encoding. SBZ""")

    def __init__(self):
        _connect.SProfilerEncode_swiginit(self, _connect.new_SProfilerEncode())
    __swig_destroy__ = _connect.delete_SProfilerEncode

# Register SProfilerEncode in _connect:
_connect.SProfilerEncode_swigregister(SProfilerEncode)

def PR_is_level_IRQ(eLevel):
    return _connect.PR_is_level_IRQ(eLevel)

def PR_is_level_context(eLevel):
    return _connect.PR_is_level_context(eLevel)
class SMSID(object):
    r"""Describes application status."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_bValid = property(_connect.SMSID_m_bValid_get, _connect.SMSID_m_bValid_set, doc=r"""true if other settings are to be considered/valid""")
    m_bSecure = property(_connect.SMSID_m_bSecure_get, _connect.SMSID_m_bSecure_set, doc=r"""true if the device level is secure""")
    m_bVMID = property(_connect.SMSID_m_bVMID_get, _connect.SMSID_m_bVMID_set, doc=r"""consider m_nVMID in identifying the app?""")
    m_bAppID = property(_connect.SMSID_m_bAppID_get, _connect.SMSID_m_bAppID_set, doc=r"""consider m_nAppID in identifying the app?""")
    ELevel_App = _connect.SMSID_ELevel_App
    r"""App inside OS inside VM"""
    ELevel_VM = _connect.SMSID_ELevel_VM
    r"""virtual machine. an OS or app"""
    ELevel_HV = _connect.SMSID_ELevel_HV
    r"""hypervisor"""
    ELevel_Sys = _connect.SMSID_ELevel_Sys
    r"""bare metal"""
    m_eLevel = property(_connect.SMSID_m_eLevel_get, _connect.SMSID_m_eLevel_set)
    m_nVMID = property(_connect.SMSID_m_nVMID_get, _connect.SMSID_m_nVMID_set, doc=r"""virtual machine ID""")
    m_nAppID = property(_connect.SMSID_m_nAppID_get, _connect.SMSID_m_nAppID_set, doc=r"""Application/ContextID""")

    def __init__(self):
        _connect.SMSID_swiginit(self, _connect.new_SMSID())
    __swig_destroy__ = _connect.delete_SMSID

# Register SMSID in _connect:
_connect.SMSID_swigregister(SMSID)
EStatus_SoC_DETACHED = _connect.EStatus_SoC_DETACHED
r"""detached"""
EStatus_SoC_NOPOWER = _connect.EStatus_SoC_NOPOWER
r"""no power"""
EStatus_SoC_RESET = _connect.EStatus_SoC_RESET
r"""reset"""
EStatus_SoC_ATTACHING = _connect.EStatus_SoC_ATTACHING
r"""attaching"""
EStatus_SoC_ATTACHED = _connect.EStatus_SoC_ATTACHED
r"""attached"""
EStatus_Core_stDetached = _connect.EStatus_Core_stDetached
r"""the core is not observed"""
EStatus_Core_stInaccessible = _connect.EStatus_Core_stInaccessible
r"""the core is not accessible"""
EStatus_Core_stStopped = _connect.EStatus_Core_stStopped
r"""CPU is stopped"""
EStatus_Core_stRunning = _connect.EStatus_Core_stRunning
r"""CPU is running"""
EStatus_Core_stHalted = _connect.EStatus_Core_stHalted
r"""CPU is halted by target"""
EStatus_Core_stIdle = _connect.EStatus_Core_stIdle
r"""CPU idle, e.g. waiting for IRQ"""
EStatus_Core_stSuspended = _connect.EStatus_Core_stSuspended
r"""halted, will run when some Stopped core runs"""
CPUSFR_PROP_AREAS = _connect.CPUSFR_PROP_AREAS
CPUSFR_PROP_AREA = _connect.CPUSFR_PROP_AREA
CPUSFR_PROP_AREA_START = _connect.CPUSFR_PROP_AREA_START
CPUSFR_PROP_AREA_END = _connect.CPUSFR_PROP_AREA_END
CPUSFR_PROP_AREA_MAU = _connect.CPUSFR_PROP_AREA_MAU
CPUSFR_PROP_AREA_VISIBLE = _connect.CPUSFR_PROP_AREA_VISIBLE
CPUSFR_PROP_REGISTERS = _connect.CPUSFR_PROP_REGISTERS
CPUSFR_PROP_REGISTER = _connect.CPUSFR_PROP_REGISTER
CPUSFR_PROP_REGISTER_SIZE = _connect.CPUSFR_PROP_REGISTER_SIZE
CPUSFR_PROP_REGISTER_VISIBLE = _connect.CPUSFR_PROP_REGISTER_VISIBLE
class CEvent(object):
    r"""This is wrapper for Windows events."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, bManualReset, bInitialState, eventName):
        r"""
        Creates Windows event object.

        :type bManualReset: boolean
        :param bManualReset: Specifies whether a manual-reset or
            auto-reset event object is created. If ``true``, then you must
            use the ``reset()`` method to manually reset the
            state to nonsignaled. If ``false``, Windows automatically
            resets the state to nonsignaled after a single waiting
            thread has been released.

        :type bInitialState: boolean
        :param bInitialState: Specifies the initial state of the
            event object. If ``true``, the initial state is signaled;
            otherwise, it is nonsignaled.

        :type eventName: string
        :param eventName: specifies the name of the event object. The name is
            limited to ``MAX_PATH`` characters and can contain any
            character except the backslash path-separator character
            (\). Name comparison is case sensitive.



            If ``eventName`` matches the name of an existing
            named event object, this constructor requests
            ``EVENT_ALL_ACCESS`` access to the existing
            object. In this case, the ``bManualReset`` and
            ``bInitialState`` parameters are ignored because
            they have already been set by the creating process.
            If ``eventName`` is empty string,
            the event object is created without a name.



            If ``eventName`` matches the name of an existing
            semaphore, mutex, or file-mapping object, the constructor
            fails and the ``SystemException`` is thrown. This
            occurs because event, mutex, semaphore, and file-mapping
            objects share the same name space.

        :raises: SystemException if Windows event object can not be
            created.

        See also: #alreadyExists
        """
        _connect.CEvent_swiginit(self, _connect.new_CEvent(bManualReset, bInitialState, eventName))
    __swig_destroy__ = _connect.delete_CEvent

    def set(self):
        r"""
        Sets the state of object to signaled.

        The state of a manual-reset event object remains signaled
        until it is reset by ``reset()`` method. Any
        number of waiting threads, or threads that subsequently
        begin wait operations for the specified event object by
        calling one of the wait functions, can be released while
        the object's state is signaled.

        The state of an auto-reset event object remains set
        until a single waiting thread is released, at which time
        the system automatically resets the object. If
        no threads are waiting, the object remains
        set.

        :raises: SystemException if operation failed.
        """
        return _connect.CEvent_set(self)

    def pulse(self):
        r"""
        Sets the state of the specified event object to signaled
        and then to non-signaled after releasing the appropriate
        number of waiting threads.

        For a manual-reset event object, all waiting threads that
        can be released immediately are released. The function then
        resets the event object's state to non-signaled and returns.

        For an auto-reset event object, the function resets the
        state to non-signaled and returns after releasing a single
        waiting thread, even if multiple threads are waiting.

        If no threads are waiting, or if no thread can be released
        immediately, PulseEvent simply sets the event object's
        state to non-signaled and returns.

        :raises: SystemException if operation failed.
        """
        return _connect.CEvent_pulse(self)

    def reset(self):
        r"""
        Sets the state of object to non-signaled.

        The object remains reset until it
        is explicitly set by the ``set`` or ``pulse``
        method. This state blocks the execution of
        any threads that have called ``waitFor()`` method.

        The ``reset()`` method is used primarily for
        manual-reset event objects, which must be reset explicitly.
        Auto-reset event objects automatically change to reset
        state after a single waiting thread is released.

        :raises: SystemException if operation failed.
        """
        return _connect.CEvent_reset(self)

    def waitFor(self, *args):
        r"""
        Waits until event is set or timeout expires.

        :type timeout: int, optional
        :param timeout: Specifies the time-out interval, in
            milliseconds. The function returns if the interval elapses,
            even if the object's state is non-signaled. If
            ``timeout`` is zero, the function tests the object's
            state and returns immediately. If ``timeout`` is
            INFINITE, the function's time-out interval never elapses.

        :rtype: boolean
        :return: ``true`` if event was set,
            ``false`` if timeout elapsed

        :raises: SystemException if function failed.
        """
        return _connect.CEvent_waitFor(self, *args)

    def getHandle(self):
        r"""
        Returns Windows handle to event object. Use this method
        only if you really need functionality not covered by this
        class.
        """
        return _connect.CEvent_getHandle(self)

    def alreadyExists(self):
        r"""
        Returns true, if event object, with the name specified in
        constructor parameter ``eventName``, existed before
        creation of this object.
        """
        return _connect.CEvent_alreadyExists(self)

    def close(self):
        r"""
        Closes event handle. It is recommended to use this method
        when closing event. This way we can get the exception if
        something goes wrong, while in destructor it is lost.

        If this method is not called directly by application, it is
        called by destructor. However, see recommendation above.


        :raises: SystemException if ``CloseHandle()`` system function fails
        :raises: IllegalStateException if event is already closed.
        """
        return _connect.CEvent_close(self)

# Register CEvent in _connect:
_connect.CEvent_swigregister(CEvent)
class VectorBatchAccessItem(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorBatchAccessItem_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorBatchAccessItem___nonzero__(self)

    def __bool__(self):
        return _connect.VectorBatchAccessItem___bool__(self)

    def __len__(self):
        return _connect.VectorBatchAccessItem___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorBatchAccessItem___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorBatchAccessItem___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorBatchAccessItem___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorBatchAccessItem___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorBatchAccessItem___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorBatchAccessItem___setitem__(self, *args)

    def pop(self):
        return _connect.VectorBatchAccessItem_pop(self)

    def append(self, x):
        return _connect.VectorBatchAccessItem_append(self, x)

    def empty(self):
        return _connect.VectorBatchAccessItem_empty(self)

    def size(self):
        return _connect.VectorBatchAccessItem_size(self)

    def swap(self, v):
        return _connect.VectorBatchAccessItem_swap(self, v)

    def begin(self):
        return _connect.VectorBatchAccessItem_begin(self)

    def end(self):
        return _connect.VectorBatchAccessItem_end(self)

    def rbegin(self):
        return _connect.VectorBatchAccessItem_rbegin(self)

    def rend(self):
        return _connect.VectorBatchAccessItem_rend(self)

    def clear(self):
        return _connect.VectorBatchAccessItem_clear(self)

    def get_allocator(self):
        return _connect.VectorBatchAccessItem_get_allocator(self)

    def pop_back(self):
        return _connect.VectorBatchAccessItem_pop_back(self)

    def erase(self, *args):
        return _connect.VectorBatchAccessItem_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorBatchAccessItem_swiginit(self, _connect.new_VectorBatchAccessItem(*args))

    def push_back(self, x):
        return _connect.VectorBatchAccessItem_push_back(self, x)

    def front(self):
        return _connect.VectorBatchAccessItem_front(self)

    def back(self):
        return _connect.VectorBatchAccessItem_back(self)

    def assign(self, n, x):
        return _connect.VectorBatchAccessItem_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorBatchAccessItem_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorBatchAccessItem_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorBatchAccessItem_reserve(self, n)

    def capacity(self):
        return _connect.VectorBatchAccessItem_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBatchAccessItem

# Register VectorBatchAccessItem in _connect:
_connect.VectorBatchAccessItem_swigregister(VectorBatchAccessItem)
class VectorBatchAccessResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorBatchAccessResult_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorBatchAccessResult___nonzero__(self)

    def __bool__(self):
        return _connect.VectorBatchAccessResult___bool__(self)

    def __len__(self):
        return _connect.VectorBatchAccessResult___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorBatchAccessResult___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorBatchAccessResult___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorBatchAccessResult___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorBatchAccessResult___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorBatchAccessResult___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorBatchAccessResult___setitem__(self, *args)

    def pop(self):
        return _connect.VectorBatchAccessResult_pop(self)

    def append(self, x):
        return _connect.VectorBatchAccessResult_append(self, x)

    def empty(self):
        return _connect.VectorBatchAccessResult_empty(self)

    def size(self):
        return _connect.VectorBatchAccessResult_size(self)

    def swap(self, v):
        return _connect.VectorBatchAccessResult_swap(self, v)

    def begin(self):
        return _connect.VectorBatchAccessResult_begin(self)

    def end(self):
        return _connect.VectorBatchAccessResult_end(self)

    def rbegin(self):
        return _connect.VectorBatchAccessResult_rbegin(self)

    def rend(self):
        return _connect.VectorBatchAccessResult_rend(self)

    def clear(self):
        return _connect.VectorBatchAccessResult_clear(self)

    def get_allocator(self):
        return _connect.VectorBatchAccessResult_get_allocator(self)

    def pop_back(self):
        return _connect.VectorBatchAccessResult_pop_back(self)

    def erase(self, *args):
        return _connect.VectorBatchAccessResult_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorBatchAccessResult_swiginit(self, _connect.new_VectorBatchAccessResult(*args))

    def push_back(self, x):
        return _connect.VectorBatchAccessResult_push_back(self, x)

    def front(self):
        return _connect.VectorBatchAccessResult_front(self)

    def back(self):
        return _connect.VectorBatchAccessResult_back(self)

    def assign(self, n, x):
        return _connect.VectorBatchAccessResult_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorBatchAccessResult_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorBatchAccessResult_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorBatchAccessResult_reserve(self, n)

    def capacity(self):
        return _connect.VectorBatchAccessResult_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBatchAccessResult

# Register VectorBatchAccessResult in _connect:
_connect.VectorBatchAccessResult_swigregister(VectorBatchAccessResult)
class VectorWinIDEAInstanceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorWinIDEAInstanceInfo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorWinIDEAInstanceInfo___nonzero__(self)

    def __bool__(self):
        return _connect.VectorWinIDEAInstanceInfo___bool__(self)

    def __len__(self):
        return _connect.VectorWinIDEAInstanceInfo___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorWinIDEAInstanceInfo___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorWinIDEAInstanceInfo___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorWinIDEAInstanceInfo___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorWinIDEAInstanceInfo___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorWinIDEAInstanceInfo___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorWinIDEAInstanceInfo___setitem__(self, *args)

    def pop(self):
        return _connect.VectorWinIDEAInstanceInfo_pop(self)

    def append(self, x):
        return _connect.VectorWinIDEAInstanceInfo_append(self, x)

    def empty(self):
        return _connect.VectorWinIDEAInstanceInfo_empty(self)

    def size(self):
        return _connect.VectorWinIDEAInstanceInfo_size(self)

    def swap(self, v):
        return _connect.VectorWinIDEAInstanceInfo_swap(self, v)

    def begin(self):
        return _connect.VectorWinIDEAInstanceInfo_begin(self)

    def end(self):
        return _connect.VectorWinIDEAInstanceInfo_end(self)

    def rbegin(self):
        return _connect.VectorWinIDEAInstanceInfo_rbegin(self)

    def rend(self):
        return _connect.VectorWinIDEAInstanceInfo_rend(self)

    def clear(self):
        return _connect.VectorWinIDEAInstanceInfo_clear(self)

    def get_allocator(self):
        return _connect.VectorWinIDEAInstanceInfo_get_allocator(self)

    def pop_back(self):
        return _connect.VectorWinIDEAInstanceInfo_pop_back(self)

    def erase(self, *args):
        return _connect.VectorWinIDEAInstanceInfo_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorWinIDEAInstanceInfo_swiginit(self, _connect.new_VectorWinIDEAInstanceInfo(*args))

    def push_back(self, x):
        return _connect.VectorWinIDEAInstanceInfo_push_back(self, x)

    def front(self):
        return _connect.VectorWinIDEAInstanceInfo_front(self)

    def back(self):
        return _connect.VectorWinIDEAInstanceInfo_back(self)

    def assign(self, n, x):
        return _connect.VectorWinIDEAInstanceInfo_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorWinIDEAInstanceInfo_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorWinIDEAInstanceInfo_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorWinIDEAInstanceInfo_reserve(self, n)

    def capacity(self):
        return _connect.VectorWinIDEAInstanceInfo_capacity(self)
    __swig_destroy__ = _connect.delete_VectorWinIDEAInstanceInfo

# Register VectorWinIDEAInstanceInfo in _connect:
_connect.VectorWinIDEAInstanceInfo_swigregister(VectorWinIDEAInstanceInfo)
class VectorSinstalled_winIDEA(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorSinstalled_winIDEA_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorSinstalled_winIDEA___nonzero__(self)

    def __bool__(self):
        return _connect.VectorSinstalled_winIDEA___bool__(self)

    def __len__(self):
        return _connect.VectorSinstalled_winIDEA___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorSinstalled_winIDEA___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorSinstalled_winIDEA___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorSinstalled_winIDEA___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorSinstalled_winIDEA___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorSinstalled_winIDEA___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorSinstalled_winIDEA___setitem__(self, *args)

    def pop(self):
        return _connect.VectorSinstalled_winIDEA_pop(self)

    def append(self, x):
        return _connect.VectorSinstalled_winIDEA_append(self, x)

    def empty(self):
        return _connect.VectorSinstalled_winIDEA_empty(self)

    def size(self):
        return _connect.VectorSinstalled_winIDEA_size(self)

    def swap(self, v):
        return _connect.VectorSinstalled_winIDEA_swap(self, v)

    def begin(self):
        return _connect.VectorSinstalled_winIDEA_begin(self)

    def end(self):
        return _connect.VectorSinstalled_winIDEA_end(self)

    def rbegin(self):
        return _connect.VectorSinstalled_winIDEA_rbegin(self)

    def rend(self):
        return _connect.VectorSinstalled_winIDEA_rend(self)

    def clear(self):
        return _connect.VectorSinstalled_winIDEA_clear(self)

    def get_allocator(self):
        return _connect.VectorSinstalled_winIDEA_get_allocator(self)

    def pop_back(self):
        return _connect.VectorSinstalled_winIDEA_pop_back(self)

    def erase(self, *args):
        return _connect.VectorSinstalled_winIDEA_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorSinstalled_winIDEA_swiginit(self, _connect.new_VectorSinstalled_winIDEA(*args))

    def push_back(self, x):
        return _connect.VectorSinstalled_winIDEA_push_back(self, x)

    def front(self):
        return _connect.VectorSinstalled_winIDEA_front(self)

    def back(self):
        return _connect.VectorSinstalled_winIDEA_back(self)

    def assign(self, n, x):
        return _connect.VectorSinstalled_winIDEA_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorSinstalled_winIDEA_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorSinstalled_winIDEA_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorSinstalled_winIDEA_reserve(self, n)

    def capacity(self):
        return _connect.VectorSinstalled_winIDEA_capacity(self)
    __swig_destroy__ = _connect.delete_VectorSinstalled_winIDEA

# Register VectorSinstalled_winIDEA in _connect:
_connect.VectorSinstalled_winIDEA_swigregister(VectorSinstalled_winIDEA)
class VWinIDEAVersion(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VWinIDEAVersion_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VWinIDEAVersion___nonzero__(self)

    def __bool__(self):
        return _connect.VWinIDEAVersion___bool__(self)

    def __len__(self):
        return _connect.VWinIDEAVersion___len__(self)

    def __getslice__(self, i, j):
        return _connect.VWinIDEAVersion___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VWinIDEAVersion___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VWinIDEAVersion___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VWinIDEAVersion___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VWinIDEAVersion___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VWinIDEAVersion___setitem__(self, *args)

    def pop(self):
        return _connect.VWinIDEAVersion_pop(self)

    def append(self, x):
        return _connect.VWinIDEAVersion_append(self, x)

    def empty(self):
        return _connect.VWinIDEAVersion_empty(self)

    def size(self):
        return _connect.VWinIDEAVersion_size(self)

    def swap(self, v):
        return _connect.VWinIDEAVersion_swap(self, v)

    def begin(self):
        return _connect.VWinIDEAVersion_begin(self)

    def end(self):
        return _connect.VWinIDEAVersion_end(self)

    def rbegin(self):
        return _connect.VWinIDEAVersion_rbegin(self)

    def rend(self):
        return _connect.VWinIDEAVersion_rend(self)

    def clear(self):
        return _connect.VWinIDEAVersion_clear(self)

    def get_allocator(self):
        return _connect.VWinIDEAVersion_get_allocator(self)

    def pop_back(self):
        return _connect.VWinIDEAVersion_pop_back(self)

    def erase(self, *args):
        return _connect.VWinIDEAVersion_erase(self, *args)

    def __init__(self, *args):
        _connect.VWinIDEAVersion_swiginit(self, _connect.new_VWinIDEAVersion(*args))

    def push_back(self, x):
        return _connect.VWinIDEAVersion_push_back(self, x)

    def front(self):
        return _connect.VWinIDEAVersion_front(self)

    def back(self):
        return _connect.VWinIDEAVersion_back(self)

    def assign(self, n, x):
        return _connect.VWinIDEAVersion_assign(self, n, x)

    def resize(self, *args):
        return _connect.VWinIDEAVersion_resize(self, *args)

    def insert(self, *args):
        return _connect.VWinIDEAVersion_insert(self, *args)

    def reserve(self, n):
        return _connect.VWinIDEAVersion_reserve(self, n)

    def capacity(self):
        return _connect.VWinIDEAVersion_capacity(self)
    __swig_destroy__ = _connect.delete_VWinIDEAVersion

# Register VWinIDEAVersion in _connect:
_connect.VWinIDEAVersion_swigregister(VWinIDEAVersion)
class VectorDataComposite(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorDataComposite_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorDataComposite___nonzero__(self)

    def __bool__(self):
        return _connect.VectorDataComposite___bool__(self)

    def __len__(self):
        return _connect.VectorDataComposite___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorDataComposite___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorDataComposite___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorDataComposite___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorDataComposite___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorDataComposite___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorDataComposite___setitem__(self, *args)

    def pop(self):
        return _connect.VectorDataComposite_pop(self)

    def append(self, x):
        return _connect.VectorDataComposite_append(self, x)

    def empty(self):
        return _connect.VectorDataComposite_empty(self)

    def size(self):
        return _connect.VectorDataComposite_size(self)

    def swap(self, v):
        return _connect.VectorDataComposite_swap(self, v)

    def begin(self):
        return _connect.VectorDataComposite_begin(self)

    def end(self):
        return _connect.VectorDataComposite_end(self)

    def rbegin(self):
        return _connect.VectorDataComposite_rbegin(self)

    def rend(self):
        return _connect.VectorDataComposite_rend(self)

    def clear(self):
        return _connect.VectorDataComposite_clear(self)

    def get_allocator(self):
        return _connect.VectorDataComposite_get_allocator(self)

    def pop_back(self):
        return _connect.VectorDataComposite_pop_back(self)

    def erase(self, *args):
        return _connect.VectorDataComposite_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorDataComposite_swiginit(self, _connect.new_VectorDataComposite(*args))

    def push_back(self, x):
        return _connect.VectorDataComposite_push_back(self, x)

    def front(self):
        return _connect.VectorDataComposite_front(self)

    def back(self):
        return _connect.VectorDataComposite_back(self)

    def assign(self, n, x):
        return _connect.VectorDataComposite_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorDataComposite_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorDataComposite_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorDataComposite_reserve(self, n)

    def capacity(self):
        return _connect.VectorDataComposite_capacity(self)
    __swig_destroy__ = _connect.delete_VectorDataComposite

# Register VectorDataComposite in _connect:
_connect.VectorDataComposite_swigregister(VectorDataComposite)
class VectorOnChipData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorOnChipData_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorOnChipData___nonzero__(self)

    def __bool__(self):
        return _connect.VectorOnChipData___bool__(self)

    def __len__(self):
        return _connect.VectorOnChipData___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorOnChipData___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorOnChipData___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorOnChipData___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorOnChipData___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorOnChipData___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorOnChipData___setitem__(self, *args)

    def pop(self):
        return _connect.VectorOnChipData_pop(self)

    def append(self, x):
        return _connect.VectorOnChipData_append(self, x)

    def empty(self):
        return _connect.VectorOnChipData_empty(self)

    def size(self):
        return _connect.VectorOnChipData_size(self)

    def swap(self, v):
        return _connect.VectorOnChipData_swap(self, v)

    def begin(self):
        return _connect.VectorOnChipData_begin(self)

    def end(self):
        return _connect.VectorOnChipData_end(self)

    def rbegin(self):
        return _connect.VectorOnChipData_rbegin(self)

    def rend(self):
        return _connect.VectorOnChipData_rend(self)

    def clear(self):
        return _connect.VectorOnChipData_clear(self)

    def get_allocator(self):
        return _connect.VectorOnChipData_get_allocator(self)

    def pop_back(self):
        return _connect.VectorOnChipData_pop_back(self)

    def erase(self, *args):
        return _connect.VectorOnChipData_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorOnChipData_swiginit(self, _connect.new_VectorOnChipData(*args))

    def push_back(self, x):
        return _connect.VectorOnChipData_push_back(self, x)

    def front(self):
        return _connect.VectorOnChipData_front(self)

    def back(self):
        return _connect.VectorOnChipData_back(self)

    def assign(self, n, x):
        return _connect.VectorOnChipData_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorOnChipData_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorOnChipData_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorOnChipData_reserve(self, n)

    def capacity(self):
        return _connect.VectorOnChipData_capacity(self)
    __swig_destroy__ = _connect.delete_VectorOnChipData

# Register VectorOnChipData in _connect:
_connect.VectorOnChipData_swigregister(VectorOnChipData)
class VBPInstances(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VBPInstances_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VBPInstances___nonzero__(self)

    def __bool__(self):
        return _connect.VBPInstances___bool__(self)

    def __len__(self):
        return _connect.VBPInstances___len__(self)

    def __getslice__(self, i, j):
        return _connect.VBPInstances___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VBPInstances___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VBPInstances___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VBPInstances___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VBPInstances___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VBPInstances___setitem__(self, *args)

    def pop(self):
        return _connect.VBPInstances_pop(self)

    def append(self, x):
        return _connect.VBPInstances_append(self, x)

    def empty(self):
        return _connect.VBPInstances_empty(self)

    def size(self):
        return _connect.VBPInstances_size(self)

    def swap(self, v):
        return _connect.VBPInstances_swap(self, v)

    def begin(self):
        return _connect.VBPInstances_begin(self)

    def end(self):
        return _connect.VBPInstances_end(self)

    def rbegin(self):
        return _connect.VBPInstances_rbegin(self)

    def rend(self):
        return _connect.VBPInstances_rend(self)

    def clear(self):
        return _connect.VBPInstances_clear(self)

    def get_allocator(self):
        return _connect.VBPInstances_get_allocator(self)

    def pop_back(self):
        return _connect.VBPInstances_pop_back(self)

    def erase(self, *args):
        return _connect.VBPInstances_erase(self, *args)

    def __init__(self, *args):
        _connect.VBPInstances_swiginit(self, _connect.new_VBPInstances(*args))

    def push_back(self, x):
        return _connect.VBPInstances_push_back(self, x)

    def front(self):
        return _connect.VBPInstances_front(self)

    def back(self):
        return _connect.VBPInstances_back(self)

    def assign(self, n, x):
        return _connect.VBPInstances_assign(self, n, x)

    def resize(self, *args):
        return _connect.VBPInstances_resize(self, *args)

    def insert(self, *args):
        return _connect.VBPInstances_insert(self, *args)

    def reserve(self, n):
        return _connect.VBPInstances_reserve(self, n)

    def capacity(self):
        return _connect.VBPInstances_capacity(self)
    __swig_destroy__ = _connect.delete_VBPInstances

# Register VBPInstances in _connect:
_connect.VBPInstances_swigregister(VBPInstances)
class IVectorDisassemblyLines(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorDisassemblyLines_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorDisassemblyLines_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorDisassemblyLines

# Register IVectorDisassemblyLines in _connect:
_connect.IVectorDisassemblyLines_swigregister(IVectorDisassemblyLines)
class IVectorVariables(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorVariables_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorVariables_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorVariables

# Register IVectorVariables in _connect:
_connect.IVectorVariables_swigregister(IVectorVariables)
class IVectorFunctions(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorFunctions_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorFunctions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorFunctions

# Register IVectorFunctions in _connect:
_connect.IVectorFunctions_swigregister(IVectorFunctions)
class IVectorStackFrames(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorStackFrames_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorStackFrames_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorStackFrames

# Register IVectorStackFrames in _connect:
_connect.IVectorStackFrames_swigregister(IVectorStackFrames)
class IVectorPartitions(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorPartitions_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorPartitions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorPartitions

# Register IVectorPartitions in _connect:
_connect.IVectorPartitions_swigregister(IVectorPartitions)
class IVectorModules(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorModules_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorModules_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorModules

# Register IVectorModules in _connect:
_connect.IVectorModules_swigregister(IVectorModules)
class IVectorSFRs(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorSFRs_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorSFRs_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorSFRs

# Register IVectorSFRs in _connect:
_connect.IVectorSFRs_swigregister(IVectorSFRs)
class IVectorValueMap(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorValueMap_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorValueMap_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorValueMap

# Register IVectorValueMap in _connect:
_connect.IVectorValueMap_swigregister(IVectorValueMap)
class IVectorTypes(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorTypes_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorTypes_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorTypes

# Register IVectorTypes in _connect:
_connect.IVectorTypes_swigregister(IVectorTypes)
class IVectorTypedefs(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorTypedefs_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorTypedefs_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorTypedefs

# Register IVectorTypedefs in _connect:
_connect.IVectorTypedefs_swigregister(IVectorTypedefs)
class IVectorItemDescriptors(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorItemDescriptors_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorItemDescriptors_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorItemDescriptors

# Register IVectorItemDescriptors in _connect:
_connect.IVectorItemDescriptors_swigregister(IVectorItemDescriptors)
class IVectorEnumMaps(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorEnumMaps_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorEnumMaps_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorEnumMaps

# Register IVectorEnumMaps in _connect:
_connect.IVectorEnumMaps_swigregister(IVectorEnumMaps)
class IVectorInstructions(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorInstructions_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorInstructions_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorInstructions

# Register IVectorInstructions in _connect:
_connect.IVectorInstructions_swigregister(IVectorInstructions)
class IVectorMacros(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorMacros_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorMacros_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorMacros

# Register IVectorMacros in _connect:
_connect.IVectorMacros_swigregister(IVectorMacros)
class IVectorProperties(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorProperties_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorProperties_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorProperties

# Register IVectorProperties in _connect:
_connect.IVectorProperties_swigregister(IVectorProperties)
class IVectorMenuItems(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorMenuItems_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorMenuItems_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorMenuItems

# Register IVectorMenuItems in _connect:
_connect.IVectorMenuItems_swigregister(IVectorMenuItems)
class IVectorCallees(object):
    r"""Minimal read-only vector interface."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def size(self):
        r"""Returns the number of elements in vector."""
        return _connect.IVectorCallees_size(self)

    def at(self, _Pos):
        r"""Returns the element at position _Pos in vector."""
        return _connect.IVectorCallees_at(self, _Pos)
    __swig_destroy__ = _connect.delete_IVectorCallees

# Register IVectorCallees in _connect:
_connect.IVectorCallees_swigregister(IVectorCallees)
class ProfilerStatistics2Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.ProfilerStatistics2Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.ProfilerStatistics2Vector___nonzero__(self)

    def __bool__(self):
        return _connect.ProfilerStatistics2Vector___bool__(self)

    def __len__(self):
        return _connect.ProfilerStatistics2Vector___len__(self)

    def __getslice__(self, i, j):
        return _connect.ProfilerStatistics2Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.ProfilerStatistics2Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.ProfilerStatistics2Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.ProfilerStatistics2Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.ProfilerStatistics2Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.ProfilerStatistics2Vector___setitem__(self, *args)

    def pop(self):
        return _connect.ProfilerStatistics2Vector_pop(self)

    def append(self, x):
        return _connect.ProfilerStatistics2Vector_append(self, x)

    def empty(self):
        return _connect.ProfilerStatistics2Vector_empty(self)

    def size(self):
        return _connect.ProfilerStatistics2Vector_size(self)

    def swap(self, v):
        return _connect.ProfilerStatistics2Vector_swap(self, v)

    def begin(self):
        return _connect.ProfilerStatistics2Vector_begin(self)

    def end(self):
        return _connect.ProfilerStatistics2Vector_end(self)

    def rbegin(self):
        return _connect.ProfilerStatistics2Vector_rbegin(self)

    def rend(self):
        return _connect.ProfilerStatistics2Vector_rend(self)

    def clear(self):
        return _connect.ProfilerStatistics2Vector_clear(self)

    def get_allocator(self):
        return _connect.ProfilerStatistics2Vector_get_allocator(self)

    def pop_back(self):
        return _connect.ProfilerStatistics2Vector_pop_back(self)

    def erase(self, *args):
        return _connect.ProfilerStatistics2Vector_erase(self, *args)

    def __init__(self, *args):
        _connect.ProfilerStatistics2Vector_swiginit(self, _connect.new_ProfilerStatistics2Vector(*args))

    def push_back(self, x):
        return _connect.ProfilerStatistics2Vector_push_back(self, x)

    def front(self):
        return _connect.ProfilerStatistics2Vector_front(self)

    def back(self):
        return _connect.ProfilerStatistics2Vector_back(self)

    def assign(self, n, x):
        return _connect.ProfilerStatistics2Vector_assign(self, n, x)

    def resize(self, *args):
        return _connect.ProfilerStatistics2Vector_resize(self, *args)

    def insert(self, *args):
        return _connect.ProfilerStatistics2Vector_insert(self, *args)

    def reserve(self, n):
        return _connect.ProfilerStatistics2Vector_reserve(self, n)

    def capacity(self):
        return _connect.ProfilerStatistics2Vector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerStatistics2Vector

# Register ProfilerStatistics2Vector in _connect:
_connect.ProfilerStatistics2Vector_swigregister(ProfilerStatistics2Vector)
class ProfilerStatisticVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.ProfilerStatisticVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.ProfilerStatisticVector___nonzero__(self)

    def __bool__(self):
        return _connect.ProfilerStatisticVector___bool__(self)

    def __len__(self):
        return _connect.ProfilerStatisticVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.ProfilerStatisticVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.ProfilerStatisticVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.ProfilerStatisticVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.ProfilerStatisticVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.ProfilerStatisticVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.ProfilerStatisticVector___setitem__(self, *args)

    def pop(self):
        return _connect.ProfilerStatisticVector_pop(self)

    def append(self, x):
        return _connect.ProfilerStatisticVector_append(self, x)

    def empty(self):
        return _connect.ProfilerStatisticVector_empty(self)

    def size(self):
        return _connect.ProfilerStatisticVector_size(self)

    def swap(self, v):
        return _connect.ProfilerStatisticVector_swap(self, v)

    def begin(self):
        return _connect.ProfilerStatisticVector_begin(self)

    def end(self):
        return _connect.ProfilerStatisticVector_end(self)

    def rbegin(self):
        return _connect.ProfilerStatisticVector_rbegin(self)

    def rend(self):
        return _connect.ProfilerStatisticVector_rend(self)

    def clear(self):
        return _connect.ProfilerStatisticVector_clear(self)

    def get_allocator(self):
        return _connect.ProfilerStatisticVector_get_allocator(self)

    def pop_back(self):
        return _connect.ProfilerStatisticVector_pop_back(self)

    def erase(self, *args):
        return _connect.ProfilerStatisticVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ProfilerStatisticVector_swiginit(self, _connect.new_ProfilerStatisticVector(*args))

    def push_back(self, x):
        return _connect.ProfilerStatisticVector_push_back(self, x)

    def front(self):
        return _connect.ProfilerStatisticVector_front(self)

    def back(self):
        return _connect.ProfilerStatisticVector_back(self)

    def assign(self, n, x):
        return _connect.ProfilerStatisticVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.ProfilerStatisticVector_resize(self, *args)

    def insert(self, *args):
        return _connect.ProfilerStatisticVector_insert(self, *args)

    def reserve(self, n):
        return _connect.ProfilerStatisticVector_reserve(self, n)

    def capacity(self):
        return _connect.ProfilerStatisticVector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerStatisticVector

# Register ProfilerStatisticVector in _connect:
_connect.ProfilerStatisticVector_swigregister(ProfilerStatisticVector)
class ProfilerHistoryVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.ProfilerHistoryVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.ProfilerHistoryVector___nonzero__(self)

    def __bool__(self):
        return _connect.ProfilerHistoryVector___bool__(self)

    def __len__(self):
        return _connect.ProfilerHistoryVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.ProfilerHistoryVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.ProfilerHistoryVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.ProfilerHistoryVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.ProfilerHistoryVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.ProfilerHistoryVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.ProfilerHistoryVector___setitem__(self, *args)

    def pop(self):
        return _connect.ProfilerHistoryVector_pop(self)

    def append(self, x):
        return _connect.ProfilerHistoryVector_append(self, x)

    def empty(self):
        return _connect.ProfilerHistoryVector_empty(self)

    def size(self):
        return _connect.ProfilerHistoryVector_size(self)

    def swap(self, v):
        return _connect.ProfilerHistoryVector_swap(self, v)

    def begin(self):
        return _connect.ProfilerHistoryVector_begin(self)

    def end(self):
        return _connect.ProfilerHistoryVector_end(self)

    def rbegin(self):
        return _connect.ProfilerHistoryVector_rbegin(self)

    def rend(self):
        return _connect.ProfilerHistoryVector_rend(self)

    def clear(self):
        return _connect.ProfilerHistoryVector_clear(self)

    def get_allocator(self):
        return _connect.ProfilerHistoryVector_get_allocator(self)

    def pop_back(self):
        return _connect.ProfilerHistoryVector_pop_back(self)

    def erase(self, *args):
        return _connect.ProfilerHistoryVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ProfilerHistoryVector_swiginit(self, _connect.new_ProfilerHistoryVector(*args))

    def push_back(self, x):
        return _connect.ProfilerHistoryVector_push_back(self, x)

    def front(self):
        return _connect.ProfilerHistoryVector_front(self)

    def back(self):
        return _connect.ProfilerHistoryVector_back(self)

    def assign(self, n, x):
        return _connect.ProfilerHistoryVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.ProfilerHistoryVector_resize(self, *args)

    def insert(self, *args):
        return _connect.ProfilerHistoryVector_insert(self, *args)

    def reserve(self, n):
        return _connect.ProfilerHistoryVector_reserve(self, n)

    def capacity(self):
        return _connect.ProfilerHistoryVector_capacity(self)
    __swig_destroy__ = _connect.delete_ProfilerHistoryVector

# Register ProfilerHistoryVector in _connect:
_connect.ProfilerHistoryVector_swigregister(ProfilerHistoryVector)
class CoverageRangeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.CoverageRangeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.CoverageRangeVector___nonzero__(self)

    def __bool__(self):
        return _connect.CoverageRangeVector___bool__(self)

    def __len__(self):
        return _connect.CoverageRangeVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.CoverageRangeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.CoverageRangeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.CoverageRangeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.CoverageRangeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.CoverageRangeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.CoverageRangeVector___setitem__(self, *args)

    def pop(self):
        return _connect.CoverageRangeVector_pop(self)

    def append(self, x):
        return _connect.CoverageRangeVector_append(self, x)

    def empty(self):
        return _connect.CoverageRangeVector_empty(self)

    def size(self):
        return _connect.CoverageRangeVector_size(self)

    def swap(self, v):
        return _connect.CoverageRangeVector_swap(self, v)

    def begin(self):
        return _connect.CoverageRangeVector_begin(self)

    def end(self):
        return _connect.CoverageRangeVector_end(self)

    def rbegin(self):
        return _connect.CoverageRangeVector_rbegin(self)

    def rend(self):
        return _connect.CoverageRangeVector_rend(self)

    def clear(self):
        return _connect.CoverageRangeVector_clear(self)

    def get_allocator(self):
        return _connect.CoverageRangeVector_get_allocator(self)

    def pop_back(self):
        return _connect.CoverageRangeVector_pop_back(self)

    def erase(self, *args):
        return _connect.CoverageRangeVector_erase(self, *args)

    def __init__(self, *args):
        _connect.CoverageRangeVector_swiginit(self, _connect.new_CoverageRangeVector(*args))

    def push_back(self, x):
        return _connect.CoverageRangeVector_push_back(self, x)

    def front(self):
        return _connect.CoverageRangeVector_front(self)

    def back(self):
        return _connect.CoverageRangeVector_back(self)

    def assign(self, n, x):
        return _connect.CoverageRangeVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.CoverageRangeVector_resize(self, *args)

    def insert(self, *args):
        return _connect.CoverageRangeVector_insert(self, *args)

    def reserve(self, n):
        return _connect.CoverageRangeVector_reserve(self, n)

    def capacity(self):
        return _connect.CoverageRangeVector_capacity(self)
    __swig_destroy__ = _connect.delete_CoverageRangeVector

# Register CoverageRangeVector in _connect:
_connect.CoverageRangeVector_swigregister(CoverageRangeVector)
class DownloadListVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.DownloadListVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.DownloadListVector___nonzero__(self)

    def __bool__(self):
        return _connect.DownloadListVector___bool__(self)

    def __len__(self):
        return _connect.DownloadListVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.DownloadListVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.DownloadListVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.DownloadListVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.DownloadListVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.DownloadListVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.DownloadListVector___setitem__(self, *args)

    def pop(self):
        return _connect.DownloadListVector_pop(self)

    def append(self, x):
        return _connect.DownloadListVector_append(self, x)

    def empty(self):
        return _connect.DownloadListVector_empty(self)

    def size(self):
        return _connect.DownloadListVector_size(self)

    def swap(self, v):
        return _connect.DownloadListVector_swap(self, v)

    def begin(self):
        return _connect.DownloadListVector_begin(self)

    def end(self):
        return _connect.DownloadListVector_end(self)

    def rbegin(self):
        return _connect.DownloadListVector_rbegin(self)

    def rend(self):
        return _connect.DownloadListVector_rend(self)

    def clear(self):
        return _connect.DownloadListVector_clear(self)

    def get_allocator(self):
        return _connect.DownloadListVector_get_allocator(self)

    def pop_back(self):
        return _connect.DownloadListVector_pop_back(self)

    def erase(self, *args):
        return _connect.DownloadListVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DownloadListVector_swiginit(self, _connect.new_DownloadListVector(*args))

    def push_back(self, x):
        return _connect.DownloadListVector_push_back(self, x)

    def front(self):
        return _connect.DownloadListVector_front(self)

    def back(self):
        return _connect.DownloadListVector_back(self)

    def assign(self, n, x):
        return _connect.DownloadListVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.DownloadListVector_resize(self, *args)

    def insert(self, *args):
        return _connect.DownloadListVector_insert(self, *args)

    def reserve(self, n):
        return _connect.DownloadListVector_reserve(self, n)

    def capacity(self):
        return _connect.DownloadListVector_capacity(self)
    __swig_destroy__ = _connect.delete_DownloadListVector

# Register DownloadListVector in _connect:
_connect.DownloadListVector_swigregister(DownloadListVector)
class StackFrameVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.StackFrameVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.StackFrameVector___nonzero__(self)

    def __bool__(self):
        return _connect.StackFrameVector___bool__(self)

    def __len__(self):
        return _connect.StackFrameVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.StackFrameVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.StackFrameVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.StackFrameVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.StackFrameVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.StackFrameVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.StackFrameVector___setitem__(self, *args)

    def pop(self):
        return _connect.StackFrameVector_pop(self)

    def append(self, x):
        return _connect.StackFrameVector_append(self, x)

    def empty(self):
        return _connect.StackFrameVector_empty(self)

    def size(self):
        return _connect.StackFrameVector_size(self)

    def swap(self, v):
        return _connect.StackFrameVector_swap(self, v)

    def begin(self):
        return _connect.StackFrameVector_begin(self)

    def end(self):
        return _connect.StackFrameVector_end(self)

    def rbegin(self):
        return _connect.StackFrameVector_rbegin(self)

    def rend(self):
        return _connect.StackFrameVector_rend(self)

    def clear(self):
        return _connect.StackFrameVector_clear(self)

    def get_allocator(self):
        return _connect.StackFrameVector_get_allocator(self)

    def pop_back(self):
        return _connect.StackFrameVector_pop_back(self)

    def erase(self, *args):
        return _connect.StackFrameVector_erase(self, *args)

    def __init__(self, *args):
        _connect.StackFrameVector_swiginit(self, _connect.new_StackFrameVector(*args))

    def push_back(self, x):
        return _connect.StackFrameVector_push_back(self, x)

    def front(self):
        return _connect.StackFrameVector_front(self)

    def back(self):
        return _connect.StackFrameVector_back(self)

    def assign(self, n, x):
        return _connect.StackFrameVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.StackFrameVector_resize(self, *args)

    def insert(self, *args):
        return _connect.StackFrameVector_insert(self, *args)

    def reserve(self, n):
        return _connect.StackFrameVector_reserve(self, n)

    def capacity(self):
        return _connect.StackFrameVector_capacity(self)
    __swig_destroy__ = _connect.delete_StackFrameVector

# Register StackFrameVector in _connect:
_connect.StackFrameVector_swigregister(StackFrameVector)
class VariableVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VariableVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VariableVector___nonzero__(self)

    def __bool__(self):
        return _connect.VariableVector___bool__(self)

    def __len__(self):
        return _connect.VariableVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.VariableVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VariableVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VariableVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VariableVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VariableVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VariableVector___setitem__(self, *args)

    def pop(self):
        return _connect.VariableVector_pop(self)

    def append(self, x):
        return _connect.VariableVector_append(self, x)

    def empty(self):
        return _connect.VariableVector_empty(self)

    def size(self):
        return _connect.VariableVector_size(self)

    def swap(self, v):
        return _connect.VariableVector_swap(self, v)

    def begin(self):
        return _connect.VariableVector_begin(self)

    def end(self):
        return _connect.VariableVector_end(self)

    def rbegin(self):
        return _connect.VariableVector_rbegin(self)

    def rend(self):
        return _connect.VariableVector_rend(self)

    def clear(self):
        return _connect.VariableVector_clear(self)

    def get_allocator(self):
        return _connect.VariableVector_get_allocator(self)

    def pop_back(self):
        return _connect.VariableVector_pop_back(self)

    def erase(self, *args):
        return _connect.VariableVector_erase(self, *args)

    def __init__(self, *args):
        _connect.VariableVector_swiginit(self, _connect.new_VariableVector(*args))

    def push_back(self, x):
        return _connect.VariableVector_push_back(self, x)

    def front(self):
        return _connect.VariableVector_front(self)

    def back(self):
        return _connect.VariableVector_back(self)

    def assign(self, n, x):
        return _connect.VariableVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.VariableVector_resize(self, *args)

    def insert(self, *args):
        return _connect.VariableVector_insert(self, *args)

    def reserve(self, n):
        return _connect.VariableVector_reserve(self, n)

    def capacity(self):
        return _connect.VariableVector_capacity(self)
    __swig_destroy__ = _connect.delete_VariableVector

# Register VariableVector in _connect:
_connect.VariableVector_swigregister(VariableVector)
class FunctionVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.FunctionVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.FunctionVector___nonzero__(self)

    def __bool__(self):
        return _connect.FunctionVector___bool__(self)

    def __len__(self):
        return _connect.FunctionVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.FunctionVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.FunctionVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.FunctionVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.FunctionVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.FunctionVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.FunctionVector___setitem__(self, *args)

    def pop(self):
        return _connect.FunctionVector_pop(self)

    def append(self, x):
        return _connect.FunctionVector_append(self, x)

    def empty(self):
        return _connect.FunctionVector_empty(self)

    def size(self):
        return _connect.FunctionVector_size(self)

    def swap(self, v):
        return _connect.FunctionVector_swap(self, v)

    def begin(self):
        return _connect.FunctionVector_begin(self)

    def end(self):
        return _connect.FunctionVector_end(self)

    def rbegin(self):
        return _connect.FunctionVector_rbegin(self)

    def rend(self):
        return _connect.FunctionVector_rend(self)

    def clear(self):
        return _connect.FunctionVector_clear(self)

    def get_allocator(self):
        return _connect.FunctionVector_get_allocator(self)

    def pop_back(self):
        return _connect.FunctionVector_pop_back(self)

    def erase(self, *args):
        return _connect.FunctionVector_erase(self, *args)

    def __init__(self, *args):
        _connect.FunctionVector_swiginit(self, _connect.new_FunctionVector(*args))

    def push_back(self, x):
        return _connect.FunctionVector_push_back(self, x)

    def front(self):
        return _connect.FunctionVector_front(self)

    def back(self):
        return _connect.FunctionVector_back(self)

    def assign(self, n, x):
        return _connect.FunctionVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.FunctionVector_resize(self, *args)

    def insert(self, *args):
        return _connect.FunctionVector_insert(self, *args)

    def reserve(self, n):
        return _connect.FunctionVector_reserve(self, n)

    def capacity(self):
        return _connect.FunctionVector_capacity(self)
    __swig_destroy__ = _connect.delete_FunctionVector

# Register FunctionVector in _connect:
_connect.FunctionVector_swigregister(FunctionVector)
class ModuleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.ModuleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.ModuleVector___nonzero__(self)

    def __bool__(self):
        return _connect.ModuleVector___bool__(self)

    def __len__(self):
        return _connect.ModuleVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.ModuleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.ModuleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.ModuleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.ModuleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.ModuleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.ModuleVector___setitem__(self, *args)

    def pop(self):
        return _connect.ModuleVector_pop(self)

    def append(self, x):
        return _connect.ModuleVector_append(self, x)

    def empty(self):
        return _connect.ModuleVector_empty(self)

    def size(self):
        return _connect.ModuleVector_size(self)

    def swap(self, v):
        return _connect.ModuleVector_swap(self, v)

    def begin(self):
        return _connect.ModuleVector_begin(self)

    def end(self):
        return _connect.ModuleVector_end(self)

    def rbegin(self):
        return _connect.ModuleVector_rbegin(self)

    def rend(self):
        return _connect.ModuleVector_rend(self)

    def clear(self):
        return _connect.ModuleVector_clear(self)

    def get_allocator(self):
        return _connect.ModuleVector_get_allocator(self)

    def pop_back(self):
        return _connect.ModuleVector_pop_back(self)

    def erase(self, *args):
        return _connect.ModuleVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ModuleVector_swiginit(self, _connect.new_ModuleVector(*args))

    def push_back(self, x):
        return _connect.ModuleVector_push_back(self, x)

    def front(self):
        return _connect.ModuleVector_front(self)

    def back(self):
        return _connect.ModuleVector_back(self)

    def assign(self, n, x):
        return _connect.ModuleVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.ModuleVector_resize(self, *args)

    def insert(self, *args):
        return _connect.ModuleVector_insert(self, *args)

    def reserve(self, n):
        return _connect.ModuleVector_reserve(self, n)

    def capacity(self):
        return _connect.ModuleVector_capacity(self)
    __swig_destroy__ = _connect.delete_ModuleVector

# Register ModuleVector in _connect:
_connect.ModuleVector_swigregister(ModuleVector)
class TypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.TypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.TypeVector___nonzero__(self)

    def __bool__(self):
        return _connect.TypeVector___bool__(self)

    def __len__(self):
        return _connect.TypeVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.TypeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.TypeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.TypeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.TypeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.TypeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.TypeVector___setitem__(self, *args)

    def pop(self):
        return _connect.TypeVector_pop(self)

    def append(self, x):
        return _connect.TypeVector_append(self, x)

    def empty(self):
        return _connect.TypeVector_empty(self)

    def size(self):
        return _connect.TypeVector_size(self)

    def swap(self, v):
        return _connect.TypeVector_swap(self, v)

    def begin(self):
        return _connect.TypeVector_begin(self)

    def end(self):
        return _connect.TypeVector_end(self)

    def rbegin(self):
        return _connect.TypeVector_rbegin(self)

    def rend(self):
        return _connect.TypeVector_rend(self)

    def clear(self):
        return _connect.TypeVector_clear(self)

    def get_allocator(self):
        return _connect.TypeVector_get_allocator(self)

    def pop_back(self):
        return _connect.TypeVector_pop_back(self)

    def erase(self, *args):
        return _connect.TypeVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TypeVector_swiginit(self, _connect.new_TypeVector(*args))

    def push_back(self, x):
        return _connect.TypeVector_push_back(self, x)

    def front(self):
        return _connect.TypeVector_front(self)

    def back(self):
        return _connect.TypeVector_back(self)

    def assign(self, n, x):
        return _connect.TypeVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.TypeVector_resize(self, *args)

    def insert(self, *args):
        return _connect.TypeVector_insert(self, *args)

    def reserve(self, n):
        return _connect.TypeVector_reserve(self, n)

    def capacity(self):
        return _connect.TypeVector_capacity(self)
    __swig_destroy__ = _connect.delete_TypeVector

# Register TypeVector in _connect:
_connect.TypeVector_swigregister(TypeVector)
class TypedefVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.TypedefVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.TypedefVector___nonzero__(self)

    def __bool__(self):
        return _connect.TypedefVector___bool__(self)

    def __len__(self):
        return _connect.TypedefVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.TypedefVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.TypedefVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.TypedefVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.TypedefVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.TypedefVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.TypedefVector___setitem__(self, *args)

    def pop(self):
        return _connect.TypedefVector_pop(self)

    def append(self, x):
        return _connect.TypedefVector_append(self, x)

    def empty(self):
        return _connect.TypedefVector_empty(self)

    def size(self):
        return _connect.TypedefVector_size(self)

    def swap(self, v):
        return _connect.TypedefVector_swap(self, v)

    def begin(self):
        return _connect.TypedefVector_begin(self)

    def end(self):
        return _connect.TypedefVector_end(self)

    def rbegin(self):
        return _connect.TypedefVector_rbegin(self)

    def rend(self):
        return _connect.TypedefVector_rend(self)

    def clear(self):
        return _connect.TypedefVector_clear(self)

    def get_allocator(self):
        return _connect.TypedefVector_get_allocator(self)

    def pop_back(self):
        return _connect.TypedefVector_pop_back(self)

    def erase(self, *args):
        return _connect.TypedefVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TypedefVector_swiginit(self, _connect.new_TypedefVector(*args))

    def push_back(self, x):
        return _connect.TypedefVector_push_back(self, x)

    def front(self):
        return _connect.TypedefVector_front(self)

    def back(self):
        return _connect.TypedefVector_back(self)

    def assign(self, n, x):
        return _connect.TypedefVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.TypedefVector_resize(self, *args)

    def insert(self, *args):
        return _connect.TypedefVector_insert(self, *args)

    def reserve(self, n):
        return _connect.TypedefVector_reserve(self, n)

    def capacity(self):
        return _connect.TypedefVector_capacity(self)
    __swig_destroy__ = _connect.delete_TypedefVector

# Register TypedefVector in _connect:
_connect.TypedefVector_swigregister(TypedefVector)
class HILChannelVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.HILChannelVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.HILChannelVector___nonzero__(self)

    def __bool__(self):
        return _connect.HILChannelVector___bool__(self)

    def __len__(self):
        return _connect.HILChannelVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.HILChannelVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.HILChannelVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.HILChannelVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.HILChannelVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.HILChannelVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.HILChannelVector___setitem__(self, *args)

    def pop(self):
        return _connect.HILChannelVector_pop(self)

    def append(self, x):
        return _connect.HILChannelVector_append(self, x)

    def empty(self):
        return _connect.HILChannelVector_empty(self)

    def size(self):
        return _connect.HILChannelVector_size(self)

    def swap(self, v):
        return _connect.HILChannelVector_swap(self, v)

    def begin(self):
        return _connect.HILChannelVector_begin(self)

    def end(self):
        return _connect.HILChannelVector_end(self)

    def rbegin(self):
        return _connect.HILChannelVector_rbegin(self)

    def rend(self):
        return _connect.HILChannelVector_rend(self)

    def clear(self):
        return _connect.HILChannelVector_clear(self)

    def get_allocator(self):
        return _connect.HILChannelVector_get_allocator(self)

    def pop_back(self):
        return _connect.HILChannelVector_pop_back(self)

    def erase(self, *args):
        return _connect.HILChannelVector_erase(self, *args)

    def __init__(self, *args):
        _connect.HILChannelVector_swiginit(self, _connect.new_HILChannelVector(*args))

    def push_back(self, x):
        return _connect.HILChannelVector_push_back(self, x)

    def front(self):
        return _connect.HILChannelVector_front(self)

    def back(self):
        return _connect.HILChannelVector_back(self)

    def assign(self, n, x):
        return _connect.HILChannelVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.HILChannelVector_resize(self, *args)

    def insert(self, *args):
        return _connect.HILChannelVector_insert(self, *args)

    def reserve(self, n):
        return _connect.HILChannelVector_reserve(self, n)

    def capacity(self):
        return _connect.HILChannelVector_capacity(self)
    __swig_destroy__ = _connect.delete_HILChannelVector

# Register HILChannelVector in _connect:
_connect.HILChannelVector_swigregister(HILChannelVector)
class CValueTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.CValueTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.CValueTypeVector___nonzero__(self)

    def __bool__(self):
        return _connect.CValueTypeVector___bool__(self)

    def __len__(self):
        return _connect.CValueTypeVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.CValueTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.CValueTypeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.CValueTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.CValueTypeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.CValueTypeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.CValueTypeVector___setitem__(self, *args)

    def pop(self):
        return _connect.CValueTypeVector_pop(self)

    def append(self, x):
        return _connect.CValueTypeVector_append(self, x)

    def empty(self):
        return _connect.CValueTypeVector_empty(self)

    def size(self):
        return _connect.CValueTypeVector_size(self)

    def swap(self, v):
        return _connect.CValueTypeVector_swap(self, v)

    def begin(self):
        return _connect.CValueTypeVector_begin(self)

    def end(self):
        return _connect.CValueTypeVector_end(self)

    def rbegin(self):
        return _connect.CValueTypeVector_rbegin(self)

    def rend(self):
        return _connect.CValueTypeVector_rend(self)

    def clear(self):
        return _connect.CValueTypeVector_clear(self)

    def get_allocator(self):
        return _connect.CValueTypeVector_get_allocator(self)

    def pop_back(self):
        return _connect.CValueTypeVector_pop_back(self)

    def erase(self, *args):
        return _connect.CValueTypeVector_erase(self, *args)

    def __init__(self, *args):
        _connect.CValueTypeVector_swiginit(self, _connect.new_CValueTypeVector(*args))

    def push_back(self, x):
        return _connect.CValueTypeVector_push_back(self, x)

    def front(self):
        return _connect.CValueTypeVector_front(self)

    def back(self):
        return _connect.CValueTypeVector_back(self)

    def assign(self, n, x):
        return _connect.CValueTypeVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.CValueTypeVector_resize(self, *args)

    def insert(self, *args):
        return _connect.CValueTypeVector_insert(self, *args)

    def reserve(self, n):
        return _connect.CValueTypeVector_reserve(self, n)

    def capacity(self):
        return _connect.CValueTypeVector_capacity(self)
    __swig_destroy__ = _connect.delete_CValueTypeVector

# Register CValueTypeVector in _connect:
_connect.CValueTypeVector_swigregister(CValueTypeVector)
class VectorBYTE(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VectorBYTE_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VectorBYTE___nonzero__(self)

    def __bool__(self):
        return _connect.VectorBYTE___bool__(self)

    def __len__(self):
        return _connect.VectorBYTE___len__(self)

    def __getslice__(self, i, j):
        return _connect.VectorBYTE___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VectorBYTE___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VectorBYTE___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VectorBYTE___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VectorBYTE___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VectorBYTE___setitem__(self, *args)

    def pop(self):
        return _connect.VectorBYTE_pop(self)

    def append(self, x):
        return _connect.VectorBYTE_append(self, x)

    def empty(self):
        return _connect.VectorBYTE_empty(self)

    def size(self):
        return _connect.VectorBYTE_size(self)

    def swap(self, v):
        return _connect.VectorBYTE_swap(self, v)

    def begin(self):
        return _connect.VectorBYTE_begin(self)

    def end(self):
        return _connect.VectorBYTE_end(self)

    def rbegin(self):
        return _connect.VectorBYTE_rbegin(self)

    def rend(self):
        return _connect.VectorBYTE_rend(self)

    def clear(self):
        return _connect.VectorBYTE_clear(self)

    def get_allocator(self):
        return _connect.VectorBYTE_get_allocator(self)

    def pop_back(self):
        return _connect.VectorBYTE_pop_back(self)

    def erase(self, *args):
        return _connect.VectorBYTE_erase(self, *args)

    def __init__(self, *args):
        _connect.VectorBYTE_swiginit(self, _connect.new_VectorBYTE(*args))

    def push_back(self, x):
        return _connect.VectorBYTE_push_back(self, x)

    def front(self):
        return _connect.VectorBYTE_front(self)

    def back(self):
        return _connect.VectorBYTE_back(self)

    def assign(self, n, x):
        return _connect.VectorBYTE_assign(self, n, x)

    def resize(self, *args):
        return _connect.VectorBYTE_resize(self, *args)

    def insert(self, *args):
        return _connect.VectorBYTE_insert(self, *args)

    def reserve(self, n):
        return _connect.VectorBYTE_reserve(self, n)

    def capacity(self):
        return _connect.VectorBYTE_capacity(self)
    __swig_destroy__ = _connect.delete_VectorBYTE

# Register VectorBYTE in _connect:
_connect.VectorBYTE_swigregister(VectorBYTE)
class StrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.StrVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.StrVector___nonzero__(self)

    def __bool__(self):
        return _connect.StrVector___bool__(self)

    def __len__(self):
        return _connect.StrVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.StrVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.StrVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.StrVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.StrVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.StrVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.StrVector___setitem__(self, *args)

    def pop(self):
        return _connect.StrVector_pop(self)

    def append(self, x):
        return _connect.StrVector_append(self, x)

    def empty(self):
        return _connect.StrVector_empty(self)

    def size(self):
        return _connect.StrVector_size(self)

    def swap(self, v):
        return _connect.StrVector_swap(self, v)

    def begin(self):
        return _connect.StrVector_begin(self)

    def end(self):
        return _connect.StrVector_end(self)

    def rbegin(self):
        return _connect.StrVector_rbegin(self)

    def rend(self):
        return _connect.StrVector_rend(self)

    def clear(self):
        return _connect.StrVector_clear(self)

    def get_allocator(self):
        return _connect.StrVector_get_allocator(self)

    def pop_back(self):
        return _connect.StrVector_pop_back(self)

    def erase(self, *args):
        return _connect.StrVector_erase(self, *args)

    def __init__(self, *args):
        _connect.StrVector_swiginit(self, _connect.new_StrVector(*args))

    def push_back(self, x):
        return _connect.StrVector_push_back(self, x)

    def front(self):
        return _connect.StrVector_front(self)

    def back(self):
        return _connect.StrVector_back(self)

    def assign(self, n, x):
        return _connect.StrVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.StrVector_resize(self, *args)

    def insert(self, *args):
        return _connect.StrVector_insert(self, *args)

    def reserve(self, n):
        return _connect.StrVector_reserve(self, n)

    def capacity(self):
        return _connect.StrVector_capacity(self)
    __swig_destroy__ = _connect.delete_StrVector

# Register StrVector in _connect:
_connect.StrVector_swigregister(StrVector)
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.IntVector___nonzero__(self)

    def __bool__(self):
        return _connect.IntVector___bool__(self)

    def __len__(self):
        return _connect.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.IntVector___setitem__(self, *args)

    def pop(self):
        return _connect.IntVector_pop(self)

    def append(self, x):
        return _connect.IntVector_append(self, x)

    def empty(self):
        return _connect.IntVector_empty(self)

    def size(self):
        return _connect.IntVector_size(self)

    def swap(self, v):
        return _connect.IntVector_swap(self, v)

    def begin(self):
        return _connect.IntVector_begin(self)

    def end(self):
        return _connect.IntVector_end(self)

    def rbegin(self):
        return _connect.IntVector_rbegin(self)

    def rend(self):
        return _connect.IntVector_rend(self)

    def clear(self):
        return _connect.IntVector_clear(self)

    def get_allocator(self):
        return _connect.IntVector_get_allocator(self)

    def pop_back(self):
        return _connect.IntVector_pop_back(self)

    def erase(self, *args):
        return _connect.IntVector_erase(self, *args)

    def __init__(self, *args):
        _connect.IntVector_swiginit(self, _connect.new_IntVector(*args))

    def push_back(self, x):
        return _connect.IntVector_push_back(self, x)

    def front(self):
        return _connect.IntVector_front(self)

    def back(self):
        return _connect.IntVector_back(self)

    def assign(self, n, x):
        return _connect.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.IntVector_resize(self, *args)

    def insert(self, *args):
        return _connect.IntVector_insert(self, *args)

    def reserve(self, n):
        return _connect.IntVector_reserve(self, n)

    def capacity(self):
        return _connect.IntVector_capacity(self)
    __swig_destroy__ = _connect.delete_IntVector

# Register IntVector in _connect:
_connect.IntVector_swigregister(IntVector)
class StrSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _connect.StrSet_swiginit(self, _connect.new_StrSet(*args))

    def size(self):
        return _connect.StrSet_size(self)

    def empty(self):
        return _connect.StrSet_empty(self)

    def clear(self):
        return _connect.StrSet_clear(self)

    def remove(self, key):
        return _connect.StrSet_remove(self, key)

    def contains(self, value):
        return _connect.StrSet_contains(self, value)

    def toString(self):
        return _connect.StrSet_toString(self)
    __swig_destroy__ = _connect.delete_StrSet

# Register StrSet in _connect:
_connect.StrSet_swigregister(StrSet)
class StrStrMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.StrStrMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.StrStrMap___nonzero__(self)

    def __bool__(self):
        return _connect.StrStrMap___bool__(self)

    def __len__(self):
        return _connect.StrStrMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _connect.StrStrMap___getitem__(self, key)

    def __delitem__(self, key):
        return _connect.StrStrMap___delitem__(self, key)

    def has_key(self, key):
        return _connect.StrStrMap_has_key(self, key)

    def keys(self):
        return _connect.StrStrMap_keys(self)

    def values(self):
        return _connect.StrStrMap_values(self)

    def items(self):
        return _connect.StrStrMap_items(self)

    def __contains__(self, key):
        return _connect.StrStrMap___contains__(self, key)

    def key_iterator(self):
        return _connect.StrStrMap_key_iterator(self)

    def value_iterator(self):
        return _connect.StrStrMap_value_iterator(self)

    def __setitem__(self, *args):
        return _connect.StrStrMap___setitem__(self, *args)

    def asdict(self):
        return _connect.StrStrMap_asdict(self)

    def __init__(self, *args):
        _connect.StrStrMap_swiginit(self, _connect.new_StrStrMap(*args))

    def empty(self):
        return _connect.StrStrMap_empty(self)

    def size(self):
        return _connect.StrStrMap_size(self)

    def swap(self, v):
        return _connect.StrStrMap_swap(self, v)

    def begin(self):
        return _connect.StrStrMap_begin(self)

    def end(self):
        return _connect.StrStrMap_end(self)

    def rbegin(self):
        return _connect.StrStrMap_rbegin(self)

    def rend(self):
        return _connect.StrStrMap_rend(self)

    def clear(self):
        return _connect.StrStrMap_clear(self)

    def get_allocator(self):
        return _connect.StrStrMap_get_allocator(self)

    def count(self, x):
        return _connect.StrStrMap_count(self, x)

    def erase(self, *args):
        return _connect.StrStrMap_erase(self, *args)

    def find(self, x):
        return _connect.StrStrMap_find(self, x)

    def lower_bound(self, x):
        return _connect.StrStrMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _connect.StrStrMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrStrMap

# Register StrStrMap in _connect:
_connect.StrStrMap_swigregister(StrStrMap)
class StrStrMapIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, container):
        _connect.StrStrMapIterator_swiginit(self, _connect.new_StrStrMapIterator(container))

    def isValid(self):
        return _connect.StrStrMapIterator_isValid(self)

    def key(self):
        return _connect.StrStrMapIterator_key(self)

    def value(self):
        return _connect.StrStrMapIterator_value(self)

    def inc(self):
        return _connect.StrStrMapIterator_inc(self)
    __swig_destroy__ = _connect.delete_StrStrMapIterator

# Register StrStrMapIterator in _connect:
_connect.StrStrMapIterator_swigregister(StrStrMapIterator)
class StrStrVectorMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.StrStrVectorMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.StrStrVectorMap___nonzero__(self)

    def __bool__(self):
        return _connect.StrStrVectorMap___bool__(self)

    def __len__(self):
        return _connect.StrStrVectorMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _connect.StrStrVectorMap___getitem__(self, key)

    def __delitem__(self, key):
        return _connect.StrStrVectorMap___delitem__(self, key)

    def has_key(self, key):
        return _connect.StrStrVectorMap_has_key(self, key)

    def keys(self):
        return _connect.StrStrVectorMap_keys(self)

    def values(self):
        return _connect.StrStrVectorMap_values(self)

    def items(self):
        return _connect.StrStrVectorMap_items(self)

    def __contains__(self, key):
        return _connect.StrStrVectorMap___contains__(self, key)

    def key_iterator(self):
        return _connect.StrStrVectorMap_key_iterator(self)

    def value_iterator(self):
        return _connect.StrStrVectorMap_value_iterator(self)

    def __setitem__(self, *args):
        return _connect.StrStrVectorMap___setitem__(self, *args)

    def asdict(self):
        return _connect.StrStrVectorMap_asdict(self)

    def __init__(self, *args):
        _connect.StrStrVectorMap_swiginit(self, _connect.new_StrStrVectorMap(*args))

    def empty(self):
        return _connect.StrStrVectorMap_empty(self)

    def size(self):
        return _connect.StrStrVectorMap_size(self)

    def swap(self, v):
        return _connect.StrStrVectorMap_swap(self, v)

    def begin(self):
        return _connect.StrStrVectorMap_begin(self)

    def end(self):
        return _connect.StrStrVectorMap_end(self)

    def rbegin(self):
        return _connect.StrStrVectorMap_rbegin(self)

    def rend(self):
        return _connect.StrStrVectorMap_rend(self)

    def clear(self):
        return _connect.StrStrVectorMap_clear(self)

    def get_allocator(self):
        return _connect.StrStrVectorMap_get_allocator(self)

    def count(self, x):
        return _connect.StrStrVectorMap_count(self, x)

    def erase(self, *args):
        return _connect.StrStrVectorMap_erase(self, *args)

    def find(self, x):
        return _connect.StrStrVectorMap_find(self, x)

    def lower_bound(self, x):
        return _connect.StrStrVectorMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _connect.StrStrVectorMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrStrVectorMap

# Register StrStrVectorMap in _connect:
_connect.StrStrVectorMap_swigregister(StrStrVectorMap)
class SNodeInfoVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.SNodeInfoVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.SNodeInfoVector___nonzero__(self)

    def __bool__(self):
        return _connect.SNodeInfoVector___bool__(self)

    def __len__(self):
        return _connect.SNodeInfoVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.SNodeInfoVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.SNodeInfoVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.SNodeInfoVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.SNodeInfoVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.SNodeInfoVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.SNodeInfoVector___setitem__(self, *args)

    def pop(self):
        return _connect.SNodeInfoVector_pop(self)

    def append(self, x):
        return _connect.SNodeInfoVector_append(self, x)

    def empty(self):
        return _connect.SNodeInfoVector_empty(self)

    def size(self):
        return _connect.SNodeInfoVector_size(self)

    def swap(self, v):
        return _connect.SNodeInfoVector_swap(self, v)

    def begin(self):
        return _connect.SNodeInfoVector_begin(self)

    def end(self):
        return _connect.SNodeInfoVector_end(self)

    def rbegin(self):
        return _connect.SNodeInfoVector_rbegin(self)

    def rend(self):
        return _connect.SNodeInfoVector_rend(self)

    def clear(self):
        return _connect.SNodeInfoVector_clear(self)

    def get_allocator(self):
        return _connect.SNodeInfoVector_get_allocator(self)

    def pop_back(self):
        return _connect.SNodeInfoVector_pop_back(self)

    def erase(self, *args):
        return _connect.SNodeInfoVector_erase(self, *args)

    def __init__(self, *args):
        _connect.SNodeInfoVector_swiginit(self, _connect.new_SNodeInfoVector(*args))

    def push_back(self, x):
        return _connect.SNodeInfoVector_push_back(self, x)

    def front(self):
        return _connect.SNodeInfoVector_front(self)

    def back(self):
        return _connect.SNodeInfoVector_back(self)

    def assign(self, n, x):
        return _connect.SNodeInfoVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.SNodeInfoVector_resize(self, *args)

    def insert(self, *args):
        return _connect.SNodeInfoVector_insert(self, *args)

    def reserve(self, n):
        return _connect.SNodeInfoVector_reserve(self, n)

    def capacity(self):
        return _connect.SNodeInfoVector_capacity(self)
    __swig_destroy__ = _connect.delete_SNodeInfoVector

# Register SNodeInfoVector in _connect:
_connect.SNodeInfoVector_swigregister(SNodeInfoVector)
class DIOBankChannelIndexVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.DIOBankChannelIndexVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.DIOBankChannelIndexVector___nonzero__(self)

    def __bool__(self):
        return _connect.DIOBankChannelIndexVector___bool__(self)

    def __len__(self):
        return _connect.DIOBankChannelIndexVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.DIOBankChannelIndexVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.DIOBankChannelIndexVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.DIOBankChannelIndexVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.DIOBankChannelIndexVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.DIOBankChannelIndexVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.DIOBankChannelIndexVector___setitem__(self, *args)

    def pop(self):
        return _connect.DIOBankChannelIndexVector_pop(self)

    def append(self, x):
        return _connect.DIOBankChannelIndexVector_append(self, x)

    def empty(self):
        return _connect.DIOBankChannelIndexVector_empty(self)

    def size(self):
        return _connect.DIOBankChannelIndexVector_size(self)

    def swap(self, v):
        return _connect.DIOBankChannelIndexVector_swap(self, v)

    def begin(self):
        return _connect.DIOBankChannelIndexVector_begin(self)

    def end(self):
        return _connect.DIOBankChannelIndexVector_end(self)

    def rbegin(self):
        return _connect.DIOBankChannelIndexVector_rbegin(self)

    def rend(self):
        return _connect.DIOBankChannelIndexVector_rend(self)

    def clear(self):
        return _connect.DIOBankChannelIndexVector_clear(self)

    def get_allocator(self):
        return _connect.DIOBankChannelIndexVector_get_allocator(self)

    def pop_back(self):
        return _connect.DIOBankChannelIndexVector_pop_back(self)

    def erase(self, *args):
        return _connect.DIOBankChannelIndexVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DIOBankChannelIndexVector_swiginit(self, _connect.new_DIOBankChannelIndexVector(*args))

    def push_back(self, x):
        return _connect.DIOBankChannelIndexVector_push_back(self, x)

    def front(self):
        return _connect.DIOBankChannelIndexVector_front(self)

    def back(self):
        return _connect.DIOBankChannelIndexVector_back(self)

    def assign(self, n, x):
        return _connect.DIOBankChannelIndexVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.DIOBankChannelIndexVector_resize(self, *args)

    def insert(self, *args):
        return _connect.DIOBankChannelIndexVector_insert(self, *args)

    def reserve(self, n):
        return _connect.DIOBankChannelIndexVector_reserve(self, n)

    def capacity(self):
        return _connect.DIOBankChannelIndexVector_capacity(self)
    __swig_destroy__ = _connect.delete_DIOBankChannelIndexVector

# Register DIOBankChannelIndexVector in _connect:
_connect.DIOBankChannelIndexVector_swigregister(DIOBankChannelIndexVector)
class AddressVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.AddressVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.AddressVector___nonzero__(self)

    def __bool__(self):
        return _connect.AddressVector___bool__(self)

    def __len__(self):
        return _connect.AddressVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.AddressVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.AddressVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.AddressVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.AddressVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.AddressVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.AddressVector___setitem__(self, *args)

    def pop(self):
        return _connect.AddressVector_pop(self)

    def append(self, x):
        return _connect.AddressVector_append(self, x)

    def empty(self):
        return _connect.AddressVector_empty(self)

    def size(self):
        return _connect.AddressVector_size(self)

    def swap(self, v):
        return _connect.AddressVector_swap(self, v)

    def begin(self):
        return _connect.AddressVector_begin(self)

    def end(self):
        return _connect.AddressVector_end(self)

    def rbegin(self):
        return _connect.AddressVector_rbegin(self)

    def rend(self):
        return _connect.AddressVector_rend(self)

    def clear(self):
        return _connect.AddressVector_clear(self)

    def get_allocator(self):
        return _connect.AddressVector_get_allocator(self)

    def pop_back(self):
        return _connect.AddressVector_pop_back(self)

    def erase(self, *args):
        return _connect.AddressVector_erase(self, *args)

    def __init__(self, *args):
        _connect.AddressVector_swiginit(self, _connect.new_AddressVector(*args))

    def push_back(self, x):
        return _connect.AddressVector_push_back(self, x)

    def front(self):
        return _connect.AddressVector_front(self)

    def back(self):
        return _connect.AddressVector_back(self)

    def assign(self, n, x):
        return _connect.AddressVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.AddressVector_resize(self, *args)

    def insert(self, *args):
        return _connect.AddressVector_insert(self, *args)

    def reserve(self, n):
        return _connect.AddressVector_reserve(self, n)

    def capacity(self):
        return _connect.AddressVector_capacity(self)
    __swig_destroy__ = _connect.delete_AddressVector

# Register AddressVector in _connect:
_connect.AddressVector_swigregister(AddressVector)

ByteVector = VectorBYTE
UInt64Vector = AddressVector  # since we can't define another vector for uin64_t in SWIG (or size_t),
# use this workaround. 

# These two macros are initialized with enum value in C++ header, and this seems
# to not be supported by SWIG. Since there is nothing like javaconst for Python,
# this solution was used.
ACCESS_OK = Access_OK
ACCESS_FAIL = Access_Fail  

class StrCoverageTestResultsMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.StrCoverageTestResultsMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.StrCoverageTestResultsMap___nonzero__(self)

    def __bool__(self):
        return _connect.StrCoverageTestResultsMap___bool__(self)

    def __len__(self):
        return _connect.StrCoverageTestResultsMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _connect.StrCoverageTestResultsMap___getitem__(self, key)

    def __delitem__(self, key):
        return _connect.StrCoverageTestResultsMap___delitem__(self, key)

    def has_key(self, key):
        return _connect.StrCoverageTestResultsMap_has_key(self, key)

    def keys(self):
        return _connect.StrCoverageTestResultsMap_keys(self)

    def values(self):
        return _connect.StrCoverageTestResultsMap_values(self)

    def items(self):
        return _connect.StrCoverageTestResultsMap_items(self)

    def __contains__(self, key):
        return _connect.StrCoverageTestResultsMap___contains__(self, key)

    def key_iterator(self):
        return _connect.StrCoverageTestResultsMap_key_iterator(self)

    def value_iterator(self):
        return _connect.StrCoverageTestResultsMap_value_iterator(self)

    def __setitem__(self, *args):
        return _connect.StrCoverageTestResultsMap___setitem__(self, *args)

    def asdict(self):
        return _connect.StrCoverageTestResultsMap_asdict(self)

    def __init__(self, *args):
        _connect.StrCoverageTestResultsMap_swiginit(self, _connect.new_StrCoverageTestResultsMap(*args))

    def empty(self):
        return _connect.StrCoverageTestResultsMap_empty(self)

    def size(self):
        return _connect.StrCoverageTestResultsMap_size(self)

    def swap(self, v):
        return _connect.StrCoverageTestResultsMap_swap(self, v)

    def begin(self):
        return _connect.StrCoverageTestResultsMap_begin(self)

    def end(self):
        return _connect.StrCoverageTestResultsMap_end(self)

    def rbegin(self):
        return _connect.StrCoverageTestResultsMap_rbegin(self)

    def rend(self):
        return _connect.StrCoverageTestResultsMap_rend(self)

    def clear(self):
        return _connect.StrCoverageTestResultsMap_clear(self)

    def get_allocator(self):
        return _connect.StrCoverageTestResultsMap_get_allocator(self)

    def count(self, x):
        return _connect.StrCoverageTestResultsMap_count(self, x)

    def erase(self, *args):
        return _connect.StrCoverageTestResultsMap_erase(self, *args)

    def find(self, x):
        return _connect.StrCoverageTestResultsMap_find(self, x)

    def lower_bound(self, x):
        return _connect.StrCoverageTestResultsMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _connect.StrCoverageTestResultsMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrCoverageTestResultsMap

# Register StrCoverageTestResultsMap in _connect:
_connect.StrCoverageTestResultsMap_swigregister(StrCoverageTestResultsMap)
class StrProfilerTestResultsMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.StrProfilerTestResultsMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.StrProfilerTestResultsMap___nonzero__(self)

    def __bool__(self):
        return _connect.StrProfilerTestResultsMap___bool__(self)

    def __len__(self):
        return _connect.StrProfilerTestResultsMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _connect.StrProfilerTestResultsMap___getitem__(self, key)

    def __delitem__(self, key):
        return _connect.StrProfilerTestResultsMap___delitem__(self, key)

    def has_key(self, key):
        return _connect.StrProfilerTestResultsMap_has_key(self, key)

    def keys(self):
        return _connect.StrProfilerTestResultsMap_keys(self)

    def values(self):
        return _connect.StrProfilerTestResultsMap_values(self)

    def items(self):
        return _connect.StrProfilerTestResultsMap_items(self)

    def __contains__(self, key):
        return _connect.StrProfilerTestResultsMap___contains__(self, key)

    def key_iterator(self):
        return _connect.StrProfilerTestResultsMap_key_iterator(self)

    def value_iterator(self):
        return _connect.StrProfilerTestResultsMap_value_iterator(self)

    def __setitem__(self, *args):
        return _connect.StrProfilerTestResultsMap___setitem__(self, *args)

    def asdict(self):
        return _connect.StrProfilerTestResultsMap_asdict(self)

    def __init__(self, *args):
        _connect.StrProfilerTestResultsMap_swiginit(self, _connect.new_StrProfilerTestResultsMap(*args))

    def empty(self):
        return _connect.StrProfilerTestResultsMap_empty(self)

    def size(self):
        return _connect.StrProfilerTestResultsMap_size(self)

    def swap(self, v):
        return _connect.StrProfilerTestResultsMap_swap(self, v)

    def begin(self):
        return _connect.StrProfilerTestResultsMap_begin(self)

    def end(self):
        return _connect.StrProfilerTestResultsMap_end(self)

    def rbegin(self):
        return _connect.StrProfilerTestResultsMap_rbegin(self)

    def rend(self):
        return _connect.StrProfilerTestResultsMap_rend(self)

    def clear(self):
        return _connect.StrProfilerTestResultsMap_clear(self)

    def get_allocator(self):
        return _connect.StrProfilerTestResultsMap_get_allocator(self)

    def count(self, x):
        return _connect.StrProfilerTestResultsMap_count(self, x)

    def erase(self, *args):
        return _connect.StrProfilerTestResultsMap_erase(self, *args)

    def find(self, x):
        return _connect.StrProfilerTestResultsMap_find(self, x)

    def lower_bound(self, x):
        return _connect.StrProfilerTestResultsMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _connect.StrProfilerTestResultsMap_upper_bound(self, x)
    __swig_destroy__ = _connect.delete_StrProfilerTestResultsMap

# Register StrProfilerTestResultsMap in _connect:
_connect.StrProfilerTestResultsMap_swigregister(StrProfilerTestResultsMap)
class TestResultsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.TestResultsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.TestResultsVector___nonzero__(self)

    def __bool__(self):
        return _connect.TestResultsVector___bool__(self)

    def __len__(self):
        return _connect.TestResultsVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.TestResultsVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.TestResultsVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.TestResultsVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.TestResultsVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.TestResultsVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.TestResultsVector___setitem__(self, *args)

    def pop(self):
        return _connect.TestResultsVector_pop(self)

    def append(self, x):
        return _connect.TestResultsVector_append(self, x)

    def empty(self):
        return _connect.TestResultsVector_empty(self)

    def size(self):
        return _connect.TestResultsVector_size(self)

    def swap(self, v):
        return _connect.TestResultsVector_swap(self, v)

    def begin(self):
        return _connect.TestResultsVector_begin(self)

    def end(self):
        return _connect.TestResultsVector_end(self)

    def rbegin(self):
        return _connect.TestResultsVector_rbegin(self)

    def rend(self):
        return _connect.TestResultsVector_rend(self)

    def clear(self):
        return _connect.TestResultsVector_clear(self)

    def get_allocator(self):
        return _connect.TestResultsVector_get_allocator(self)

    def pop_back(self):
        return _connect.TestResultsVector_pop_back(self)

    def erase(self, *args):
        return _connect.TestResultsVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TestResultsVector_swiginit(self, _connect.new_TestResultsVector(*args))

    def push_back(self, x):
        return _connect.TestResultsVector_push_back(self, x)

    def front(self):
        return _connect.TestResultsVector_front(self)

    def back(self):
        return _connect.TestResultsVector_back(self)

    def assign(self, n, x):
        return _connect.TestResultsVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.TestResultsVector_resize(self, *args)

    def insert(self, *args):
        return _connect.TestResultsVector_insert(self, *args)

    def reserve(self, n):
        return _connect.TestResultsVector_reserve(self, n)

    def capacity(self):
        return _connect.TestResultsVector_capacity(self)
    __swig_destroy__ = _connect.delete_TestResultsVector

# Register TestResultsVector in _connect:
_connect.TestResultsVector_swigregister(TestResultsVector)
class TestFilterVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.TestFilterVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.TestFilterVector___nonzero__(self)

    def __bool__(self):
        return _connect.TestFilterVector___bool__(self)

    def __len__(self):
        return _connect.TestFilterVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.TestFilterVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.TestFilterVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.TestFilterVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.TestFilterVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.TestFilterVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.TestFilterVector___setitem__(self, *args)

    def pop(self):
        return _connect.TestFilterVector_pop(self)

    def append(self, x):
        return _connect.TestFilterVector_append(self, x)

    def empty(self):
        return _connect.TestFilterVector_empty(self)

    def size(self):
        return _connect.TestFilterVector_size(self)

    def swap(self, v):
        return _connect.TestFilterVector_swap(self, v)

    def begin(self):
        return _connect.TestFilterVector_begin(self)

    def end(self):
        return _connect.TestFilterVector_end(self)

    def rbegin(self):
        return _connect.TestFilterVector_rbegin(self)

    def rend(self):
        return _connect.TestFilterVector_rend(self)

    def clear(self):
        return _connect.TestFilterVector_clear(self)

    def get_allocator(self):
        return _connect.TestFilterVector_get_allocator(self)

    def pop_back(self):
        return _connect.TestFilterVector_pop_back(self)

    def erase(self, *args):
        return _connect.TestFilterVector_erase(self, *args)

    def __init__(self, *args):
        _connect.TestFilterVector_swiginit(self, _connect.new_TestFilterVector(*args))

    def push_back(self, x):
        return _connect.TestFilterVector_push_back(self, x)

    def front(self):
        return _connect.TestFilterVector_front(self)

    def back(self):
        return _connect.TestFilterVector_back(self)

    def assign(self, n, x):
        return _connect.TestFilterVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.TestFilterVector_resize(self, *args)

    def insert(self, *args):
        return _connect.TestFilterVector_insert(self, *args)

    def reserve(self, n):
        return _connect.TestFilterVector_reserve(self, n)

    def capacity(self):
        return _connect.TestFilterVector_capacity(self)
    __swig_destroy__ = _connect.delete_TestFilterVector

# Register TestFilterVector in _connect:
_connect.TestFilterVector_swigregister(TestFilterVector)
class DAQSampleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.DAQSampleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.DAQSampleVector___nonzero__(self)

    def __bool__(self):
        return _connect.DAQSampleVector___bool__(self)

    def __len__(self):
        return _connect.DAQSampleVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.DAQSampleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.DAQSampleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.DAQSampleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.DAQSampleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.DAQSampleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.DAQSampleVector___setitem__(self, *args)

    def pop(self):
        return _connect.DAQSampleVector_pop(self)

    def append(self, x):
        return _connect.DAQSampleVector_append(self, x)

    def empty(self):
        return _connect.DAQSampleVector_empty(self)

    def size(self):
        return _connect.DAQSampleVector_size(self)

    def swap(self, v):
        return _connect.DAQSampleVector_swap(self, v)

    def begin(self):
        return _connect.DAQSampleVector_begin(self)

    def end(self):
        return _connect.DAQSampleVector_end(self)

    def rbegin(self):
        return _connect.DAQSampleVector_rbegin(self)

    def rend(self):
        return _connect.DAQSampleVector_rend(self)

    def clear(self):
        return _connect.DAQSampleVector_clear(self)

    def get_allocator(self):
        return _connect.DAQSampleVector_get_allocator(self)

    def pop_back(self):
        return _connect.DAQSampleVector_pop_back(self)

    def erase(self, *args):
        return _connect.DAQSampleVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DAQSampleVector_swiginit(self, _connect.new_DAQSampleVector(*args))

    def push_back(self, x):
        return _connect.DAQSampleVector_push_back(self, x)

    def front(self):
        return _connect.DAQSampleVector_front(self)

    def back(self):
        return _connect.DAQSampleVector_back(self)

    def assign(self, n, x):
        return _connect.DAQSampleVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.DAQSampleVector_resize(self, *args)

    def insert(self, *args):
        return _connect.DAQSampleVector_insert(self, *args)

    def reserve(self, n):
        return _connect.DAQSampleVector_reserve(self, n)

    def capacity(self):
        return _connect.DAQSampleVector_capacity(self)
    __swig_destroy__ = _connect.delete_DAQSampleVector

# Register DAQSampleVector in _connect:
_connect.DAQSampleVector_swigregister(DAQSampleVector)
class DAQConfigVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.DAQConfigVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.DAQConfigVector___nonzero__(self)

    def __bool__(self):
        return _connect.DAQConfigVector___bool__(self)

    def __len__(self):
        return _connect.DAQConfigVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.DAQConfigVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.DAQConfigVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.DAQConfigVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.DAQConfigVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.DAQConfigVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.DAQConfigVector___setitem__(self, *args)

    def pop(self):
        return _connect.DAQConfigVector_pop(self)

    def append(self, x):
        return _connect.DAQConfigVector_append(self, x)

    def empty(self):
        return _connect.DAQConfigVector_empty(self)

    def size(self):
        return _connect.DAQConfigVector_size(self)

    def swap(self, v):
        return _connect.DAQConfigVector_swap(self, v)

    def begin(self):
        return _connect.DAQConfigVector_begin(self)

    def end(self):
        return _connect.DAQConfigVector_end(self)

    def rbegin(self):
        return _connect.DAQConfigVector_rbegin(self)

    def rend(self):
        return _connect.DAQConfigVector_rend(self)

    def clear(self):
        return _connect.DAQConfigVector_clear(self)

    def get_allocator(self):
        return _connect.DAQConfigVector_get_allocator(self)

    def pop_back(self):
        return _connect.DAQConfigVector_pop_back(self)

    def erase(self, *args):
        return _connect.DAQConfigVector_erase(self, *args)

    def __init__(self, *args):
        _connect.DAQConfigVector_swiginit(self, _connect.new_DAQConfigVector(*args))

    def push_back(self, x):
        return _connect.DAQConfigVector_push_back(self, x)

    def front(self):
        return _connect.DAQConfigVector_front(self)

    def back(self):
        return _connect.DAQConfigVector_back(self)

    def assign(self, n, x):
        return _connect.DAQConfigVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.DAQConfigVector_resize(self, *args)

    def insert(self, *args):
        return _connect.DAQConfigVector_insert(self, *args)

    def reserve(self, n):
        return _connect.DAQConfigVector_reserve(self, n)

    def capacity(self):
        return _connect.DAQConfigVector_capacity(self)
    __swig_destroy__ = _connect.delete_DAQConfigVector

# Register DAQConfigVector in _connect:
_connect.DAQConfigVector_swigregister(DAQConfigVector)
class ViewDataVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.ViewDataVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.ViewDataVector___nonzero__(self)

    def __bool__(self):
        return _connect.ViewDataVector___bool__(self)

    def __len__(self):
        return _connect.ViewDataVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.ViewDataVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.ViewDataVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.ViewDataVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.ViewDataVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.ViewDataVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.ViewDataVector___setitem__(self, *args)

    def pop(self):
        return _connect.ViewDataVector_pop(self)

    def append(self, x):
        return _connect.ViewDataVector_append(self, x)

    def empty(self):
        return _connect.ViewDataVector_empty(self)

    def size(self):
        return _connect.ViewDataVector_size(self)

    def swap(self, v):
        return _connect.ViewDataVector_swap(self, v)

    def begin(self):
        return _connect.ViewDataVector_begin(self)

    def end(self):
        return _connect.ViewDataVector_end(self)

    def rbegin(self):
        return _connect.ViewDataVector_rbegin(self)

    def rend(self):
        return _connect.ViewDataVector_rend(self)

    def clear(self):
        return _connect.ViewDataVector_clear(self)

    def get_allocator(self):
        return _connect.ViewDataVector_get_allocator(self)

    def pop_back(self):
        return _connect.ViewDataVector_pop_back(self)

    def erase(self, *args):
        return _connect.ViewDataVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ViewDataVector_swiginit(self, _connect.new_ViewDataVector(*args))

    def push_back(self, x):
        return _connect.ViewDataVector_push_back(self, x)

    def front(self):
        return _connect.ViewDataVector_front(self)

    def back(self):
        return _connect.ViewDataVector_back(self)

    def assign(self, n, x):
        return _connect.ViewDataVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.ViewDataVector_resize(self, *args)

    def insert(self, *args):
        return _connect.ViewDataVector_insert(self, *args)

    def reserve(self, n):
        return _connect.ViewDataVector_reserve(self, n)

    def capacity(self):
        return _connect.ViewDataVector_capacity(self)
    __swig_destroy__ = _connect.delete_ViewDataVector

# Register ViewDataVector in _connect:
_connect.ViewDataVector_swigregister(ViewDataVector)
class ViewTypeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.ViewTypeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.ViewTypeVector___nonzero__(self)

    def __bool__(self):
        return _connect.ViewTypeVector___bool__(self)

    def __len__(self):
        return _connect.ViewTypeVector___len__(self)

    def __getslice__(self, i, j):
        return _connect.ViewTypeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.ViewTypeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.ViewTypeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.ViewTypeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.ViewTypeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.ViewTypeVector___setitem__(self, *args)

    def pop(self):
        return _connect.ViewTypeVector_pop(self)

    def append(self, x):
        return _connect.ViewTypeVector_append(self, x)

    def empty(self):
        return _connect.ViewTypeVector_empty(self)

    def size(self):
        return _connect.ViewTypeVector_size(self)

    def swap(self, v):
        return _connect.ViewTypeVector_swap(self, v)

    def begin(self):
        return _connect.ViewTypeVector_begin(self)

    def end(self):
        return _connect.ViewTypeVector_end(self)

    def rbegin(self):
        return _connect.ViewTypeVector_rbegin(self)

    def rend(self):
        return _connect.ViewTypeVector_rend(self)

    def clear(self):
        return _connect.ViewTypeVector_clear(self)

    def get_allocator(self):
        return _connect.ViewTypeVector_get_allocator(self)

    def pop_back(self):
        return _connect.ViewTypeVector_pop_back(self)

    def erase(self, *args):
        return _connect.ViewTypeVector_erase(self, *args)

    def __init__(self, *args):
        _connect.ViewTypeVector_swiginit(self, _connect.new_ViewTypeVector(*args))

    def push_back(self, x):
        return _connect.ViewTypeVector_push_back(self, x)

    def front(self):
        return _connect.ViewTypeVector_front(self)

    def back(self):
        return _connect.ViewTypeVector_back(self)

    def assign(self, n, x):
        return _connect.ViewTypeVector_assign(self, n, x)

    def resize(self, *args):
        return _connect.ViewTypeVector_resize(self, *args)

    def insert(self, *args):
        return _connect.ViewTypeVector_insert(self, *args)

    def reserve(self, n):
        return _connect.ViewTypeVector_reserve(self, n)

    def capacity(self):
        return _connect.ViewTypeVector_capacity(self)
    __swig_destroy__ = _connect.delete_ViewTypeVector

# Register ViewTypeVector in _connect:
_connect.ViewTypeVector_swigregister(ViewTypeVector)
class VSPSessionStatus_Core(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPSessionStatus_Core_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPSessionStatus_Core___nonzero__(self)

    def __bool__(self):
        return _connect.VSPSessionStatus_Core___bool__(self)

    def __len__(self):
        return _connect.VSPSessionStatus_Core___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPSessionStatus_Core___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPSessionStatus_Core___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPSessionStatus_Core___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPSessionStatus_Core___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPSessionStatus_Core___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPSessionStatus_Core___setitem__(self, *args)

    def pop(self):
        return _connect.VSPSessionStatus_Core_pop(self)

    def append(self, x):
        return _connect.VSPSessionStatus_Core_append(self, x)

    def empty(self):
        return _connect.VSPSessionStatus_Core_empty(self)

    def size(self):
        return _connect.VSPSessionStatus_Core_size(self)

    def swap(self, v):
        return _connect.VSPSessionStatus_Core_swap(self, v)

    def begin(self):
        return _connect.VSPSessionStatus_Core_begin(self)

    def end(self):
        return _connect.VSPSessionStatus_Core_end(self)

    def rbegin(self):
        return _connect.VSPSessionStatus_Core_rbegin(self)

    def rend(self):
        return _connect.VSPSessionStatus_Core_rend(self)

    def clear(self):
        return _connect.VSPSessionStatus_Core_clear(self)

    def get_allocator(self):
        return _connect.VSPSessionStatus_Core_get_allocator(self)

    def pop_back(self):
        return _connect.VSPSessionStatus_Core_pop_back(self)

    def erase(self, *args):
        return _connect.VSPSessionStatus_Core_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPSessionStatus_Core_swiginit(self, _connect.new_VSPSessionStatus_Core(*args))

    def push_back(self, x):
        return _connect.VSPSessionStatus_Core_push_back(self, x)

    def front(self):
        return _connect.VSPSessionStatus_Core_front(self)

    def back(self):
        return _connect.VSPSessionStatus_Core_back(self)

    def assign(self, n, x):
        return _connect.VSPSessionStatus_Core_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPSessionStatus_Core_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPSessionStatus_Core_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPSessionStatus_Core_reserve(self, n)

    def capacity(self):
        return _connect.VSPSessionStatus_Core_capacity(self)
    __swig_destroy__ = _connect.delete_VSPSessionStatus_Core

# Register VSPSessionStatus_Core in _connect:
_connect.VSPSessionStatus_Core_swigregister(VSPSessionStatus_Core)
class VSPSessionStatus_SoC(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPSessionStatus_SoC_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPSessionStatus_SoC___nonzero__(self)

    def __bool__(self):
        return _connect.VSPSessionStatus_SoC___bool__(self)

    def __len__(self):
        return _connect.VSPSessionStatus_SoC___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPSessionStatus_SoC___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPSessionStatus_SoC___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPSessionStatus_SoC___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPSessionStatus_SoC___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPSessionStatus_SoC___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPSessionStatus_SoC___setitem__(self, *args)

    def pop(self):
        return _connect.VSPSessionStatus_SoC_pop(self)

    def append(self, x):
        return _connect.VSPSessionStatus_SoC_append(self, x)

    def empty(self):
        return _connect.VSPSessionStatus_SoC_empty(self)

    def size(self):
        return _connect.VSPSessionStatus_SoC_size(self)

    def swap(self, v):
        return _connect.VSPSessionStatus_SoC_swap(self, v)

    def begin(self):
        return _connect.VSPSessionStatus_SoC_begin(self)

    def end(self):
        return _connect.VSPSessionStatus_SoC_end(self)

    def rbegin(self):
        return _connect.VSPSessionStatus_SoC_rbegin(self)

    def rend(self):
        return _connect.VSPSessionStatus_SoC_rend(self)

    def clear(self):
        return _connect.VSPSessionStatus_SoC_clear(self)

    def get_allocator(self):
        return _connect.VSPSessionStatus_SoC_get_allocator(self)

    def pop_back(self):
        return _connect.VSPSessionStatus_SoC_pop_back(self)

    def erase(self, *args):
        return _connect.VSPSessionStatus_SoC_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPSessionStatus_SoC_swiginit(self, _connect.new_VSPSessionStatus_SoC(*args))

    def push_back(self, x):
        return _connect.VSPSessionStatus_SoC_push_back(self, x)

    def front(self):
        return _connect.VSPSessionStatus_SoC_front(self)

    def back(self):
        return _connect.VSPSessionStatus_SoC_back(self)

    def assign(self, n, x):
        return _connect.VSPSessionStatus_SoC_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPSessionStatus_SoC_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPSessionStatus_SoC_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPSessionStatus_SoC_reserve(self, n)

    def capacity(self):
        return _connect.VSPSessionStatus_SoC_capacity(self)
    __swig_destroy__ = _connect.delete_VSPSessionStatus_SoC

# Register VSPSessionStatus_SoC in _connect:
_connect.VSPSessionStatus_SoC_swigregister(VSPSessionStatus_SoC)
class VSPSessionTopology_Core(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPSessionTopology_Core_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPSessionTopology_Core___nonzero__(self)

    def __bool__(self):
        return _connect.VSPSessionTopology_Core___bool__(self)

    def __len__(self):
        return _connect.VSPSessionTopology_Core___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPSessionTopology_Core___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPSessionTopology_Core___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPSessionTopology_Core___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPSessionTopology_Core___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPSessionTopology_Core___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPSessionTopology_Core___setitem__(self, *args)

    def pop(self):
        return _connect.VSPSessionTopology_Core_pop(self)

    def append(self, x):
        return _connect.VSPSessionTopology_Core_append(self, x)

    def empty(self):
        return _connect.VSPSessionTopology_Core_empty(self)

    def size(self):
        return _connect.VSPSessionTopology_Core_size(self)

    def swap(self, v):
        return _connect.VSPSessionTopology_Core_swap(self, v)

    def begin(self):
        return _connect.VSPSessionTopology_Core_begin(self)

    def end(self):
        return _connect.VSPSessionTopology_Core_end(self)

    def rbegin(self):
        return _connect.VSPSessionTopology_Core_rbegin(self)

    def rend(self):
        return _connect.VSPSessionTopology_Core_rend(self)

    def clear(self):
        return _connect.VSPSessionTopology_Core_clear(self)

    def get_allocator(self):
        return _connect.VSPSessionTopology_Core_get_allocator(self)

    def pop_back(self):
        return _connect.VSPSessionTopology_Core_pop_back(self)

    def erase(self, *args):
        return _connect.VSPSessionTopology_Core_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPSessionTopology_Core_swiginit(self, _connect.new_VSPSessionTopology_Core(*args))

    def push_back(self, x):
        return _connect.VSPSessionTopology_Core_push_back(self, x)

    def front(self):
        return _connect.VSPSessionTopology_Core_front(self)

    def back(self):
        return _connect.VSPSessionTopology_Core_back(self)

    def assign(self, n, x):
        return _connect.VSPSessionTopology_Core_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPSessionTopology_Core_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPSessionTopology_Core_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPSessionTopology_Core_reserve(self, n)

    def capacity(self):
        return _connect.VSPSessionTopology_Core_capacity(self)
    __swig_destroy__ = _connect.delete_VSPSessionTopology_Core

# Register VSPSessionTopology_Core in _connect:
_connect.VSPSessionTopology_Core_swigregister(VSPSessionTopology_Core)
class VSPSessionTopology_CoreBinding(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPSessionTopology_CoreBinding_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPSessionTopology_CoreBinding___nonzero__(self)

    def __bool__(self):
        return _connect.VSPSessionTopology_CoreBinding___bool__(self)

    def __len__(self):
        return _connect.VSPSessionTopology_CoreBinding___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPSessionTopology_CoreBinding___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPSessionTopology_CoreBinding___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPSessionTopology_CoreBinding___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPSessionTopology_CoreBinding___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPSessionTopology_CoreBinding___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPSessionTopology_CoreBinding___setitem__(self, *args)

    def pop(self):
        return _connect.VSPSessionTopology_CoreBinding_pop(self)

    def append(self, x):
        return _connect.VSPSessionTopology_CoreBinding_append(self, x)

    def empty(self):
        return _connect.VSPSessionTopology_CoreBinding_empty(self)

    def size(self):
        return _connect.VSPSessionTopology_CoreBinding_size(self)

    def swap(self, v):
        return _connect.VSPSessionTopology_CoreBinding_swap(self, v)

    def begin(self):
        return _connect.VSPSessionTopology_CoreBinding_begin(self)

    def end(self):
        return _connect.VSPSessionTopology_CoreBinding_end(self)

    def rbegin(self):
        return _connect.VSPSessionTopology_CoreBinding_rbegin(self)

    def rend(self):
        return _connect.VSPSessionTopology_CoreBinding_rend(self)

    def clear(self):
        return _connect.VSPSessionTopology_CoreBinding_clear(self)

    def get_allocator(self):
        return _connect.VSPSessionTopology_CoreBinding_get_allocator(self)

    def pop_back(self):
        return _connect.VSPSessionTopology_CoreBinding_pop_back(self)

    def erase(self, *args):
        return _connect.VSPSessionTopology_CoreBinding_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPSessionTopology_CoreBinding_swiginit(self, _connect.new_VSPSessionTopology_CoreBinding(*args))

    def push_back(self, x):
        return _connect.VSPSessionTopology_CoreBinding_push_back(self, x)

    def front(self):
        return _connect.VSPSessionTopology_CoreBinding_front(self)

    def back(self):
        return _connect.VSPSessionTopology_CoreBinding_back(self)

    def assign(self, n, x):
        return _connect.VSPSessionTopology_CoreBinding_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPSessionTopology_CoreBinding_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPSessionTopology_CoreBinding_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPSessionTopology_CoreBinding_reserve(self, n)

    def capacity(self):
        return _connect.VSPSessionTopology_CoreBinding_capacity(self)
    __swig_destroy__ = _connect.delete_VSPSessionTopology_CoreBinding

# Register VSPSessionTopology_CoreBinding in _connect:
_connect.VSPSessionTopology_CoreBinding_swigregister(VSPSessionTopology_CoreBinding)
class VSPSessionTopology_SoC(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPSessionTopology_SoC_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPSessionTopology_SoC___nonzero__(self)

    def __bool__(self):
        return _connect.VSPSessionTopology_SoC___bool__(self)

    def __len__(self):
        return _connect.VSPSessionTopology_SoC___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPSessionTopology_SoC___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPSessionTopology_SoC___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPSessionTopology_SoC___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPSessionTopology_SoC___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPSessionTopology_SoC___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPSessionTopology_SoC___setitem__(self, *args)

    def pop(self):
        return _connect.VSPSessionTopology_SoC_pop(self)

    def append(self, x):
        return _connect.VSPSessionTopology_SoC_append(self, x)

    def empty(self):
        return _connect.VSPSessionTopology_SoC_empty(self)

    def size(self):
        return _connect.VSPSessionTopology_SoC_size(self)

    def swap(self, v):
        return _connect.VSPSessionTopology_SoC_swap(self, v)

    def begin(self):
        return _connect.VSPSessionTopology_SoC_begin(self)

    def end(self):
        return _connect.VSPSessionTopology_SoC_end(self)

    def rbegin(self):
        return _connect.VSPSessionTopology_SoC_rbegin(self)

    def rend(self):
        return _connect.VSPSessionTopology_SoC_rend(self)

    def clear(self):
        return _connect.VSPSessionTopology_SoC_clear(self)

    def get_allocator(self):
        return _connect.VSPSessionTopology_SoC_get_allocator(self)

    def pop_back(self):
        return _connect.VSPSessionTopology_SoC_pop_back(self)

    def erase(self, *args):
        return _connect.VSPSessionTopology_SoC_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPSessionTopology_SoC_swiginit(self, _connect.new_VSPSessionTopology_SoC(*args))

    def push_back(self, x):
        return _connect.VSPSessionTopology_SoC_push_back(self, x)

    def front(self):
        return _connect.VSPSessionTopology_SoC_front(self)

    def back(self):
        return _connect.VSPSessionTopology_SoC_back(self)

    def assign(self, n, x):
        return _connect.VSPSessionTopology_SoC_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPSessionTopology_SoC_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPSessionTopology_SoC_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPSessionTopology_SoC_reserve(self, n)

    def capacity(self):
        return _connect.VSPSessionTopology_SoC_capacity(self)
    __swig_destroy__ = _connect.delete_VSPSessionTopology_SoC

# Register VSPSessionTopology_SoC in _connect:
_connect.VSPSessionTopology_SoC_swigregister(VSPSessionTopology_SoC)
class VSPSessionTopology_Process(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPSessionTopology_Process_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPSessionTopology_Process___nonzero__(self)

    def __bool__(self):
        return _connect.VSPSessionTopology_Process___bool__(self)

    def __len__(self):
        return _connect.VSPSessionTopology_Process___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPSessionTopology_Process___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPSessionTopology_Process___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPSessionTopology_Process___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPSessionTopology_Process___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPSessionTopology_Process___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPSessionTopology_Process___setitem__(self, *args)

    def pop(self):
        return _connect.VSPSessionTopology_Process_pop(self)

    def append(self, x):
        return _connect.VSPSessionTopology_Process_append(self, x)

    def empty(self):
        return _connect.VSPSessionTopology_Process_empty(self)

    def size(self):
        return _connect.VSPSessionTopology_Process_size(self)

    def swap(self, v):
        return _connect.VSPSessionTopology_Process_swap(self, v)

    def begin(self):
        return _connect.VSPSessionTopology_Process_begin(self)

    def end(self):
        return _connect.VSPSessionTopology_Process_end(self)

    def rbegin(self):
        return _connect.VSPSessionTopology_Process_rbegin(self)

    def rend(self):
        return _connect.VSPSessionTopology_Process_rend(self)

    def clear(self):
        return _connect.VSPSessionTopology_Process_clear(self)

    def get_allocator(self):
        return _connect.VSPSessionTopology_Process_get_allocator(self)

    def pop_back(self):
        return _connect.VSPSessionTopology_Process_pop_back(self)

    def erase(self, *args):
        return _connect.VSPSessionTopology_Process_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPSessionTopology_Process_swiginit(self, _connect.new_VSPSessionTopology_Process(*args))

    def push_back(self, x):
        return _connect.VSPSessionTopology_Process_push_back(self, x)

    def front(self):
        return _connect.VSPSessionTopology_Process_front(self)

    def back(self):
        return _connect.VSPSessionTopology_Process_back(self)

    def assign(self, n, x):
        return _connect.VSPSessionTopology_Process_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPSessionTopology_Process_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPSessionTopology_Process_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPSessionTopology_Process_reserve(self, n)

    def capacity(self):
        return _connect.VSPSessionTopology_Process_capacity(self)
    __swig_destroy__ = _connect.delete_VSPSessionTopology_Process

# Register VSPSessionTopology_Process in _connect:
_connect.VSPSessionTopology_Process_swigregister(VSPSessionTopology_Process)
class VSPProcess_Thread(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _connect.VSPProcess_Thread_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _connect.VSPProcess_Thread___nonzero__(self)

    def __bool__(self):
        return _connect.VSPProcess_Thread___bool__(self)

    def __len__(self):
        return _connect.VSPProcess_Thread___len__(self)

    def __getslice__(self, i, j):
        return _connect.VSPProcess_Thread___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _connect.VSPProcess_Thread___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _connect.VSPProcess_Thread___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _connect.VSPProcess_Thread___delitem__(self, *args)

    def __getitem__(self, *args):
        return _connect.VSPProcess_Thread___getitem__(self, *args)

    def __setitem__(self, *args):
        return _connect.VSPProcess_Thread___setitem__(self, *args)

    def pop(self):
        return _connect.VSPProcess_Thread_pop(self)

    def append(self, x):
        return _connect.VSPProcess_Thread_append(self, x)

    def empty(self):
        return _connect.VSPProcess_Thread_empty(self)

    def size(self):
        return _connect.VSPProcess_Thread_size(self)

    def swap(self, v):
        return _connect.VSPProcess_Thread_swap(self, v)

    def begin(self):
        return _connect.VSPProcess_Thread_begin(self)

    def end(self):
        return _connect.VSPProcess_Thread_end(self)

    def rbegin(self):
        return _connect.VSPProcess_Thread_rbegin(self)

    def rend(self):
        return _connect.VSPProcess_Thread_rend(self)

    def clear(self):
        return _connect.VSPProcess_Thread_clear(self)

    def get_allocator(self):
        return _connect.VSPProcess_Thread_get_allocator(self)

    def pop_back(self):
        return _connect.VSPProcess_Thread_pop_back(self)

    def erase(self, *args):
        return _connect.VSPProcess_Thread_erase(self, *args)

    def __init__(self, *args):
        _connect.VSPProcess_Thread_swiginit(self, _connect.new_VSPProcess_Thread(*args))

    def push_back(self, x):
        return _connect.VSPProcess_Thread_push_back(self, x)

    def front(self):
        return _connect.VSPProcess_Thread_front(self)

    def back(self):
        return _connect.VSPProcess_Thread_back(self)

    def assign(self, n, x):
        return _connect.VSPProcess_Thread_assign(self, n, x)

    def resize(self, *args):
        return _connect.VSPProcess_Thread_resize(self, *args)

    def insert(self, *args):
        return _connect.VSPProcess_Thread_insert(self, *args)

    def reserve(self, n):
        return _connect.VSPProcess_Thread_reserve(self, n)

    def capacity(self):
        return _connect.VSPProcess_Thread_capacity(self)
    __swig_destroy__ = _connect.delete_VSPProcess_Thread

# Register VSPProcess_Thread in _connect:
_connect.VSPProcess_Thread_swigregister(VSPProcess_Thread)

__version__ = getModuleVersion()


