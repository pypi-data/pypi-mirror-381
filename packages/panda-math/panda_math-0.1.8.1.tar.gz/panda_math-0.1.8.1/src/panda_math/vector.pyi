from __future__ import annotations
import numpy as np
from typing import (
    List,
    Tuple,
    Union,
    Iterator,
    Iterable,
    TypeVar,
    Generic,
    Any,
    TYPE_CHECKING,
    Type,
    overload,
    Sequence,
)
from abc import ABC

if TYPE_CHECKING:
    from .matrix import Matrix

T = TypeVar("T", bound="VectorBase")
Number = Union[int, float]

class VectorBase(Generic[T], Sequence[float], ABC):
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __contains__(self, item) -> bool: ...
    def to_list(self) -> List[float]: ...
    def to_tuple(self) -> Tuple[float, ...]: ...
    def to_numpy(self) -> np.ndarray: ...
    @classmethod
    def from_numpy(cls: Type[T], array: np.ndarray) -> T: ...
    @property
    def magnitude(self) -> float: ...
    def normalize(self: T) -> T: ...
    @property
    def normalized(self: T) -> T: ...
    def distance_to(self, other: T) -> float: ...
    def dot(self, other: T) -> float: ...
    def reverse(self: T) -> T: ...
    @property
    def reversed(self: T) -> T: ...

class Vector2(VectorBase[Vector2]):
    @overload
    def __init__(self, x: Number, y: Number) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __init__(self, *args) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def xy(self) -> "Vector3": ...
    @x.setter
    def x(self, value: float): ...
    @y.setter
    def y(self, value: float): ...
    @xy.setter
    def xy(self, values: Iterable): ...
    def __getattr__(
        self, name: str
    ) -> Union[float, Vector2, Vector3, Vector4, Tuple[float, ...]]: ...
    def __setattr__(self, name: str, value: float) -> None: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

    # Arithmetic operations
    def __add__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __radd__(self, other: Number) -> Vector2: ...
    def __sub__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rsub__(self, other: Number) -> Vector2: ...
    def __mul__(self, other: Union[Vector2, Number, Matrix]) -> Union[Vector2, Any]: ...
    def __rmul__(self, other: Number) -> Vector2: ...
    def __truediv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rtruediv__(self, other: Number) -> Vector2: ...
    def __floordiv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rfloordiv__(self, other: Number) -> Vector2: ...
    def __mod__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rmod__(self, other: Number) -> Vector2: ...
    def __pow__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __rpow__(self, other: Number) -> Vector2: ...

    # In-place operations
    def __iadd__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __isub__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __imul__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __itruediv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __ifloordiv__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __imod__(self, other: Union[Vector2, Number]) -> Vector2: ...
    def __ipow__(self, other: Union[Vector2, Number]) -> Vector2: ...

    # Comparison
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Union[Vector2, Number]) -> bool: ...
    def __gt__(self, other: Union[Vector2, Number]) -> bool: ...
    def __le__(self, other: Union[Vector2, Number]) -> bool: ...
    def __ge__(self, other: Union[Vector2, Number]) -> bool: ...
    def __hash__(self) -> int: ...

class Vector3(VectorBase[Vector3]):
    @overload
    def __init__(self, x: Number, y: Number, z: Number) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __init__(self, *args) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    @property
    def xyz(self) -> "Vector3": ...
    @x.setter
    def x(self, value: float): ...
    @y.setter
    def y(self, value: float): ...
    @z.setter
    def z(self, value: float): ...
    @xyz.setter
    def xyz(self, values: Iterable): ...
    def __getattr__(
        self, name: str
    ) -> Union[float, Vector2, Vector3, Vector4, Tuple[float, ...]]: ...
    def __setattr__(self, name: str, value: float) -> None: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

    # Arithmetic operations
    def __add__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __radd__(self, other: Number) -> Vector3: ...
    def __sub__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rsub__(self, other: Number) -> Vector3: ...
    def __mul__(self, other: Union[Vector3, Number, Matrix]) -> Union[Vector3, Any]: ...
    def __rmul__(self, other: Number) -> Vector3: ...
    def __truediv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rtruediv__(self, other: Number) -> Vector3: ...
    def __floordiv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rfloordiv__(self, other: Number) -> Vector3: ...
    def __mod__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rmod__(self, other: Number) -> Vector3: ...
    def __pow__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __rpow__(self, other: Number) -> Vector3: ...

    # In-place operations
    def __iadd__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __isub__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __imul__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __itruediv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __ifloordiv__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __imod__(self, other: Union[Vector3, Number]) -> Vector3: ...
    def __ipow__(self, other: Union[Vector3, Number]) -> Vector3: ...

    # Comparison
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Union[Vector3, Number]) -> bool: ...
    def __gt__(self, other: Union[Vector3, Number]) -> bool: ...
    def __le__(self, other: Union[Vector3, Number]) -> bool: ...
    def __ge__(self, other: Union[Vector3, Number]) -> bool: ...
    def __hash__(self) -> int: ...

    # Vector3 specific methods
    def cross(self, other: Vector3) -> Vector3: ...

class Vector4(VectorBase[Vector4]):
    @overload
    def __init__(self, x: Number, y: Number, z: Number, w: Number) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Number]) -> None: ...
    @overload
    def __init__(self, value: Number) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def __init__(self, *args) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    @property
    def w(self) -> float: ...
    @property
    def xyzw(self) -> "Vector4": ...
    @x.setter
    def x(self, value: float): ...
    @y.setter
    def y(self, value: float): ...
    @z.setter
    def z(self, value: float): ...
    @w.setter
    def w(self, value: float): ...
    @xyzw.setter
    def xyzw(self, values: Iterable): ...
    def __getattr__(
        self, name: str
    ) -> Union[float, Vector2, Vector3, Vector4, Tuple[float, ...]]: ...
    def __setattr__(self, name: str, value: float) -> None: ...
    def __iter__(self) -> Iterator[float]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> float: ...
    def __setitem__(self, index: int, value: float) -> None: ...

    # Arithmetic operations
    def __add__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __radd__(self, other: Number) -> Vector4: ...
    def __sub__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rsub__(self, other: Number) -> Vector4: ...
    def __mul__(self, other: Union[Vector4, Number, Matrix]) -> Union[Vector4, Any]: ...
    def __rmul__(self, other: Number) -> Vector4: ...
    def __truediv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rtruediv__(self, other: Number) -> Vector4: ...
    def __floordiv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rfloordiv__(self, other: Number) -> Vector4: ...
    def __mod__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rmod__(self, other: Number) -> Vector4: ...
    def __pow__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __rpow__(self, other: Number) -> Vector4: ...

    # In-place operations
    def __iadd__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __isub__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __imul__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __itruediv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __ifloordiv__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __imod__(self, other: Union[Vector4, Number]) -> Vector4: ...
    def __ipow__(self, other: Union[Vector4, Number]) -> Vector4: ...

    # Comparison
    def __eq__(self, other: Any) -> bool: ...
    def __lt__(self, other: Union[Vector4, Number]) -> bool: ...
    def __gt__(self, other: Union[Vector4, Number]) -> bool: ...
    def __le__(self, other: Union[Vector4, Number]) -> bool: ...
    def __ge__(self, other: Union[Vector4, Number]) -> bool: ...
    def __hash__(self) -> int: ...

# Aliases
Vec2 = Vector2
vec2 = Vector2
Vec3 = Vector3
vec3 = Vector3
Vec4 = Vector4
vec4 = Vector4

# Utility functions
def vec2_to_vec3(v: Vector2, z: float = 0.0) -> Vector3: ...
def vec2_to_vec4(v: Vector2, z: float = 0.0, w: float = 1.0) -> Vector4: ...
def vec3_to_vec2(v: Vector3) -> Vector2: ...
def vec3_to_vec4(v: Vector3, w: float = 1.0) -> Vector4: ...
def vec4_to_vec2(v: Vector4) -> Vector2: ...
def vec4_to_vec3(v: Vector4) -> Vector3: ...
