#!/usr/bin/env python3
"""
Generated MCP Server by scriptthing

This file was automatically generated by scriptthing's MCP generator.
DO NOT EDIT THIS FILE MANUALLY - it will be overwritten on regeneration.

To regenerate this file:
    scriptthing generate mcp

This server exposes the following scriptthing scripts as MCP tools:
{% for script_tool in script_tools %}
- {{ script_tool.tool.name }}: {{ script_tool.tool.description }} (from {{ script_tool.script_name }})
{% endfor %}

Generated on: {{ generated_timestamp }}
Python executable: {{ python_executable }}
"""

import asyncio
import subprocess
import sys
from pathlib import Path
from fastmcp import FastMCP

# Initialize the MCP application
mcp = FastMCP("scriptthing-tools")


def _enhance_output_with_instructions(output: str, context: str, output_instructions: str) -> str:
    """Enhance output with AI instructions, handling JSON appropriately"""
    if not context and not output_instructions:
        return output
        
    try:
        import json
        # Try to parse as JSON
        json_output = json.loads(output.strip())
        
        # Add AI instructions to JSON based on type
        if isinstance(json_output, dict):
            # For JSON objects, add instruction fields directly
            if context:
                json_output["_context"] = context
            if output_instructions:
                json_output["_output_instructions"] = output_instructions
            return json.dumps(json_output, indent=2)
            
        elif isinstance(json_output, list):
            # For JSON arrays, wrap in an object with instructions
            response_obj = {"data": json_output}
            if context:
                response_obj["_context"] = context
            if output_instructions:
                response_obj["_output_instructions"] = output_instructions
            return json.dumps(response_obj, indent=2)
            
        else:
            # For primitive JSON values, wrap in an object
            response_obj = {"value": json_output}
            if context:
                response_obj["_context"] = context
            if output_instructions:
                response_obj["_output_instructions"] = output_instructions
            return json.dumps(response_obj, indent=2)
            
    except (json.JSONDecodeError, ValueError):
        # Not JSON, handle as plain text
        response_parts = []
        if context:
            response_parts.append(context)
        response_parts.append(output)
        if output_instructions:
            response_parts.append(output_instructions)
        return "\n\n".join(response_parts)

{% for script_tool in script_tools %}
{% set func_name = script_tool.tool.name | replace('-', '_') | replace(' ', '_') | regex_replace('[^a-zA-Z0-9_]', '_') %}
{% if func_name[0].isdigit() %}{% set func_name = "tool_" + func_name %}{% endif %}

# Tool: {{ script_tool.tool.name }} (from {{ script_tool.script_name }})
@mcp.tool()
async def {{ func_name }}({% for param in script_tool.tool.parameters %}{{ param.name }}{% if param.type == "number" %}: float{% elif param.type == "integer" %}: int{% elif param.type == "boolean" %}: bool{% else %}: str{% endif %}{% if not param.required %}{% if param.default is not none %} = {{ param.default | repr }}{% else %} = None{% endif %}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}) -> str:
    """
    {{ script_tool.tool.description }}
    
    Args:
{% for param in script_tool.tool.parameters %}
        {{ param.name }} ({{ param.type }}{% if param.enum %} (one of: {{ param.enum | join(', ') }}){% endif %}, {{ "required" if param.required else "optional" }}): {{ param.description }}
{% endfor %}
    
    Returns:
        str: The output from the script execution
    """
{% for param in script_tool.tool.parameters %}
{% if param.required %}
    if {{ param.name }} is None:
        raise ValueError("Parameter '{{ param.name }}' is required")
{% endif %}
{% if param.enum %}
    if {{ param.name }} is not None and {{ param.name }} not in {{ param.enum | list }}:
        raise ValueError(f"Parameter '{{ param.name }}' must be one of {{ param.enum | list }}, got {repr({{ param.name }})}")
{% endif %}
{% endfor %}
    
    # Execute the script
    try:
        # Build command arguments
{% if script_tool.script_path.endswith('.sh') %}
        cmd = ["bash", "{{ script_tool.script_path }}"]
{% elif script_tool.script_path.endswith('.py') %}
        cmd = ["{{ python_executable }}", "{{ script_tool.script_path }}"]
{% else %}
        cmd = ["{{ script_tool.script_path }}"]
{% endif %}
        
        # Add parameters as arguments (modify this based on your script's argument format)
{% for param in script_tool.tool.parameters %}
        if {{ param.name }} is not None:
            cmd.extend(["--{{ param.name }}", str({{ param.name }})])
{% endfor %}
        
        # Execute the script
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=30  # 30 second timeout
        )
        
        if result.returncode != 0:
            return f"Script execution failed: {result.stderr}"
        
        # Build the response with AI instructions
        output = result.stdout if result.stdout else "Script executed successfully"
        
{% if script_tool.tool.ai_instructions_before or script_tool.tool.ai_instructions_after %}
        return _enhance_output_with_instructions(
            output, 
            "{{ script_tool.tool.ai_instructions_before or '' }}", 
            "{{ script_tool.tool.ai_instructions_after or '' }}"
        )
{% else %}
        return output
{% endif %}
        
    except subprocess.TimeoutExpired:
        return "Script execution timed out"
    except Exception as e:
        return f"Error executing script: {str(e)}"


{% endfor %}
if __name__ == "__main__":
    # Run the MCP server
    mcp.run()
