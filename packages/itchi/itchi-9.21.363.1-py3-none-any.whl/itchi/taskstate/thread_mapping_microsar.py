import logging
from typing import Optional
from dataclasses import dataclass
from pathlib import Path
from itchi.ortilib.orti import Orti


@dataclass
class ThreadIdMapping:
    name: str
    id: str


def get_thread_mapping(orti: Orti, os_types_lcfg_h: Path) -> list[ThreadIdMapping]:
    if os_types_lcfg_h != Path():
        if os_types_lcfg_h.is_file():
            logging.info(f"Extracing MICROSAR thread mapping from '{os_types_lcfg_h}'.")
            return get_thread_mapping_os_types_lcfg_h(os_types_lcfg_h)
        else:
            m = f"Could not find {os_types_lcfg_h}. Extracting thread mapping from ORTI file."
            logging.warning(m)
    return get_thread_mapping_orti(orti)


def get_thread_mapping_orti(orti: Orti) -> list[ThreadIdMapping]:
    """
    Extract thread mapping from ORTI file.

    Args:
        orti (Orti): An instance of the Orti class.

    Returns:
        list[ThreadIdMapping]: List of thread names and their corresponding IDs.
    """
    # (FelixM) The following requires knowledge about how Vector DaVinci
    # Configurator assigns the thread IDs. The ORTI file contains an array of
    # tasks and an array of ISRs. The thread IDs are generated by first
    # enumerating the tasks, and then enumerating the ISRs starting from the
    # last task index. Finally, there are a THREAD_ID_COUNT and a INVALID_THREAD
    # object that get their own ID (after the other Tasks and ISRs). The
    # INVALID_TASK and INVALID_ISR objects don't get an ID and have to be
    # ignored.
    thread_id_counter = 0
    thread_mapping = []

    for task_enum in orti.get_enum_elements_runningtask():
        task_name = task_enum.desc
        if task_name != "INVALID_TASK":
            thread_mapping.append(ThreadIdMapping(task_name, str(thread_id_counter)))
            thread_id_counter += 1

    for isrEnum in orti.get_enum_elements_runningisr2():
        isrName = isrEnum.desc
        if isrName != "INVALID_ISR":
            thread_mapping.append(ThreadIdMapping(isrName, str(thread_id_counter)))
            thread_id_counter += 1

    # (04-Dec-2024 Felixm) This now longer works in all cases because in "newer"
    # (2021ish) MICROSAR versions there can be an arbitrary number of "hooks"
    # thread IDs after the last ISR in `Os_Types_lcfg.h`. This won't be accounted
    # for in the ORTI file and consequently "raw" IDs will appear in the winIDEA Analyzer.
    # This can be avoided by using the `Os_Types_lcfg.h` file, which contains
    # all information or manually editing the Profiler XML file to add the missing
    # thread IDs.

    # For historic reasons, we map "THREAD_ID_COUNT" as "INVALID_THREAD".
    thread_mapping.append(ThreadIdMapping("INVALID_THREAD", str(thread_id_counter)))
    thread_id_counter += 1

    # We map "OS_TRACE_INVALID_THREAD" as "NO_THREAD".
    thread_mapping.append(ThreadIdMapping("NO_THREAD", str(thread_id_counter)))
    return thread_mapping


def get_thread_mapping_os_types_lcfg_h(os_types_lcfg_h: Path) -> list[ThreadIdMapping]:
    """
    Extract thread mapping from Vector MICROSAR Os_Types_Lcfg.h file.

    We supported this many years ago and then removed it because the same
    information could be extracted from the ORTI file. However, this is no
    longer the case and there are scenarios where a user might want to get
    "entirely correct" IDs in which case parsing Os_Types_Lcfg.h becomes
    necessary again.

    See https://tasking.atlassian.net/browse/PLAP-99 for more context.

    Args:
        os_types_lcfg_h: Path to the Os_Types_Lcfg.h file.

    Returns:
        List of thread names and their corresponding IDs.

    Raises:
        FileNotFoundError: If the input file doesn't exist.
        ValueError: If parsing fails or expected enum is not found.
    """
    if not os_types_lcfg_h.is_file():
        raise FileNotFoundError(
            f"Cannot extract mapping because '{os_types_lcfg_h}' was not found."
        )

    def scan(source: str) -> list[str]:
        """Tokenize C source into words and operators."""
        i = 0
        words = []

        while i < len(source):
            c = source[i]
            if c.isspace():
                i += 1
            elif c == "/" and i + 1 < len(source) and source[i + 1] == "*":
                # Skip C-style comments
                i += 2  # Skip /*
                while i + 1 < len(source):
                    if source[i] == "*" and source[i + 1] == "/":
                        i += 2  # Skip */
                        break
                    i += 1
            elif c.isalnum() or c == "_":
                # Extract alphanumeric words and identifiers
                word = ""
                while i < len(source) and (source[i].isalnum() or source[i] == "_"):
                    word += source[i]
                    i += 1
                words.append(word)
            else:
                # Extract operators and symbols
                symbol = ""
                while (
                    i < len(source)
                    and not source[i].isspace()
                    and not source[i].isalnum()
                    and source[i] != "_"
                ):
                    symbol += source[i]
                    i += 1
                if symbol:  # Only add non-empty symbols
                    words.append(symbol)

        return words

    class Parser:
        """Simple parser for C enum declarations."""

        def __init__(self, words: list[str]):
            self.words = words
            self.i = 0

        def at_typedef_enum(self) -> bool:
            """Check if current position is at 'typedef enum'."""
            return (
                self.i + 1 < len(self.words)
                and self.words[self.i] == "typedef"
                and self.words[self.i + 1] == "enum"
            )

        def at_eof(self) -> bool:
            """Check if at end of word list."""
            return self.i >= len(self.words)

        def consume(self, expected: Optional[str] = None) -> str:
            """Consume and return next word, optionally checking it matches expected."""
            if self.i >= len(self.words):
                raise ValueError(
                    f"Unexpected end of file '{os_types_lcfg_h}'. Unable to extract thread mapping."
                )

            word = self.words[self.i]
            if expected is not None and word != expected:
                raise ValueError(
                    f"Expected '{expected}' but got '{word}' in '{os_types_lcfg_h}'. "
                    "Unable to extract thread mapping."
                )

            self.i += 1
            return word

        def next_enum(self) -> Optional[tuple[str, list[ThreadIdMapping]]]:
            """Parse the next enum declaration."""
            # Find next typedef enum
            while not self.at_typedef_enum():
                if self.at_eof():
                    return None
                self.consume()

            self.consume("typedef")
            self.consume("enum")
            self.consume("{")

            mappings = []

            while True:
                name = self.consume()
                self.consume("=")

                # Parse identifier (may be an expression)
                identifier = self.consume()
                delimiter = self.consume()

                # Handle complex expressions (e.g., "OS_TRACE_THREADID_COUNT + 1")
                while delimiter not in (",", "}"):
                    identifier += " " + delimiter
                    delimiter = self.consume()

                mappings.append(ThreadIdMapping(name, identifier))

                if delimiter == "}":
                    break
                elif delimiter != ",":
                    raise ValueError(
                        f"Unexpected delimiter '{delimiter}' in enum from {os_types_lcfg_h}"
                    )

            # Get enum type name
            enum_name = self.consume()
            self.consume(";")
            return enum_name, mappings

    with open(os_types_lcfg_h, "r", encoding="utf-8") as f:
        source = f.read()

    words = scan(source)
    parser = Parser(words)

    target_enum_name = "Os_TraceThreadIdType"
    mappings = None
    while (enum_data := parser.next_enum()) is not None:
        enum_name, enum_mappings = enum_data
        if enum_name == target_enum_name:
            mappings = enum_mappings
            break

    if mappings is None:
        raise ValueError(f"Unable to find enum '{target_enum_name}' in '{os_types_lcfg_h}'")

    # Post-process mappings to match ORTI format
    for i, mapping in enumerate(mappings):
        mapping.name = mapping.name.replace("Os_TraceId_", "")
        if mapping.name == "OS_TRACE_THREADID_COUNT":
            mapping.name = "INVALID_THREAD"
        elif mapping.name == "OS_TRACE_INVALID_THREAD":
            mapping.name = "NO_THREAD"
            mapping.id = str(i)

    return mappings
