
# ********************************************************************************
#
# This file has been auto-generated by a code generation tool.
#
# DO NOT MODIFY THIS FILE
# This file is maintained by DNV.
# Editing it may lead to inconsistent results and limit DNV's ability to provide support.
# Please contact DNV if you believe changes are required.
#
# Version:   4.2.25
# Date/time: 01 Oct 2025 18:25:53
# Template:  templates/pythonpws/calculations.razor.
#
# ********************************************************************************

# ================================================================================
# Python PWS calculations.
# ================================================================================

import uuid
import requests
from requests import Response
from http import HTTPStatus
from marshmallow import Schema, fields, pre_load, post_load, EXCLUDE
from marshmallow_enum import EnumField, ValidationError

from .constants import *
from .enums import *
from .entities import *
from .entity_schemas import *
from .utilities import get_access_token, get_analytics_api_target, get_client_alias_id, get_access_token_info

class _CalculationRequestBase(object):
    """Calculation request base class."""

    def __init__(self):
      pass

class _CalculationBase(object):
    """Calculation base class."""

    def __init__(self):

        self.result_code = ResultCode.SUCCESS
        """ resultCode: ResultCode

            Possible values:

            -1: Failed validation
            0: Success
            +1: Failed execution

        """

        self.messages = list[str]()
        """ messages: List of messages returned by a calculation. """

        self.calculation_elapsed_time = 0.0
        """ calculation_elapsed_time: Time taken to run the calculation. """

        self.operation_id = ''
        """ operation_id: Operation id which can be used to request support. """

    # Post json to url and time the call
    def post_request(self, url: str, data: str, access_token: str) -> Response:

        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {access_token}'
        }

        (platform, expiry_date, has_expired) = get_access_token_info(access_token)

        if not has_expired:
            response = requests.post(url, data = data, headers = headers, verify = 'localhost' not in url)
            return response
        else:
            print(f"Your access token has expired: {expiry_date}")

            response = Response()

            response.status_code = HTTPStatus.UNAUTHORIZED
            response.reason = "Expired access token"

            return response

    def print_messages(self):
        """Utility method to print the messages returned by the calculation."""
        if (self.messages is not None and len(self.messages) > 0):
            for message in self.messages:
                print(message)
        else:
            print("No messages")

    def handle_failed_response(self, response):
        try:
            calculation_failed_response_schema = _CalculationFailedResponseSchema()
            calculation_failed_response = calculation_failed_response_schema.loads(response.text)
            self.result_code = ResultCode(calculation_failed_response.result_code)
            self.messages.extend(calculation_failed_response.messages)
            self.calculation_elapsed_time = calculation_failed_response.calculation_elapsed_time
            self.operation_id = calculation_failed_response.operation_id
        except:
            pass
        finally:
            self.messages.append(f"{response.reason} (Status code: {response.status_code})")

class _CalculationResponseBase(object):
    """Calculation response base class."""

    def __init__(self, result_code: ResultCode = None, messages: list[str] = None, calculation_elapsed_time: int = None, operation_id: str = None):

        self.result_code = result_code
        """Result code: Result status of the calculation"""

        self.messages = messages
        """messages: Messages coming back from the calculation"""

        self.calculation_elapsed_time = calculation_elapsed_time
        """self.calculation_elapsed_time: Time taken to run the calculation"""

        self.operation_id = operation_id
        """ operation_id: Operation id which can be used to request support. """

class CalculationFailedResponse(_CalculationResponseBase):
    """Calculation failed response class."""

    def __init__(self, result_code: ResultCode = None, messages: list[str] = [], calculation_elapsed_time: int = 0, operation_id: str = ''):
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

class _CalculationFailedResponseSchema(Schema):
    """Calculation failed response schema."""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")

    @post_load
    def make_calculation_failed_response(self, data, **kwargs):
        """Post-processing of the CalculationFailedResponseSchema class."""

        return CalculationFailedResponse(**data)

class _BESSConfidenceIntervalEnergyScalingCalculationRequest(_CalculationRequestBase):
    """
    _BESSConfidenceIntervalEnergyScalingCalculationRequest class.

    Attributes
    ----------
        chemistry : int
             Battery chemistry of interest.
        confidence_interval : float
             Confidence level of interest (0.5 < interval < 1.0).

    """
    def __init__(self, chemistry: int, confidence_interval: float):
        """Initializes a new instance of the _BESSConfidenceIntervalEnergyScalingCalculationRequest class"""

        super().__init__()

        self.chemistry = chemistry
        self.confidence_interval = confidence_interval

class _BESSConfidenceIntervalEnergyScalingCalculationRequestSchema(Schema):
    """Schema for the BESSConfidenceIntervalEnergyScaling calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    chemistry = fields.Int(data_key="chemistry")
    confidence_interval = fields.Float(data_key="confidenceInterval")

    @post_load
    def make_bess_confidence_interval_energy_scaling_calculation_request(self, data, **kwargs):
        """Post-processing of the BESSConfidenceIntervalEnergyScalingCalculationRequestSchema class."""

        return _BESSConfidenceIntervalEnergyScalingCalculationRequest(**data)

class BESSConfidenceIntervalEnergyScalingCalculation(_CalculationBase):
    """
    BESSConfidenceIntervalEnergyScalingCalculation class.

    Attributes
    ----------
    Calculation inputs:
        chemistry : int
             Battery chemistry of interest.
        confidence_interval : float
             Confidence level of interest (0.5 < interval < 1.0).

    Calculation outputs:
        k_upper : float
             Energy scaling value for upper confidence bound.
        k_lower : float
             Energy scaling value for lower confidence bound.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, chemistry: int, confidence_interval: float):
        """Initializes a new instance of the BESSConfidenceIntervalEnergyScalingCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.chemistry = chemistry
        self.confidence_interval = confidence_interval

        # Calculation outputs.
        self.k_upper = None
        self.k_lower = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        BESSConfidenceIntervalEnergyScalingCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _BESSConfidenceIntervalEnergyScalingCalculationRequest object.
        bess_confidence_interval_energy_scaling_calculation_request = _BESSConfidenceIntervalEnergyScalingCalculationRequest(self.chemistry, self.confidence_interval)

        # Get the _BESSConfidenceIntervalEnergyScalingCalculationRequestSchema and use that to serialize to json.
        bess_confidence_interval_energy_scaling_calculation_request_schema = _BESSConfidenceIntervalEnergyScalingCalculationRequestSchema()

        request_json = bess_confidence_interval_energy_scaling_calculation_request_schema.dumps(bess_confidence_interval_energy_scaling_calculation_request)
        url = get_analytics_api_target() + 'calculatebessconfidenceintervalenergyscaling?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            bess_confidence_interval_energy_scaling_calculation_response_schema = _BESSConfidenceIntervalEnergyScalingCalculationResponseSchema()
            bess_confidence_interval_energy_scaling_calculation_response = bess_confidence_interval_energy_scaling_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(bess_confidence_interval_energy_scaling_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.k_upper = bess_confidence_interval_energy_scaling_calculation_response.k_upper
                self.k_lower = bess_confidence_interval_energy_scaling_calculation_response.k_lower
                self.result_code = bess_confidence_interval_energy_scaling_calculation_response.result_code
                self.messages = bess_confidence_interval_energy_scaling_calculation_response.messages
                self.calculation_elapsed_time = bess_confidence_interval_energy_scaling_calculation_response.calculation_elapsed_time
                self.operation_id = bess_confidence_interval_energy_scaling_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(bess_confidence_interval_energy_scaling_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the BESSConfidenceIntervalEnergyScalingCalculation object"""

        parts = ['* BESSConfidenceIntervalEnergyScaling']

        parts.append(f'chemistry:	{str(self.chemistry)}')
        parts.append(f'confidence_interval:	{str(self.confidence_interval)}')
        parts.append(f'k_upper:	{str(self.k_upper)}')
        parts.append(f'k_lower:	{str(self.k_lower)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _BESSConfidenceIntervalEnergyScalingCalculationResponseSchema(Schema):
    """Schema for the BESSConfidenceIntervalEnergyScalingCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    k_upper = fields.Float(data_key="kUpper")
    k_lower = fields.Float(data_key="kLower")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_bess_confidence_interval_energy_scaling_calculation_response(self, data, **kwargs):
        """Post-processing of the BESSConfidenceIntervalEnergyScalingCalculationResponseSchema class."""

        return _BESSConfidenceIntervalEnergyScalingCalculationResponse(**data)

class _BESSConfidenceIntervalEnergyScalingCalculationResponse(_CalculationResponseBase):
    """
    _BESSConfidenceIntervalEnergyScalingCalculationResponse class.

    Attributes
    ----------
        k_upper : float
             Energy scaling value for upper confidence bound.
        k_lower : float
             Energy scaling value for lower confidence bound.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, k_upper: float, k_lower: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the BESSConfidenceIntervalEnergyScalingCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.k_upper = k_upper
        self.k_lower = k_lower
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _BESSLinkedRunnerCalculationRequest(_CalculationRequestBase):
    """
    _BESSLinkedRunnerCalculationRequest class.

    Attributes
    ----------
        bess_unit : BESSUnit
              a BESS unit entity.
        bess_release : BESSRelease
              a BESS release entity.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    """
    def __init__(self, bess_unit: BESSUnit, bess_release: BESSRelease, weather: Weather, substrate: Substrate, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _BESSLinkedRunnerCalculationRequest class"""

        super().__init__()

        self.bess_unit = bess_unit
        self.bess_release = bess_release
        self.weather = weather
        self.substrate = substrate
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

class _BESSLinkedRunnerCalculationRequestSchema(Schema):
    """Schema for the BESSLinkedRunner calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    bess_unit = fields.Nested(BESSUnitSchema, data_key="bessUnit")
    bess_release = fields.Nested(BESSReleaseSchema, data_key="bessRelease")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_bess_linked_runner_calculation_request(self, data, **kwargs):
        """Post-processing of the BESSLinkedRunnerCalculationRequestSchema class."""

        return _BESSLinkedRunnerCalculationRequest(**data)

class BESSLinkedRunnerCalculation(_CalculationBase):
    """
    BESSLinkedRunnerCalculation class.

    Attributes
    ----------
    Calculation inputs:
        bess_unit : BESSUnit
              a BESS unit entity.
        bess_release : BESSRelease
              a BESS release entity.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    Calculation outputs:
        exit_material : Material
             Exit material from the BESS unit, dependent on BESS chemistry.
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, bess_unit: BESSUnit, bess_release: BESSRelease, weather: Weather, substrate: Substrate, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the BESSLinkedRunnerCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.bess_unit = bess_unit
        self.bess_release = bess_release
        self.weather = weather
        self.substrate = substrate
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.exit_material = None
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.n_jet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.n_flam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.n_pool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.n_toxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        BESSLinkedRunnerCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _BESSLinkedRunnerCalculationRequest object.
        bess_linked_runner_calculation_request = _BESSLinkedRunnerCalculationRequest(self.bess_unit, self.bess_release, self.weather, self.substrate, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the _BESSLinkedRunnerCalculationRequestSchema and use that to serialize to json.
        bess_linked_runner_calculation_request_schema = _BESSLinkedRunnerCalculationRequestSchema()

        request_json = bess_linked_runner_calculation_request_schema.dumps(bess_linked_runner_calculation_request)
        url = get_analytics_api_target() + 'batteryhazardlinkedrun?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            bess_linked_runner_calculation_response_schema = _BESSLinkedRunnerCalculationResponseSchema()
            bess_linked_runner_calculation_response = bess_linked_runner_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(bess_linked_runner_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = bess_linked_runner_calculation_response.exit_material
                self.discharge_record = bess_linked_runner_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = bess_linked_runner_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = bess_linked_runner_calculation_response.jet_contour_points
                self.n_jet_contour_points = bess_linked_runner_calculation_response.n_jet_contour_points
                self.area_contour_jet = bess_linked_runner_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = bess_linked_runner_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = bess_linked_runner_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = bess_linked_runner_calculation_response.flam_conc_contour_points
                self.n_flam_conc_contour_points = bess_linked_runner_calculation_response.n_flam_conc_contour_points
                self.area_footprint_flam_conc = bess_linked_runner_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = bess_linked_runner_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = bess_linked_runner_calculation_response.pool_contour_points
                self.n_pool_contour_points = bess_linked_runner_calculation_response.n_pool_contour_points
                self.area_contour_pool = bess_linked_runner_calculation_response.area_contour_pool
                self.explosion_overpressure_results = bess_linked_runner_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = bess_linked_runner_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = bess_linked_runner_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = bess_linked_runner_calculation_response.toxic_conc_contour_points
                self.n_toxic_conc_contour_points = bess_linked_runner_calculation_response.n_toxic_conc_contour_points
                self.area_footprint_toxic_conc = bess_linked_runner_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = bess_linked_runner_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = bess_linked_runner_calculation_response.pool_fire_flame_result
                self.result_code = bess_linked_runner_calculation_response.result_code
                self.messages = bess_linked_runner_calculation_response.messages
                self.calculation_elapsed_time = bess_linked_runner_calculation_response.calculation_elapsed_time
                self.operation_id = bess_linked_runner_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(bess_linked_runner_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the BESSLinkedRunnerCalculation object"""

        parts = ['* BESSLinkedRunner']

        parts.append('* BESSUnit')
        parts.append(f'bess_unit:	{str(self.bess_unit)}')
        parts.append('* BESSRelease')
        parts.append(f'bess_release:	{str(self.bess_release)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.extend(['dispersion_parameters_element' for dispersion_parameters_element in self.dispersion_parameters] if self.dispersion_parameters else [f'dispersion_parameters does not contain any elements'])
        parts.append(f'dispersion_parameter_count:	{str(self.dispersion_parameter_count)}')
        parts.append(f'end_point_concentration:	{str(self.end_point_concentration)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['dispersion_flam_output_configs_element' for dispersion_flam_output_configs_element in self.dispersion_flam_output_configs] if self.dispersion_flam_output_configs else [f'dispersion_flam_output_configs does not contain any elements'])
        parts.append(f'dispersion_flam_output_config_count:	{str(self.dispersion_flam_output_config_count)}')
        parts.extend(['dispersion_toxic_output_configs_element' for dispersion_toxic_output_configs_element in self.dispersion_toxic_output_configs] if self.dispersion_toxic_output_configs else [f'dispersion_toxic_output_configs does not contain any elements'])
        parts.append(f'dispersion_toxic_output_config_count:	{str(self.dispersion_toxic_output_config_count)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['explosion_output_configs_element' for explosion_output_configs_element in self.explosion_output_configs] if self.explosion_output_configs else [f'explosion_output_configs does not contain any elements'])
        parts.append(f'explosion_output_config_count:	{str(self.explosion_output_config_count)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.append('* Material')
        parts.append(f'exit_material:	{str(self.exit_material)}')
        parts.append('* DischargeRecord')
        parts.append(f'discharge_record:	{str(self.discharge_record)}')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.extend(['n_jet_contour_points_element' for n_jet_contour_points_element in self.n_jet_contour_points] if self.n_jet_contour_points else [f'n_jet_contour_points does not contain any elements'])
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.extend(['n_flam_conc_contour_points_element' for n_flam_conc_contour_points_element in self.n_flam_conc_contour_points] if self.n_flam_conc_contour_points else [f'n_flam_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.extend(['n_pool_contour_points_element' for n_pool_contour_points_element in self.n_pool_contour_points] if self.n_pool_contour_points else [f'n_pool_contour_points does not contain any elements'])
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.extend(['n_toxic_conc_contour_points_element' for n_toxic_conc_contour_points_element in self.n_toxic_conc_contour_points] if self.n_toxic_conc_contour_points else [f'n_toxic_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append('* FlameResult')
        parts.append(f'jet_fire_flame_result:	{str(self.jet_fire_flame_result)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _BESSLinkedRunnerCalculationResponseSchema(Schema):
    """Schema for the BESSLinkedRunnerCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    n_jet_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float(), allow_none=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float(), allow_none=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    n_flam_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    n_pool_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float(), allow_none=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float(), allow_none=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    n_toxic_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_bess_linked_runner_calculation_response(self, data, **kwargs):
        """Post-processing of the BESSLinkedRunnerCalculationResponseSchema class."""

        return _BESSLinkedRunnerCalculationResponse(**data)

class _BESSLinkedRunnerCalculationResponse(_CalculationResponseBase):
    """
    _BESSLinkedRunnerCalculationResponse class.

    Attributes
    ----------
        exit_material : Material
             Exit material from the BESS unit, dependent on BESS chemistry.
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, exit_material: Material, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], n_jet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], n_flam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], n_pool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], n_toxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the BESSLinkedRunnerCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.exit_material = exit_material
        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation
        self.jet_contour_points = jet_contour_points
        self.n_jet_contour_points = n_jet_contour_points
        self.area_contour_jet = area_contour_jet
        self.distances_to_flam_concentration = distances_to_flam_concentration
        self.flam_concentrations_used = flam_concentrations_used
        self.flam_conc_contour_points = flam_conc_contour_points
        self.n_flam_conc_contour_points = n_flam_conc_contour_points
        self.area_footprint_flam_conc = area_footprint_flam_conc
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation
        self.pool_contour_points = pool_contour_points
        self.n_pool_contour_points = n_pool_contour_points
        self.area_contour_pool = area_contour_pool
        self.explosion_overpressure_results = explosion_overpressure_results
        self.distances_to_toxic_concentration = distances_to_toxic_concentration
        self.toxic_concentration_used = toxic_concentration_used
        self.toxic_conc_contour_points = toxic_conc_contour_points
        self.n_toxic_conc_contour_points = n_toxic_conc_contour_points
        self.area_footprint_toxic_conc = area_footprint_toxic_conc
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _BESSToxicSourceCalculationRequest(_CalculationRequestBase):
    """
    _BESSToxicSourceCalculationRequest class.

    Attributes
    ----------
        bess_unit : BESSUnit
             BESS unit under thermal runaway.
        bess_release : BESSRelease
             Specifics of the release from the unit being considered.

    """
    def __init__(self, bess_unit: BESSUnit, bess_release: BESSRelease):
        """Initializes a new instance of the _BESSToxicSourceCalculationRequest class"""

        super().__init__()

        self.bess_unit = bess_unit
        self.bess_release = bess_release

class _BESSToxicSourceCalculationRequestSchema(Schema):
    """Schema for the BESSToxicSource calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    bess_unit = fields.Nested(BESSUnitSchema, data_key="bessUnit")
    bess_release = fields.Nested(BESSReleaseSchema, data_key="bessRelease")

    @post_load
    def make_bess_toxic_source_calculation_request(self, data, **kwargs):
        """Post-processing of the BESSToxicSourceCalculationRequestSchema class."""

        return _BESSToxicSourceCalculationRequest(**data)

class BESSToxicSourceCalculation(_CalculationBase):
    """
    BESSToxicSourceCalculation class.

    Attributes
    ----------
    Calculation inputs:
        bess_unit : BESSUnit
             BESS unit under thermal runaway.
        bess_release : BESSRelease
             Specifics of the release from the unit being considered.

    Calculation outputs:
        bess_material : Material
             Composition of the released material (dependent on batter chemistry).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
             Array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, bess_unit: BESSUnit, bess_release: BESSRelease):
        """Initializes a new instance of the BESSToxicSourceCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.bess_unit = bess_unit
        self.bess_release = bess_release

        # Calculation outputs.
        self.bess_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        BESSToxicSourceCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _BESSToxicSourceCalculationRequest object.
        bess_toxic_source_calculation_request = _BESSToxicSourceCalculationRequest(self.bess_unit, self.bess_release)

        # Get the _BESSToxicSourceCalculationRequestSchema and use that to serialize to json.
        bess_toxic_source_calculation_request_schema = _BESSToxicSourceCalculationRequestSchema()

        request_json = bess_toxic_source_calculation_request_schema.dumps(bess_toxic_source_calculation_request)
        url = get_analytics_api_target() + 'calculatebesstoxicsource?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            bess_toxic_source_calculation_response_schema = _BESSToxicSourceCalculationResponseSchema()
            bess_toxic_source_calculation_response = bess_toxic_source_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(bess_toxic_source_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.bess_material = bess_toxic_source_calculation_response.bess_material
                self.discharge_result = bess_toxic_source_calculation_response.discharge_result
                self.discharge_records = bess_toxic_source_calculation_response.discharge_records
                self.result_code = bess_toxic_source_calculation_response.result_code
                self.messages = bess_toxic_source_calculation_response.messages
                self.calculation_elapsed_time = bess_toxic_source_calculation_response.calculation_elapsed_time
                self.operation_id = bess_toxic_source_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(bess_toxic_source_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the BESSToxicSourceCalculation object"""

        parts = ['* BESSToxicSource']

        parts.append('* BESSUnit')
        parts.append(f'bess_unit:	{str(self.bess_unit)}')
        parts.append('* BESSRelease')
        parts.append(f'bess_release:	{str(self.bess_release)}')
        parts.append('* Material')
        parts.append(f'bess_material:	{str(self.bess_material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _BESSToxicSourceCalculationResponseSchema(Schema):
    """Schema for the BESSToxicSourceCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    bess_material = fields.Nested(MaterialSchema, data_key="bessMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_bess_toxic_source_calculation_response(self, data, **kwargs):
        """Post-processing of the BESSToxicSourceCalculationResponseSchema class."""

        return _BESSToxicSourceCalculationResponse(**data)

class _BESSToxicSourceCalculationResponse(_CalculationResponseBase):
    """
    _BESSToxicSourceCalculationResponse class.

    Attributes
    ----------
        bess_material : Material
             Composition of the released material (dependent on batter chemistry).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
             Array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, bess_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the BESSToxicSourceCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.bess_material = bess_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _ConcentrationAtPointCalculationRequest(_CalculationRequestBase):
    """
    _ConcentrationAtPointCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
             Array of dispersion record.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _ConcentrationAtPointCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

class _ConcentrationAtPointCalculationRequestSchema(Schema):
    """Schema for the ConcentrationAtPoint calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_concentration_at_point_calculation_request(self, data, **kwargs):
        """Post-processing of the ConcentrationAtPointCalculationRequestSchema class."""

        return _ConcentrationAtPointCalculationRequest(**data)

class ConcentrationAtPointCalculation(_CalculationBase):
    """
    ConcentrationAtPointCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
             Array of dispersion record.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        concentration : float
             Concentration at a position of interest.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the ConcentrationAtPointCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.concentration = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        ConcentrationAtPointCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ConcentrationAtPointCalculationRequest object.
        concentration_at_point_calculation_request = _ConcentrationAtPointCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the _ConcentrationAtPointCalculationRequestSchema and use that to serialize to json.
        concentration_at_point_calculation_request_schema = _ConcentrationAtPointCalculationRequestSchema()

        request_json = concentration_at_point_calculation_request_schema.dumps(concentration_at_point_calculation_request)
        url = get_analytics_api_target() + 'calculateconcentrationatpoint?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            concentration_at_point_calculation_response_schema = _ConcentrationAtPointCalculationResponseSchema()
            concentration_at_point_calculation_response = concentration_at_point_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(concentration_at_point_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.concentration = concentration_at_point_calculation_response.concentration
                self.result_code = concentration_at_point_calculation_response.result_code
                self.messages = concentration_at_point_calculation_response.messages
                self.calculation_elapsed_time = concentration_at_point_calculation_response.calculation_elapsed_time
                self.operation_id = concentration_at_point_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(concentration_at_point_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the ConcentrationAtPointCalculation object"""

        parts = ['* ConcentrationAtPoint']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append(f'concentration:	{str(self.concentration)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _ConcentrationAtPointCalculationResponseSchema(Schema):
    """Schema for the ConcentrationAtPointCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    concentration = fields.Float(data_key="concentration")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_concentration_at_point_calculation_response(self, data, **kwargs):
        """Post-processing of the ConcentrationAtPointCalculationResponseSchema class."""

        return _ConcentrationAtPointCalculationResponse(**data)

class _ConcentrationAtPointCalculationResponse(_CalculationResponseBase):
    """
    _ConcentrationAtPointCalculationResponse class.

    Attributes
    ----------
        concentration : float
             Concentration at a position of interest.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, concentration: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the ConcentrationAtPointCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.concentration = concentration
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _ConvertCompositionMassToMoleCalculationRequest(_CalculationRequestBase):
    """
    _ConvertCompositionMassToMoleCalculationRequest class.

    Attributes
    ----------
        mixture : Material
              a material entity with two or more material components to have composition converted.
        composition_mass : list[float]
             Array of mass fractions.
        composition_mass_count : int
             Number of components in mixture.

    """
    def __init__(self, mixture: Material, composition_mass: list[float], composition_mass_count: int):
        """Initializes a new instance of the _ConvertCompositionMassToMoleCalculationRequest class"""

        super().__init__()

        self.mixture = mixture
        self.composition_mass = composition_mass
        self.composition_mass_count = composition_mass_count

class _ConvertCompositionMassToMoleCalculationRequestSchema(Schema):
    """Schema for the ConvertCompositionMassToMole calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mixture = fields.Nested(MaterialSchema, data_key="mixture")
    composition_mass = fields.List(fields.Float(), allow_none=True, data_key="compositionMass")
    composition_mass_count = fields.Int(data_key="compositionMassCount")

    @post_load
    def make_convert_composition_mass_to_mole_calculation_request(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMassToMoleCalculationRequestSchema class."""

        return _ConvertCompositionMassToMoleCalculationRequest(**data)

class ConvertCompositionMassToMoleCalculation(_CalculationBase):
    """
    ConvertCompositionMassToMoleCalculation class.

    Attributes
    ----------
    Calculation inputs:
        mixture : Material
              a material entity with two or more material components to have composition converted.
        composition_mass : list[float]
             Array of mass fractions.
        composition_mass_count : int
             Number of components in mixture.

    Calculation outputs:
        composition_mole : list[float]
             Array of mole fractions.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, mixture: Material, composition_mass: list[float], composition_mass_count: int):
        """Initializes a new instance of the ConvertCompositionMassToMoleCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.mixture = mixture
        self.composition_mass = composition_mass
        self.composition_mass_count = composition_mass_count

        # Calculation outputs.
        self.composition_mole = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        ConvertCompositionMassToMoleCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ConvertCompositionMassToMoleCalculationRequest object.
        convert_composition_mass_to_mole_calculation_request = _ConvertCompositionMassToMoleCalculationRequest(self.mixture, self.composition_mass, self.composition_mass_count)

        # Get the _ConvertCompositionMassToMoleCalculationRequestSchema and use that to serialize to json.
        convert_composition_mass_to_mole_calculation_request_schema = _ConvertCompositionMassToMoleCalculationRequestSchema()

        request_json = convert_composition_mass_to_mole_calculation_request_schema.dumps(convert_composition_mass_to_mole_calculation_request)
        url = get_analytics_api_target() + 'utilities/convertcompositionmasstomole?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            convert_composition_mass_to_mole_calculation_response_schema = _ConvertCompositionMassToMoleCalculationResponseSchema()
            convert_composition_mass_to_mole_calculation_response = convert_composition_mass_to_mole_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(convert_composition_mass_to_mole_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.composition_mole = convert_composition_mass_to_mole_calculation_response.composition_mole
                self.result_code = convert_composition_mass_to_mole_calculation_response.result_code
                self.messages = convert_composition_mass_to_mole_calculation_response.messages
                self.calculation_elapsed_time = convert_composition_mass_to_mole_calculation_response.calculation_elapsed_time
                self.operation_id = convert_composition_mass_to_mole_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(convert_composition_mass_to_mole_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the ConvertCompositionMassToMoleCalculation object"""

        parts = ['* ConvertCompositionMassToMole']

        parts.append('* Material')
        parts.append(f'mixture:	{str(self.mixture)}')
        parts.extend(['composition_mass_element' for composition_mass_element in self.composition_mass] if self.composition_mass else [f'composition_mass does not contain any elements'])
        parts.append(f'composition_mass_count:	{str(self.composition_mass_count)}')
        parts.extend(['composition_mole_element' for composition_mole_element in self.composition_mole] if self.composition_mole else [f'composition_mole does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _ConvertCompositionMassToMoleCalculationResponseSchema(Schema):
    """Schema for the ConvertCompositionMassToMoleCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    composition_mole = fields.List(fields.Float(), allow_none=True, data_key="compositionMole")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_convert_composition_mass_to_mole_calculation_response(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMassToMoleCalculationResponseSchema class."""

        return _ConvertCompositionMassToMoleCalculationResponse(**data)

class _ConvertCompositionMassToMoleCalculationResponse(_CalculationResponseBase):
    """
    _ConvertCompositionMassToMoleCalculationResponse class.

    Attributes
    ----------
        composition_mole : list[float]
             Array of mole fractions.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, composition_mole: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the ConvertCompositionMassToMoleCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.composition_mole = composition_mole
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _ConvertCompositionMoleToMassCalculationRequest(_CalculationRequestBase):
    """
    _ConvertCompositionMoleToMassCalculationRequest class.

    Attributes
    ----------
        mixture : Material
              a material entity with two or more material components to have composition converted.
        composition_moles : list[float]
             Array of mole fractions.
        composition_moles_count : int
             Number of components in mixture.

    """
    def __init__(self, mixture: Material, composition_moles: list[float], composition_moles_count: int):
        """Initializes a new instance of the _ConvertCompositionMoleToMassCalculationRequest class"""

        super().__init__()

        self.mixture = mixture
        self.composition_moles = composition_moles
        self.composition_moles_count = composition_moles_count

class _ConvertCompositionMoleToMassCalculationRequestSchema(Schema):
    """Schema for the ConvertCompositionMoleToMass calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mixture = fields.Nested(MaterialSchema, data_key="mixture")
    composition_moles = fields.List(fields.Float(), allow_none=True, data_key="compositionMoles")
    composition_moles_count = fields.Int(data_key="compositionMolesCount")

    @post_load
    def make_convert_composition_mole_to_mass_calculation_request(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMoleToMassCalculationRequestSchema class."""

        return _ConvertCompositionMoleToMassCalculationRequest(**data)

class ConvertCompositionMoleToMassCalculation(_CalculationBase):
    """
    ConvertCompositionMoleToMassCalculation class.

    Attributes
    ----------
    Calculation inputs:
        mixture : Material
              a material entity with two or more material components to have composition converted.
        composition_moles : list[float]
             Array of mole fractions.
        composition_moles_count : int
             Number of components in mixture.

    Calculation outputs:
        composition_mass : list[float]
             Array of mass fractions.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, mixture: Material, composition_moles: list[float], composition_moles_count: int):
        """Initializes a new instance of the ConvertCompositionMoleToMassCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.mixture = mixture
        self.composition_moles = composition_moles
        self.composition_moles_count = composition_moles_count

        # Calculation outputs.
        self.composition_mass = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        ConvertCompositionMoleToMassCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ConvertCompositionMoleToMassCalculationRequest object.
        convert_composition_mole_to_mass_calculation_request = _ConvertCompositionMoleToMassCalculationRequest(self.mixture, self.composition_moles, self.composition_moles_count)

        # Get the _ConvertCompositionMoleToMassCalculationRequestSchema and use that to serialize to json.
        convert_composition_mole_to_mass_calculation_request_schema = _ConvertCompositionMoleToMassCalculationRequestSchema()

        request_json = convert_composition_mole_to_mass_calculation_request_schema.dumps(convert_composition_mole_to_mass_calculation_request)
        url = get_analytics_api_target() + 'utilities/convertcompositionmoletomass?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            convert_composition_mole_to_mass_calculation_response_schema = _ConvertCompositionMoleToMassCalculationResponseSchema()
            convert_composition_mole_to_mass_calculation_response = convert_composition_mole_to_mass_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(convert_composition_mole_to_mass_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.composition_mass = convert_composition_mole_to_mass_calculation_response.composition_mass
                self.result_code = convert_composition_mole_to_mass_calculation_response.result_code
                self.messages = convert_composition_mole_to_mass_calculation_response.messages
                self.calculation_elapsed_time = convert_composition_mole_to_mass_calculation_response.calculation_elapsed_time
                self.operation_id = convert_composition_mole_to_mass_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(convert_composition_mole_to_mass_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the ConvertCompositionMoleToMassCalculation object"""

        parts = ['* ConvertCompositionMoleToMass']

        parts.append('* Material')
        parts.append(f'mixture:	{str(self.mixture)}')
        parts.extend(['composition_moles_element' for composition_moles_element in self.composition_moles] if self.composition_moles else [f'composition_moles does not contain any elements'])
        parts.append(f'composition_moles_count:	{str(self.composition_moles_count)}')
        parts.extend(['composition_mass_element' for composition_mass_element in self.composition_mass] if self.composition_mass else [f'composition_mass does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _ConvertCompositionMoleToMassCalculationResponseSchema(Schema):
    """Schema for the ConvertCompositionMoleToMassCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    composition_mass = fields.List(fields.Float(), allow_none=True, data_key="compositionMass")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_convert_composition_mole_to_mass_calculation_response(self, data, **kwargs):
        """Post-processing of the ConvertCompositionMoleToMassCalculationResponseSchema class."""

        return _ConvertCompositionMoleToMassCalculationResponse(**data)

class _ConvertCompositionMoleToMassCalculationResponse(_CalculationResponseBase):
    """
    _ConvertCompositionMoleToMassCalculationResponse class.

    Attributes
    ----------
        composition_mass : list[float]
             Array of mass fractions.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, composition_mass: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the ConvertCompositionMoleToMassCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.composition_mass = composition_mass
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DispersionCalculationRequest(_CalculationRequestBase):
    """
    _DispersionCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        substrate : Substrate
              a substrate entity.
        discharge_result : DischargeResult
             Discharge / source term definition.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        discharge_record_count : int
             Number of discharge records.
        weather : Weather
              a weather entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).

    """
    def __init__(self, material: Material, substrate: Substrate, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, weather: Weather, dispersion_parameters: DispersionParameters, end_point_concentration: float):
        """Initializes a new instance of the _DispersionCalculationRequest class"""

        super().__init__()

        self.material = material
        self.substrate = substrate
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.end_point_concentration = end_point_concentration

class _DispersionCalculationRequestSchema(Schema):
    """Schema for the Dispersion calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    end_point_concentration = fields.Float(data_key="endPointConcentration")

    @post_load
    def make_dispersion_calculation_request(self, data, **kwargs):
        """Post-processing of the DispersionCalculationRequestSchema class."""

        return _DispersionCalculationRequest(**data)

class DispersionCalculation(_CalculationBase):
    """
    DispersionCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        substrate : Substrate
              a substrate entity.
        discharge_result : DischargeResult
             Discharge / source term definition.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        discharge_record_count : int
             Number of discharge records.
        weather : Weather
              a weather entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).

    Calculation outputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        pool_records : list[PoolRecord]
              an array of pool records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, substrate: Substrate, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, weather: Weather, dispersion_parameters: DispersionParameters, end_point_concentration: float):
        """Initializes a new instance of the DispersionCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.substrate = substrate
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.end_point_concentration = end_point_concentration

        # Calculation outputs.
        self.scalar_udm_outputs = None
        self.dispersion_records = None
        self.pool_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DispersionCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DispersionCalculationRequest object.
        dispersion_calculation_request = _DispersionCalculationRequest(self.material, self.substrate, self.discharge_result, self.discharge_records, self.discharge_record_count, self.weather, self.dispersion_parameters, self.end_point_concentration)

        # Get the _DispersionCalculationRequestSchema and use that to serialize to json.
        dispersion_calculation_request_schema = _DispersionCalculationRequestSchema()

        request_json = dispersion_calculation_request_schema.dumps(dispersion_calculation_request)
        url = get_analytics_api_target() + 'calculatedispersion?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            dispersion_calculation_response_schema = _DispersionCalculationResponseSchema()
            dispersion_calculation_response = dispersion_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(dispersion_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.scalar_udm_outputs = dispersion_calculation_response.scalar_udm_outputs
                self.dispersion_records = dispersion_calculation_response.dispersion_records
                self.pool_records = dispersion_calculation_response.pool_records
                self.result_code = dispersion_calculation_response.result_code
                self.messages = dispersion_calculation_response.messages
                self.calculation_elapsed_time = dispersion_calculation_response.calculation_elapsed_time
                self.operation_id = dispersion_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(dispersion_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DispersionCalculation object"""

        parts = ['* Dispersion']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'discharge_record_count:	{str(self.discharge_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append(f'end_point_concentration:	{str(self.end_point_concentration)}')
        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.extend(['pool_records_element' for pool_records_element in self.pool_records] if self.pool_records else [f'pool_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DispersionCalculationResponseSchema(Schema):
    """Schema for the DispersionCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    pool_records = fields.Nested(PoolRecordSchema, allow_none=True, many=True, data_key="poolRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_dispersion_calculation_response(self, data, **kwargs):
        """Post-processing of the DispersionCalculationResponseSchema class."""

        return _DispersionCalculationResponse(**data)

class _DispersionCalculationResponse(_CalculationResponseBase):
    """
    _DispersionCalculationResponse class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        pool_records : list[PoolRecord]
              an array of pool records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, dispersion_records: list[DispersionRecord], pool_records: list[PoolRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DispersionCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.scalar_udm_outputs = scalar_udm_outputs
        self.dispersion_records = dispersion_records
        self.pool_records = pool_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DistancesAndEllipsesToRadiationLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesAndEllipsesToRadiationLevelsCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
             Array of flammable output configs.
        flammable_output_config_count : int
             Number of radiation levels.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _DistancesAndEllipsesToRadiationLevelsCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

class _DistancesAndEllipsesToRadiationLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevels calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_distances_and_ellipses_to_radiation_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsCalculationRequestSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsCalculationRequest(**data)

class DistancesAndEllipsesToRadiationLevelsCalculation(_CalculationBase):
    """
    DistancesAndEllipsesToRadiationLevelsCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
             Array of flammable output configs.
        flammable_output_config_count : int
             Number of radiation levels.

    Calculation outputs:
        distances : list[float]
              an array of distances to radiation levels, corresponding to the flammable output configs.
        contour_points : list[LocalPosition]
             Contour points of radiation ellipses to radiation levels.
        n_contour_points : list[int]
              an array of the number of contour points, corresponding to the flammable output configs.
        areas : list[float]
              an array of areas of the ellipses to radiation levels, corresponding to the flammable output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.distances = None
        self.contour_points = None
        self.n_contour_points = None
        self.areas = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DistancesAndEllipsesToRadiationLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesAndEllipsesToRadiationLevelsCalculationRequest object.
        distances_and_ellipses_to_radiation_levels_calculation_request = _DistancesAndEllipsesToRadiationLevelsCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the _DistancesAndEllipsesToRadiationLevelsCalculationRequestSchema and use that to serialize to json.
        distances_and_ellipses_to_radiation_levels_calculation_request_schema = _DistancesAndEllipsesToRadiationLevelsCalculationRequestSchema()

        request_json = distances_and_ellipses_to_radiation_levels_calculation_request_schema.dumps(distances_and_ellipses_to_radiation_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancesandellipsestoradiationlevels?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            distances_and_ellipses_to_radiation_levels_calculation_response_schema = _DistancesAndEllipsesToRadiationLevelsCalculationResponseSchema()
            distances_and_ellipses_to_radiation_levels_calculation_response = distances_and_ellipses_to_radiation_levels_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(distances_and_ellipses_to_radiation_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances = distances_and_ellipses_to_radiation_levels_calculation_response.distances
                self.contour_points = distances_and_ellipses_to_radiation_levels_calculation_response.contour_points
                self.n_contour_points = distances_and_ellipses_to_radiation_levels_calculation_response.n_contour_points
                self.areas = distances_and_ellipses_to_radiation_levels_calculation_response.areas
                self.result_code = distances_and_ellipses_to_radiation_levels_calculation_response.result_code
                self.messages = distances_and_ellipses_to_radiation_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_and_ellipses_to_radiation_levels_calculation_response.calculation_elapsed_time
                self.operation_id = distances_and_ellipses_to_radiation_levels_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(distances_and_ellipses_to_radiation_levels_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesAndEllipsesToRadiationLevelsCalculation object"""

        parts = ['* DistancesAndEllipsesToRadiationLevels']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.extend(['n_contour_points_element' for n_contour_points_element in self.n_contour_points] if self.n_contour_points else [f'n_contour_points does not contain any elements'])
        parts.extend(['areas_element' for areas_element in self.areas] if self.areas else [f'areas does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DistancesAndEllipsesToRadiationLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevelsCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances = fields.List(fields.Float(), allow_none=True, data_key="distances")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    n_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nContourPoints")
    areas = fields.List(fields.Float(), allow_none=True, data_key="areas")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_distances_and_ellipses_to_radiation_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsCalculationResponseSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsCalculationResponse(**data)

class _DistancesAndEllipsesToRadiationLevelsCalculationResponse(_CalculationResponseBase):
    """
    _DistancesAndEllipsesToRadiationLevelsCalculationResponse class.

    Attributes
    ----------
        distances : list[float]
              an array of distances to radiation levels, corresponding to the flammable output configs.
        contour_points : list[LocalPosition]
             Contour points of radiation ellipses to radiation levels.
        n_contour_points : list[int]
              an array of the number of contour points, corresponding to the flammable output configs.
        areas : list[float]
              an array of areas of the ellipses to radiation levels, corresponding to the flammable output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, distances: list[float], contour_points: list[LocalPosition], n_contour_points: list[int], areas: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.distances = distances
        self.contour_points = contour_points
        self.n_contour_points = n_contour_points
        self.areas = areas
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest class.

    Attributes
    ----------
        pool_fire_flame_result : PoolFireFlameResult
             Scalar pool fire flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs.
        flammable_output_config_count : int
             Number of radiation levels.

    """
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest class"""

        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevelsForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequestSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest(**data)

class DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation(_CalculationBase):
    """
    DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation class.

    Attributes
    ----------
    Calculation inputs:
        pool_fire_flame_result : PoolFireFlameResult
             Scalar pool fire flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs.
        flammable_output_config_count : int
             Number of radiation levels.

    Calculation outputs:
        distances : list[float]
              an array of distances to radiation levels, corresponding to the flammable output configs.
        contour_points : list[LocalPosition]
             Contour points of radiation ellipses to radiation levels.
        n_contour_points : list[int]
              an array of the number of contour points, corresponding to the flammable output configs.
        areas : list[float]
              an array of areas of the ellipses to radiation levels, responding to the flammable output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.distances = None
        self.contour_points = None
        self.n_contour_points = None
        self.areas = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest object.
        distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request = _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequestSchema and use that to serialize to json.
        distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request_schema = _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationRequestSchema()

        request_json = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request_schema.dumps(distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancesandellipsestoradiationlevelsforpoolfires?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response_schema = _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponseSchema()
            distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.distances
                self.contour_points = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.contour_points
                self.n_contour_points = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.n_contour_points
                self.areas = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.areas
                self.result_code = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.result_code
                self.messages = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.calculation_elapsed_time
                self.operation_id = distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculation object"""

        parts = ['* DistancesAndEllipsesToRadiationLevelsForPoolFires']

        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.extend(['n_contour_points_element' for n_contour_points_element in self.n_contour_points] if self.n_contour_points else [f'n_contour_points does not contain any elements'])
        parts.extend(['areas_element' for areas_element in self.areas] if self.areas else [f'areas does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances = fields.List(fields.Float(), allow_none=True, data_key="distances")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    n_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nContourPoints")
    areas = fields.List(fields.Float(), allow_none=True, data_key="areas")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_distances_and_ellipses_to_radiation_levels_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponseSchema class."""

        return _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse(**data)

class _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    _DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse class.

    Attributes
    ----------
        distances : list[float]
              an array of distances to radiation levels, corresponding to the flammable output configs.
        contour_points : list[LocalPosition]
             Contour points of radiation ellipses to radiation levels.
        n_contour_points : list[int]
              an array of the number of contour points, corresponding to the flammable output configs.
        areas : list[float]
              an array of areas of the ellipses to radiation levels, responding to the flammable output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, distances: list[float], contour_points: list[LocalPosition], n_contour_points: list[int], areas: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DistancesAndEllipsesToRadiationLevelsForPoolFiresCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.distances = distances
        self.contour_points = contour_points
        self.n_contour_points = n_contour_points
        self.areas = areas
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DistancesAndFootprintsToConcentrationLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesAndFootprintsToConcentrationLevelsCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs.
        dispersion_output_config_count : int
             Number of dispersion output configs.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        material : Material
              a material entity with post-discharge composition.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, dispersion_parameters: DispersionParameters, material: Material):
        """Initializes a new instance of the _DistancesAndFootprintsToConcentrationLevelsCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.dispersion_parameters = dispersion_parameters
        self.material = material

class _DistancesAndFootprintsToConcentrationLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesAndFootprintsToConcentrationLevels calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionOutputConfigs")
    dispersion_output_config_count = fields.Int(data_key="dispersionOutputConfigCount")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    material = fields.Nested(MaterialSchema, data_key="material")

    @post_load
    def make_distances_and_footprints_to_concentration_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesAndFootprintsToConcentrationLevelsCalculationRequestSchema class."""

        return _DistancesAndFootprintsToConcentrationLevelsCalculationRequest(**data)

class DistancesAndFootprintsToConcentrationLevelsCalculation(_CalculationBase):
    """
    DistancesAndFootprintsToConcentrationLevelsCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs.
        dispersion_output_config_count : int
             Number of dispersion output configs.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        material : Material
              a material entity with post-discharge composition.

    Calculation outputs:
        concs_used : list[float]
              an array of concentrations of interest, corresponding to the dispersion output configs.
        n_contour_points : list[int]
              an array of the number of contour points, corresponding to the dispersion output configs.
        areas_contour : list[float]
              an array of areas of footprint contours, corresponding to the dispersion output configs.
        distances_concentration : list[float]
              an array of the maximum distances downwind, corresponding to the dispersion output configs.
        contour_points : list[LocalPosition]
             Contour points of maximum footprints to concentration level.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, dispersion_parameters: DispersionParameters, material: Material):
        """Initializes a new instance of the DistancesAndFootprintsToConcentrationLevelsCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.dispersion_parameters = dispersion_parameters
        self.material = material

        # Calculation outputs.
        self.concs_used = None
        self.n_contour_points = None
        self.areas_contour = None
        self.distances_concentration = None
        self.contour_points = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DistancesAndFootprintsToConcentrationLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesAndFootprintsToConcentrationLevelsCalculationRequest object.
        distances_and_footprints_to_concentration_levels_calculation_request = _DistancesAndFootprintsToConcentrationLevelsCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_configs, self.dispersion_output_config_count, self.dispersion_parameters, self.material)

        # Get the _DistancesAndFootprintsToConcentrationLevelsCalculationRequestSchema and use that to serialize to json.
        distances_and_footprints_to_concentration_levels_calculation_request_schema = _DistancesAndFootprintsToConcentrationLevelsCalculationRequestSchema()

        request_json = distances_and_footprints_to_concentration_levels_calculation_request_schema.dumps(distances_and_footprints_to_concentration_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancesandfootprintstoconcentrationlevels?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            distances_and_footprints_to_concentration_levels_calculation_response_schema = _DistancesAndFootprintsToConcentrationLevelsCalculationResponseSchema()
            distances_and_footprints_to_concentration_levels_calculation_response = distances_and_footprints_to_concentration_levels_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(distances_and_footprints_to_concentration_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.concs_used = distances_and_footprints_to_concentration_levels_calculation_response.concs_used
                self.n_contour_points = distances_and_footprints_to_concentration_levels_calculation_response.n_contour_points
                self.areas_contour = distances_and_footprints_to_concentration_levels_calculation_response.areas_contour
                self.distances_concentration = distances_and_footprints_to_concentration_levels_calculation_response.distances_concentration
                self.contour_points = distances_and_footprints_to_concentration_levels_calculation_response.contour_points
                self.result_code = distances_and_footprints_to_concentration_levels_calculation_response.result_code
                self.messages = distances_and_footprints_to_concentration_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_and_footprints_to_concentration_levels_calculation_response.calculation_elapsed_time
                self.operation_id = distances_and_footprints_to_concentration_levels_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(distances_and_footprints_to_concentration_levels_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesAndFootprintsToConcentrationLevelsCalculation object"""

        parts = ['* DistancesAndFootprintsToConcentrationLevels']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.extend(['dispersion_output_configs_element' for dispersion_output_configs_element in self.dispersion_output_configs] if self.dispersion_output_configs else [f'dispersion_output_configs does not contain any elements'])
        parts.append(f'dispersion_output_config_count:	{str(self.dispersion_output_config_count)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.extend(['concs_used_element' for concs_used_element in self.concs_used] if self.concs_used else [f'concs_used does not contain any elements'])
        parts.extend(['n_contour_points_element' for n_contour_points_element in self.n_contour_points] if self.n_contour_points else [f'n_contour_points does not contain any elements'])
        parts.extend(['areas_contour_element' for areas_contour_element in self.areas_contour] if self.areas_contour else [f'areas_contour does not contain any elements'])
        parts.extend(['distances_concentration_element' for distances_concentration_element in self.distances_concentration] if self.distances_concentration else [f'distances_concentration does not contain any elements'])
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DistancesAndFootprintsToConcentrationLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesAndFootprintsToConcentrationLevelsCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    concs_used = fields.List(fields.Float(), allow_none=True, data_key="concsUsed")
    n_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nContourPoints")
    areas_contour = fields.List(fields.Float(), allow_none=True, data_key="areasContour")
    distances_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesConcentration")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_distances_and_footprints_to_concentration_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesAndFootprintsToConcentrationLevelsCalculationResponseSchema class."""

        return _DistancesAndFootprintsToConcentrationLevelsCalculationResponse(**data)

class _DistancesAndFootprintsToConcentrationLevelsCalculationResponse(_CalculationResponseBase):
    """
    _DistancesAndFootprintsToConcentrationLevelsCalculationResponse class.

    Attributes
    ----------
        concs_used : list[float]
              an array of concentrations of interest, corresponding to the dispersion output configs.
        n_contour_points : list[int]
              an array of the number of contour points, corresponding to the dispersion output configs.
        areas_contour : list[float]
              an array of areas of footprint contours, corresponding to the dispersion output configs.
        distances_concentration : list[float]
              an array of the maximum distances downwind, corresponding to the dispersion output configs.
        contour_points : list[LocalPosition]
             Contour points of maximum footprints to concentration level.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, concs_used: list[float], n_contour_points: list[int], areas_contour: list[float], distances_concentration: list[float], contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DistancesAndFootprintsToConcentrationLevelsCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.concs_used = concs_used
        self.n_contour_points = n_contour_points
        self.areas_contour = areas_contour
        self.distances_concentration = distances_concentration
        self.contour_points = contour_points
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DistancesToConcLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesToConcLevelsCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs.
        dispersion_output_config_count : int
             Number of dispersion output configs.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _DistancesToConcLevelsCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.material = material
        self.dispersion_parameters = dispersion_parameters

class _DistancesToConcLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesToConcLevels calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionOutputConfigs")
    dispersion_output_config_count = fields.Int(data_key="dispersionOutputConfigCount")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_distances_to_conc_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesToConcLevelsCalculationRequestSchema class."""

        return _DistancesToConcLevelsCalculationRequest(**data)

class DistancesToConcLevelsCalculation(_CalculationBase):
    """
    DistancesToConcLevelsCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs.
        dispersion_output_config_count : int
             Number of dispersion output configs.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        conc_used : list[float]
              an array of concentrations of interest, corresponding to the dispersion output configs.
        distances : list[float]
              an array of the distances to concentration of interest, corresponding to the dispersion output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_configs: list[DispersionOutputConfig], dispersion_output_config_count: int, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the DistancesToConcLevelsCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_configs = dispersion_output_configs
        self.dispersion_output_config_count = dispersion_output_config_count
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.distances = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DistancesToConcLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesToConcLevelsCalculationRequest object.
        distances_to_conc_levels_calculation_request = _DistancesToConcLevelsCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_configs, self.dispersion_output_config_count, self.material, self.dispersion_parameters)

        # Get the _DistancesToConcLevelsCalculationRequestSchema and use that to serialize to json.
        distances_to_conc_levels_calculation_request_schema = _DistancesToConcLevelsCalculationRequestSchema()

        request_json = distances_to_conc_levels_calculation_request_schema.dumps(distances_to_conc_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancestoconclevels?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            distances_to_conc_levels_calculation_response_schema = _DistancesToConcLevelsCalculationResponseSchema()
            distances_to_conc_levels_calculation_response = distances_to_conc_levels_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(distances_to_conc_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = distances_to_conc_levels_calculation_response.conc_used
                self.distances = distances_to_conc_levels_calculation_response.distances
                self.result_code = distances_to_conc_levels_calculation_response.result_code
                self.messages = distances_to_conc_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_to_conc_levels_calculation_response.calculation_elapsed_time
                self.operation_id = distances_to_conc_levels_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(distances_to_conc_levels_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesToConcLevelsCalculation object"""

        parts = ['* DistancesToConcLevels']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.extend(['dispersion_output_configs_element' for dispersion_output_configs_element in self.dispersion_output_configs] if self.dispersion_output_configs else [f'dispersion_output_configs does not contain any elements'])
        parts.append(f'dispersion_output_config_count:	{str(self.dispersion_output_config_count)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.extend(['conc_used_element' for conc_used_element in self.conc_used] if self.conc_used else [f'conc_used does not contain any elements'])
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DistancesToConcLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesToConcLevelsCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.List(fields.Float(), allow_none=True, data_key="concUsed")
    distances = fields.List(fields.Float(), allow_none=True, data_key="distances")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_distances_to_conc_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesToConcLevelsCalculationResponseSchema class."""

        return _DistancesToConcLevelsCalculationResponse(**data)

class _DistancesToConcLevelsCalculationResponse(_CalculationResponseBase):
    """
    _DistancesToConcLevelsCalculationResponse class.

    Attributes
    ----------
        conc_used : list[float]
              an array of concentrations of interest, corresponding to the dispersion output configs.
        distances : list[float]
              an array of the distances to concentration of interest, corresponding to the dispersion output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, conc_used: list[float], distances: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DistancesToConcLevelsCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.conc_used = conc_used
        self.distances = distances
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DistancesToRadiationLevelsCalculationRequest(_CalculationRequestBase):
    """
    _DistancesToRadiationLevelsCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs.
        flammable_output_config_count : int
             Number of flammable output configs.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _DistancesToRadiationLevelsCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

class _DistancesToRadiationLevelsCalculationRequestSchema(Schema):
    """Schema for the DistancesToRadiationLevels calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_distances_to_radiation_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the DistancesToRadiationLevelsCalculationRequestSchema class."""

        return _DistancesToRadiationLevelsCalculationRequest(**data)

class DistancesToRadiationLevelsCalculation(_CalculationBase):
    """
    DistancesToRadiationLevelsCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs.
        flammable_output_config_count : int
             Number of flammable output configs.

    Calculation outputs:
        distances : list[float]
              an array of distances to radiation levels, corresponding to the flammable output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the DistancesToRadiationLevelsCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.distances = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DistancesToRadiationLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistancesToRadiationLevelsCalculationRequest object.
        distances_to_radiation_levels_calculation_request = _DistancesToRadiationLevelsCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the _DistancesToRadiationLevelsCalculationRequestSchema and use that to serialize to json.
        distances_to_radiation_levels_calculation_request_schema = _DistancesToRadiationLevelsCalculationRequestSchema()

        request_json = distances_to_radiation_levels_calculation_request_schema.dumps(distances_to_radiation_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancestoradiationlevels?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            distances_to_radiation_levels_calculation_response_schema = _DistancesToRadiationLevelsCalculationResponseSchema()
            distances_to_radiation_levels_calculation_response = distances_to_radiation_levels_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(distances_to_radiation_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances = distances_to_radiation_levels_calculation_response.distances
                self.result_code = distances_to_radiation_levels_calculation_response.result_code
                self.messages = distances_to_radiation_levels_calculation_response.messages
                self.calculation_elapsed_time = distances_to_radiation_levels_calculation_response.calculation_elapsed_time
                self.operation_id = distances_to_radiation_levels_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(distances_to_radiation_levels_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DistancesToRadiationLevelsCalculation object"""

        parts = ['* DistancesToRadiationLevels']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['distances_element' for distances_element in self.distances] if self.distances else [f'distances does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DistancesToRadiationLevelsCalculationResponseSchema(Schema):
    """Schema for the DistancesToRadiationLevelsCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances = fields.List(fields.Float(), allow_none=True, data_key="distances")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_distances_to_radiation_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the DistancesToRadiationLevelsCalculationResponseSchema class."""

        return _DistancesToRadiationLevelsCalculationResponse(**data)

class _DistancesToRadiationLevelsCalculationResponse(_CalculationResponseBase):
    """
    _DistancesToRadiationLevelsCalculationResponse class.

    Attributes
    ----------
        distances : list[float]
              an array of distances to radiation levels, corresponding to the flammable output configs.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, distances: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DistancesToRadiationLevelsCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.distances = distances
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _DistanceToRadiationCalculationRequest(_CalculationRequestBase):
    """
    _DistanceToRadiationCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _DistanceToRadiationCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

class _DistanceToRadiationCalculationRequestSchema(Schema):
    """Schema for the DistanceToRadiation calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_distance_to_radiation_calculation_request(self, data, **kwargs):
        """Post-processing of the DistanceToRadiationCalculationRequestSchema class."""

        return _DistanceToRadiationCalculationRequest(**data)

class DistanceToRadiationCalculation(_CalculationBase):
    """
    DistanceToRadiationCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    Calculation outputs:
        distance : float
             Distance to radiation level.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the DistanceToRadiationCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.distance = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        DistanceToRadiationCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _DistanceToRadiationCalculationRequest object.
        distance_to_radiation_calculation_request = _DistanceToRadiationCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the _DistanceToRadiationCalculationRequestSchema and use that to serialize to json.
        distance_to_radiation_calculation_request_schema = _DistanceToRadiationCalculationRequestSchema()

        request_json = distance_to_radiation_calculation_request_schema.dumps(distance_to_radiation_calculation_request)
        url = get_analytics_api_target() + 'calculatedistancetoradiation?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            distance_to_radiation_calculation_response_schema = _DistanceToRadiationCalculationResponseSchema()
            distance_to_radiation_calculation_response = distance_to_radiation_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(distance_to_radiation_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distance = distance_to_radiation_calculation_response.distance
                self.result_code = distance_to_radiation_calculation_response.result_code
                self.messages = distance_to_radiation_calculation_response.messages
                self.calculation_elapsed_time = distance_to_radiation_calculation_response.calculation_elapsed_time
                self.operation_id = distance_to_radiation_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(distance_to_radiation_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the DistanceToRadiationCalculation object"""

        parts = ['* DistanceToRadiation']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlammableOutputConfig')
        parts.append(f'flammable_output_config:	{str(self.flammable_output_config)}')
        parts.append(f'distance:	{str(self.distance)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _DistanceToRadiationCalculationResponseSchema(Schema):
    """Schema for the DistanceToRadiationCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distance = fields.Float(data_key="distance")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_distance_to_radiation_calculation_response(self, data, **kwargs):
        """Post-processing of the DistanceToRadiationCalculationResponseSchema class."""

        return _DistanceToRadiationCalculationResponse(**data)

class _DistanceToRadiationCalculationResponse(_CalculationResponseBase):
    """
    _DistanceToRadiationCalculationResponse class.

    Attributes
    ----------
        distance : float
             Distance to radiation level.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, distance: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the DistanceToRadiationCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.distance = distance
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _FireballCalculationRequest(_CalculationRequestBase):
    """
    _FireballCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        state : State
              a state entity.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        discharge_record_count : int
             Number of discharge records.
        discharge_result : DischargeResult
             Discharge / source term definition.
        weather : Weather
              a weather entity.

    """
    def __init__(self, material: Material, state: State, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather):
        """Initializes a new instance of the _FireballCalculationRequest class"""

        super().__init__()

        self.material = material
        self.state = state
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather

class _FireballCalculationRequestSchema(Schema):
    """Schema for the Fireball calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    state = fields.Nested(StateSchema, data_key="state")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    weather = fields.Nested(WeatherSchema, data_key="weather")

    @post_load
    def make_fireball_calculation_request(self, data, **kwargs):
        """Post-processing of the FireballCalculationRequestSchema class."""

        return _FireballCalculationRequest(**data)

class FireballCalculation(_CalculationBase):
    """
    FireballCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        state : State
              a state entity.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        discharge_record_count : int
             Number of discharge records.
        discharge_result : DischargeResult
             Discharge / source term definition.
        weather : Weather
              a weather entity.

    Calculation outputs:
        flame_result : FlameResult
             Flame scalar result.
        flame_records : list[FlameRecord]
              an array of fireball flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, state: State, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather):
        """Initializes a new instance of the FireballCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.state = state
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather

        # Calculation outputs.
        self.flame_result = None
        self.flame_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        FireballCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _FireballCalculationRequest object.
        fireball_calculation_request = _FireballCalculationRequest(self.material, self.state, self.discharge_records, self.discharge_record_count, self.discharge_result, self.weather)

        # Get the _FireballCalculationRequestSchema and use that to serialize to json.
        fireball_calculation_request_schema = _FireballCalculationRequestSchema()

        request_json = fireball_calculation_request_schema.dumps(fireball_calculation_request)
        url = get_analytics_api_target() + 'calculatefireball?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            fireball_calculation_response_schema = _FireballCalculationResponseSchema()
            fireball_calculation_response = fireball_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(fireball_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.flame_result = fireball_calculation_response.flame_result
                self.flame_records = fireball_calculation_response.flame_records
                self.result_code = fireball_calculation_response.result_code
                self.messages = fireball_calculation_response.messages
                self.calculation_elapsed_time = fireball_calculation_response.calculation_elapsed_time
                self.operation_id = fireball_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(fireball_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the FireballCalculation object"""

        parts = ['* Fireball']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* State')
        parts.append(f'state:	{str(self.state)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'discharge_record_count:	{str(self.discharge_record_count)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _FireballCalculationResponseSchema(Schema):
    """Schema for the FireballCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_fireball_calculation_response(self, data, **kwargs):
        """Post-processing of the FireballCalculationResponseSchema class."""

        return _FireballCalculationResponse(**data)

class _FireballCalculationResponse(_CalculationResponseBase):
    """
    _FireballCalculationResponse class.

    Attributes
    ----------
        flame_result : FlameResult
             Flame scalar result.
        flame_records : list[FlameRecord]
              an array of fireball flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the FireballCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _FlashCalculationRequest(_CalculationRequestBase):
    """
    _FlashCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity.
        material_state : State
              a state entity.

    """
    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the _FlashCalculationRequest class"""

        super().__init__()

        self.material = material
        self.material_state = material_state

class _FlashCalculationRequestSchema(Schema):
    """Schema for the Flash calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    material_state = fields.Nested(StateSchema, data_key="materialState")

    @post_load
    def make_flash_calculation_request(self, data, **kwargs):
        """Post-processing of the FlashCalculationRequestSchema class."""

        return _FlashCalculationRequest(**data)

class FlashCalculation(_CalculationBase):
    """
    FlashCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity.
        material_state : State
              a state entity.

    Calculation outputs:
        flash_result : FlashResult
             Fluid properties at given conditions.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the FlashCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.material_state = material_state

        # Calculation outputs.
        self.flash_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        FlashCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _FlashCalculationRequest object.
        flash_calculation_request = _FlashCalculationRequest(self.material, self.material_state)

        # Get the _FlashCalculationRequestSchema and use that to serialize to json.
        flash_calculation_request_schema = _FlashCalculationRequestSchema()

        request_json = flash_calculation_request_schema.dumps(flash_calculation_request)
        url = get_analytics_api_target() + 'calculateflash?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            flash_calculation_response_schema = _FlashCalculationResponseSchema()
            flash_calculation_response = flash_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(flash_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.flash_result = flash_calculation_response.flash_result
                self.result_code = flash_calculation_response.result_code
                self.messages = flash_calculation_response.messages
                self.calculation_elapsed_time = flash_calculation_response.calculation_elapsed_time
                self.operation_id = flash_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(flash_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the FlashCalculation object"""

        parts = ['* Flash']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* State')
        parts.append(f'material_state:	{str(self.material_state)}')
        parts.append('* FlashResult')
        parts.append(f'flash_result:	{str(self.flash_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _FlashCalculationResponseSchema(Schema):
    """Schema for the FlashCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flash_result = fields.Nested(FlashResultSchema, data_key="flashResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_flash_calculation_response(self, data, **kwargs):
        """Post-processing of the FlashCalculationResponseSchema class."""

        return _FlashCalculationResponse(**data)

class _FlashCalculationResponse(_CalculationResponseBase):
    """
    _FlashCalculationResponse class.

    Attributes
    ----------
        flash_result : FlashResult
             Fluid properties at given conditions.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, flash_result: FlashResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the FlashCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.flash_result = flash_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _GetMassFromVesselCalculationRequest(_CalculationRequestBase):
    """
    _GetMassFromVesselCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.

    """
    def __init__(self, vessel: Vessel):
        """Initializes a new instance of the _GetMassFromVesselCalculationRequest class"""

        super().__init__()

        self.vessel = vessel

class _GetMassFromVesselCalculationRequestSchema(Schema):
    """Schema for the GetMassFromVessel calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_get_mass_from_vessel_calculation_request(self, data, **kwargs):
        """Post-processing of the GetMassFromVesselCalculationRequestSchema class."""

        return _GetMassFromVesselCalculationRequest(**data)

class GetMassFromVesselCalculation(_CalculationBase):
    """
    GetMassFromVesselCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.

    Calculation outputs:
        mass_inventory : float
             Mass inventory in the vessel (kg).
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel):
        """Initializes a new instance of the GetMassFromVesselCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel

        # Calculation outputs.
        self.mass_inventory = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        GetMassFromVesselCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _GetMassFromVesselCalculationRequest object.
        get_mass_from_vessel_calculation_request = _GetMassFromVesselCalculationRequest(self.vessel)

        # Get the _GetMassFromVesselCalculationRequestSchema and use that to serialize to json.
        get_mass_from_vessel_calculation_request_schema = _GetMassFromVesselCalculationRequestSchema()

        request_json = get_mass_from_vessel_calculation_request_schema.dumps(get_mass_from_vessel_calculation_request)
        url = get_analytics_api_target() + 'utilities/getmassfromvessel?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            get_mass_from_vessel_calculation_response_schema = _GetMassFromVesselCalculationResponseSchema()
            get_mass_from_vessel_calculation_response = get_mass_from_vessel_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(get_mass_from_vessel_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.mass_inventory = get_mass_from_vessel_calculation_response.mass_inventory
                self.result_code = get_mass_from_vessel_calculation_response.result_code
                self.messages = get_mass_from_vessel_calculation_response.messages
                self.calculation_elapsed_time = get_mass_from_vessel_calculation_response.calculation_elapsed_time
                self.operation_id = get_mass_from_vessel_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(get_mass_from_vessel_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the GetMassFromVesselCalculation object"""

        parts = ['* GetMassFromVessel']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append(f'mass_inventory:	{str(self.mass_inventory)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _GetMassFromVesselCalculationResponseSchema(Schema):
    """Schema for the GetMassFromVesselCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mass_inventory = fields.Float(data_key="massInventory")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_get_mass_from_vessel_calculation_response(self, data, **kwargs):
        """Post-processing of the GetMassFromVesselCalculationResponseSchema class."""

        return _GetMassFromVesselCalculationResponse(**data)

class _GetMassFromVesselCalculationResponse(_CalculationResponseBase):
    """
    _GetMassFromVesselCalculationResponse class.

    Attributes
    ----------
        mass_inventory : float
             Mass inventory in the vessel (kg).
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, mass_inventory: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the GetMassFromVesselCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.mass_inventory = mass_inventory
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _JetFireCalculationRequest(_CalculationRequestBase):
    """
    _JetFireCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        discharge_records : list[DischargeRecord]
             Discharge / source term definition.
        discharge_record_count : int
             Number of discharge records.
        discharge_result : DischargeResult
             Discharge / source term definition.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.

    """
    def __init__(self, material: Material, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _JetFireCalculationRequest class"""

        super().__init__()

        self.material = material
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

class _JetFireCalculationRequestSchema(Schema):
    """Schema for the JetFire calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_jet_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the JetFireCalculationRequestSchema class."""

        return _JetFireCalculationRequest(**data)

class JetFireCalculation(_CalculationBase):
    """
    JetFireCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        discharge_records : list[DischargeRecord]
             Discharge / source term definition.
        discharge_record_count : int
             Number of discharge records.
        discharge_result : DischargeResult
             Discharge / source term definition.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.

    Calculation outputs:
        flame_result : FlameResult
             Flame scalar results.
        flame_records : list[FlameRecord]
              an array of jet fire flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, discharge_records: list[DischargeRecord], discharge_record_count: int, discharge_result: DischargeResult, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the JetFireCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.discharge_result = discharge_result
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.flame_result = None
        self.flame_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        JetFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _JetFireCalculationRequest object.
        jet_fire_calculation_request = _JetFireCalculationRequest(self.material, self.discharge_records, self.discharge_record_count, self.discharge_result, self.weather, self.substrate, self.flammable_parameters)

        # Get the _JetFireCalculationRequestSchema and use that to serialize to json.
        jet_fire_calculation_request_schema = _JetFireCalculationRequestSchema()

        request_json = jet_fire_calculation_request_schema.dumps(jet_fire_calculation_request)
        url = get_analytics_api_target() + 'calculatejetfire?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            jet_fire_calculation_response_schema = _JetFireCalculationResponseSchema()
            jet_fire_calculation_response = jet_fire_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(jet_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.flame_result = jet_fire_calculation_response.flame_result
                self.flame_records = jet_fire_calculation_response.flame_records
                self.result_code = jet_fire_calculation_response.result_code
                self.messages = jet_fire_calculation_response.messages
                self.calculation_elapsed_time = jet_fire_calculation_response.calculation_elapsed_time
                self.operation_id = jet_fire_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(jet_fire_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the JetFireCalculation object"""

        parts = ['* JetFire']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'discharge_record_count:	{str(self.discharge_record_count)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _JetFireCalculationResponseSchema(Schema):
    """Schema for the JetFireCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_jet_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the JetFireCalculationResponseSchema class."""

        return _JetFireCalculationResponse(**data)

class _JetFireCalculationResponse(_CalculationResponseBase):
    """
    _JetFireCalculationResponse class.

    Attributes
    ----------
        flame_result : FlameResult
             Flame scalar results.
        flame_records : list[FlameRecord]
              an array of jet fire flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the JetFireCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LateExplosionCalculationRequest(_CalculationRequestBase):
    """
    _LateExplosionCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config.
        explosion_output_config : ExplosionOutputConfig
              an explosion output config.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_config: ExplosionOutputConfig, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _LateExplosionCalculationRequest class"""

        super().__init__()

        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_config = explosion_output_config
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters

class _LateExplosionCalculationRequestSchema(Schema):
    """Schema for the LateExplosion calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    explosion_output_config = fields.Nested(ExplosionOutputConfigSchema, data_key="explosionOutputConfig")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_late_explosion_calculation_request(self, data, **kwargs):
        """Post-processing of the LateExplosionCalculationRequestSchema class."""

        return _LateExplosionCalculationRequest(**data)

class LateExplosionCalculation(_CalculationBase):
    """
    LateExplosionCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config.
        explosion_output_config : ExplosionOutputConfig
              an explosion output config.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        explosion_unif_conf_overpressure_result : ExplosionOverpressureResult
             Uniform confined explosion overpressure result.
        explosion_unconf_overpressure_result : ExplosionOverpressureResult
             Unconfined explosion overpressure result.
        result_code : ResultCode
             Eror code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_config: ExplosionOutputConfig, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the LateExplosionCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_config = explosion_output_config
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.explosion_unif_conf_overpressure_result = None
        self.explosion_unconf_overpressure_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LateExplosionCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LateExplosionCalculationRequest object.
        late_explosion_calculation_request = _LateExplosionCalculationRequest(self.material, self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.explosion_output_config, self.explosion_parameters, self.explosion_confined_volumes, self.explosion_confined_volume_count, self.dispersion_parameters)

        # Get the _LateExplosionCalculationRequestSchema and use that to serialize to json.
        late_explosion_calculation_request_schema = _LateExplosionCalculationRequestSchema()

        request_json = late_explosion_calculation_request_schema.dumps(late_explosion_calculation_request)
        url = get_analytics_api_target() + 'calculatelateexplosion?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            late_explosion_calculation_response_schema = _LateExplosionCalculationResponseSchema()
            late_explosion_calculation_response = late_explosion_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(late_explosion_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.explosion_unif_conf_overpressure_result = late_explosion_calculation_response.explosion_unif_conf_overpressure_result
                self.explosion_unconf_overpressure_result = late_explosion_calculation_response.explosion_unconf_overpressure_result
                self.result_code = late_explosion_calculation_response.result_code
                self.messages = late_explosion_calculation_response.messages
                self.calculation_elapsed_time = late_explosion_calculation_response.calculation_elapsed_time
                self.operation_id = late_explosion_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(late_explosion_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LateExplosionCalculation object"""

        parts = ['* LateExplosion']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* ExplosionOutputConfig')
        parts.append(f'explosion_output_config:	{str(self.explosion_output_config)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append('* ExplosionOverpressureResult')
        parts.append(f'explosion_unif_conf_overpressure_result:	{str(self.explosion_unif_conf_overpressure_result)}')
        parts.append('* ExplosionOverpressureResult')
        parts.append(f'explosion_unconf_overpressure_result:	{str(self.explosion_unconf_overpressure_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LateExplosionCalculationResponseSchema(Schema):
    """Schema for the LateExplosionCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    explosion_unif_conf_overpressure_result = fields.Nested(ExplosionOverpressureResultSchema, data_key="explosionUnifConfOverpressureResult")
    explosion_unconf_overpressure_result = fields.Nested(ExplosionOverpressureResultSchema, data_key="explosionUnconfOverpressureResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_late_explosion_calculation_response(self, data, **kwargs):
        """Post-processing of the LateExplosionCalculationResponseSchema class."""

        return _LateExplosionCalculationResponse(**data)

class _LateExplosionCalculationResponse(_CalculationResponseBase):
    """
    _LateExplosionCalculationResponse class.

    Attributes
    ----------
        explosion_unif_conf_overpressure_result : ExplosionOverpressureResult
             Uniform confined explosion overpressure result.
        explosion_unconf_overpressure_result : ExplosionOverpressureResult
             Unconfined explosion overpressure result.
        result_code : ResultCode
             Eror code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, explosion_unif_conf_overpressure_result: ExplosionOverpressureResult, explosion_unconf_overpressure_result: ExplosionOverpressureResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LateExplosionCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.explosion_unif_conf_overpressure_result = explosion_unif_conf_overpressure_result
        self.explosion_unconf_overpressure_result = explosion_unconf_overpressure_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LateExplosionToOPLevelsCalculationRequest(_CalculationRequestBase):
    """
    _LateExplosionToOPLevelsCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
             Cloud definition.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs.
        explosion_output_config_count : int
             Number of explosion output configs.
        explosion_parameters : ExplosionParameters
             Explosion parameters.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _LateExplosionToOPLevelsCalculationRequest class"""

        super().__init__()

        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters

class _LateExplosionToOPLevelsCalculationRequestSchema(Schema):
    """Schema for the LateExplosionToOPLevels calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_late_explosion_to_op_levels_calculation_request(self, data, **kwargs):
        """Post-processing of the LateExplosionToOPLevelsCalculationRequestSchema class."""

        return _LateExplosionToOPLevelsCalculationRequest(**data)

class LateExplosionToOPLevelsCalculation(_CalculationBase):
    """
    LateExplosionToOPLevelsCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
             Cloud definition.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs.
        explosion_output_config_count : int
             Number of explosion output configs.
        explosion_parameters : ExplosionParameters
             Explosion parameters.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        explosion_unif_conf_overpressure_results : list[ExplosionOverpressureResult]
              an array of uniform confined explosion overpressure results.
        explosion_unconf_overpressure_results : list[ExplosionOverpressureResult]
              an array of unconfined explosion overpressure results.
        result_code : ResultCode
             Eror code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_parameters: ExplosionParameters, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the LateExplosionToOPLevelsCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_parameters = explosion_parameters
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.explosion_unif_conf_overpressure_results = None
        self.explosion_unconf_overpressure_results = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LateExplosionToOPLevelsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LateExplosionToOPLevelsCalculationRequest object.
        late_explosion_to_op_levels_calculation_request = _LateExplosionToOPLevelsCalculationRequest(self.material, self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_parameters, self.explosion_confined_volumes, self.explosion_confined_volume_count, self.dispersion_parameters)

        # Get the _LateExplosionToOPLevelsCalculationRequestSchema and use that to serialize to json.
        late_explosion_to_op_levels_calculation_request_schema = _LateExplosionToOPLevelsCalculationRequestSchema()

        request_json = late_explosion_to_op_levels_calculation_request_schema.dumps(late_explosion_to_op_levels_calculation_request)
        url = get_analytics_api_target() + 'calculatelateexplosiontooplevels?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            late_explosion_to_op_levels_calculation_response_schema = _LateExplosionToOPLevelsCalculationResponseSchema()
            late_explosion_to_op_levels_calculation_response = late_explosion_to_op_levels_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(late_explosion_to_op_levels_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.explosion_unif_conf_overpressure_results = late_explosion_to_op_levels_calculation_response.explosion_unif_conf_overpressure_results
                self.explosion_unconf_overpressure_results = late_explosion_to_op_levels_calculation_response.explosion_unconf_overpressure_results
                self.result_code = late_explosion_to_op_levels_calculation_response.result_code
                self.messages = late_explosion_to_op_levels_calculation_response.messages
                self.calculation_elapsed_time = late_explosion_to_op_levels_calculation_response.calculation_elapsed_time
                self.operation_id = late_explosion_to_op_levels_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(late_explosion_to_op_levels_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LateExplosionToOPLevelsCalculation object"""

        parts = ['* LateExplosionToOPLevels']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.extend(['explosion_output_configs_element' for explosion_output_configs_element in self.explosion_output_configs] if self.explosion_output_configs else [f'explosion_output_configs does not contain any elements'])
        parts.append(f'explosion_output_config_count:	{str(self.explosion_output_config_count)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.extend(['explosion_unif_conf_overpressure_results_element' for explosion_unif_conf_overpressure_results_element in self.explosion_unif_conf_overpressure_results] if self.explosion_unif_conf_overpressure_results else [f'explosion_unif_conf_overpressure_results does not contain any elements'])
        parts.extend(['explosion_unconf_overpressure_results_element' for explosion_unconf_overpressure_results_element in self.explosion_unconf_overpressure_results] if self.explosion_unconf_overpressure_results else [f'explosion_unconf_overpressure_results does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LateExplosionToOPLevelsCalculationResponseSchema(Schema):
    """Schema for the LateExplosionToOPLevelsCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    explosion_unif_conf_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionUnifConfOverpressureResults")
    explosion_unconf_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionUnconfOverpressureResults")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_late_explosion_to_op_levels_calculation_response(self, data, **kwargs):
        """Post-processing of the LateExplosionToOPLevelsCalculationResponseSchema class."""

        return _LateExplosionToOPLevelsCalculationResponse(**data)

class _LateExplosionToOPLevelsCalculationResponse(_CalculationResponseBase):
    """
    _LateExplosionToOPLevelsCalculationResponse class.

    Attributes
    ----------
        explosion_unif_conf_overpressure_results : list[ExplosionOverpressureResult]
              an array of uniform confined explosion overpressure results.
        explosion_unconf_overpressure_results : list[ExplosionOverpressureResult]
              an array of unconfined explosion overpressure results.
        result_code : ResultCode
             Eror code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, explosion_unif_conf_overpressure_results: list[ExplosionOverpressureResult], explosion_unconf_overpressure_results: list[ExplosionOverpressureResult], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LateExplosionToOPLevelsCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.explosion_unif_conf_overpressure_results = explosion_unif_conf_overpressure_results
        self.explosion_unconf_overpressure_results = explosion_unconf_overpressure_results
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LethalityDistanceCalculationRequest(_CalculationRequestBase):
    """
    _LethalityDistanceCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _LethalityDistanceCalculationRequest class"""

        super().__init__()

        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.dispersion_parameters = dispersion_parameters

class _LethalityDistanceCalculationRequestSchema(Schema):
    """Schema for the LethalityDistance calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_lethality_distance_calculation_request(self, data, **kwargs):
        """Post-processing of the LethalityDistanceCalculationRequestSchema class."""

        return _LethalityDistanceCalculationRequest(**data)

class LethalityDistanceCalculation(_CalculationBase):
    """
    LethalityDistanceCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        toxic_records : list[ToxicRecord]
              an array of toxic records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the LethalityDistanceCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.toxic_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LethalityDistanceCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LethalityDistanceCalculationRequest object.
        lethality_distance_calculation_request = _LethalityDistanceCalculationRequest(self.material, self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.dispersion_parameters)

        # Get the _LethalityDistanceCalculationRequestSchema and use that to serialize to json.
        lethality_distance_calculation_request_schema = _LethalityDistanceCalculationRequestSchema()

        request_json = lethality_distance_calculation_request_schema.dumps(lethality_distance_calculation_request)
        url = get_analytics_api_target() + 'calculatelethalitydistance?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            lethality_distance_calculation_response_schema = _LethalityDistanceCalculationResponseSchema()
            lethality_distance_calculation_response = lethality_distance_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(lethality_distance_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.toxic_records = lethality_distance_calculation_response.toxic_records
                self.result_code = lethality_distance_calculation_response.result_code
                self.messages = lethality_distance_calculation_response.messages
                self.calculation_elapsed_time = lethality_distance_calculation_response.calculation_elapsed_time
                self.operation_id = lethality_distance_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(lethality_distance_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LethalityDistanceCalculation object"""

        parts = ['* LethalityDistance']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.extend(['toxic_records_element' for toxic_records_element in self.toxic_records] if self.toxic_records else [f'toxic_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LethalityDistanceCalculationResponseSchema(Schema):
    """Schema for the LethalityDistanceCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    toxic_records = fields.Nested(ToxicRecordSchema, allow_none=True, many=True, data_key="toxicRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_lethality_distance_calculation_response(self, data, **kwargs):
        """Post-processing of the LethalityDistanceCalculationResponseSchema class."""

        return _LethalityDistanceCalculationResponse(**data)

class _LethalityDistanceCalculationResponse(_CalculationResponseBase):
    """
    _LethalityDistanceCalculationResponse class.

    Attributes
    ----------
        toxic_records : list[ToxicRecord]
              an array of toxic records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, toxic_records: list[ToxicRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LethalityDistanceCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.toxic_records = toxic_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LoadMassInventoryVesselForLeakScenarioCalculationRequest(_CalculationRequestBase):
    """
    _LoadMassInventoryVesselForLeakScenarioCalculationRequest class.

    Attributes
    ----------
        material : Material
             Vessel material.
        mass : float
             Total vessel mass inventory.
        pressure : float
             Vessel pressure in absolute scale.
        temperature : float
             Vessel temperature.
        hole_size : float
             Leak hole size.
        release_elevation : float
             Release elevation.
        release_angle : float
             Release angle.

    """
    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, hole_size: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the _LoadMassInventoryVesselForLeakScenarioCalculationRequest class"""

        super().__init__()

        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.hole_size = hole_size
        self.release_elevation = release_elevation
        self.release_angle = release_angle

class _LoadMassInventoryVesselForLeakScenarioCalculationRequestSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLeakScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    mass = fields.Float(data_key="mass")
    pressure = fields.Float(data_key="pressure")
    temperature = fields.Float(data_key="temperature")
    hole_size = fields.Float(data_key="holeSize")
    release_elevation = fields.Float(data_key="releaseElevation")
    release_angle = fields.Float(data_key="releaseAngle")

    @post_load
    def make_load_mass_inventory_vessel_for_leak_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLeakScenarioCalculationRequestSchema class."""

        return _LoadMassInventoryVesselForLeakScenarioCalculationRequest(**data)

class LoadMassInventoryVesselForLeakScenarioCalculation(_CalculationBase):
    """
    LoadMassInventoryVesselForLeakScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
             Vessel material.
        mass : float
             Total vessel mass inventory.
        pressure : float
             Vessel pressure in absolute scale.
        temperature : float
             Vessel temperature.
        hole_size : float
             Leak hole size.
        release_elevation : float
             Release elevation.
        release_angle : float
             Release angle.

    Calculation outputs:
        vessel : Vessel
             Vessel definition.
        leak : Leak
             Leak scenario.
        volume : float
             Volume of the vessel.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, hole_size: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the LoadMassInventoryVesselForLeakScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.hole_size = hole_size
        self.release_elevation = release_elevation
        self.release_angle = release_angle

        # Calculation outputs.
        self.vessel = None
        self.leak = None
        self.volume = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LoadMassInventoryVesselForLeakScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LoadMassInventoryVesselForLeakScenarioCalculationRequest object.
        load_mass_inventory_vessel_for_leak_scenario_calculation_request = _LoadMassInventoryVesselForLeakScenarioCalculationRequest(self.material, self.mass, self.pressure, self.temperature, self.hole_size, self.release_elevation, self.release_angle)

        # Get the _LoadMassInventoryVesselForLeakScenarioCalculationRequestSchema and use that to serialize to json.
        load_mass_inventory_vessel_for_leak_scenario_calculation_request_schema = _LoadMassInventoryVesselForLeakScenarioCalculationRequestSchema()

        request_json = load_mass_inventory_vessel_for_leak_scenario_calculation_request_schema.dumps(load_mass_inventory_vessel_for_leak_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/loadmassinventoryvesselforleakscenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            load_mass_inventory_vessel_for_leak_scenario_calculation_response_schema = _LoadMassInventoryVesselForLeakScenarioCalculationResponseSchema()
            load_mass_inventory_vessel_for_leak_scenario_calculation_response = load_mass_inventory_vessel_for_leak_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(load_mass_inventory_vessel_for_leak_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel = load_mass_inventory_vessel_for_leak_scenario_calculation_response.vessel
                self.leak = load_mass_inventory_vessel_for_leak_scenario_calculation_response.leak
                self.volume = load_mass_inventory_vessel_for_leak_scenario_calculation_response.volume
                self.result_code = load_mass_inventory_vessel_for_leak_scenario_calculation_response.result_code
                self.messages = load_mass_inventory_vessel_for_leak_scenario_calculation_response.messages
                self.calculation_elapsed_time = load_mass_inventory_vessel_for_leak_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = load_mass_inventory_vessel_for_leak_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(load_mass_inventory_vessel_for_leak_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LoadMassInventoryVesselForLeakScenarioCalculation object"""

        parts = ['* LoadMassInventoryVesselForLeakScenario']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append(f'mass:	{str(self.mass)}')
        parts.append(f'pressure:	{str(self.pressure)}')
        parts.append(f'temperature:	{str(self.temperature)}')
        parts.append(f'hole_size:	{str(self.hole_size)}')
        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append(f'release_angle:	{str(self.release_angle)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* Leak')
        parts.append(f'leak:	{str(self.leak)}')
        parts.append(f'volume:	{str(self.volume)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LoadMassInventoryVesselForLeakScenarioCalculationResponseSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLeakScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    volume = fields.Float(data_key="volume")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_load_mass_inventory_vessel_for_leak_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLeakScenarioCalculationResponseSchema class."""

        return _LoadMassInventoryVesselForLeakScenarioCalculationResponse(**data)

class _LoadMassInventoryVesselForLeakScenarioCalculationResponse(_CalculationResponseBase):
    """
    _LoadMassInventoryVesselForLeakScenarioCalculationResponse class.

    Attributes
    ----------
        vessel : Vessel
             Vessel definition.
        leak : Leak
             Leak scenario.
        volume : float
             Volume of the vessel.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, vessel: Vessel, leak: Leak, volume: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LoadMassInventoryVesselForLeakScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.vessel = vessel
        self.leak = leak
        self.volume = volume
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest(_CalculationRequestBase):
    """
    _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest class.

    Attributes
    ----------
        material : Material
             Vessel material.
        mass : float
             Total vessel mass inventory.
        pressure : float
             Vessel pressure in absolute scale.
        temperature : float
             Vessel temperature.
        pipe_diameter : float
             Pipe diameter.
        pipe_length : float
             Pipe length.
        release_elevation : float
             Release elevation.
        release_angle : float
             Release angle.

    """
    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest class"""

        super().__init__()

        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle

class _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequestSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLineRuptureScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    mass = fields.Float(data_key="mass")
    pressure = fields.Float(data_key="pressure")
    temperature = fields.Float(data_key="temperature")
    pipe_diameter = fields.Float(data_key="pipeDiameter")
    pipe_length = fields.Float(data_key="pipeLength")
    release_elevation = fields.Float(data_key="releaseElevation")
    release_angle = fields.Float(data_key="releaseAngle")

    @post_load
    def make_load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLineRuptureScenarioCalculationRequestSchema class."""

        return _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest(**data)

class LoadMassInventoryVesselForLineRuptureScenarioCalculation(_CalculationBase):
    """
    LoadMassInventoryVesselForLineRuptureScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
             Vessel material.
        mass : float
             Total vessel mass inventory.
        pressure : float
             Vessel pressure in absolute scale.
        temperature : float
             Vessel temperature.
        pipe_diameter : float
             Pipe diameter.
        pipe_length : float
             Pipe length.
        release_elevation : float
             Release elevation.
        release_angle : float
             Release angle.

    Calculation outputs:
        vessel : Vessel
             Vessel definition.
        line_rupture : LineRupture
             Line rupture.
        volume : float
             Volume of the vessel.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the LoadMassInventoryVesselForLineRuptureScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle

        # Calculation outputs.
        self.vessel = None
        self.line_rupture = None
        self.volume = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LoadMassInventoryVesselForLineRuptureScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest object.
        load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request = _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequest(self.material, self.mass, self.pressure, self.temperature, self.pipe_diameter, self.pipe_length, self.release_elevation, self.release_angle)

        # Get the _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequestSchema and use that to serialize to json.
        load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request_schema = _LoadMassInventoryVesselForLineRuptureScenarioCalculationRequestSchema()

        request_json = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request_schema.dumps(load_mass_inventory_vessel_for_line_rupture_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/loadmassinventoryvesselforlinerupturescenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response_schema = _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponseSchema()
            load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.vessel
                self.line_rupture = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.line_rupture
                self.volume = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.volume
                self.result_code = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.result_code
                self.messages = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.messages
                self.calculation_elapsed_time = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LoadMassInventoryVesselForLineRuptureScenarioCalculation object"""

        parts = ['* LoadMassInventoryVesselForLineRuptureScenario']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append(f'mass:	{str(self.mass)}')
        parts.append(f'pressure:	{str(self.pressure)}')
        parts.append(f'temperature:	{str(self.temperature)}')
        parts.append(f'pipe_diameter:	{str(self.pipe_diameter)}')
        parts.append(f'pipe_length:	{str(self.pipe_length)}')
        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append(f'release_angle:	{str(self.release_angle)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* LineRupture')
        parts.append(f'line_rupture:	{str(self.line_rupture)}')
        parts.append(f'volume:	{str(self.volume)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponseSchema(Schema):
    """Schema for the LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    line_rupture = fields.Nested(LineRuptureSchema, data_key="lineRupture")
    volume = fields.Float(data_key="volume")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_load_mass_inventory_vessel_for_line_rupture_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForLineRuptureScenarioCalculationResponseSchema class."""

        return _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse(**data)

class _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse(_CalculationResponseBase):
    """
    _LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse class.

    Attributes
    ----------
        vessel : Vessel
             Vessel definition.
        line_rupture : LineRupture
             Line rupture.
        volume : float
             Volume of the vessel.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, vessel: Vessel, line_rupture: LineRupture, volume: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LoadMassInventoryVesselForLineRuptureScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.vessel = vessel
        self.line_rupture = line_rupture
        self.volume = volume
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest(_CalculationRequestBase):
    """
    _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest class.

    Attributes
    ----------
        material : Material
             Vessel material.
        mass : float
             Total vessel mass inventory.
        pressure : float
             Vessel pressure in absolute scale.
        temperature : float
             Vessel temperature.
        constriction_size : float
             Constriction size.
        pipe_diameter : float
             Pipe diameter.
        pipe_length : float
             Pipe length.
        release_elevation : float
             Release elevation.
        release_angle : float
             Release angle.

    """
    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, constriction_size: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest class"""

        super().__init__()

        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.constriction_size = constriction_size
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle

class _LoadMassInventoryVesselForReliefValveScenarioCalculationRequestSchema(Schema):
    """Schema for the LoadMassInventoryVesselForReliefValveScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    mass = fields.Float(data_key="mass")
    pressure = fields.Float(data_key="pressure")
    temperature = fields.Float(data_key="temperature")
    constriction_size = fields.Float(data_key="constrictionSize")
    pipe_diameter = fields.Float(data_key="pipeDiameter")
    pipe_length = fields.Float(data_key="pipeLength")
    release_elevation = fields.Float(data_key="releaseElevation")
    release_angle = fields.Float(data_key="releaseAngle")

    @post_load
    def make_load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForReliefValveScenarioCalculationRequestSchema class."""

        return _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest(**data)

class LoadMassInventoryVesselForReliefValveScenarioCalculation(_CalculationBase):
    """
    LoadMassInventoryVesselForReliefValveScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
             Vessel material.
        mass : float
             Total vessel mass inventory.
        pressure : float
             Vessel pressure in absolute scale.
        temperature : float
             Vessel temperature.
        constriction_size : float
             Constriction size.
        pipe_diameter : float
             Pipe diameter.
        pipe_length : float
             Pipe length.
        release_elevation : float
             Release elevation.
        release_angle : float
             Release angle.

    Calculation outputs:
        vessel : Vessel
             Vessel definition.
        relief_valve : ReliefValve
             Relief valve.
        volume : float
             Volume of the vessel.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, mass: float, pressure: float, temperature: float, constriction_size: float, pipe_diameter: float, pipe_length: float, release_elevation: float, release_angle: float):
        """Initializes a new instance of the LoadMassInventoryVesselForReliefValveScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.mass = mass
        self.pressure = pressure
        self.temperature = temperature
        self.constriction_size = constriction_size
        self.pipe_diameter = pipe_diameter
        self.pipe_length = pipe_length
        self.release_elevation = release_elevation
        self.release_angle = release_angle

        # Calculation outputs.
        self.vessel = None
        self.relief_valve = None
        self.volume = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LoadMassInventoryVesselForReliefValveScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest object.
        load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request = _LoadMassInventoryVesselForReliefValveScenarioCalculationRequest(self.material, self.mass, self.pressure, self.temperature, self.constriction_size, self.pipe_diameter, self.pipe_length, self.release_elevation, self.release_angle)

        # Get the _LoadMassInventoryVesselForReliefValveScenarioCalculationRequestSchema and use that to serialize to json.
        load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request_schema = _LoadMassInventoryVesselForReliefValveScenarioCalculationRequestSchema()

        request_json = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request_schema.dumps(load_mass_inventory_vessel_for_relief_valve_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/loadmassinventoryvesselforreliefvalvescenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response_schema = _LoadMassInventoryVesselForReliefValveScenarioCalculationResponseSchema()
            load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.vessel
                self.relief_valve = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.relief_valve
                self.volume = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.volume
                self.result_code = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.result_code
                self.messages = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.messages
                self.calculation_elapsed_time = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LoadMassInventoryVesselForReliefValveScenarioCalculation object"""

        parts = ['* LoadMassInventoryVesselForReliefValveScenario']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append(f'mass:	{str(self.mass)}')
        parts.append(f'pressure:	{str(self.pressure)}')
        parts.append(f'temperature:	{str(self.temperature)}')
        parts.append(f'constriction_size:	{str(self.constriction_size)}')
        parts.append(f'pipe_diameter:	{str(self.pipe_diameter)}')
        parts.append(f'pipe_length:	{str(self.pipe_length)}')
        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append(f'release_angle:	{str(self.release_angle)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* ReliefValve')
        parts.append(f'relief_valve:	{str(self.relief_valve)}')
        parts.append(f'volume:	{str(self.volume)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LoadMassInventoryVesselForReliefValveScenarioCalculationResponseSchema(Schema):
    """Schema for the LoadMassInventoryVesselForReliefValveScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    relief_valve = fields.Nested(ReliefValveSchema, data_key="reliefValve")
    volume = fields.Float(data_key="volume")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_load_mass_inventory_vessel_for_relief_valve_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the LoadMassInventoryVesselForReliefValveScenarioCalculationResponseSchema class."""

        return _LoadMassInventoryVesselForReliefValveScenarioCalculationResponse(**data)

class _LoadMassInventoryVesselForReliefValveScenarioCalculationResponse(_CalculationResponseBase):
    """
    _LoadMassInventoryVesselForReliefValveScenarioCalculationResponse class.

    Attributes
    ----------
        vessel : Vessel
             Vessel definition.
        relief_valve : ReliefValve
             Relief valve.
        volume : float
             Volume of the vessel.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, volume: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LoadMassInventoryVesselForReliefValveScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.vessel = vessel
        self.relief_valve = relief_valve
        self.volume = volume
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _LongPipeBreachCalculationRequest(_CalculationRequestBase):
    """
    _LongPipeBreachCalculationRequest class.

    Attributes
    ----------
        pipe : Pipe
              a pipe entity.
        pipe_breach : PipeBreach
              a pipe breach entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    """
    def __init__(self, pipe: Pipe, pipe_breach: PipeBreach, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _LongPipeBreachCalculationRequest class"""

        super().__init__()

        self.pipe = pipe
        self.pipe_breach = pipe_breach
        self.discharge_parameters = discharge_parameters

class _LongPipeBreachCalculationRequestSchema(Schema):
    """Schema for the LongPipeBreach calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pipe = fields.Nested(PipeSchema, data_key="pipe")
    pipe_breach = fields.Nested(PipeBreachSchema, data_key="pipeBreach")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_long_pipe_breach_calculation_request(self, data, **kwargs):
        """Post-processing of the LongPipeBreachCalculationRequestSchema class."""

        return _LongPipeBreachCalculationRequest(**data)

class LongPipeBreachCalculation(_CalculationBase):
    """
    LongPipeBreachCalculation class.

    Attributes
    ----------
    Calculation inputs:
        pipe : Pipe
              a pipe entity.
        pipe_breach : PipeBreach
              a pipe breach entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    Calculation outputs:
        exit_material : Material
              a material entity, representing composition of the released material.
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pipe: Pipe, pipe_breach: PipeBreach, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the LongPipeBreachCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.pipe = pipe
        self.pipe_breach = pipe_breach
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        LongPipeBreachCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _LongPipeBreachCalculationRequest object.
        long_pipe_breach_calculation_request = _LongPipeBreachCalculationRequest(self.pipe, self.pipe_breach, self.discharge_parameters)

        # Get the _LongPipeBreachCalculationRequestSchema and use that to serialize to json.
        long_pipe_breach_calculation_request_schema = _LongPipeBreachCalculationRequestSchema()

        request_json = long_pipe_breach_calculation_request_schema.dumps(long_pipe_breach_calculation_request)
        url = get_analytics_api_target() + 'calculatelongpipebreach?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            long_pipe_breach_calculation_response_schema = _LongPipeBreachCalculationResponseSchema()
            long_pipe_breach_calculation_response = long_pipe_breach_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(long_pipe_breach_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = long_pipe_breach_calculation_response.exit_material
                self.discharge_result = long_pipe_breach_calculation_response.discharge_result
                self.discharge_records = long_pipe_breach_calculation_response.discharge_records
                self.result_code = long_pipe_breach_calculation_response.result_code
                self.messages = long_pipe_breach_calculation_response.messages
                self.calculation_elapsed_time = long_pipe_breach_calculation_response.calculation_elapsed_time
                self.operation_id = long_pipe_breach_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(long_pipe_breach_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the LongPipeBreachCalculation object"""

        parts = ['* LongPipeBreach']

        parts.append('* Pipe')
        parts.append(f'pipe:	{str(self.pipe)}')
        parts.append('* PipeBreach')
        parts.append(f'pipe_breach:	{str(self.pipe_breach)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Material')
        parts.append(f'exit_material:	{str(self.exit_material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _LongPipeBreachCalculationResponseSchema(Schema):
    """Schema for the LongPipeBreachCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_long_pipe_breach_calculation_response(self, data, **kwargs):
        """Post-processing of the LongPipeBreachCalculationResponseSchema class."""

        return _LongPipeBreachCalculationResponse(**data)

class _LongPipeBreachCalculationResponse(_CalculationResponseBase):
    """
    _LongPipeBreachCalculationResponse class.

    Attributes
    ----------
        exit_material : Material
              a material entity, representing composition of the released material.
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the LongPipeBreachCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _MaxConcDistanceCalculationRequest(_CalculationRequestBase):
    """
    _MaxConcDistanceCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _MaxConcDistanceCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

class _MaxConcDistanceCalculationRequestSchema(Schema):
    """Schema for the MaxConcDistance calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_max_conc_distance_calculation_request(self, data, **kwargs):
        """Post-processing of the MaxConcDistanceCalculationRequestSchema class."""

        return _MaxConcDistanceCalculationRequest(**data)

class MaxConcDistanceCalculation(_CalculationBase):
    """
    MaxConcDistanceCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        conc_used : float
             Concentration of interest.
        concentration_records : list[ConcentrationRecord]
              an array of maximum concentration at x, y, z coordinates.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the MaxConcDistanceCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.concentration_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        MaxConcDistanceCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MaxConcDistanceCalculationRequest object.
        max_conc_distance_calculation_request = _MaxConcDistanceCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the _MaxConcDistanceCalculationRequestSchema and use that to serialize to json.
        max_conc_distance_calculation_request_schema = _MaxConcDistanceCalculationRequestSchema()

        request_json = max_conc_distance_calculation_request_schema.dumps(max_conc_distance_calculation_request)
        url = get_analytics_api_target() + 'calculatemaxconcdistance?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            max_conc_distance_calculation_response_schema = _MaxConcDistanceCalculationResponseSchema()
            max_conc_distance_calculation_response = max_conc_distance_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(max_conc_distance_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = max_conc_distance_calculation_response.conc_used
                self.concentration_records = max_conc_distance_calculation_response.concentration_records
                self.result_code = max_conc_distance_calculation_response.result_code
                self.messages = max_conc_distance_calculation_response.messages
                self.calculation_elapsed_time = max_conc_distance_calculation_response.calculation_elapsed_time
                self.operation_id = max_conc_distance_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(max_conc_distance_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the MaxConcDistanceCalculation object"""

        parts = ['* MaxConcDistance']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append(f'conc_used:	{str(self.conc_used)}')
        parts.extend(['concentration_records_element' for concentration_records_element in self.concentration_records] if self.concentration_records else [f'concentration_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _MaxConcDistanceCalculationResponseSchema(Schema):
    """Schema for the MaxConcDistanceCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    concentration_records = fields.Nested(ConcentrationRecordSchema, allow_none=True, many=True, data_key="concentrationRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_max_conc_distance_calculation_response(self, data, **kwargs):
        """Post-processing of the MaxConcDistanceCalculationResponseSchema class."""

        return _MaxConcDistanceCalculationResponse(**data)

class _MaxConcDistanceCalculationResponse(_CalculationResponseBase):
    """
    _MaxConcDistanceCalculationResponse class.

    Attributes
    ----------
        conc_used : float
             Concentration of interest.
        concentration_records : list[ConcentrationRecord]
              an array of maximum concentration at x, y, z coordinates.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, conc_used: float, concentration_records: list[ConcentrationRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the MaxConcDistanceCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.conc_used = conc_used
        self.concentration_records = concentration_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _MaxConcFootprintCalculationRequest(_CalculationRequestBase):
    """
    _MaxConcFootprintCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _MaxConcFootprintCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

class _MaxConcFootprintCalculationRequestSchema(Schema):
    """Schema for the MaxConcFootprint calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_max_conc_footprint_calculation_request(self, data, **kwargs):
        """Post-processing of the MaxConcFootprintCalculationRequestSchema class."""

        return _MaxConcFootprintCalculationRequest(**data)

class MaxConcFootprintCalculation(_CalculationBase):
    """
    MaxConcFootprintCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        conc_used : float
             Concentration of interest.
        contour_points : list[LocalPosition]
              an array of points along the footprint contour.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the MaxConcFootprintCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.contour_points = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        MaxConcFootprintCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MaxConcFootprintCalculationRequest object.
        max_conc_footprint_calculation_request = _MaxConcFootprintCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the _MaxConcFootprintCalculationRequestSchema and use that to serialize to json.
        max_conc_footprint_calculation_request_schema = _MaxConcFootprintCalculationRequestSchema()

        request_json = max_conc_footprint_calculation_request_schema.dumps(max_conc_footprint_calculation_request)
        url = get_analytics_api_target() + 'calculatemaxconcfootprint?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            max_conc_footprint_calculation_response_schema = _MaxConcFootprintCalculationResponseSchema()
            max_conc_footprint_calculation_response = max_conc_footprint_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(max_conc_footprint_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = max_conc_footprint_calculation_response.conc_used
                self.contour_points = max_conc_footprint_calculation_response.contour_points
                self.result_code = max_conc_footprint_calculation_response.result_code
                self.messages = max_conc_footprint_calculation_response.messages
                self.calculation_elapsed_time = max_conc_footprint_calculation_response.calculation_elapsed_time
                self.operation_id = max_conc_footprint_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(max_conc_footprint_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the MaxConcFootprintCalculation object"""

        parts = ['* MaxConcFootprint']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append(f'conc_used:	{str(self.conc_used)}')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _MaxConcFootprintCalculationResponseSchema(Schema):
    """Schema for the MaxConcFootprintCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_max_conc_footprint_calculation_response(self, data, **kwargs):
        """Post-processing of the MaxConcFootprintCalculationResponseSchema class."""

        return _MaxConcFootprintCalculationResponse(**data)

class _MaxConcFootprintCalculationResponse(_CalculationResponseBase):
    """
    _MaxConcFootprintCalculationResponse class.

    Attributes
    ----------
        conc_used : float
             Concentration of interest.
        contour_points : list[LocalPosition]
              an array of points along the footprint contour.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, conc_used: float, contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the MaxConcFootprintCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.conc_used = conc_used
        self.contour_points = contour_points
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _MaxDistanceToConcCalculationRequest(_CalculationRequestBase):
    """
    _MaxDistanceToConcCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        material : Material
              a material entity with post-discharge composition.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, dispersion_parameters: DispersionParameters, material: Material):
        """Initializes a new instance of the _MaxDistanceToConcCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.dispersion_parameters = dispersion_parameters
        self.material = material

class _MaxDistanceToConcCalculationRequestSchema(Schema):
    """Schema for the MaxDistanceToConc calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    material = fields.Nested(MaterialSchema, data_key="material")

    @post_load
    def make_max_distance_to_conc_calculation_request(self, data, **kwargs):
        """Post-processing of the MaxDistanceToConcCalculationRequestSchema class."""

        return _MaxDistanceToConcCalculationRequest(**data)

class MaxDistanceToConcCalculation(_CalculationBase):
    """
    MaxDistanceToConcCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion results.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        material : Material
              a material entity with post-discharge composition.

    Calculation outputs:
        conc_used : float
             Concentration of interest.
        distance : float
             Maximum distance to concentration of interest.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, dispersion_parameters: DispersionParameters, material: Material):
        """Initializes a new instance of the MaxDistanceToConcCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.dispersion_parameters = dispersion_parameters
        self.material = material

        # Calculation outputs.
        self.conc_used = None
        self.distance = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        MaxDistanceToConcCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MaxDistanceToConcCalculationRequest object.
        max_distance_to_conc_calculation_request = _MaxDistanceToConcCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.dispersion_parameters, self.material)

        # Get the _MaxDistanceToConcCalculationRequestSchema and use that to serialize to json.
        max_distance_to_conc_calculation_request_schema = _MaxDistanceToConcCalculationRequestSchema()

        request_json = max_distance_to_conc_calculation_request_schema.dumps(max_distance_to_conc_calculation_request)
        url = get_analytics_api_target() + 'calculatemaxdistancetoconc?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            max_distance_to_conc_calculation_response_schema = _MaxDistanceToConcCalculationResponseSchema()
            max_distance_to_conc_calculation_response = max_distance_to_conc_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(max_distance_to_conc_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = max_distance_to_conc_calculation_response.conc_used
                self.distance = max_distance_to_conc_calculation_response.distance
                self.result_code = max_distance_to_conc_calculation_response.result_code
                self.messages = max_distance_to_conc_calculation_response.messages
                self.calculation_elapsed_time = max_distance_to_conc_calculation_response.calculation_elapsed_time
                self.operation_id = max_distance_to_conc_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(max_distance_to_conc_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the MaxDistanceToConcCalculation object"""

        parts = ['* MaxDistanceToConc']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append(f'conc_used:	{str(self.conc_used)}')
        parts.append(f'distance:	{str(self.distance)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _MaxDistanceToConcCalculationResponseSchema(Schema):
    """Schema for the MaxDistanceToConcCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    distance = fields.Float(data_key="distance")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_max_distance_to_conc_calculation_response(self, data, **kwargs):
        """Post-processing of the MaxDistanceToConcCalculationResponseSchema class."""

        return _MaxDistanceToConcCalculationResponse(**data)

class _MaxDistanceToConcCalculationResponse(_CalculationResponseBase):
    """
    _MaxDistanceToConcCalculationResponse class.

    Attributes
    ----------
        conc_used : float
             Concentration of interest.
        distance : float
             Maximum distance to concentration of interest.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, conc_used: float, distance: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the MaxDistanceToConcCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.conc_used = conc_used
        self.distance = distance
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _MixtureConstantPropertiesCalculationRequest(_CalculationRequestBase):
    """
    _MixtureConstantPropertiesCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity representing a mixture.

    """
    def __init__(self, material: Material):
        """Initializes a new instance of the _MixtureConstantPropertiesCalculationRequest class"""

        super().__init__()

        self.material = material

class _MixtureConstantPropertiesCalculationRequestSchema(Schema):
    """Schema for the MixtureConstantProperties calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")

    @post_load
    def make_mixture_constant_properties_calculation_request(self, data, **kwargs):
        """Post-processing of the MixtureConstantPropertiesCalculationRequestSchema class."""

        return _MixtureConstantPropertiesCalculationRequest(**data)

class MixtureConstantPropertiesCalculation(_CalculationBase):
    """
    MixtureConstantPropertiesCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity representing a mixture.

    Calculation outputs:
        mix_constant_prop_result : MixtureConstantPropertiesResult
             Constant properties of the mixture.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material):
        """Initializes a new instance of the MixtureConstantPropertiesCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material

        # Calculation outputs.
        self.mix_constant_prop_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        MixtureConstantPropertiesCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _MixtureConstantPropertiesCalculationRequest object.
        mixture_constant_properties_calculation_request = _MixtureConstantPropertiesCalculationRequest(self.material)

        # Get the _MixtureConstantPropertiesCalculationRequestSchema and use that to serialize to json.
        mixture_constant_properties_calculation_request_schema = _MixtureConstantPropertiesCalculationRequestSchema()

        request_json = mixture_constant_properties_calculation_request_schema.dumps(mixture_constant_properties_calculation_request)
        url = get_analytics_api_target() + 'constantmixtureproperties?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            mixture_constant_properties_calculation_response_schema = _MixtureConstantPropertiesCalculationResponseSchema()
            mixture_constant_properties_calculation_response = mixture_constant_properties_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(mixture_constant_properties_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.mix_constant_prop_result = mixture_constant_properties_calculation_response.mix_constant_prop_result
                self.result_code = mixture_constant_properties_calculation_response.result_code
                self.messages = mixture_constant_properties_calculation_response.messages
                self.calculation_elapsed_time = mixture_constant_properties_calculation_response.calculation_elapsed_time
                self.operation_id = mixture_constant_properties_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(mixture_constant_properties_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the MixtureConstantPropertiesCalculation object"""

        parts = ['* MixtureConstantProperties']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* MixtureConstantPropertiesResult')
        parts.append(f'mix_constant_prop_result:	{str(self.mix_constant_prop_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _MixtureConstantPropertiesCalculationResponseSchema(Schema):
    """Schema for the MixtureConstantPropertiesCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mix_constant_prop_result = fields.Nested(MixtureConstantPropertiesResultSchema, data_key="mixConstantPropResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_mixture_constant_properties_calculation_response(self, data, **kwargs):
        """Post-processing of the MixtureConstantPropertiesCalculationResponseSchema class."""

        return _MixtureConstantPropertiesCalculationResponse(**data)

class _MixtureConstantPropertiesCalculationResponse(_CalculationResponseBase):
    """
    _MixtureConstantPropertiesCalculationResponse class.

    Attributes
    ----------
        mix_constant_prop_result : MixtureConstantPropertiesResult
             Constant properties of the mixture.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, mix_constant_prop_result: MixtureConstantPropertiesResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the MixtureConstantPropertiesCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.mix_constant_prop_result = mix_constant_prop_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _ModifyFuelRateForJetFireCalculationRequest(_CalculationRequestBase):
    """
    _ModifyFuelRateForJetFireCalculationRequest class.

    Attributes
    ----------
        discharge_records : list[DischargeRecord]
             Discharge records.
        discharge_record_count : int
             Number of discharge records.
        pool_records : list[PoolRecord]
             Pool records.
        pool_record_count : int
             Number of pool records.
        flammable_parameters : FlammableParameters
             Flammable parameters.

    """
    def __init__(self, discharge_records: list[DischargeRecord], discharge_record_count: int, pool_records: list[PoolRecord], pool_record_count: int, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _ModifyFuelRateForJetFireCalculationRequest class"""

        super().__init__()

        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.pool_records = pool_records
        self.pool_record_count = pool_record_count
        self.flammable_parameters = flammable_parameters

class _ModifyFuelRateForJetFireCalculationRequestSchema(Schema):
    """Schema for the ModifyFuelRateForJetFire calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    pool_records = fields.Nested(PoolRecordSchema, allow_none=True, many=True, data_key="poolRecords")
    pool_record_count = fields.Int(data_key="poolRecordCount")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_modify_fuel_rate_for_jet_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the ModifyFuelRateForJetFireCalculationRequestSchema class."""

        return _ModifyFuelRateForJetFireCalculationRequest(**data)

class ModifyFuelRateForJetFireCalculation(_CalculationBase):
    """
    ModifyFuelRateForJetFireCalculation class.

    Attributes
    ----------
    Calculation inputs:
        discharge_records : list[DischargeRecord]
             Discharge records.
        discharge_record_count : int
             Number of discharge records.
        pool_records : list[PoolRecord]
             Pool records.
        pool_record_count : int
             Number of pool records.
        flammable_parameters : FlammableParameters
             Flammable parameters.

    Calculation outputs:
        mod_discharge_records : list[DischargeRecord]
             Modified discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, discharge_records: list[DischargeRecord], discharge_record_count: int, pool_records: list[PoolRecord], pool_record_count: int, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the ModifyFuelRateForJetFireCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.pool_records = pool_records
        self.pool_record_count = pool_record_count
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.mod_discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        ModifyFuelRateForJetFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ModifyFuelRateForJetFireCalculationRequest object.
        modify_fuel_rate_for_jet_fire_calculation_request = _ModifyFuelRateForJetFireCalculationRequest(self.discharge_records, self.discharge_record_count, self.pool_records, self.pool_record_count, self.flammable_parameters)

        # Get the _ModifyFuelRateForJetFireCalculationRequestSchema and use that to serialize to json.
        modify_fuel_rate_for_jet_fire_calculation_request_schema = _ModifyFuelRateForJetFireCalculationRequestSchema()

        request_json = modify_fuel_rate_for_jet_fire_calculation_request_schema.dumps(modify_fuel_rate_for_jet_fire_calculation_request)
        url = get_analytics_api_target() + 'ModifyFuelRateForJetFire?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            modify_fuel_rate_for_jet_fire_calculation_response_schema = _ModifyFuelRateForJetFireCalculationResponseSchema()
            modify_fuel_rate_for_jet_fire_calculation_response = modify_fuel_rate_for_jet_fire_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(modify_fuel_rate_for_jet_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.mod_discharge_records = modify_fuel_rate_for_jet_fire_calculation_response.mod_discharge_records
                self.result_code = modify_fuel_rate_for_jet_fire_calculation_response.result_code
                self.messages = modify_fuel_rate_for_jet_fire_calculation_response.messages
                self.calculation_elapsed_time = modify_fuel_rate_for_jet_fire_calculation_response.calculation_elapsed_time
                self.operation_id = modify_fuel_rate_for_jet_fire_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(modify_fuel_rate_for_jet_fire_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the ModifyFuelRateForJetFireCalculation object"""

        parts = ['* ModifyFuelRateForJetFire']

        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'discharge_record_count:	{str(self.discharge_record_count)}')
        parts.extend(['pool_records_element' for pool_records_element in self.pool_records] if self.pool_records else [f'pool_records does not contain any elements'])
        parts.append(f'pool_record_count:	{str(self.pool_record_count)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.extend(['mod_discharge_records_element' for mod_discharge_records_element in self.mod_discharge_records] if self.mod_discharge_records else [f'mod_discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _ModifyFuelRateForJetFireCalculationResponseSchema(Schema):
    """Schema for the ModifyFuelRateForJetFireCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    mod_discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="modDischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_modify_fuel_rate_for_jet_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the ModifyFuelRateForJetFireCalculationResponseSchema class."""

        return _ModifyFuelRateForJetFireCalculationResponse(**data)

class _ModifyFuelRateForJetFireCalculationResponse(_CalculationResponseBase):
    """
    _ModifyFuelRateForJetFireCalculationResponse class.

    Attributes
    ----------
        mod_discharge_records : list[DischargeRecord]
             Modified discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, mod_discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the ModifyFuelRateForJetFireCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.mod_discharge_records = mod_discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _PoolFireCalculationRequest(_CalculationRequestBase):
    """
    _PoolFireCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity with post-discharge composition.
        pool_records : list[PoolRecord]
              an array of pool records.
        pool_record_count : int
             Number of pool records.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.

    """
    def __init__(self, material: Material, pool_records: list[PoolRecord], pool_record_count: int, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _PoolFireCalculationRequest class"""

        super().__init__()

        self.material = material
        self.pool_records = pool_records
        self.pool_record_count = pool_record_count
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

class _PoolFireCalculationRequestSchema(Schema):
    """Schema for the PoolFire calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    pool_records = fields.Nested(PoolRecordSchema, allow_none=True, many=True, data_key="poolRecords")
    pool_record_count = fields.Int(data_key="poolRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_pool_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the PoolFireCalculationRequestSchema class."""

        return _PoolFireCalculationRequest(**data)

class PoolFireCalculation(_CalculationBase):
    """
    PoolFireCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity with post-discharge composition.
        pool_records : list[PoolRecord]
              an array of pool records.
        pool_record_count : int
             Number of pool records.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.

    Calculation outputs:
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of pool fire flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, pool_records: list[PoolRecord], pool_record_count: int, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the PoolFireCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.pool_records = pool_records
        self.pool_record_count = pool_record_count
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.pool_fire_flame_result = None
        self.flame_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        PoolFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _PoolFireCalculationRequest object.
        pool_fire_calculation_request = _PoolFireCalculationRequest(self.material, self.pool_records, self.pool_record_count, self.weather, self.substrate, self.flammable_parameters)

        # Get the _PoolFireCalculationRequestSchema and use that to serialize to json.
        pool_fire_calculation_request_schema = _PoolFireCalculationRequestSchema()

        request_json = pool_fire_calculation_request_schema.dumps(pool_fire_calculation_request)
        url = get_analytics_api_target() + 'calculatepoolfire?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            pool_fire_calculation_response_schema = _PoolFireCalculationResponseSchema()
            pool_fire_calculation_response = pool_fire_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(pool_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.pool_fire_flame_result = pool_fire_calculation_response.pool_fire_flame_result
                self.flame_records = pool_fire_calculation_response.flame_records
                self.result_code = pool_fire_calculation_response.result_code
                self.messages = pool_fire_calculation_response.messages
                self.calculation_elapsed_time = pool_fire_calculation_response.calculation_elapsed_time
                self.operation_id = pool_fire_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(pool_fire_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the PoolFireCalculation object"""

        parts = ['* PoolFire']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.extend(['pool_records_element' for pool_records_element in self.pool_records] if self.pool_records else [f'pool_records does not contain any elements'])
        parts.append(f'pool_record_count:	{str(self.pool_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _PoolFireCalculationResponseSchema(Schema):
    """Schema for the PoolFireCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_pool_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the PoolFireCalculationResponseSchema class."""

        return _PoolFireCalculationResponse(**data)

class _PoolFireCalculationResponse(_CalculationResponseBase):
    """
    _PoolFireCalculationResponse class.

    Attributes
    ----------
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of pool fire flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the PoolFireCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationAtAPointCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtAPointCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity, for setting the point coordinates.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationAtAPointCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

class _RadiationAtAPointCalculationRequestSchema(Schema):
    """Schema for the RadiationAtAPoint calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_at_a_point_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointCalculationRequestSchema class."""

        return _RadiationAtAPointCalculationRequest(**data)

class RadiationAtAPointCalculation(_CalculationBase):
    """
    RadiationAtAPointCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity, for setting the point coordinates.

    Calculation outputs:
        radiation : float
             Radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationAtAPointCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationAtAPointCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtAPointCalculationRequest object.
        radiation_at_a_point_calculation_request = _RadiationAtAPointCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the _RadiationAtAPointCalculationRequestSchema and use that to serialize to json.
        radiation_at_a_point_calculation_request_schema = _RadiationAtAPointCalculationRequestSchema()

        request_json = radiation_at_a_point_calculation_request_schema.dumps(radiation_at_a_point_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatapoint?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_at_a_point_calculation_response_schema = _RadiationAtAPointCalculationResponseSchema()
            radiation_at_a_point_calculation_response = radiation_at_a_point_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_at_a_point_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_a_point_calculation_response.radiation
                self.result_code = radiation_at_a_point_calculation_response.result_code
                self.messages = radiation_at_a_point_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_a_point_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_at_a_point_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_at_a_point_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtAPointCalculation object"""

        parts = ['* RadiationAtAPoint']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlammableOutputConfig')
        parts.append(f'flammable_output_config:	{str(self.flammable_output_config)}')
        parts.append(f'radiation:	{str(self.radiation)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationAtAPointCalculationResponseSchema(Schema):
    """Schema for the RadiationAtAPointCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.Float(data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_at_a_point_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointCalculationResponseSchema class."""

        return _RadiationAtAPointCalculationResponse(**data)

class _RadiationAtAPointCalculationResponse(_CalculationResponseBase):
    """
    _RadiationAtAPointCalculationResponse class.

    Attributes
    ----------
        radiation : float
             Radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, radiation: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationAtAPointCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.radiation = radiation
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationAtAPointForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtAPointForPoolFiresCalculationRequest class.

    Attributes
    ----------
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity, for setting the point coordinates.

    """
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationAtAPointForPoolFiresCalculationRequest class"""

        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

class _RadiationAtAPointForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the RadiationAtAPointForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_at_a_point_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointForPoolFiresCalculationRequestSchema class."""

        return _RadiationAtAPointForPoolFiresCalculationRequest(**data)

class RadiationAtAPointForPoolFiresCalculation(_CalculationBase):
    """
    RadiationAtAPointForPoolFiresCalculation class.

    Attributes
    ----------
    Calculation inputs:
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity, for setting the point coordinates.

    Calculation outputs:
        radiation : float
             Radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationAtAPointForPoolFiresCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationAtAPointForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtAPointForPoolFiresCalculationRequest object.
        radiation_at_a_point_for_pool_fires_calculation_request = _RadiationAtAPointForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the _RadiationAtAPointForPoolFiresCalculationRequestSchema and use that to serialize to json.
        radiation_at_a_point_for_pool_fires_calculation_request_schema = _RadiationAtAPointForPoolFiresCalculationRequestSchema()

        request_json = radiation_at_a_point_for_pool_fires_calculation_request_schema.dumps(radiation_at_a_point_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatapointforpoolfires?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_at_a_point_for_pool_fires_calculation_response_schema = _RadiationAtAPointForPoolFiresCalculationResponseSchema()
            radiation_at_a_point_for_pool_fires_calculation_response = radiation_at_a_point_for_pool_fires_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_at_a_point_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_a_point_for_pool_fires_calculation_response.radiation
                self.result_code = radiation_at_a_point_for_pool_fires_calculation_response.result_code
                self.messages = radiation_at_a_point_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_a_point_for_pool_fires_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_at_a_point_for_pool_fires_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_at_a_point_for_pool_fires_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtAPointForPoolFiresCalculation object"""

        parts = ['* RadiationAtAPointForPoolFires']

        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlammableOutputConfig')
        parts.append(f'flammable_output_config:	{str(self.flammable_output_config)}')
        parts.append(f'radiation:	{str(self.radiation)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationAtAPointForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the RadiationAtAPointForPoolFiresCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.Float(data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_at_a_point_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtAPointForPoolFiresCalculationResponseSchema class."""

        return _RadiationAtAPointForPoolFiresCalculationResponse(**data)

class _RadiationAtAPointForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    _RadiationAtAPointForPoolFiresCalculationResponse class.

    Attributes
    ----------
        radiation : float
             Radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, radiation: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationAtAPointForPoolFiresCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.radiation = radiation
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationAtPointsCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtPointsCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              a flammable output config entity, for setting the point coordinates.
        flammable_output_config_count : int
             Number of points.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _RadiationAtPointsCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

class _RadiationAtPointsCalculationRequestSchema(Schema):
    """Schema for the RadiationAtPoints calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_radiation_at_points_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsCalculationRequestSchema class."""

        return _RadiationAtPointsCalculationRequest(**data)

class RadiationAtPointsCalculation(_CalculationBase):
    """
    RadiationAtPointsCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              a flammable output config entity, for setting the point coordinates.
        flammable_output_config_count : int
             Number of points.

    Calculation outputs:
        radiation : list[float]
              an array of radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the RadiationAtPointsCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.radiation = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationAtPointsCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtPointsCalculationRequest object.
        radiation_at_points_calculation_request = _RadiationAtPointsCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the _RadiationAtPointsCalculationRequestSchema and use that to serialize to json.
        radiation_at_points_calculation_request_schema = _RadiationAtPointsCalculationRequestSchema()

        request_json = radiation_at_points_calculation_request_schema.dumps(radiation_at_points_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatpoints?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_at_points_calculation_response_schema = _RadiationAtPointsCalculationResponseSchema()
            radiation_at_points_calculation_response = radiation_at_points_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_at_points_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_points_calculation_response.radiation
                self.result_code = radiation_at_points_calculation_response.result_code
                self.messages = radiation_at_points_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_points_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_at_points_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_at_points_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtPointsCalculation object"""

        parts = ['* RadiationAtPoints']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['radiation_element' for radiation_element in self.radiation] if self.radiation else [f'radiation does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationAtPointsCalculationResponseSchema(Schema):
    """Schema for the RadiationAtPointsCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.List(fields.Float(), allow_none=True, data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_at_points_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsCalculationResponseSchema class."""

        return _RadiationAtPointsCalculationResponse(**data)

class _RadiationAtPointsCalculationResponse(_CalculationResponseBase):
    """
    _RadiationAtPointsCalculationResponse class.

    Attributes
    ----------
        radiation : list[float]
              an array of radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, radiation: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationAtPointsCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.radiation = radiation
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationAtPointsForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _RadiationAtPointsForPoolFiresCalculationRequest class.

    Attributes
    ----------
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              a flammable output config entity, for setting the point coordinates.
        flammable_output_config_count : int
             Number of points.

    """
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the _RadiationAtPointsForPoolFiresCalculationRequest class"""

        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

class _RadiationAtPointsForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the RadiationAtPointsForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")

    @post_load
    def make_radiation_at_points_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsForPoolFiresCalculationRequestSchema class."""

        return _RadiationAtPointsForPoolFiresCalculationRequest(**data)

class RadiationAtPointsForPoolFiresCalculation(_CalculationBase):
    """
    RadiationAtPointsForPoolFiresCalculation class.

    Attributes
    ----------
    Calculation inputs:
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_configs : list[FlammableOutputConfig]
              a flammable output config entity, for setting the point coordinates.
        flammable_output_config_count : int
             Number of points.

    Calculation outputs:
        radiation : list[float]
              an array of radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int):
        """Initializes a new instance of the RadiationAtPointsForPoolFiresCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count

        # Calculation outputs.
        self.radiation = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationAtPointsForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationAtPointsForPoolFiresCalculationRequest object.
        radiation_at_points_for_pool_fires_calculation_request = _RadiationAtPointsForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_configs, self.flammable_output_config_count)

        # Get the _RadiationAtPointsForPoolFiresCalculationRequestSchema and use that to serialize to json.
        radiation_at_points_for_pool_fires_calculation_request_schema = _RadiationAtPointsForPoolFiresCalculationRequestSchema()

        request_json = radiation_at_points_for_pool_fires_calculation_request_schema.dumps(radiation_at_points_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationatpointsforpoolfires?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_at_points_for_pool_fires_calculation_response_schema = _RadiationAtPointsForPoolFiresCalculationResponseSchema()
            radiation_at_points_for_pool_fires_calculation_response = radiation_at_points_for_pool_fires_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_at_points_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation = radiation_at_points_for_pool_fires_calculation_response.radiation
                self.result_code = radiation_at_points_for_pool_fires_calculation_response.result_code
                self.messages = radiation_at_points_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = radiation_at_points_for_pool_fires_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_at_points_for_pool_fires_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_at_points_for_pool_fires_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationAtPointsForPoolFiresCalculation object"""

        parts = ['* RadiationAtPointsForPoolFires']

        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['radiation_element' for radiation_element in self.radiation] if self.radiation else [f'radiation does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationAtPointsForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the RadiationAtPointsForPoolFiresCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation = fields.List(fields.Float(), allow_none=True, data_key="radiation")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_at_points_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationAtPointsForPoolFiresCalculationResponseSchema class."""

        return _RadiationAtPointsForPoolFiresCalculationResponse(**data)

class _RadiationAtPointsForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    _RadiationAtPointsForPoolFiresCalculationResponse class.

    Attributes
    ----------
        radiation : list[float]
              an array of radiation at a point.
        result_code : ResultCode
             Response code.
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, radiation: list[float], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationAtPointsForPoolFiresCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.radiation = radiation
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationContourCalculationRequest(_CalculationRequestBase):
    """
    _RadiationContourCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationContourCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

class _RadiationContourCalculationRequestSchema(Schema):
    """Schema for the RadiationContour calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_contour_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationContourCalculationRequestSchema class."""

        return _RadiationContourCalculationRequest(**data)

class RadiationContourCalculation(_CalculationBase):
    """
    RadiationContourCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    Calculation outputs:
        contour_points : list[LocalPosition]
              an array of contour points.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationContourCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.contour_points = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationContourCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationContourCalculationRequest object.
        radiation_contour_calculation_request = _RadiationContourCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the _RadiationContourCalculationRequestSchema and use that to serialize to json.
        radiation_contour_calculation_request_schema = _RadiationContourCalculationRequestSchema()

        request_json = radiation_contour_calculation_request_schema.dumps(radiation_contour_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationcontour?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_contour_calculation_response_schema = _RadiationContourCalculationResponseSchema()
            radiation_contour_calculation_response = radiation_contour_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_contour_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.contour_points = radiation_contour_calculation_response.contour_points
                self.result_code = radiation_contour_calculation_response.result_code
                self.messages = radiation_contour_calculation_response.messages
                self.calculation_elapsed_time = radiation_contour_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_contour_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_contour_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationContourCalculation object"""

        parts = ['* RadiationContour']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlammableOutputConfig')
        parts.append(f'flammable_output_config:	{str(self.flammable_output_config)}')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationContourCalculationResponseSchema(Schema):
    """Schema for the RadiationContourCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_contour_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationContourCalculationResponseSchema class."""

        return _RadiationContourCalculationResponse(**data)

class _RadiationContourCalculationResponse(_CalculationResponseBase):
    """
    _RadiationContourCalculationResponse class.

    Attributes
    ----------
        contour_points : list[LocalPosition]
              an array of contour points.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationContourCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.contour_points = contour_points
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationTransectCalculationRequest(_CalculationRequestBase):
    """
    _RadiationTransectCalculationRequest class.

    Attributes
    ----------
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    """
    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationTransectCalculationRequest class"""

        super().__init__()

        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

class _RadiationTransectCalculationRequestSchema(Schema):
    """Schema for the RadiationTransect calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    flame_result = fields.Nested(FlameResultSchema, data_key="flameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_transect_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationTransectCalculationRequestSchema class."""

        return _RadiationTransectCalculationRequest(**data)

class RadiationTransectCalculation(_CalculationBase):
    """
    RadiationTransectCalculation class.

    Attributes
    ----------
    Calculation inputs:
        flame_result : FlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    Calculation outputs:
        radiation_records : list[RadiationRecord]
              an array of radiation records along transect.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, flame_result: FlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationTransectCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.flame_result = flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationTransectCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationTransectCalculationRequest object.
        radiation_transect_calculation_request = _RadiationTransectCalculationRequest(self.flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the _RadiationTransectCalculationRequestSchema and use that to serialize to json.
        radiation_transect_calculation_request_schema = _RadiationTransectCalculationRequestSchema()

        request_json = radiation_transect_calculation_request_schema.dumps(radiation_transect_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationtransect?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_transect_calculation_response_schema = _RadiationTransectCalculationResponseSchema()
            radiation_transect_calculation_response = radiation_transect_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_transect_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation_records = radiation_transect_calculation_response.radiation_records
                self.result_code = radiation_transect_calculation_response.result_code
                self.messages = radiation_transect_calculation_response.messages
                self.calculation_elapsed_time = radiation_transect_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_transect_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_transect_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationTransectCalculation object"""

        parts = ['* RadiationTransect']

        parts.append('* FlameResult')
        parts.append(f'flame_result:	{str(self.flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlammableOutputConfig')
        parts.append(f'flammable_output_config:	{str(self.flammable_output_config)}')
        parts.extend(['radiation_records_element' for radiation_records_element in self.radiation_records] if self.radiation_records else [f'radiation_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationTransectCalculationResponseSchema(Schema):
    """Schema for the RadiationTransectCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation_records = fields.Nested(RadiationRecordSchema, allow_none=True, many=True, data_key="radiationRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_transect_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationTransectCalculationResponseSchema class."""

        return _RadiationTransectCalculationResponse(**data)

class _RadiationTransectCalculationResponse(_CalculationResponseBase):
    """
    _RadiationTransectCalculationResponse class.

    Attributes
    ----------
        radiation_records : list[RadiationRecord]
              an array of radiation records along transect.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, radiation_records: list[RadiationRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationTransectCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.radiation_records = radiation_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _RadiationTransectForPoolFiresCalculationRequest(_CalculationRequestBase):
    """
    _RadiationTransectForPoolFiresCalculationRequest class.

    Attributes
    ----------
        pool_fire_flame_result : PoolFireFlameResult
             Pool fire flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    """
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the _RadiationTransectForPoolFiresCalculationRequest class"""

        super().__init__()

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

class _RadiationTransectForPoolFiresCalculationRequestSchema(Schema):
    """Schema for the RadiationTransectForPoolFires calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    flame_record_count = fields.Int(data_key="flameRecordCount")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    flammable_output_config = fields.Nested(FlammableOutputConfigSchema, data_key="flammableOutputConfig")

    @post_load
    def make_radiation_transect_for_pool_fires_calculation_request(self, data, **kwargs):
        """Post-processing of the RadiationTransectForPoolFiresCalculationRequestSchema class."""

        return _RadiationTransectForPoolFiresCalculationRequest(**data)

class RadiationTransectForPoolFiresCalculation(_CalculationBase):
    """
    RadiationTransectForPoolFiresCalculation class.

    Attributes
    ----------
    Calculation inputs:
        pool_fire_flame_result : PoolFireFlameResult
             Pool fire flame results.
        flame_records : list[FlameRecord]
              an array of flame records.
        flame_record_count : int
             Number of flame records.
        weather : Weather
              a weather entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        flammable_output_config : FlammableOutputConfig
              a flammable output config entity.

    Calculation outputs:
        radiation_records : list[RadiationRecord]
              an array of radiation records along transect.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], flame_record_count: int, weather: Weather, flammable_parameters: FlammableParameters, flammable_output_config: FlammableOutputConfig):
        """Initializes a new instance of the RadiationTransectForPoolFiresCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.flame_record_count = flame_record_count
        self.weather = weather
        self.flammable_parameters = flammable_parameters
        self.flammable_output_config = flammable_output_config

        # Calculation outputs.
        self.radiation_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        RadiationTransectForPoolFiresCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _RadiationTransectForPoolFiresCalculationRequest object.
        radiation_transect_for_pool_fires_calculation_request = _RadiationTransectForPoolFiresCalculationRequest(self.pool_fire_flame_result, self.flame_records, self.flame_record_count, self.weather, self.flammable_parameters, self.flammable_output_config)

        # Get the _RadiationTransectForPoolFiresCalculationRequestSchema and use that to serialize to json.
        radiation_transect_for_pool_fires_calculation_request_schema = _RadiationTransectForPoolFiresCalculationRequestSchema()

        request_json = radiation_transect_for_pool_fires_calculation_request_schema.dumps(radiation_transect_for_pool_fires_calculation_request)
        url = get_analytics_api_target() + 'calculateradiationtransectforpoolfires?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            radiation_transect_for_pool_fires_calculation_response_schema = _RadiationTransectForPoolFiresCalculationResponseSchema()
            radiation_transect_for_pool_fires_calculation_response = radiation_transect_for_pool_fires_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(radiation_transect_for_pool_fires_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.radiation_records = radiation_transect_for_pool_fires_calculation_response.radiation_records
                self.result_code = radiation_transect_for_pool_fires_calculation_response.result_code
                self.messages = radiation_transect_for_pool_fires_calculation_response.messages
                self.calculation_elapsed_time = radiation_transect_for_pool_fires_calculation_response.calculation_elapsed_time
                self.operation_id = radiation_transect_for_pool_fires_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(radiation_transect_for_pool_fires_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the RadiationTransectForPoolFiresCalculation object"""

        parts = ['* RadiationTransectForPoolFires']

        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'flame_record_count:	{str(self.flame_record_count)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* FlammableOutputConfig')
        parts.append(f'flammable_output_config:	{str(self.flammable_output_config)}')
        parts.extend(['radiation_records_element' for radiation_records_element in self.radiation_records] if self.radiation_records else [f'radiation_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _RadiationTransectForPoolFiresCalculationResponseSchema(Schema):
    """Schema for the RadiationTransectForPoolFiresCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    radiation_records = fields.Nested(RadiationRecordSchema, allow_none=True, many=True, data_key="radiationRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_radiation_transect_for_pool_fires_calculation_response(self, data, **kwargs):
        """Post-processing of the RadiationTransectForPoolFiresCalculationResponseSchema class."""

        return _RadiationTransectForPoolFiresCalculationResponse(**data)

class _RadiationTransectForPoolFiresCalculationResponse(_CalculationResponseBase):
    """
    _RadiationTransectForPoolFiresCalculationResponse class.

    Attributes
    ----------
        radiation_records : list[RadiationRecord]
              an array of radiation records along transect.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, radiation_records: list[RadiationRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the RadiationTransectForPoolFiresCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.radiation_records = radiation_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _ReliefValveMinTemperatureCalculationRequest(_CalculationRequestBase):
    """
    _ReliefValveMinTemperatureCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity.
        pressure : float
             Input pressure (absolute) at which to evaluate bubble point temperature.

    """
    def __init__(self, material: Material, pressure: float):
        """Initializes a new instance of the _ReliefValveMinTemperatureCalculationRequest class"""

        super().__init__()

        self.material = material
        self.pressure = pressure

class _ReliefValveMinTemperatureCalculationRequestSchema(Schema):
    """Schema for the ReliefValveMinTemperature calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    pressure = fields.Float(data_key="pressure")

    @post_load
    def make_relief_valve_min_temperature_calculation_request(self, data, **kwargs):
        """Post-processing of the ReliefValveMinTemperatureCalculationRequestSchema class."""

        return _ReliefValveMinTemperatureCalculationRequest(**data)

class ReliefValveMinTemperatureCalculation(_CalculationBase):
    """
    ReliefValveMinTemperatureCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity.
        pressure : float
             Input pressure (absolute) at which to evaluate bubble point temperature.

    Calculation outputs:
        min_temperature : float
             Calculated lower temperature limit for relief valve scenario.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, pressure: float):
        """Initializes a new instance of the ReliefValveMinTemperatureCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.pressure = pressure

        # Calculation outputs.
        self.min_temperature = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        ReliefValveMinTemperatureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _ReliefValveMinTemperatureCalculationRequest object.
        relief_valve_min_temperature_calculation_request = _ReliefValveMinTemperatureCalculationRequest(self.material, self.pressure)

        # Get the _ReliefValveMinTemperatureCalculationRequestSchema and use that to serialize to json.
        relief_valve_min_temperature_calculation_request_schema = _ReliefValveMinTemperatureCalculationRequestSchema()

        request_json = relief_valve_min_temperature_calculation_request_schema.dumps(relief_valve_min_temperature_calculation_request)
        url = get_analytics_api_target() + 'utilities/reliefvalvemintemperature?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            relief_valve_min_temperature_calculation_response_schema = _ReliefValveMinTemperatureCalculationResponseSchema()
            relief_valve_min_temperature_calculation_response = relief_valve_min_temperature_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(relief_valve_min_temperature_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.min_temperature = relief_valve_min_temperature_calculation_response.min_temperature
                self.result_code = relief_valve_min_temperature_calculation_response.result_code
                self.messages = relief_valve_min_temperature_calculation_response.messages
                self.calculation_elapsed_time = relief_valve_min_temperature_calculation_response.calculation_elapsed_time
                self.operation_id = relief_valve_min_temperature_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(relief_valve_min_temperature_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the ReliefValveMinTemperatureCalculation object"""

        parts = ['* ReliefValveMinTemperature']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append(f'pressure:	{str(self.pressure)}')
        parts.append(f'min_temperature:	{str(self.min_temperature)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _ReliefValveMinTemperatureCalculationResponseSchema(Schema):
    """Schema for the ReliefValveMinTemperatureCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    min_temperature = fields.Float(data_key="minTemperature")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_relief_valve_min_temperature_calculation_response(self, data, **kwargs):
        """Post-processing of the ReliefValveMinTemperatureCalculationResponseSchema class."""

        return _ReliefValveMinTemperatureCalculationResponse(**data)

class _ReliefValveMinTemperatureCalculationResponse(_CalculationResponseBase):
    """
    _ReliefValveMinTemperatureCalculationResponse class.

    Attributes
    ----------
        min_temperature : float
             Calculated lower temperature limit for relief valve scenario.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, min_temperature: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the ReliefValveMinTemperatureCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.min_temperature = min_temperature
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _SetMixingLayerHeightCalculationRequest(_CalculationRequestBase):
    """
    _SetMixingLayerHeightCalculationRequest class.

    Attributes
    ----------
        weather : Weather
              a weather entity.

    """
    def __init__(self, weather: Weather):
        """Initializes a new instance of the _SetMixingLayerHeightCalculationRequest class"""

        super().__init__()

        self.weather = weather

class _SetMixingLayerHeightCalculationRequestSchema(Schema):
    """Schema for the SetMixingLayerHeight calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    weather = fields.Nested(WeatherSchema, data_key="weather")

    @post_load
    def make_set_mixing_layer_height_calculation_request(self, data, **kwargs):
        """Post-processing of the SetMixingLayerHeightCalculationRequestSchema class."""

        return _SetMixingLayerHeightCalculationRequest(**data)

class SetMixingLayerHeightCalculation(_CalculationBase):
    """
    SetMixingLayerHeightCalculation class.

    Attributes
    ----------
    Calculation inputs:
        weather : Weather
              a weather entity.

    Calculation outputs:
        updated_weather : Weather
             Updated weather entity.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, weather: Weather):
        """Initializes a new instance of the SetMixingLayerHeightCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.weather = weather

        # Calculation outputs.
        self.updated_weather = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        SetMixingLayerHeightCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetMixingLayerHeightCalculationRequest object.
        set_mixing_layer_height_calculation_request = _SetMixingLayerHeightCalculationRequest(self.weather)

        # Get the _SetMixingLayerHeightCalculationRequestSchema and use that to serialize to json.
        set_mixing_layer_height_calculation_request_schema = _SetMixingLayerHeightCalculationRequestSchema()

        request_json = set_mixing_layer_height_calculation_request_schema.dumps(set_mixing_layer_height_calculation_request)
        url = get_analytics_api_target() + 'utilities/SetMixingLayerHeight?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            set_mixing_layer_height_calculation_response_schema = _SetMixingLayerHeightCalculationResponseSchema()
            set_mixing_layer_height_calculation_response = set_mixing_layer_height_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(set_mixing_layer_height_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.updated_weather = set_mixing_layer_height_calculation_response.updated_weather
                self.result_code = set_mixing_layer_height_calculation_response.result_code
                self.messages = set_mixing_layer_height_calculation_response.messages
                self.calculation_elapsed_time = set_mixing_layer_height_calculation_response.calculation_elapsed_time
                self.operation_id = set_mixing_layer_height_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(set_mixing_layer_height_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the SetMixingLayerHeightCalculation object"""

        parts = ['* SetMixingLayerHeight']

        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* Weather')
        parts.append(f'updated_weather:	{str(self.updated_weather)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _SetMixingLayerHeightCalculationResponseSchema(Schema):
    """Schema for the SetMixingLayerHeightCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    updated_weather = fields.Nested(WeatherSchema, data_key="updatedWeather")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_set_mixing_layer_height_calculation_response(self, data, **kwargs):
        """Post-processing of the SetMixingLayerHeightCalculationResponseSchema class."""

        return _SetMixingLayerHeightCalculationResponse(**data)

class _SetMixingLayerHeightCalculationResponse(_CalculationResponseBase):
    """
    _SetMixingLayerHeightCalculationResponse class.

    Attributes
    ----------
        updated_weather : Weather
             Updated weather entity.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, updated_weather: Weather, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the SetMixingLayerHeightCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.updated_weather = updated_weather
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _SetPhaseToReleaseForLeakScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetPhaseToReleaseForLeakScenarioCalculationRequest class.

    Attributes
    ----------
        phase_to_release : Phase
             Requested fluid phase to release.
        release_elevation : float
             Release point elevation above ground.
        vessel : Vessel
              a vessel entity.

    """
    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the _SetPhaseToReleaseForLeakScenarioCalculationRequest class"""

        super().__init__()

        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

class _SetPhaseToReleaseForLeakScenarioCalculationRequestSchema(Schema):
    """Schema for the SetPhaseToReleaseForLeakScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    phase_to_release = fields.Enum(Phase, by_value=True, data_key="phaseToRelease")
    release_elevation = fields.Float(data_key="releaseElevation")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_phase_to_release_for_leak_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLeakScenarioCalculationRequestSchema class."""

        return _SetPhaseToReleaseForLeakScenarioCalculationRequest(**data)

class SetPhaseToReleaseForLeakScenarioCalculation(_CalculationBase):
    """
    SetPhaseToReleaseForLeakScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        phase_to_release : Phase
             Requested fluid phase to release.
        release_elevation : float
             Release point elevation above ground.
        vessel : Vessel
              a vessel entity.

    Calculation outputs:
        z_coord_updated : float
             Updated z-coordinate of vessel to accommodate requested phase to release.
        hole_height_fraction_updated : float
             Updated hole height fraction to accommodate requested phase to release.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the SetPhaseToReleaseForLeakScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

        # Calculation outputs.
        self.z_coord_updated = None
        self.hole_height_fraction_updated = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        SetPhaseToReleaseForLeakScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetPhaseToReleaseForLeakScenarioCalculationRequest object.
        set_phase_to_release_for_leak_scenario_calculation_request = _SetPhaseToReleaseForLeakScenarioCalculationRequest(self.phase_to_release, self.release_elevation, self.vessel)

        # Get the _SetPhaseToReleaseForLeakScenarioCalculationRequestSchema and use that to serialize to json.
        set_phase_to_release_for_leak_scenario_calculation_request_schema = _SetPhaseToReleaseForLeakScenarioCalculationRequestSchema()

        request_json = set_phase_to_release_for_leak_scenario_calculation_request_schema.dumps(set_phase_to_release_for_leak_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setphasetoreleaseforleakscenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            set_phase_to_release_for_leak_scenario_calculation_response_schema = _SetPhaseToReleaseForLeakScenarioCalculationResponseSchema()
            set_phase_to_release_for_leak_scenario_calculation_response = set_phase_to_release_for_leak_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(set_phase_to_release_for_leak_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.z_coord_updated = set_phase_to_release_for_leak_scenario_calculation_response.z_coord_updated
                self.hole_height_fraction_updated = set_phase_to_release_for_leak_scenario_calculation_response.hole_height_fraction_updated
                self.result_code = set_phase_to_release_for_leak_scenario_calculation_response.result_code
                self.messages = set_phase_to_release_for_leak_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_phase_to_release_for_leak_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = set_phase_to_release_for_leak_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(set_phase_to_release_for_leak_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the SetPhaseToReleaseForLeakScenarioCalculation object"""

        parts = ['* SetPhaseToReleaseForLeakScenario']

        parts.append(f'phase_to_release:	{str(self.phase_to_release)}')
        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append(f'z_coord_updated:	{str(self.z_coord_updated)}')
        parts.append(f'hole_height_fraction_updated:	{str(self.hole_height_fraction_updated)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _SetPhaseToReleaseForLeakScenarioCalculationResponseSchema(Schema):
    """Schema for the SetPhaseToReleaseForLeakScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    z_coord_updated = fields.Float(data_key="zCoordUpdated")
    hole_height_fraction_updated = fields.Float(data_key="holeHeightFractionUpdated")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_set_phase_to_release_for_leak_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLeakScenarioCalculationResponseSchema class."""

        return _SetPhaseToReleaseForLeakScenarioCalculationResponse(**data)

class _SetPhaseToReleaseForLeakScenarioCalculationResponse(_CalculationResponseBase):
    """
    _SetPhaseToReleaseForLeakScenarioCalculationResponse class.

    Attributes
    ----------
        z_coord_updated : float
             Updated z-coordinate of vessel to accommodate requested phase to release.
        hole_height_fraction_updated : float
             Updated hole height fraction to accommodate requested phase to release.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, z_coord_updated: float, hole_height_fraction_updated: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the SetPhaseToReleaseForLeakScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.z_coord_updated = z_coord_updated
        self.hole_height_fraction_updated = hole_height_fraction_updated
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest class.

    Attributes
    ----------
        phase_to_release : Phase
             Requested fluid phase to release.
        release_elevation : float
             Release point elevation above ground.
        vessel : Vessel
              a vessel entity.

    """
    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest class"""

        super().__init__()

        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

class _SetPhaseToReleaseForLineRuptureScenarioCalculationRequestSchema(Schema):
    """Schema for the SetPhaseToReleaseForLineRuptureScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    phase_to_release = fields.Enum(Phase, by_value=True, data_key="phaseToRelease")
    release_elevation = fields.Float(data_key="releaseElevation")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_phase_to_release_for_line_rupture_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLineRuptureScenarioCalculationRequestSchema class."""

        return _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest(**data)

class SetPhaseToReleaseForLineRuptureScenarioCalculation(_CalculationBase):
    """
    SetPhaseToReleaseForLineRuptureScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        phase_to_release : Phase
             Requested fluid phase to release.
        release_elevation : float
             Release point elevation above ground.
        vessel : Vessel
              a vessel entity.

    Calculation outputs:
        z_coord_updated : float
             Updated z-coordinate of vessel to accommodate requested phase to release.
        pipe_height_fraction_updated : float
             Updated pipe height fraction to accommodate requested phase to release.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the SetPhaseToReleaseForLineRuptureScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

        # Calculation outputs.
        self.z_coord_updated = None
        self.pipe_height_fraction_updated = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        SetPhaseToReleaseForLineRuptureScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest object.
        set_phase_to_release_for_line_rupture_scenario_calculation_request = _SetPhaseToReleaseForLineRuptureScenarioCalculationRequest(self.phase_to_release, self.release_elevation, self.vessel)

        # Get the _SetPhaseToReleaseForLineRuptureScenarioCalculationRequestSchema and use that to serialize to json.
        set_phase_to_release_for_line_rupture_scenario_calculation_request_schema = _SetPhaseToReleaseForLineRuptureScenarioCalculationRequestSchema()

        request_json = set_phase_to_release_for_line_rupture_scenario_calculation_request_schema.dumps(set_phase_to_release_for_line_rupture_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setphasetoreleaseforlinerupturescenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            set_phase_to_release_for_line_rupture_scenario_calculation_response_schema = _SetPhaseToReleaseForLineRuptureScenarioCalculationResponseSchema()
            set_phase_to_release_for_line_rupture_scenario_calculation_response = set_phase_to_release_for_line_rupture_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(set_phase_to_release_for_line_rupture_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.z_coord_updated = set_phase_to_release_for_line_rupture_scenario_calculation_response.z_coord_updated
                self.pipe_height_fraction_updated = set_phase_to_release_for_line_rupture_scenario_calculation_response.pipe_height_fraction_updated
                self.result_code = set_phase_to_release_for_line_rupture_scenario_calculation_response.result_code
                self.messages = set_phase_to_release_for_line_rupture_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_phase_to_release_for_line_rupture_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = set_phase_to_release_for_line_rupture_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(set_phase_to_release_for_line_rupture_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the SetPhaseToReleaseForLineRuptureScenarioCalculation object"""

        parts = ['* SetPhaseToReleaseForLineRuptureScenario']

        parts.append(f'phase_to_release:	{str(self.phase_to_release)}')
        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append(f'z_coord_updated:	{str(self.z_coord_updated)}')
        parts.append(f'pipe_height_fraction_updated:	{str(self.pipe_height_fraction_updated)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _SetPhaseToReleaseForLineRuptureScenarioCalculationResponseSchema(Schema):
    """Schema for the SetPhaseToReleaseForLineRuptureScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    z_coord_updated = fields.Float(data_key="zCoordUpdated")
    pipe_height_fraction_updated = fields.Float(data_key="pipeHeightFractionUpdated")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_set_phase_to_release_for_line_rupture_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForLineRuptureScenarioCalculationResponseSchema class."""

        return _SetPhaseToReleaseForLineRuptureScenarioCalculationResponse(**data)

class _SetPhaseToReleaseForLineRuptureScenarioCalculationResponse(_CalculationResponseBase):
    """
    _SetPhaseToReleaseForLineRuptureScenarioCalculationResponse class.

    Attributes
    ----------
        z_coord_updated : float
             Updated z-coordinate of vessel to accommodate requested phase to release.
        pipe_height_fraction_updated : float
             Updated pipe height fraction to accommodate requested phase to release.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, z_coord_updated: float, pipe_height_fraction_updated: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the SetPhaseToReleaseForLineRuptureScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.z_coord_updated = z_coord_updated
        self.pipe_height_fraction_updated = pipe_height_fraction_updated
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _SetPhaseToReleaseForReliefValveScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetPhaseToReleaseForReliefValveScenarioCalculationRequest class.

    Attributes
    ----------
        phase_to_release : Phase
             Requested fluid phase to release.
        release_elevation : float
             Release point elevation above ground.
        vessel : Vessel
              a vessel entity.

    """
    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the _SetPhaseToReleaseForReliefValveScenarioCalculationRequest class"""

        super().__init__()

        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

class _SetPhaseToReleaseForReliefValveScenarioCalculationRequestSchema(Schema):
    """Schema for the SetPhaseToReleaseForReliefValveScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    phase_to_release = fields.Enum(Phase, by_value=True, data_key="phaseToRelease")
    release_elevation = fields.Float(data_key="releaseElevation")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_phase_to_release_for_relief_valve_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForReliefValveScenarioCalculationRequestSchema class."""

        return _SetPhaseToReleaseForReliefValveScenarioCalculationRequest(**data)

class SetPhaseToReleaseForReliefValveScenarioCalculation(_CalculationBase):
    """
    SetPhaseToReleaseForReliefValveScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        phase_to_release : Phase
             Requested fluid phase to release.
        release_elevation : float
             Release point elevation above ground.
        vessel : Vessel
              a vessel entity.

    Calculation outputs:
        z_coord_updated : float
             Updated z-coordinate of vessel to accommodate requested phase to release.
        pipe_height_fraction_updated : float
             Updated pipe height fraction to accommodate requested phase to release.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, phase_to_release: Phase, release_elevation: float, vessel: Vessel):
        """Initializes a new instance of the SetPhaseToReleaseForReliefValveScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.phase_to_release = phase_to_release
        self.release_elevation = release_elevation
        self.vessel = vessel

        # Calculation outputs.
        self.z_coord_updated = None
        self.pipe_height_fraction_updated = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        SetPhaseToReleaseForReliefValveScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetPhaseToReleaseForReliefValveScenarioCalculationRequest object.
        set_phase_to_release_for_relief_valve_scenario_calculation_request = _SetPhaseToReleaseForReliefValveScenarioCalculationRequest(self.phase_to_release, self.release_elevation, self.vessel)

        # Get the _SetPhaseToReleaseForReliefValveScenarioCalculationRequestSchema and use that to serialize to json.
        set_phase_to_release_for_relief_valve_scenario_calculation_request_schema = _SetPhaseToReleaseForReliefValveScenarioCalculationRequestSchema()

        request_json = set_phase_to_release_for_relief_valve_scenario_calculation_request_schema.dumps(set_phase_to_release_for_relief_valve_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/setphasetoreleaseforreliefvalvescenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            set_phase_to_release_for_relief_valve_scenario_calculation_response_schema = _SetPhaseToReleaseForReliefValveScenarioCalculationResponseSchema()
            set_phase_to_release_for_relief_valve_scenario_calculation_response = set_phase_to_release_for_relief_valve_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(set_phase_to_release_for_relief_valve_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.z_coord_updated = set_phase_to_release_for_relief_valve_scenario_calculation_response.z_coord_updated
                self.pipe_height_fraction_updated = set_phase_to_release_for_relief_valve_scenario_calculation_response.pipe_height_fraction_updated
                self.result_code = set_phase_to_release_for_relief_valve_scenario_calculation_response.result_code
                self.messages = set_phase_to_release_for_relief_valve_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_phase_to_release_for_relief_valve_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = set_phase_to_release_for_relief_valve_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(set_phase_to_release_for_relief_valve_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the SetPhaseToReleaseForReliefValveScenarioCalculation object"""

        parts = ['* SetPhaseToReleaseForReliefValveScenario']

        parts.append(f'phase_to_release:	{str(self.phase_to_release)}')
        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append(f'z_coord_updated:	{str(self.z_coord_updated)}')
        parts.append(f'pipe_height_fraction_updated:	{str(self.pipe_height_fraction_updated)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _SetPhaseToReleaseForReliefValveScenarioCalculationResponseSchema(Schema):
    """Schema for the SetPhaseToReleaseForReliefValveScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    z_coord_updated = fields.Float(data_key="zCoordUpdated")
    pipe_height_fraction_updated = fields.Float(data_key="pipeHeightFractionUpdated")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_set_phase_to_release_for_relief_valve_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetPhaseToReleaseForReliefValveScenarioCalculationResponseSchema class."""

        return _SetPhaseToReleaseForReliefValveScenarioCalculationResponse(**data)

class _SetPhaseToReleaseForReliefValveScenarioCalculationResponse(_CalculationResponseBase):
    """
    _SetPhaseToReleaseForReliefValveScenarioCalculationResponse class.

    Attributes
    ----------
        z_coord_updated : float
             Updated z-coordinate of vessel to accommodate requested phase to release.
        pipe_height_fraction_updated : float
             Updated pipe height fraction to accommodate requested phase to release.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, z_coord_updated: float, pipe_height_fraction_updated: float, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the SetPhaseToReleaseForReliefValveScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.z_coord_updated = z_coord_updated
        self.pipe_height_fraction_updated = pipe_height_fraction_updated
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _SetReleaseElevationForScenarioCalculationRequest(_CalculationRequestBase):
    """
    _SetReleaseElevationForScenarioCalculationRequest class.

    Attributes
    ----------
        release_elevation : float
             Release point elevation above ground.
        release_height_fraction : float
             Release height fraction of the total vessel height.
        vessel : Vessel
              a vessel entity.

    """
    def __init__(self, release_elevation: float, release_height_fraction: float, vessel: Vessel):
        """Initializes a new instance of the _SetReleaseElevationForScenarioCalculationRequest class"""

        super().__init__()

        self.release_elevation = release_elevation
        self.release_height_fraction = release_height_fraction
        self.vessel = vessel

class _SetReleaseElevationForScenarioCalculationRequestSchema(Schema):
    """Schema for the SetReleaseElevationForScenario calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    release_elevation = fields.Float(data_key="releaseElevation")
    release_height_fraction = fields.Float(data_key="releaseHeightFraction")
    vessel = fields.Nested(VesselSchema, data_key="vessel")

    @post_load
    def make_set_release_elevation_for_scenario_calculation_request(self, data, **kwargs):
        """Post-processing of the SetReleaseElevationForScenarioCalculationRequestSchema class."""

        return _SetReleaseElevationForScenarioCalculationRequest(**data)

class SetReleaseElevationForScenarioCalculation(_CalculationBase):
    """
    SetReleaseElevationForScenarioCalculation class.

    Attributes
    ----------
    Calculation inputs:
        release_elevation : float
             Release point elevation above ground.
        release_height_fraction : float
             Release height fraction of the total vessel height.
        vessel : Vessel
              a vessel entity.

    Calculation outputs:
        updated_vessel : Vessel
             Updated vessel entity with modified z coordinate.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, release_elevation: float, release_height_fraction: float, vessel: Vessel):
        """Initializes a new instance of the SetReleaseElevationForScenarioCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.release_elevation = release_elevation
        self.release_height_fraction = release_height_fraction
        self.vessel = vessel

        # Calculation outputs.
        self.updated_vessel = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        SetReleaseElevationForScenarioCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SetReleaseElevationForScenarioCalculationRequest object.
        set_release_elevation_for_scenario_calculation_request = _SetReleaseElevationForScenarioCalculationRequest(self.release_elevation, self.release_height_fraction, self.vessel)

        # Get the _SetReleaseElevationForScenarioCalculationRequestSchema and use that to serialize to json.
        set_release_elevation_for_scenario_calculation_request_schema = _SetReleaseElevationForScenarioCalculationRequestSchema()

        request_json = set_release_elevation_for_scenario_calculation_request_schema.dumps(set_release_elevation_for_scenario_calculation_request)
        url = get_analytics_api_target() + 'utilities/SetReleaseElevationForScenario?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            set_release_elevation_for_scenario_calculation_response_schema = _SetReleaseElevationForScenarioCalculationResponseSchema()
            set_release_elevation_for_scenario_calculation_response = set_release_elevation_for_scenario_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(set_release_elevation_for_scenario_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.updated_vessel = set_release_elevation_for_scenario_calculation_response.updated_vessel
                self.result_code = set_release_elevation_for_scenario_calculation_response.result_code
                self.messages = set_release_elevation_for_scenario_calculation_response.messages
                self.calculation_elapsed_time = set_release_elevation_for_scenario_calculation_response.calculation_elapsed_time
                self.operation_id = set_release_elevation_for_scenario_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(set_release_elevation_for_scenario_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the SetReleaseElevationForScenarioCalculation object"""

        parts = ['* SetReleaseElevationForScenario']

        parts.append(f'release_elevation:	{str(self.release_elevation)}')
        parts.append(f'release_height_fraction:	{str(self.release_height_fraction)}')
        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* Vessel')
        parts.append(f'updated_vessel:	{str(self.updated_vessel)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _SetReleaseElevationForScenarioCalculationResponseSchema(Schema):
    """Schema for the SetReleaseElevationForScenarioCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    updated_vessel = fields.Nested(VesselSchema, data_key="updatedVessel")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_set_release_elevation_for_scenario_calculation_response(self, data, **kwargs):
        """Post-processing of the SetReleaseElevationForScenarioCalculationResponseSchema class."""

        return _SetReleaseElevationForScenarioCalculationResponse(**data)

class _SetReleaseElevationForScenarioCalculationResponse(_CalculationResponseBase):
    """
    _SetReleaseElevationForScenarioCalculationResponse class.

    Attributes
    ----------
        updated_vessel : Vessel
             Updated vessel entity with modified z coordinate.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, updated_vessel: Vessel, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the SetReleaseElevationForScenarioCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.updated_vessel = updated_vessel
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _SideviewAtTimeCalculationRequest(_CalculationRequestBase):
    """
    _SideviewAtTimeCalculationRequest class.

    Attributes
    ----------
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion outputs.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    """
    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the _SideviewAtTimeCalculationRequest class"""

        super().__init__()

        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

class _SideviewAtTimeCalculationRequestSchema(Schema):
    """Schema for the SideviewAtTime calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    scalar_udm_outputs = fields.Nested(ScalarUdmOutputsSchema, data_key="scalarUdmOutputs")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_records = fields.Nested(DispersionRecordSchema, allow_none=True, many=True, data_key="dispersionRecords")
    dispersion_record_count = fields.Int(data_key="dispersionRecordCount")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")
    material = fields.Nested(MaterialSchema, data_key="material")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")

    @post_load
    def make_sideview_at_time_calculation_request(self, data, **kwargs):
        """Post-processing of the SideviewAtTimeCalculationRequestSchema class."""

        return _SideviewAtTimeCalculationRequest(**data)

class SideviewAtTimeCalculation(_CalculationBase):
    """
    SideviewAtTimeCalculation class.

    Attributes
    ----------
    Calculation inputs:
        scalar_udm_outputs : ScalarUdmOutputs
             Scalar dispersion outputs.
        weather : Weather
              a weather entity.
        dispersion_records : list[DispersionRecord]
              an array of dispersion records.
        dispersion_record_count : int
             Number of dispersion records.
        substrate : Substrate
              a substrate entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity.
        material : Material
              a material entity with post-discharge composition.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.

    Calculation outputs:
        conc_used : float
             Concentration of interest.
        contour_points : list[LocalPosition]
              an array of points along the sideview contour.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, scalar_udm_outputs: ScalarUdmOutputs, weather: Weather, dispersion_records: list[DispersionRecord], dispersion_record_count: int, substrate: Substrate, dispersion_output_config: DispersionOutputConfig, material: Material, dispersion_parameters: DispersionParameters):
        """Initializes a new instance of the SideviewAtTimeCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.scalar_udm_outputs = scalar_udm_outputs
        self.weather = weather
        self.dispersion_records = dispersion_records
        self.dispersion_record_count = dispersion_record_count
        self.substrate = substrate
        self.dispersion_output_config = dispersion_output_config
        self.material = material
        self.dispersion_parameters = dispersion_parameters

        # Calculation outputs.
        self.conc_used = None
        self.contour_points = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        SideviewAtTimeCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _SideviewAtTimeCalculationRequest object.
        sideview_at_time_calculation_request = _SideviewAtTimeCalculationRequest(self.scalar_udm_outputs, self.weather, self.dispersion_records, self.dispersion_record_count, self.substrate, self.dispersion_output_config, self.material, self.dispersion_parameters)

        # Get the _SideviewAtTimeCalculationRequestSchema and use that to serialize to json.
        sideview_at_time_calculation_request_schema = _SideviewAtTimeCalculationRequestSchema()

        request_json = sideview_at_time_calculation_request_schema.dumps(sideview_at_time_calculation_request)
        url = get_analytics_api_target() + 'calculatesideviewattime?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            sideview_at_time_calculation_response_schema = _SideviewAtTimeCalculationResponseSchema()
            sideview_at_time_calculation_response = sideview_at_time_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(sideview_at_time_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.conc_used = sideview_at_time_calculation_response.conc_used
                self.contour_points = sideview_at_time_calculation_response.contour_points
                self.result_code = sideview_at_time_calculation_response.result_code
                self.messages = sideview_at_time_calculation_response.messages
                self.calculation_elapsed_time = sideview_at_time_calculation_response.calculation_elapsed_time
                self.operation_id = sideview_at_time_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(sideview_at_time_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the SideviewAtTimeCalculation object"""

        parts = ['* SideviewAtTime']

        parts.append('* ScalarUdmOutputs')
        parts.append(f'scalar_udm_outputs:	{str(self.scalar_udm_outputs)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_records_element' for dispersion_records_element in self.dispersion_records] if self.dispersion_records else [f'dispersion_records does not contain any elements'])
        parts.append(f'dispersion_record_count:	{str(self.dispersion_record_count)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append(f'conc_used:	{str(self.conc_used)}')
        parts.extend(['contour_points_element' for contour_points_element in self.contour_points] if self.contour_points else [f'contour_points does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _SideviewAtTimeCalculationResponseSchema(Schema):
    """Schema for the SideviewAtTimeCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    conc_used = fields.Float(data_key="concUsed")
    contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="contourPoints")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_sideview_at_time_calculation_response(self, data, **kwargs):
        """Post-processing of the SideviewAtTimeCalculationResponseSchema class."""

        return _SideviewAtTimeCalculationResponse(**data)

class _SideviewAtTimeCalculationResponse(_CalculationResponseBase):
    """
    _SideviewAtTimeCalculationResponse class.

    Attributes
    ----------
        conc_used : float
             Concentration of interest.
        contour_points : list[LocalPosition]
              an array of points along the sideview contour.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, conc_used: float, contour_points: list[LocalPosition], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the SideviewAtTimeCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.conc_used = conc_used
        self.contour_points = contour_points
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _TankFireCalculationRequest(_CalculationRequestBase):
    """
    _TankFireCalculationRequest class.

    Attributes
    ----------
        atmospheric_storage_tank : AtmosphericStorageTank
              an atmospheric storage tank entity.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.

    """
    def __init__(self, atmospheric_storage_tank: AtmosphericStorageTank, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the _TankFireCalculationRequest class"""

        super().__init__()

        self.atmospheric_storage_tank = atmospheric_storage_tank
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

class _TankFireCalculationRequestSchema(Schema):
    """Schema for the TankFire calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    atmospheric_storage_tank = fields.Nested(AtmosphericStorageTankSchema, data_key="atmosphericStorageTank")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")

    @post_load
    def make_tank_fire_calculation_request(self, data, **kwargs):
        """Post-processing of the TankFireCalculationRequestSchema class."""

        return _TankFireCalculationRequest(**data)

class TankFireCalculation(_CalculationBase):
    """
    TankFireCalculation class.

    Attributes
    ----------
    Calculation inputs:
        atmospheric_storage_tank : AtmosphericStorageTank
              an atmospheric storage tank entity.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        flammable_parameters : FlammableParameters
              a flammable parameters entity.

    Calculation outputs:
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of pool fire flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, atmospheric_storage_tank: AtmosphericStorageTank, weather: Weather, substrate: Substrate, flammable_parameters: FlammableParameters):
        """Initializes a new instance of the TankFireCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.atmospheric_storage_tank = atmospheric_storage_tank
        self.weather = weather
        self.substrate = substrate
        self.flammable_parameters = flammable_parameters

        # Calculation outputs.
        self.pool_fire_flame_result = None
        self.flame_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        TankFireCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _TankFireCalculationRequest object.
        tank_fire_calculation_request = _TankFireCalculationRequest(self.atmospheric_storage_tank, self.weather, self.substrate, self.flammable_parameters)

        # Get the _TankFireCalculationRequestSchema and use that to serialize to json.
        tank_fire_calculation_request_schema = _TankFireCalculationRequestSchema()

        request_json = tank_fire_calculation_request_schema.dumps(tank_fire_calculation_request)
        url = get_analytics_api_target() + 'calculatetankfire?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            tank_fire_calculation_response_schema = _TankFireCalculationResponseSchema()
            tank_fire_calculation_response = tank_fire_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(tank_fire_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.pool_fire_flame_result = tank_fire_calculation_response.pool_fire_flame_result
                self.flame_records = tank_fire_calculation_response.flame_records
                self.result_code = tank_fire_calculation_response.result_code
                self.messages = tank_fire_calculation_response.messages
                self.calculation_elapsed_time = tank_fire_calculation_response.calculation_elapsed_time
                self.operation_id = tank_fire_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(tank_fire_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the TankFireCalculation object"""

        parts = ['* TankFire']

        parts.append('* AtmosphericStorageTank')
        parts.append(f'atmospheric_storage_tank:	{str(self.atmospheric_storage_tank)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.extend(['flame_records_element' for flame_records_element in self.flame_records] if self.flame_records else [f'flame_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _TankFireCalculationResponseSchema(Schema):
    """Schema for the TankFireCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    flame_records = fields.Nested(FlameRecordSchema, allow_none=True, many=True, data_key="flameRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_tank_fire_calculation_response(self, data, **kwargs):
        """Post-processing of the TankFireCalculationResponseSchema class."""

        return _TankFireCalculationResponse(**data)

class _TankFireCalculationResponse(_CalculationResponseBase):
    """
    _TankFireCalculationResponse class.

    Attributes
    ----------
        pool_fire_flame_result : PoolFireFlameResult
             Scalar flame results.
        flame_records : list[FlameRecord]
              an array of pool fire flame records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, pool_fire_flame_result: PoolFireFlameResult, flame_records: list[FlameRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the TankFireCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.pool_fire_flame_result = pool_fire_flame_result
        self.flame_records = flame_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _UserDefinedSourceLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _UserDefinedSourceLinkedRunCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity.
        discharge_result : DischargeResult
             Scalar discharge data.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        discharge_record_count : int
             Number of discharge records.
        phase_to_be_released : Phase
             Phase to be released ( vapour, two-phase or liquid).
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    """
    def __init__(self, material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, phase_to_be_released: Phase, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _UserDefinedSourceLinkedRunCalculationRequest class"""

        super().__init__()

        self.material = material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.phase_to_be_released = phase_to_be_released
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

class _UserDefinedSourceLinkedRunCalculationRequestSchema(Schema):
    """Schema for the UserDefinedSourceLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    discharge_record_count = fields.Int(data_key="dischargeRecordCount")
    phase_to_be_released = fields.Enum(Phase, by_value=True, data_key="phaseToBeReleased")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_user_defined_source_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the UserDefinedSourceLinkedRunCalculationRequestSchema class."""

        return _UserDefinedSourceLinkedRunCalculationRequest(**data)

class UserDefinedSourceLinkedRunCalculation(_CalculationBase):
    """
    UserDefinedSourceLinkedRunCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity.
        discharge_result : DischargeResult
             Scalar discharge data.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        discharge_record_count : int
             Number of discharge records.
        phase_to_be_released : Phase
             Phase to be released ( vapour, two-phase or liquid).
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    Calculation outputs:
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], discharge_record_count: int, phase_to_be_released: Phase, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the UserDefinedSourceLinkedRunCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.discharge_record_count = discharge_record_count
        self.phase_to_be_released = phase_to_be_released
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.n_jet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.n_flam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.n_pool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.n_toxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        UserDefinedSourceLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _UserDefinedSourceLinkedRunCalculationRequest object.
        user_defined_source_linked_run_calculation_request = _UserDefinedSourceLinkedRunCalculationRequest(self.material, self.discharge_result, self.discharge_records, self.discharge_record_count, self.phase_to_be_released, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the _UserDefinedSourceLinkedRunCalculationRequestSchema and use that to serialize to json.
        user_defined_source_linked_run_calculation_request_schema = _UserDefinedSourceLinkedRunCalculationRequestSchema()

        request_json = user_defined_source_linked_run_calculation_request_schema.dumps(user_defined_source_linked_run_calculation_request)
        url = get_analytics_api_target() + 'userdefinedsourcelinkedrun?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            user_defined_source_linked_run_calculation_response_schema = _UserDefinedSourceLinkedRunCalculationResponseSchema()
            user_defined_source_linked_run_calculation_response = user_defined_source_linked_run_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(user_defined_source_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.distances_to_jet_fire_radiation = user_defined_source_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = user_defined_source_linked_run_calculation_response.jet_contour_points
                self.n_jet_contour_points = user_defined_source_linked_run_calculation_response.n_jet_contour_points
                self.area_contour_jet = user_defined_source_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = user_defined_source_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = user_defined_source_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = user_defined_source_linked_run_calculation_response.flam_conc_contour_points
                self.n_flam_conc_contour_points = user_defined_source_linked_run_calculation_response.n_flam_conc_contour_points
                self.area_footprint_flam_conc = user_defined_source_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = user_defined_source_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = user_defined_source_linked_run_calculation_response.pool_contour_points
                self.n_pool_contour_points = user_defined_source_linked_run_calculation_response.n_pool_contour_points
                self.area_contour_pool = user_defined_source_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = user_defined_source_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = user_defined_source_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = user_defined_source_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = user_defined_source_linked_run_calculation_response.toxic_conc_contour_points
                self.n_toxic_conc_contour_points = user_defined_source_linked_run_calculation_response.n_toxic_conc_contour_points
                self.area_footprint_toxic_conc = user_defined_source_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = user_defined_source_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = user_defined_source_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = user_defined_source_linked_run_calculation_response.result_code
                self.messages = user_defined_source_linked_run_calculation_response.messages
                self.calculation_elapsed_time = user_defined_source_linked_run_calculation_response.calculation_elapsed_time
                self.operation_id = user_defined_source_linked_run_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(user_defined_source_linked_run_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the UserDefinedSourceLinkedRunCalculation object"""

        parts = ['* UserDefinedSourceLinkedRun']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'discharge_record_count:	{str(self.discharge_record_count)}')
        parts.append(f'phase_to_be_released:	{str(self.phase_to_be_released)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_parameters_element' for dispersion_parameters_element in self.dispersion_parameters] if self.dispersion_parameters else [f'dispersion_parameters does not contain any elements'])
        parts.append(f'dispersion_parameter_count:	{str(self.dispersion_parameter_count)}')
        parts.append(f'end_point_concentration:	{str(self.end_point_concentration)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['dispersion_flam_output_configs_element' for dispersion_flam_output_configs_element in self.dispersion_flam_output_configs] if self.dispersion_flam_output_configs else [f'dispersion_flam_output_configs does not contain any elements'])
        parts.append(f'dispersion_flam_output_config_count:	{str(self.dispersion_flam_output_config_count)}')
        parts.extend(['dispersion_toxic_output_configs_element' for dispersion_toxic_output_configs_element in self.dispersion_toxic_output_configs] if self.dispersion_toxic_output_configs else [f'dispersion_toxic_output_configs does not contain any elements'])
        parts.append(f'dispersion_toxic_output_config_count:	{str(self.dispersion_toxic_output_config_count)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['explosion_output_configs_element' for explosion_output_configs_element in self.explosion_output_configs] if self.explosion_output_configs else [f'explosion_output_configs does not contain any elements'])
        parts.append(f'explosion_output_config_count:	{str(self.explosion_output_config_count)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.extend(['n_jet_contour_points_element' for n_jet_contour_points_element in self.n_jet_contour_points] if self.n_jet_contour_points else [f'n_jet_contour_points does not contain any elements'])
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.extend(['n_flam_conc_contour_points_element' for n_flam_conc_contour_points_element in self.n_flam_conc_contour_points] if self.n_flam_conc_contour_points else [f'n_flam_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.extend(['n_pool_contour_points_element' for n_pool_contour_points_element in self.n_pool_contour_points] if self.n_pool_contour_points else [f'n_pool_contour_points does not contain any elements'])
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.extend(['n_toxic_conc_contour_points_element' for n_toxic_conc_contour_points_element in self.n_toxic_conc_contour_points] if self.n_toxic_conc_contour_points else [f'n_toxic_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append('* FlameResult')
        parts.append(f'jet_fire_flame_result:	{str(self.jet_fire_flame_result)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _UserDefinedSourceLinkedRunCalculationResponseSchema(Schema):
    """Schema for the UserDefinedSourceLinkedRunCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    distances_to_jet_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    n_jet_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float(), allow_none=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float(), allow_none=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    n_flam_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    n_pool_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float(), allow_none=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float(), allow_none=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    n_toxic_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_user_defined_source_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the UserDefinedSourceLinkedRunCalculationResponseSchema class."""

        return _UserDefinedSourceLinkedRunCalculationResponse(**data)

class _UserDefinedSourceLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    _UserDefinedSourceLinkedRunCalculationResponse class.

    Attributes
    ----------
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], n_jet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], n_flam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], n_pool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], n_toxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the UserDefinedSourceLinkedRunCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation
        self.jet_contour_points = jet_contour_points
        self.n_jet_contour_points = n_jet_contour_points
        self.area_contour_jet = area_contour_jet
        self.distances_to_flam_concentration = distances_to_flam_concentration
        self.flam_concentrations_used = flam_concentrations_used
        self.flam_conc_contour_points = flam_conc_contour_points
        self.n_flam_conc_contour_points = n_flam_conc_contour_points
        self.area_footprint_flam_conc = area_footprint_flam_conc
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation
        self.pool_contour_points = pool_contour_points
        self.n_pool_contour_points = n_pool_contour_points
        self.area_contour_pool = area_contour_pool
        self.explosion_overpressure_results = explosion_overpressure_results
        self.distances_to_toxic_concentration = distances_to_toxic_concentration
        self.toxic_concentration_used = toxic_concentration_used
        self.toxic_conc_contour_points = toxic_conc_contour_points
        self.n_toxic_conc_contour_points = n_toxic_conc_contour_points
        self.area_footprint_toxic_conc = area_footprint_toxic_conc
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselCatastrophicRuptureCalculationRequest(_CalculationRequestBase):
    """
    _VesselCatastrophicRuptureCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    """
    def __init__(self, vessel: Vessel, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselCatastrophicRuptureCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.discharge_parameters = discharge_parameters

class _VesselCatastrophicRuptureCalculationRequestSchema(Schema):
    """Schema for the VesselCatastrophicRupture calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_catastrophic_rupture_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselCatastrophicRuptureCalculationRequestSchema class."""

        return _VesselCatastrophicRuptureCalculationRequest(**data)

class VesselCatastrophicRuptureCalculation(_CalculationBase):
    """
    VesselCatastrophicRuptureCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    Calculation outputs:
        exit_material : Material
              a material entity representing the released material (indentical to storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselCatastrophicRuptureCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselCatastrophicRuptureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselCatastrophicRuptureCalculationRequest object.
        vessel_catastrophic_rupture_calculation_request = _VesselCatastrophicRuptureCalculationRequest(self.vessel, self.discharge_parameters)

        # Get the _VesselCatastrophicRuptureCalculationRequestSchema and use that to serialize to json.
        vessel_catastrophic_rupture_calculation_request_schema = _VesselCatastrophicRuptureCalculationRequestSchema()

        request_json = vessel_catastrophic_rupture_calculation_request_schema.dumps(vessel_catastrophic_rupture_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselcatastrophicrupture?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_catastrophic_rupture_calculation_response_schema = _VesselCatastrophicRuptureCalculationResponseSchema()
            vessel_catastrophic_rupture_calculation_response = vessel_catastrophic_rupture_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_catastrophic_rupture_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_catastrophic_rupture_calculation_response.exit_material
                self.discharge_result = vessel_catastrophic_rupture_calculation_response.discharge_result
                self.discharge_records = vessel_catastrophic_rupture_calculation_response.discharge_records
                self.result_code = vessel_catastrophic_rupture_calculation_response.result_code
                self.messages = vessel_catastrophic_rupture_calculation_response.messages
                self.calculation_elapsed_time = vessel_catastrophic_rupture_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_catastrophic_rupture_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_catastrophic_rupture_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselCatastrophicRuptureCalculation object"""

        parts = ['* VesselCatastrophicRupture']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Material')
        parts.append(f'exit_material:	{str(self.exit_material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselCatastrophicRuptureCalculationResponseSchema(Schema):
    """Schema for the VesselCatastrophicRuptureCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_catastrophic_rupture_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselCatastrophicRuptureCalculationResponseSchema class."""

        return _VesselCatastrophicRuptureCalculationResponse(**data)

class _VesselCatastrophicRuptureCalculationResponse(_CalculationResponseBase):
    """
    _VesselCatastrophicRuptureCalculationResponse class.

    Attributes
    ----------
        exit_material : Material
              a material entity representing the released material (indentical to storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselCatastrophicRuptureCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselLeakCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        leak : Leak
              a leak entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    """
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselLeakCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters

class _VesselLeakCalculationRequestSchema(Schema):
    """Schema for the VesselLeak calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_leak_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakCalculationRequestSchema class."""

        return _VesselLeakCalculationRequest(**data)

class VesselLeakCalculation(_CalculationBase):
    """
    VesselLeakCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        leak : Leak
              a leak entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    Calculation outputs:
        exit_material : Material
              a material entity representing the released material (may differ from storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselLeakCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselLeakCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakCalculationRequest object.
        vessel_leak_calculation_request = _VesselLeakCalculationRequest(self.vessel, self.leak, self.discharge_parameters)

        # Get the _VesselLeakCalculationRequestSchema and use that to serialize to json.
        vessel_leak_calculation_request_schema = _VesselLeakCalculationRequestSchema()

        request_json = vessel_leak_calculation_request_schema.dumps(vessel_leak_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselleak?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_leak_calculation_response_schema = _VesselLeakCalculationResponseSchema()
            vessel_leak_calculation_response = vessel_leak_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_leak_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_leak_calculation_response.exit_material
                self.discharge_result = vessel_leak_calculation_response.discharge_result
                self.discharge_records = vessel_leak_calculation_response.discharge_records
                self.result_code = vessel_leak_calculation_response.result_code
                self.messages = vessel_leak_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_leak_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_leak_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakCalculation object"""

        parts = ['* VesselLeak']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* Leak')
        parts.append(f'leak:	{str(self.leak)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Material')
        parts.append(f'exit_material:	{str(self.exit_material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselLeakCalculationResponseSchema(Schema):
    """Schema for the VesselLeakCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_leak_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakCalculationResponseSchema class."""

        return _VesselLeakCalculationResponse(**data)

class _VesselLeakCalculationResponse(_CalculationResponseBase):
    """
    _VesselLeakCalculationResponse class.

    Attributes
    ----------
        exit_material : Material
              a material entity representing the released material (may differ from storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselLeakCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselLeakLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakLinkedRunCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        leak : Leak
              a leak entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    """
    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLeakLinkedRunCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

class _VesselLeakLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselLeakLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_leak_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakLinkedRunCalculationRequestSchema class."""

        return _VesselLeakLinkedRunCalculationRequest(**data)

class VesselLeakLinkedRunCalculation(_CalculationBase):
    """
    VesselLeakLinkedRunCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        leak : Leak
              a leak entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    Calculation outputs:
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLeakLinkedRunCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.n_jet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.n_flam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.n_pool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.n_toxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselLeakLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakLinkedRunCalculationRequest object.
        vessel_leak_linked_run_calculation_request = _VesselLeakLinkedRunCalculationRequest(self.vessel, self.leak, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the _VesselLeakLinkedRunCalculationRequestSchema and use that to serialize to json.
        vessel_leak_linked_run_calculation_request_schema = _VesselLeakLinkedRunCalculationRequestSchema()

        request_json = vessel_leak_linked_run_calculation_request_schema.dumps(vessel_leak_linked_run_calculation_request)
        url = get_analytics_api_target() + 'vesselleaklinkedrun?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_leak_linked_run_calculation_response_schema = _VesselLeakLinkedRunCalculationResponseSchema()
            vessel_leak_linked_run_calculation_response = vessel_leak_linked_run_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_leak_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_leak_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_leak_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_leak_linked_run_calculation_response.jet_contour_points
                self.n_jet_contour_points = vessel_leak_linked_run_calculation_response.n_jet_contour_points
                self.area_contour_jet = vessel_leak_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = vessel_leak_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_leak_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_leak_linked_run_calculation_response.flam_conc_contour_points
                self.n_flam_conc_contour_points = vessel_leak_linked_run_calculation_response.n_flam_conc_contour_points
                self.area_footprint_flam_conc = vessel_leak_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_leak_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_leak_linked_run_calculation_response.pool_contour_points
                self.n_pool_contour_points = vessel_leak_linked_run_calculation_response.n_pool_contour_points
                self.area_contour_pool = vessel_leak_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = vessel_leak_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_leak_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_leak_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_leak_linked_run_calculation_response.toxic_conc_contour_points
                self.n_toxic_conc_contour_points = vessel_leak_linked_run_calculation_response.n_toxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_leak_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_leak_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_leak_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_leak_linked_run_calculation_response.result_code
                self.messages = vessel_leak_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_linked_run_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_leak_linked_run_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_leak_linked_run_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakLinkedRunCalculation object"""

        parts = ['* VesselLeakLinkedRun']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* Leak')
        parts.append(f'leak:	{str(self.leak)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_parameters_element' for dispersion_parameters_element in self.dispersion_parameters] if self.dispersion_parameters else [f'dispersion_parameters does not contain any elements'])
        parts.append(f'dispersion_parameter_count:	{str(self.dispersion_parameter_count)}')
        parts.append(f'end_point_concentration:	{str(self.end_point_concentration)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['dispersion_flam_output_configs_element' for dispersion_flam_output_configs_element in self.dispersion_flam_output_configs] if self.dispersion_flam_output_configs else [f'dispersion_flam_output_configs does not contain any elements'])
        parts.append(f'dispersion_flam_output_config_count:	{str(self.dispersion_flam_output_config_count)}')
        parts.extend(['dispersion_toxic_output_configs_element' for dispersion_toxic_output_configs_element in self.dispersion_toxic_output_configs] if self.dispersion_toxic_output_configs else [f'dispersion_toxic_output_configs does not contain any elements'])
        parts.append(f'dispersion_toxic_output_config_count:	{str(self.dispersion_toxic_output_config_count)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['explosion_output_configs_element' for explosion_output_configs_element in self.explosion_output_configs] if self.explosion_output_configs else [f'explosion_output_configs does not contain any elements'])
        parts.append(f'explosion_output_config_count:	{str(self.explosion_output_config_count)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.append('* DischargeRecord')
        parts.append(f'discharge_record:	{str(self.discharge_record)}')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.extend(['n_jet_contour_points_element' for n_jet_contour_points_element in self.n_jet_contour_points] if self.n_jet_contour_points else [f'n_jet_contour_points does not contain any elements'])
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.extend(['n_flam_conc_contour_points_element' for n_flam_conc_contour_points_element in self.n_flam_conc_contour_points] if self.n_flam_conc_contour_points else [f'n_flam_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.extend(['n_pool_contour_points_element' for n_pool_contour_points_element in self.n_pool_contour_points] if self.n_pool_contour_points else [f'n_pool_contour_points does not contain any elements'])
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.extend(['n_toxic_conc_contour_points_element' for n_toxic_conc_contour_points_element in self.n_toxic_conc_contour_points] if self.n_toxic_conc_contour_points else [f'n_toxic_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append('* FlameResult')
        parts.append(f'jet_fire_flame_result:	{str(self.jet_fire_flame_result)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselLeakLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselLeakLinkedRunCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    n_jet_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float(), allow_none=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float(), allow_none=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    n_flam_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    n_pool_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float(), allow_none=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float(), allow_none=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    n_toxic_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_leak_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakLinkedRunCalculationResponseSchema class."""

        return _VesselLeakLinkedRunCalculationResponse(**data)

class _VesselLeakLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    _VesselLeakLinkedRunCalculationResponse class.

    Attributes
    ----------
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], n_jet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], n_flam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], n_pool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], n_toxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselLeakLinkedRunCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation
        self.jet_contour_points = jet_contour_points
        self.n_jet_contour_points = n_jet_contour_points
        self.area_contour_jet = area_contour_jet
        self.distances_to_flam_concentration = distances_to_flam_concentration
        self.flam_concentrations_used = flam_concentrations_used
        self.flam_conc_contour_points = flam_conc_contour_points
        self.n_flam_conc_contour_points = n_flam_conc_contour_points
        self.area_footprint_flam_conc = area_footprint_flam_conc
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation
        self.pool_contour_points = pool_contour_points
        self.n_pool_contour_points = n_pool_contour_points
        self.area_contour_pool = area_contour_pool
        self.explosion_overpressure_results = explosion_overpressure_results
        self.distances_to_toxic_concentration = distances_to_toxic_concentration
        self.toxic_concentration_used = toxic_concentration_used
        self.toxic_conc_contour_points = toxic_conc_contour_points
        self.n_toxic_conc_contour_points = n_toxic_conc_contour_points
        self.area_footprint_toxic_conc = area_footprint_toxic_conc
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselLeakMaxFlammableCloudCalculationRequest(_CalculationRequestBase):
    """
    _VesselLeakMaxFlammableCloudCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        leak : Leak
              a leak entity.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity, used to set height of interest.

    """
    def __init__(self, vessel: Vessel, leak: Leak, weather: Weather, substrate: Substrate, discharge_parameters: DischargeParameters, dispersion_parameters: DispersionParameters, dispersion_output_config: DispersionOutputConfig):
        """Initializes a new instance of the _VesselLeakMaxFlammableCloudCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.leak = leak
        self.weather = weather
        self.substrate = substrate
        self.discharge_parameters = discharge_parameters
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_output_config = dispersion_output_config

class _VesselLeakMaxFlammableCloudCalculationRequestSchema(Schema):
    """Schema for the VesselLeakMaxFlammableCloud calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    leak = fields.Nested(LeakSchema, data_key="leak")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, data_key="dispersionParameters")
    dispersion_output_config = fields.Nested(DispersionOutputConfigSchema, data_key="dispersionOutputConfig")

    @post_load
    def make_vessel_leak_max_flammable_cloud_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLeakMaxFlammableCloudCalculationRequestSchema class."""

        return _VesselLeakMaxFlammableCloudCalculationRequest(**data)

class VesselLeakMaxFlammableCloudCalculation(_CalculationBase):
    """
    VesselLeakMaxFlammableCloudCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        leak : Leak
              a leak entity.
        weather : Weather
              a weather entity.
        substrate : Substrate
              a substrate entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        dispersion_parameters : DispersionParameters
              a dispersion parameters entity.
        dispersion_output_config : DispersionOutputConfig
              a dispersion output config entity, used to set height of interest.

    Calculation outputs:
        vessel_leak_max_flammable_cloud_results : VesselLeakMaxFlammableCloudResults
              a vessel leak max flammable cloud results entity.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, leak: Leak, weather: Weather, substrate: Substrate, discharge_parameters: DischargeParameters, dispersion_parameters: DispersionParameters, dispersion_output_config: DispersionOutputConfig):
        """Initializes a new instance of the VesselLeakMaxFlammableCloudCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.leak = leak
        self.weather = weather
        self.substrate = substrate
        self.discharge_parameters = discharge_parameters
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_output_config = dispersion_output_config

        # Calculation outputs.
        self.vessel_leak_max_flammable_cloud_results = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselLeakMaxFlammableCloudCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLeakMaxFlammableCloudCalculationRequest object.
        vessel_leak_max_flammable_cloud_calculation_request = _VesselLeakMaxFlammableCloudCalculationRequest(self.vessel, self.leak, self.weather, self.substrate, self.discharge_parameters, self.dispersion_parameters, self.dispersion_output_config)

        # Get the _VesselLeakMaxFlammableCloudCalculationRequestSchema and use that to serialize to json.
        vessel_leak_max_flammable_cloud_calculation_request_schema = _VesselLeakMaxFlammableCloudCalculationRequestSchema()

        request_json = vessel_leak_max_flammable_cloud_calculation_request_schema.dumps(vessel_leak_max_flammable_cloud_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselleakmaxflammablecloud?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_leak_max_flammable_cloud_calculation_response_schema = _VesselLeakMaxFlammableCloudCalculationResponseSchema()
            vessel_leak_max_flammable_cloud_calculation_response = vessel_leak_max_flammable_cloud_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_leak_max_flammable_cloud_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel_leak_max_flammable_cloud_results = vessel_leak_max_flammable_cloud_calculation_response.vessel_leak_max_flammable_cloud_results
                self.result_code = vessel_leak_max_flammable_cloud_calculation_response.result_code
                self.messages = vessel_leak_max_flammable_cloud_calculation_response.messages
                self.calculation_elapsed_time = vessel_leak_max_flammable_cloud_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_leak_max_flammable_cloud_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_leak_max_flammable_cloud_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLeakMaxFlammableCloudCalculation object"""

        parts = ['* VesselLeakMaxFlammableCloud']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* Leak')
        parts.append(f'leak:	{str(self.leak)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* DispersionParameters')
        parts.append(f'dispersion_parameters:	{str(self.dispersion_parameters)}')
        parts.append('* DispersionOutputConfig')
        parts.append(f'dispersion_output_config:	{str(self.dispersion_output_config)}')
        parts.append('* VesselLeakMaxFlammableCloudResults')
        parts.append(f'vessel_leak_max_flammable_cloud_results:	{str(self.vessel_leak_max_flammable_cloud_results)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselLeakMaxFlammableCloudCalculationResponseSchema(Schema):
    """Schema for the VesselLeakMaxFlammableCloudCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel_leak_max_flammable_cloud_results = fields.Nested(VesselLeakMaxFlammableCloudResultsSchema, data_key="vesselLeakMaxFlammableCloudResults")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_leak_max_flammable_cloud_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLeakMaxFlammableCloudCalculationResponseSchema class."""

        return _VesselLeakMaxFlammableCloudCalculationResponse(**data)

class _VesselLeakMaxFlammableCloudCalculationResponse(_CalculationResponseBase):
    """
    _VesselLeakMaxFlammableCloudCalculationResponse class.

    Attributes
    ----------
        vessel_leak_max_flammable_cloud_results : VesselLeakMaxFlammableCloudResults
              a vessel leak max flammable cloud results entity.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, vessel_leak_max_flammable_cloud_results: VesselLeakMaxFlammableCloudResults, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselLeakMaxFlammableCloudCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.vessel_leak_max_flammable_cloud_results = vessel_leak_max_flammable_cloud_results
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselLineRuptureCalculationRequest(_CalculationRequestBase):
    """
    _VesselLineRuptureCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        line_rupture : LineRupture
              a line rupture entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    """
    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselLineRuptureCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters

class _VesselLineRuptureCalculationRequestSchema(Schema):
    """Schema for the VesselLineRupture calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    line_rupture = fields.Nested(LineRuptureSchema, data_key="lineRupture")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_line_rupture_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureCalculationRequestSchema class."""

        return _VesselLineRuptureCalculationRequest(**data)

class VesselLineRuptureCalculation(_CalculationBase):
    """
    VesselLineRuptureCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        line_rupture : LineRupture
              a line rupture entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    Calculation outputs:
        exit_material : Material
              a material entity representing the released material (which may differ from storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselLineRuptureCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselLineRuptureCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLineRuptureCalculationRequest object.
        vessel_line_rupture_calculation_request = _VesselLineRuptureCalculationRequest(self.vessel, self.line_rupture, self.discharge_parameters)

        # Get the _VesselLineRuptureCalculationRequestSchema and use that to serialize to json.
        vessel_line_rupture_calculation_request_schema = _VesselLineRuptureCalculationRequestSchema()

        request_json = vessel_line_rupture_calculation_request_schema.dumps(vessel_line_rupture_calculation_request)
        url = get_analytics_api_target() + 'calculatevessellinerupture?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_line_rupture_calculation_response_schema = _VesselLineRuptureCalculationResponseSchema()
            vessel_line_rupture_calculation_response = vessel_line_rupture_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_line_rupture_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_line_rupture_calculation_response.exit_material
                self.discharge_result = vessel_line_rupture_calculation_response.discharge_result
                self.discharge_records = vessel_line_rupture_calculation_response.discharge_records
                self.result_code = vessel_line_rupture_calculation_response.result_code
                self.messages = vessel_line_rupture_calculation_response.messages
                self.calculation_elapsed_time = vessel_line_rupture_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_line_rupture_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_line_rupture_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLineRuptureCalculation object"""

        parts = ['* VesselLineRupture']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* LineRupture')
        parts.append(f'line_rupture:	{str(self.line_rupture)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Material')
        parts.append(f'exit_material:	{str(self.exit_material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselLineRuptureCalculationResponseSchema(Schema):
    """Schema for the VesselLineRuptureCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_line_rupture_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureCalculationResponseSchema class."""

        return _VesselLineRuptureCalculationResponse(**data)

class _VesselLineRuptureCalculationResponse(_CalculationResponseBase):
    """
    _VesselLineRuptureCalculationResponse class.

    Attributes
    ----------
        exit_material : Material
              a material entity representing the released material (which may differ from storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselLineRuptureCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselLineRuptureLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselLineRuptureLinkedRunCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        line_rupture : LineRupture
              a line rupture entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    """
    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselLineRuptureLinkedRunCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

class _VesselLineRuptureLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselLineRuptureLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    line_rupture = fields.Nested(LineRuptureSchema, data_key="lineRupture")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_line_rupture_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureLinkedRunCalculationRequestSchema class."""

        return _VesselLineRuptureLinkedRunCalculationRequest(**data)

class VesselLineRuptureLinkedRunCalculation(_CalculationBase):
    """
    VesselLineRuptureLinkedRunCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        line_rupture : LineRupture
              a line rupture entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    Calculation outputs:
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, line_rupture: LineRupture, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselLineRuptureLinkedRunCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.line_rupture = line_rupture
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.n_jet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.n_flam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.n_pool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.n_toxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselLineRuptureLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselLineRuptureLinkedRunCalculationRequest object.
        vessel_line_rupture_linked_run_calculation_request = _VesselLineRuptureLinkedRunCalculationRequest(self.vessel, self.line_rupture, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the _VesselLineRuptureLinkedRunCalculationRequestSchema and use that to serialize to json.
        vessel_line_rupture_linked_run_calculation_request_schema = _VesselLineRuptureLinkedRunCalculationRequestSchema()

        request_json = vessel_line_rupture_linked_run_calculation_request_schema.dumps(vessel_line_rupture_linked_run_calculation_request)
        url = get_analytics_api_target() + 'vessellinerupturelinkedrun?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_line_rupture_linked_run_calculation_response_schema = _VesselLineRuptureLinkedRunCalculationResponseSchema()
            vessel_line_rupture_linked_run_calculation_response = vessel_line_rupture_linked_run_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_line_rupture_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_line_rupture_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_line_rupture_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_line_rupture_linked_run_calculation_response.jet_contour_points
                self.n_jet_contour_points = vessel_line_rupture_linked_run_calculation_response.n_jet_contour_points
                self.area_contour_jet = vessel_line_rupture_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = vessel_line_rupture_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_line_rupture_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.flam_conc_contour_points
                self.n_flam_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.n_flam_conc_contour_points
                self.area_footprint_flam_conc = vessel_line_rupture_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_line_rupture_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_line_rupture_linked_run_calculation_response.pool_contour_points
                self.n_pool_contour_points = vessel_line_rupture_linked_run_calculation_response.n_pool_contour_points
                self.area_contour_pool = vessel_line_rupture_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = vessel_line_rupture_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_line_rupture_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_line_rupture_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.toxic_conc_contour_points
                self.n_toxic_conc_contour_points = vessel_line_rupture_linked_run_calculation_response.n_toxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_line_rupture_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_line_rupture_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_line_rupture_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_line_rupture_linked_run_calculation_response.result_code
                self.messages = vessel_line_rupture_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_line_rupture_linked_run_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_line_rupture_linked_run_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_line_rupture_linked_run_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselLineRuptureLinkedRunCalculation object"""

        parts = ['* VesselLineRuptureLinkedRun']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* LineRupture')
        parts.append(f'line_rupture:	{str(self.line_rupture)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_parameters_element' for dispersion_parameters_element in self.dispersion_parameters] if self.dispersion_parameters else [f'dispersion_parameters does not contain any elements'])
        parts.append(f'dispersion_parameter_count:	{str(self.dispersion_parameter_count)}')
        parts.append(f'end_point_concentration:	{str(self.end_point_concentration)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['dispersion_flam_output_configs_element' for dispersion_flam_output_configs_element in self.dispersion_flam_output_configs] if self.dispersion_flam_output_configs else [f'dispersion_flam_output_configs does not contain any elements'])
        parts.append(f'dispersion_flam_output_config_count:	{str(self.dispersion_flam_output_config_count)}')
        parts.extend(['dispersion_toxic_output_configs_element' for dispersion_toxic_output_configs_element in self.dispersion_toxic_output_configs] if self.dispersion_toxic_output_configs else [f'dispersion_toxic_output_configs does not contain any elements'])
        parts.append(f'dispersion_toxic_output_config_count:	{str(self.dispersion_toxic_output_config_count)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['explosion_output_configs_element' for explosion_output_configs_element in self.explosion_output_configs] if self.explosion_output_configs else [f'explosion_output_configs does not contain any elements'])
        parts.append(f'explosion_output_config_count:	{str(self.explosion_output_config_count)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.append('* DischargeRecord')
        parts.append(f'discharge_record:	{str(self.discharge_record)}')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.extend(['n_jet_contour_points_element' for n_jet_contour_points_element in self.n_jet_contour_points] if self.n_jet_contour_points else [f'n_jet_contour_points does not contain any elements'])
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.extend(['n_flam_conc_contour_points_element' for n_flam_conc_contour_points_element in self.n_flam_conc_contour_points] if self.n_flam_conc_contour_points else [f'n_flam_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.extend(['n_pool_contour_points_element' for n_pool_contour_points_element in self.n_pool_contour_points] if self.n_pool_contour_points else [f'n_pool_contour_points does not contain any elements'])
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.extend(['n_toxic_conc_contour_points_element' for n_toxic_conc_contour_points_element in self.n_toxic_conc_contour_points] if self.n_toxic_conc_contour_points else [f'n_toxic_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append('* FlameResult')
        parts.append(f'jet_fire_flame_result:	{str(self.jet_fire_flame_result)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselLineRuptureLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselLineRuptureLinkedRunCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    n_jet_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float(), allow_none=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float(), allow_none=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    n_flam_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    n_pool_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float(), allow_none=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float(), allow_none=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    n_toxic_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_line_rupture_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselLineRuptureLinkedRunCalculationResponseSchema class."""

        return _VesselLineRuptureLinkedRunCalculationResponse(**data)

class _VesselLineRuptureLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    _VesselLineRuptureLinkedRunCalculationResponse class.

    Attributes
    ----------
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire contours, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire contours, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], n_jet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], n_flam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], n_pool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], n_toxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselLineRuptureLinkedRunCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation
        self.jet_contour_points = jet_contour_points
        self.n_jet_contour_points = n_jet_contour_points
        self.area_contour_jet = area_contour_jet
        self.distances_to_flam_concentration = distances_to_flam_concentration
        self.flam_concentrations_used = flam_concentrations_used
        self.flam_conc_contour_points = flam_conc_contour_points
        self.n_flam_conc_contour_points = n_flam_conc_contour_points
        self.area_footprint_flam_conc = area_footprint_flam_conc
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation
        self.pool_contour_points = pool_contour_points
        self.n_pool_contour_points = n_pool_contour_points
        self.area_contour_pool = area_contour_pool
        self.explosion_overpressure_results = explosion_overpressure_results
        self.distances_to_toxic_concentration = distances_to_toxic_concentration
        self.toxic_concentration_used = toxic_concentration_used
        self.toxic_conc_contour_points = toxic_conc_contour_points
        self.n_toxic_conc_contour_points = n_toxic_conc_contour_points
        self.area_footprint_toxic_conc = area_footprint_toxic_conc
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselReliefValveCalculationRequest(_CalculationRequestBase):
    """
    _VesselReliefValveCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        relief_valve : ReliefValve
              a relief valve entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    """
    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the _VesselReliefValveCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters

class _VesselReliefValveCalculationRequestSchema(Schema):
    """Schema for the VesselReliefValve calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    relief_valve = fields.Nested(ReliefValveSchema, data_key="reliefValve")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")

    @post_load
    def make_vessel_relief_valve_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselReliefValveCalculationRequestSchema class."""

        return _VesselReliefValveCalculationRequest(**data)

class VesselReliefValveCalculation(_CalculationBase):
    """
    VesselReliefValveCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        relief_valve : ReliefValve
              a relief valve entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.

    Calculation outputs:
        exit_material : Material
              a material entity representing the released material (which may differ from storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters):
        """Initializes a new instance of the VesselReliefValveCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters

        # Calculation outputs.
        self.exit_material = None
        self.discharge_result = None
        self.discharge_records = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselReliefValveCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselReliefValveCalculationRequest object.
        vessel_relief_valve_calculation_request = _VesselReliefValveCalculationRequest(self.vessel, self.relief_valve, self.discharge_parameters)

        # Get the _VesselReliefValveCalculationRequestSchema and use that to serialize to json.
        vessel_relief_valve_calculation_request_schema = _VesselReliefValveCalculationRequestSchema()

        request_json = vessel_relief_valve_calculation_request_schema.dumps(vessel_relief_valve_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselreliefvalve?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_relief_valve_calculation_response_schema = _VesselReliefValveCalculationResponseSchema()
            vessel_relief_valve_calculation_response = vessel_relief_valve_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_relief_valve_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.exit_material = vessel_relief_valve_calculation_response.exit_material
                self.discharge_result = vessel_relief_valve_calculation_response.discharge_result
                self.discharge_records = vessel_relief_valve_calculation_response.discharge_records
                self.result_code = vessel_relief_valve_calculation_response.result_code
                self.messages = vessel_relief_valve_calculation_response.messages
                self.calculation_elapsed_time = vessel_relief_valve_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_relief_valve_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_relief_valve_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselReliefValveCalculation object"""

        parts = ['* VesselReliefValve']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* ReliefValve')
        parts.append(f'relief_valve:	{str(self.relief_valve)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Material')
        parts.append(f'exit_material:	{str(self.exit_material)}')
        parts.append('* DischargeResult')
        parts.append(f'discharge_result:	{str(self.discharge_result)}')
        parts.extend(['discharge_records_element' for discharge_records_element in self.discharge_records] if self.discharge_records else [f'discharge_records does not contain any elements'])
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselReliefValveCalculationResponseSchema(Schema):
    """Schema for the VesselReliefValveCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    exit_material = fields.Nested(MaterialSchema, data_key="exitMaterial")
    discharge_result = fields.Nested(DischargeResultSchema, data_key="dischargeResult")
    discharge_records = fields.Nested(DischargeRecordSchema, allow_none=True, many=True, data_key="dischargeRecords")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_relief_valve_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselReliefValveCalculationResponseSchema class."""

        return _VesselReliefValveCalculationResponse(**data)

class _VesselReliefValveCalculationResponse(_CalculationResponseBase):
    """
    _VesselReliefValveCalculationResponse class.

    Attributes
    ----------
        exit_material : Material
              a material entity representing the released material (which may differ from storage composition).
        discharge_result : DischargeResult
             Scalar discharge results.
        discharge_records : list[DischargeRecord]
              an array of discharge records.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, exit_material: Material, discharge_result: DischargeResult, discharge_records: list[DischargeRecord], result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselReliefValveCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.exit_material = exit_material
        self.discharge_result = discharge_result
        self.discharge_records = discharge_records
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselReliefValveLinkedRunCalculationRequest(_CalculationRequestBase):
    """
    _VesselReliefValveLinkedRunCalculationRequest class.

    Attributes
    ----------
        vessel : Vessel
              a vessel entity.
        relief_valve : ReliefValve
              a relief valve entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    """
    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the _VesselReliefValveLinkedRunCalculationRequest class"""

        super().__init__()

        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

class _VesselReliefValveLinkedRunCalculationRequestSchema(Schema):
    """Schema for the VesselReliefValveLinkedRun calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel = fields.Nested(VesselSchema, data_key="vessel")
    relief_valve = fields.Nested(ReliefValveSchema, data_key="reliefValve")
    discharge_parameters = fields.Nested(DischargeParametersSchema, data_key="dischargeParameters")
    substrate = fields.Nested(SubstrateSchema, data_key="substrate")
    weather = fields.Nested(WeatherSchema, data_key="weather")
    dispersion_parameters = fields.Nested(DispersionParametersSchema, allow_none=True, many=True, data_key="dispersionParameters")
    dispersion_parameter_count = fields.Int(data_key="dispersionParameterCount")
    end_point_concentration = fields.Float(data_key="endPointConcentration")
    flammable_parameters = fields.Nested(FlammableParametersSchema, data_key="flammableParameters")
    explosion_parameters = fields.Nested(ExplosionParametersSchema, data_key="explosionParameters")
    dispersion_flam_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionFlamOutputConfigs")
    dispersion_flam_output_config_count = fields.Int(data_key="dispersionFlamOutputConfigCount")
    dispersion_toxic_output_configs = fields.Nested(DispersionOutputConfigSchema, allow_none=True, many=True, data_key="dispersionToxicOutputConfigs")
    dispersion_toxic_output_config_count = fields.Int(data_key="dispersionToxicOutputConfigCount")
    flammable_output_configs = fields.Nested(FlammableOutputConfigSchema, allow_none=True, many=True, data_key="flammableOutputConfigs")
    flammable_output_config_count = fields.Int(data_key="flammableOutputConfigCount")
    explosion_output_configs = fields.Nested(ExplosionOutputConfigSchema, allow_none=True, many=True, data_key="explosionOutputConfigs")
    explosion_output_config_count = fields.Int(data_key="explosionOutputConfigCount")
    explosion_confined_volumes = fields.Nested(ExplosionConfinedVolumeSchema, allow_none=True, many=True, data_key="explosionConfinedVolumes")
    explosion_confined_volume_count = fields.Int(data_key="explosionConfinedVolumeCount")

    @post_load
    def make_vessel_relief_valve_linked_run_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselReliefValveLinkedRunCalculationRequestSchema class."""

        return _VesselReliefValveLinkedRunCalculationRequest(**data)

class VesselReliefValveLinkedRunCalculation(_CalculationBase):
    """
    VesselReliefValveLinkedRunCalculation class.

    Attributes
    ----------
    Calculation inputs:
        vessel : Vessel
              a vessel entity.
        relief_valve : ReliefValve
              a relief valve entity.
        discharge_parameters : DischargeParameters
              a discharge parameters entity.
        substrate : Substrate
              a substrate entity.
        weather : Weather
              a weather entity.
        dispersion_parameters : list[DispersionParameters]
              an array of dispersion parameters.
        dispersion_parameter_count : int
             Number of dispersion parameters.
        end_point_concentration : float
             Concentration at which the dispersion calculations will terminate (v/v fraction).
        flammable_parameters : FlammableParameters
              a flammable parameters entity.
        explosion_parameters : ExplosionParameters
              an explosion parameters entity.
        dispersion_flam_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for flammable concentrations of interest.
        dispersion_flam_output_config_count : int
             Number of dispersion output configs for flammable concentrations of interest.
        dispersion_toxic_output_configs : list[DispersionOutputConfig]
              an array of dispersion output configs for toxic concentrations of interest.
        dispersion_toxic_output_config_count : int
             Number of dispersion output configs for toxic concentrations of interest.
        flammable_output_configs : list[FlammableOutputConfig]
              an array of flammable output configs for radiation levels of interest.
        flammable_output_config_count : int
             Number of flammable ouput configs for radiation levels of interest.
        explosion_output_configs : list[ExplosionOutputConfig]
              an array of explosion output configs for overpressure levels of interest.
        explosion_output_config_count : int
             Number of explosion output configs for overpressure levels of interest.
        explosion_confined_volumes : list[ExplosionConfinedVolume]
              an array of explosion confined volumes.
        explosion_confined_volume_count : int
             Number of explosion confined volumes.

    Calculation outputs:
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation ellipse contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation ellipse contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire ellipses, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire ellipses, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, vessel: Vessel, relief_valve: ReliefValve, discharge_parameters: DischargeParameters, substrate: Substrate, weather: Weather, dispersion_parameters: list[DispersionParameters], dispersion_parameter_count: int, end_point_concentration: float, flammable_parameters: FlammableParameters, explosion_parameters: ExplosionParameters, dispersion_flam_output_configs: list[DispersionOutputConfig], dispersion_flam_output_config_count: int, dispersion_toxic_output_configs: list[DispersionOutputConfig], dispersion_toxic_output_config_count: int, flammable_output_configs: list[FlammableOutputConfig], flammable_output_config_count: int, explosion_output_configs: list[ExplosionOutputConfig], explosion_output_config_count: int, explosion_confined_volumes: list[ExplosionConfinedVolume], explosion_confined_volume_count: int):
        """Initializes a new instance of the VesselReliefValveLinkedRunCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.vessel = vessel
        self.relief_valve = relief_valve
        self.discharge_parameters = discharge_parameters
        self.substrate = substrate
        self.weather = weather
        self.dispersion_parameters = dispersion_parameters
        self.dispersion_parameter_count = dispersion_parameter_count
        self.end_point_concentration = end_point_concentration
        self.flammable_parameters = flammable_parameters
        self.explosion_parameters = explosion_parameters
        self.dispersion_flam_output_configs = dispersion_flam_output_configs
        self.dispersion_flam_output_config_count = dispersion_flam_output_config_count
        self.dispersion_toxic_output_configs = dispersion_toxic_output_configs
        self.dispersion_toxic_output_config_count = dispersion_toxic_output_config_count
        self.flammable_output_configs = flammable_output_configs
        self.flammable_output_config_count = flammable_output_config_count
        self.explosion_output_configs = explosion_output_configs
        self.explosion_output_config_count = explosion_output_config_count
        self.explosion_confined_volumes = explosion_confined_volumes
        self.explosion_confined_volume_count = explosion_confined_volume_count

        # Calculation outputs.
        self.discharge_record = None
        self.distances_to_jet_fire_radiation = None
        self.jet_contour_points = None
        self.n_jet_contour_points = None
        self.area_contour_jet = None
        self.distances_to_flam_concentration = None
        self.flam_concentrations_used = None
        self.flam_conc_contour_points = None
        self.n_flam_conc_contour_points = None
        self.area_footprint_flam_conc = None
        self.distances_to_pool_fire_radiation = None
        self.pool_contour_points = None
        self.n_pool_contour_points = None
        self.area_contour_pool = None
        self.explosion_overpressure_results = None
        self.distances_to_toxic_concentration = None
        self.toxic_concentration_used = None
        self.toxic_conc_contour_points = None
        self.n_toxic_conc_contour_points = None
        self.area_footprint_toxic_conc = None
        self.jet_fire_flame_result = None
        self.pool_fire_flame_result = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselReliefValveLinkedRunCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselReliefValveLinkedRunCalculationRequest object.
        vessel_relief_valve_linked_run_calculation_request = _VesselReliefValveLinkedRunCalculationRequest(self.vessel, self.relief_valve, self.discharge_parameters, self.substrate, self.weather, self.dispersion_parameters, self.dispersion_parameter_count, self.end_point_concentration, self.flammable_parameters, self.explosion_parameters, self.dispersion_flam_output_configs, self.dispersion_flam_output_config_count, self.dispersion_toxic_output_configs, self.dispersion_toxic_output_config_count, self.flammable_output_configs, self.flammable_output_config_count, self.explosion_output_configs, self.explosion_output_config_count, self.explosion_confined_volumes, self.explosion_confined_volume_count)

        # Get the _VesselReliefValveLinkedRunCalculationRequestSchema and use that to serialize to json.
        vessel_relief_valve_linked_run_calculation_request_schema = _VesselReliefValveLinkedRunCalculationRequestSchema()

        request_json = vessel_relief_valve_linked_run_calculation_request_schema.dumps(vessel_relief_valve_linked_run_calculation_request)
        url = get_analytics_api_target() + 'vesselreliefvalvelinkedrun?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_relief_valve_linked_run_calculation_response_schema = _VesselReliefValveLinkedRunCalculationResponseSchema()
            vessel_relief_valve_linked_run_calculation_response = vessel_relief_valve_linked_run_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_relief_valve_linked_run_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.discharge_record = vessel_relief_valve_linked_run_calculation_response.discharge_record
                self.distances_to_jet_fire_radiation = vessel_relief_valve_linked_run_calculation_response.distances_to_jet_fire_radiation
                self.jet_contour_points = vessel_relief_valve_linked_run_calculation_response.jet_contour_points
                self.n_jet_contour_points = vessel_relief_valve_linked_run_calculation_response.n_jet_contour_points
                self.area_contour_jet = vessel_relief_valve_linked_run_calculation_response.area_contour_jet
                self.distances_to_flam_concentration = vessel_relief_valve_linked_run_calculation_response.distances_to_flam_concentration
                self.flam_concentrations_used = vessel_relief_valve_linked_run_calculation_response.flam_concentrations_used
                self.flam_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.flam_conc_contour_points
                self.n_flam_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.n_flam_conc_contour_points
                self.area_footprint_flam_conc = vessel_relief_valve_linked_run_calculation_response.area_footprint_flam_conc
                self.distances_to_pool_fire_radiation = vessel_relief_valve_linked_run_calculation_response.distances_to_pool_fire_radiation
                self.pool_contour_points = vessel_relief_valve_linked_run_calculation_response.pool_contour_points
                self.n_pool_contour_points = vessel_relief_valve_linked_run_calculation_response.n_pool_contour_points
                self.area_contour_pool = vessel_relief_valve_linked_run_calculation_response.area_contour_pool
                self.explosion_overpressure_results = vessel_relief_valve_linked_run_calculation_response.explosion_overpressure_results
                self.distances_to_toxic_concentration = vessel_relief_valve_linked_run_calculation_response.distances_to_toxic_concentration
                self.toxic_concentration_used = vessel_relief_valve_linked_run_calculation_response.toxic_concentration_used
                self.toxic_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.toxic_conc_contour_points
                self.n_toxic_conc_contour_points = vessel_relief_valve_linked_run_calculation_response.n_toxic_conc_contour_points
                self.area_footprint_toxic_conc = vessel_relief_valve_linked_run_calculation_response.area_footprint_toxic_conc
                self.jet_fire_flame_result = vessel_relief_valve_linked_run_calculation_response.jet_fire_flame_result
                self.pool_fire_flame_result = vessel_relief_valve_linked_run_calculation_response.pool_fire_flame_result
                self.result_code = vessel_relief_valve_linked_run_calculation_response.result_code
                self.messages = vessel_relief_valve_linked_run_calculation_response.messages
                self.calculation_elapsed_time = vessel_relief_valve_linked_run_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_relief_valve_linked_run_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_relief_valve_linked_run_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselReliefValveLinkedRunCalculation object"""

        parts = ['* VesselReliefValveLinkedRun']

        parts.append('* Vessel')
        parts.append(f'vessel:	{str(self.vessel)}')
        parts.append('* ReliefValve')
        parts.append(f'relief_valve:	{str(self.relief_valve)}')
        parts.append('* DischargeParameters')
        parts.append(f'discharge_parameters:	{str(self.discharge_parameters)}')
        parts.append('* Substrate')
        parts.append(f'substrate:	{str(self.substrate)}')
        parts.append('* Weather')
        parts.append(f'weather:	{str(self.weather)}')
        parts.extend(['dispersion_parameters_element' for dispersion_parameters_element in self.dispersion_parameters] if self.dispersion_parameters else [f'dispersion_parameters does not contain any elements'])
        parts.append(f'dispersion_parameter_count:	{str(self.dispersion_parameter_count)}')
        parts.append(f'end_point_concentration:	{str(self.end_point_concentration)}')
        parts.append('* FlammableParameters')
        parts.append(f'flammable_parameters:	{str(self.flammable_parameters)}')
        parts.append('* ExplosionParameters')
        parts.append(f'explosion_parameters:	{str(self.explosion_parameters)}')
        parts.extend(['dispersion_flam_output_configs_element' for dispersion_flam_output_configs_element in self.dispersion_flam_output_configs] if self.dispersion_flam_output_configs else [f'dispersion_flam_output_configs does not contain any elements'])
        parts.append(f'dispersion_flam_output_config_count:	{str(self.dispersion_flam_output_config_count)}')
        parts.extend(['dispersion_toxic_output_configs_element' for dispersion_toxic_output_configs_element in self.dispersion_toxic_output_configs] if self.dispersion_toxic_output_configs else [f'dispersion_toxic_output_configs does not contain any elements'])
        parts.append(f'dispersion_toxic_output_config_count:	{str(self.dispersion_toxic_output_config_count)}')
        parts.extend(['flammable_output_configs_element' for flammable_output_configs_element in self.flammable_output_configs] if self.flammable_output_configs else [f'flammable_output_configs does not contain any elements'])
        parts.append(f'flammable_output_config_count:	{str(self.flammable_output_config_count)}')
        parts.extend(['explosion_output_configs_element' for explosion_output_configs_element in self.explosion_output_configs] if self.explosion_output_configs else [f'explosion_output_configs does not contain any elements'])
        parts.append(f'explosion_output_config_count:	{str(self.explosion_output_config_count)}')
        parts.extend(['explosion_confined_volumes_element' for explosion_confined_volumes_element in self.explosion_confined_volumes] if self.explosion_confined_volumes else [f'explosion_confined_volumes does not contain any elements'])
        parts.append(f'explosion_confined_volume_count:	{str(self.explosion_confined_volume_count)}')
        parts.append('* DischargeRecord')
        parts.append(f'discharge_record:	{str(self.discharge_record)}')
        parts.extend(['distances_to_jet_fire_radiation_element' for distances_to_jet_fire_radiation_element in self.distances_to_jet_fire_radiation] if self.distances_to_jet_fire_radiation else [f'distances_to_jet_fire_radiation does not contain any elements'])
        parts.extend(['jet_contour_points_element' for jet_contour_points_element in self.jet_contour_points] if self.jet_contour_points else [f'jet_contour_points does not contain any elements'])
        parts.extend(['n_jet_contour_points_element' for n_jet_contour_points_element in self.n_jet_contour_points] if self.n_jet_contour_points else [f'n_jet_contour_points does not contain any elements'])
        parts.extend(['area_contour_jet_element' for area_contour_jet_element in self.area_contour_jet] if self.area_contour_jet else [f'area_contour_jet does not contain any elements'])
        parts.extend(['distances_to_flam_concentration_element' for distances_to_flam_concentration_element in self.distances_to_flam_concentration] if self.distances_to_flam_concentration else [f'distances_to_flam_concentration does not contain any elements'])
        parts.extend(['flam_concentrations_used_element' for flam_concentrations_used_element in self.flam_concentrations_used] if self.flam_concentrations_used else [f'flam_concentrations_used does not contain any elements'])
        parts.extend(['flam_conc_contour_points_element' for flam_conc_contour_points_element in self.flam_conc_contour_points] if self.flam_conc_contour_points else [f'flam_conc_contour_points does not contain any elements'])
        parts.extend(['n_flam_conc_contour_points_element' for n_flam_conc_contour_points_element in self.n_flam_conc_contour_points] if self.n_flam_conc_contour_points else [f'n_flam_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_flam_conc_element' for area_footprint_flam_conc_element in self.area_footprint_flam_conc] if self.area_footprint_flam_conc else [f'area_footprint_flam_conc does not contain any elements'])
        parts.extend(['distances_to_pool_fire_radiation_element' for distances_to_pool_fire_radiation_element in self.distances_to_pool_fire_radiation] if self.distances_to_pool_fire_radiation else [f'distances_to_pool_fire_radiation does not contain any elements'])
        parts.extend(['pool_contour_points_element' for pool_contour_points_element in self.pool_contour_points] if self.pool_contour_points else [f'pool_contour_points does not contain any elements'])
        parts.extend(['n_pool_contour_points_element' for n_pool_contour_points_element in self.n_pool_contour_points] if self.n_pool_contour_points else [f'n_pool_contour_points does not contain any elements'])
        parts.extend(['area_contour_pool_element' for area_contour_pool_element in self.area_contour_pool] if self.area_contour_pool else [f'area_contour_pool does not contain any elements'])
        parts.extend(['explosion_overpressure_results_element' for explosion_overpressure_results_element in self.explosion_overpressure_results] if self.explosion_overpressure_results else [f'explosion_overpressure_results does not contain any elements'])
        parts.extend(['distances_to_toxic_concentration_element' for distances_to_toxic_concentration_element in self.distances_to_toxic_concentration] if self.distances_to_toxic_concentration else [f'distances_to_toxic_concentration does not contain any elements'])
        parts.extend(['toxic_concentration_used_element' for toxic_concentration_used_element in self.toxic_concentration_used] if self.toxic_concentration_used else [f'toxic_concentration_used does not contain any elements'])
        parts.extend(['toxic_conc_contour_points_element' for toxic_conc_contour_points_element in self.toxic_conc_contour_points] if self.toxic_conc_contour_points else [f'toxic_conc_contour_points does not contain any elements'])
        parts.extend(['n_toxic_conc_contour_points_element' for n_toxic_conc_contour_points_element in self.n_toxic_conc_contour_points] if self.n_toxic_conc_contour_points else [f'n_toxic_conc_contour_points does not contain any elements'])
        parts.extend(['area_footprint_toxic_conc_element' for area_footprint_toxic_conc_element in self.area_footprint_toxic_conc] if self.area_footprint_toxic_conc else [f'area_footprint_toxic_conc does not contain any elements'])
        parts.append('* FlameResult')
        parts.append(f'jet_fire_flame_result:	{str(self.jet_fire_flame_result)}')
        parts.append('* PoolFireFlameResult')
        parts.append(f'pool_fire_flame_result:	{str(self.pool_fire_flame_result)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselReliefValveLinkedRunCalculationResponseSchema(Schema):
    """Schema for the VesselReliefValveLinkedRunCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    discharge_record = fields.Nested(DischargeRecordSchema, data_key="dischargeRecord")
    distances_to_jet_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToJetFireRadiation")
    jet_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="jetContourPoints")
    n_jet_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nJetContourPoints")
    area_contour_jet = fields.List(fields.Float(), allow_none=True, data_key="areaContourJet")
    distances_to_flam_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToFlamConcentration")
    flam_concentrations_used = fields.List(fields.Float(), allow_none=True, data_key="flamConcentrationsUsed")
    flam_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="flamConcContourPoints")
    n_flam_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nFlamConcContourPoints")
    area_footprint_flam_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintFlamConc")
    distances_to_pool_fire_radiation = fields.List(fields.Float(), allow_none=True, data_key="distancesToPoolFireRadiation")
    pool_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="poolContourPoints")
    n_pool_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nPoolContourPoints")
    area_contour_pool = fields.List(fields.Float(), allow_none=True, data_key="areaContourPool")
    explosion_overpressure_results = fields.Nested(ExplosionOverpressureResultSchema, allow_none=True, many=True, data_key="explosionOverpressureResults")
    distances_to_toxic_concentration = fields.List(fields.Float(), allow_none=True, data_key="distancesToToxicConcentration")
    toxic_concentration_used = fields.List(fields.Float(), allow_none=True, data_key="toxicConcentrationUsed")
    toxic_conc_contour_points = fields.Nested(LocalPositionSchema, allow_none=True, many=True, data_key="toxicConcContourPoints")
    n_toxic_conc_contour_points = fields.List(fields.Int(), allow_none=True, data_key="nToxicConcContourPoints")
    area_footprint_toxic_conc = fields.List(fields.Float(), allow_none=True, data_key="areaFootprintToxicConc")
    jet_fire_flame_result = fields.Nested(FlameResultSchema, data_key="jetFireFlameResult")
    pool_fire_flame_result = fields.Nested(PoolFireFlameResultSchema, data_key="poolFireFlameResult")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_relief_valve_linked_run_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselReliefValveLinkedRunCalculationResponseSchema class."""

        return _VesselReliefValveLinkedRunCalculationResponse(**data)

class _VesselReliefValveLinkedRunCalculationResponse(_CalculationResponseBase):
    """
    _VesselReliefValveLinkedRunCalculationResponse class.

    Attributes
    ----------
        discharge_record : DischargeRecord
              a discharge record entity.
        distances_to_jet_fire_radiation : list[float]
              an array of distances to jet fire radiation levels, ordered according to the flammable output configs.
        jet_contour_points : list[LocalPosition]
              an array of jet fire radiation ellipse contour points, ordered according to the flammable output configs.
        n_jet_contour_points : list[int]
              an array of the number of jet fire radiation ellipse contour points, ordered according to the flammable output configs.
        area_contour_jet : list[float]
              an array of areas of the jet fire ellipses, ordered according to the flammable output configs.
        distances_to_flam_concentration : list[float]
              an array of distances to flammable concentration levels, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_concentrations_used : list[float]
              an array of flammable concentration levels used in the calculations, ordered according to the dispersion output configs for flammable concentrations of interest.
        flam_conc_contour_points : list[LocalPosition]
              an array of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        n_flam_conc_contour_points : list[int]
              an array of the number of maximum flammable concentration footprint contour points, ordered according to the dispersion output configs for flammable concentrations of interest.
        area_footprint_flam_conc : list[float]
              an array of areas of the maximum flammable concentration footprint contours, ordered according to the dispersion output configs for flammable concentrations of interest.
        distances_to_pool_fire_radiation : list[float]
              an array of distances to pool fire radiation levels, ordered according to the flammable output configs.
        pool_contour_points : list[LocalPosition]
              an array of pool fire radiation contour points, ordered according to the flammable output configs.
        n_pool_contour_points : list[int]
              an array of the number of pool fire radiation contour points, ordered according to the flammable output configs.
        area_contour_pool : list[float]
              an array of areas of the pool fire ellipses, ordered according to the flammable output configs.
        explosion_overpressure_results : list[ExplosionOverpressureResult]
              an array of explosion overpressure results, ordered according to the explosion output configs.
        distances_to_toxic_concentration : list[float]
              an array of distances to toxic concentration levels, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_concentration_used : list[float]
              an array of toxic concentration levels used in the calculations, ordered according to the dispersion output configs for toxic concentrations of interest.
        toxic_conc_contour_points : list[LocalPosition]
              an array of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        n_toxic_conc_contour_points : list[int]
              an array of the number of maximum toxic concentration footprint contour points, ordered according to the dispersion output configs for toxic concentrations of interest.
        area_footprint_toxic_conc : list[float]
              an array of areas of the maximum toxic concentration footprint contours, ordered according to the dispersion output configs for toxic concentrations of interest.
        jet_fire_flame_result : FlameResult
              a flame results entity, for jet fire.
        pool_fire_flame_result : PoolFireFlameResult
              a pool fire flame results entity, for pool fire.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, discharge_record: DischargeRecord, distances_to_jet_fire_radiation: list[float], jet_contour_points: list[LocalPosition], n_jet_contour_points: list[int], area_contour_jet: list[float], distances_to_flam_concentration: list[float], flam_concentrations_used: list[float], flam_conc_contour_points: list[LocalPosition], n_flam_conc_contour_points: list[int], area_footprint_flam_conc: list[float], distances_to_pool_fire_radiation: list[float], pool_contour_points: list[LocalPosition], n_pool_contour_points: list[int], area_contour_pool: list[float], explosion_overpressure_results: list[ExplosionOverpressureResult], distances_to_toxic_concentration: list[float], toxic_concentration_used: list[float], toxic_conc_contour_points: list[LocalPosition], n_toxic_conc_contour_points: list[int], area_footprint_toxic_conc: list[float], jet_fire_flame_result: FlameResult, pool_fire_flame_result: PoolFireFlameResult, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselReliefValveLinkedRunCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.discharge_record = discharge_record
        self.distances_to_jet_fire_radiation = distances_to_jet_fire_radiation
        self.jet_contour_points = jet_contour_points
        self.n_jet_contour_points = n_jet_contour_points
        self.area_contour_jet = area_contour_jet
        self.distances_to_flam_concentration = distances_to_flam_concentration
        self.flam_concentrations_used = flam_concentrations_used
        self.flam_conc_contour_points = flam_conc_contour_points
        self.n_flam_conc_contour_points = n_flam_conc_contour_points
        self.area_footprint_flam_conc = area_footprint_flam_conc
        self.distances_to_pool_fire_radiation = distances_to_pool_fire_radiation
        self.pool_contour_points = pool_contour_points
        self.n_pool_contour_points = n_pool_contour_points
        self.area_contour_pool = area_contour_pool
        self.explosion_overpressure_results = explosion_overpressure_results
        self.distances_to_toxic_concentration = distances_to_toxic_concentration
        self.toxic_concentration_used = toxic_concentration_used
        self.toxic_conc_contour_points = toxic_conc_contour_points
        self.n_toxic_conc_contour_points = n_toxic_conc_contour_points
        self.area_footprint_toxic_conc = area_footprint_toxic_conc
        self.jet_fire_flame_result = jet_fire_flame_result
        self.pool_fire_flame_result = pool_fire_flame_result
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id

class _VesselStateCalculationRequest(_CalculationRequestBase):
    """
    _VesselStateCalculationRequest class.

    Attributes
    ----------
        material : Material
              a material entity.
        material_state : State
              a state entity describing the fluid pressure, temperature, liquid fraction.

    """
    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the _VesselStateCalculationRequest class"""

        super().__init__()

        self.material = material
        self.material_state = material_state

class _VesselStateCalculationRequestSchema(Schema):
    """Schema for the VesselState calculation request, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    material = fields.Nested(MaterialSchema, data_key="material")
    material_state = fields.Nested(StateSchema, data_key="materialState")

    @post_load
    def make_vessel_state_calculation_request(self, data, **kwargs):
        """Post-processing of the VesselStateCalculationRequestSchema class."""

        return _VesselStateCalculationRequest(**data)

class VesselStateCalculation(_CalculationBase):
    """
    VesselStateCalculation class.

    Attributes
    ----------
    Calculation inputs:
        material : Material
              a material entity.
        material_state : State
              a state entity describing the fluid pressure, temperature, liquid fraction.

    Calculation outputs:
        vessel_conditions : VesselConditions
             The conditions of the material in the vessel.
        output_state : State
              a state entity describing the fluid pressure, temperature and liquid fraction after the flash calculation.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    Methods
    -------
    run:
        Runs the calculation.
    """

    def __init__(self, material: Material, material_state: State):
        """Initializes a new instance of the VesselStateCalculation class"""

        super().__init__()

        # Calculation inputs.
        self.material = material
        self.material_state = material_state

        # Calculation outputs.
        self.vessel_conditions = None
        self.output_state = None
        self.result_code = None
        self.messages = list[str]()
        self.calculation_elapsed_time = 0
        self.operation_id = ''


    def run(self) -> ResultCode:
        """
        VesselStateCalculation run method.

        Returns
        -------
        result_code : ResultCode
            -1: Failed validation
            0: Success
            +1: Failed execution
        """

        # Create the _VesselStateCalculationRequest object.
        vessel_state_calculation_request = _VesselStateCalculationRequest(self.material, self.material_state)

        # Get the _VesselStateCalculationRequestSchema and use that to serialize to json.
        vessel_state_calculation_request_schema = _VesselStateCalculationRequestSchema()

        request_json = vessel_state_calculation_request_schema.dumps(vessel_state_calculation_request)
        url = get_analytics_api_target() + 'calculatevesselstate?clientId=' + get_client_alias_id()

        # Default the result code to an unexpected application error.
        self.result_code = ResultCode.UNEXPECTED_APPLICATION_ERROR

        # Use the base class post_request method to post the request.
        response = _CalculationBase.post_request(self, url, request_json, get_access_token())

        if response.ok:

            # The response is OK, so deserialize the response.
            vessel_state_calculation_response_schema = _VesselStateCalculationResponseSchema()
            vessel_state_calculation_response = vessel_state_calculation_response_schema.loads(response.text)

            # Set the calculation outputs.
            self.result_code = ResultCode(vessel_state_calculation_response.result_code)

            if (self.result_code == ResultCode.SUCCESS):
                self.vessel_conditions = vessel_state_calculation_response.vessel_conditions
                self.output_state = vessel_state_calculation_response.output_state
                self.result_code = vessel_state_calculation_response.result_code
                self.messages = vessel_state_calculation_response.messages
                self.calculation_elapsed_time = vessel_state_calculation_response.calculation_elapsed_time
                self.operation_id = vessel_state_calculation_response.operation_id

            else:
                # The calculation was not successful, so send back whatever messages we received.
                self.messages.extend(vessel_state_calculation_response.messages)

        else:
            # The calculation call failed, so deserialize the failed response.
            try:
                calculation_failed_response_schema = _CalculationFailedResponseSchema()
                calculation_failed_response = calculation_failed_response_schema.loads(response.text)
                self.result_code = ResultCode(calculation_failed_response.result_code)
                self.messages.extend(calculation_failed_response.messages)
                self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                self.operation_id = calculation_failed_response.operation_id
            except ValidationError as e:
                   self.messages.append(f"Validation error: {e.messages}")
            except Exception as e:
                   self.messages.append(f"Unexpected error: {str(e)}")
                   self.messages.append(f"{response.reason} (Status code: {response.status_code})")
                   return self.result_code
        return self.result_code

    def __str__(self):
        """Return a string representation of the VesselStateCalculation object"""

        parts = ['* VesselState']

        parts.append('* Material')
        parts.append(f'material:	{str(self.material)}')
        parts.append('* State')
        parts.append(f'material_state:	{str(self.material_state)}')
        parts.append(f'vessel_conditions:	{str(self.vessel_conditions)}')
        parts.append('* State')
        parts.append(f'output_state:	{str(self.output_state)}')
        parts.append(f'result_code:	{str(self.result_code)}')
        parts.append(f'calculation_elapsed_time:	{"(None)" if self.calculation_elapsed_time is None else self.calculation_elapsed_time}')
        parts.append(f'operation_id:	{"(None)" if self.operation_id is None else self.operation_id}')

        return '\n'.join(parts)

class _VesselStateCalculationResponseSchema(Schema):
    """Schema for the VesselStateCalculationResponse class, used by marshmallow in json serialization/deserialization"""

    class Meta:
        unknown = EXCLUDE  # Exclude unknown fields

    vessel_conditions = fields.Enum(VesselConditions, by_value=True, data_key="vesselConditions")
    output_state = fields.Nested(StateSchema, data_key="outputState")
    result_code = fields.Enum(ResultCode, by_value=True, data_key="resultCode")
    messages = fields.List(fields.Str(data_key="messages"))
    calculation_elapsed_time = fields.Int(data_key="calculationElapsedTime")
    operation_id = fields.Str(data_key="operationId")
    @post_load
    def make_vessel_state_calculation_response(self, data, **kwargs):
        """Post-processing of the VesselStateCalculationResponseSchema class."""

        return _VesselStateCalculationResponse(**data)

class _VesselStateCalculationResponse(_CalculationResponseBase):
    """
    _VesselStateCalculationResponse class.

    Attributes
    ----------
        vessel_conditions : VesselConditions
             The conditions of the material in the vessel.
        output_state : State
              a state entity describing the fluid pressure, temperature and liquid fraction after the flash calculation.
        result_code : ResultCode
             Error code (0 = OK, < 0 data input error, > 0 execution error).
        messages : list[str]
             Messages coming back from the calculation
        calculation_elapsed_time : int
             Messages coming back from the calculation
        operation_id : str
             Messages coming back from the calculation
    """
    def __init__(self, vessel_conditions: VesselConditions, output_state: State, result_code: ResultCode, messages: list[str], calculation_elapsed_time: int, operation_id: str):
        """Initializes a new instance of the VesselStateCalculationResponse class"""
        super().__init__(result_code, messages, calculation_elapsed_time, operation_id)

        self.vessel_conditions = vessel_conditions
        self.output_state = output_state
        self.result_code = result_code
        self.messages = messages
        self.calculation_elapsed_time = calculation_elapsed_time
        self.operation_id = operation_id