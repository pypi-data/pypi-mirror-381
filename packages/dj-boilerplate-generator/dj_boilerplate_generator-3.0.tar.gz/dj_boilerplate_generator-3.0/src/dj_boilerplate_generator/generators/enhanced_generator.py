# src/dj_boilerplate_generator/generators/enhanced_generator.py
"""
Enhance the base Django project with enterprise features
"""

import shutil
from pathlib import Path
from typing import Dict
import jinja2

from .django_core import DjangoCoreGenerator


class EnhancedProjectGenerator(DjangoCoreGenerator):
    """Enhance Django project with enterprise features"""
    
    def __init__(self):
        super().__init__()
        template_path = Path(__file__).parent.parent / 'templates' / 'phase1'
        self.template_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(str(template_path)),
            trim_blocks=True,
            lstrip_blocks=True
        )
    
    def generate_enterprise_project(self, config: Dict):
        """Main method to generate enterprise Django project"""
        # Step 1: Create base Django project
        self.create_django_project(config)
        
        # Step 2: Enhance with enterprise features
        project_path = Path(config['output_dir']) / config['project_name']
        
        self._convert_to_modular_settings(project_path, config)
        self._create_enterprise_structure(project_path, config)
        self._enhance_settings_with_enterprise_features(project_path, config)
        self._setup_development_environment(project_path, config)
        self._add_enterprise_configurations(project_path, config)
    
    def _convert_to_modular_settings(self, project_path: Path, config: Dict):
        """Convert single settings.py to modular settings structure"""
        settings_file = project_path / config['project_name'] / 'settings.py'
        
        if settings_file.exists():
            # Backup original settings
            backup_path = settings_file.with_suffix('.py.original')
            shutil.copy2(settings_file, backup_path)
            
            # Create settings directory
            settings_dir = project_path / config['project_name'] / 'settings'
            settings_dir.mkdir(exist_ok=True)
            
            # Convert to modular structure
            self._create_modular_settings(settings_dir, config, settings_file)
            
            # Remove original settings.py
            settings_file.unlink()
            
            print("✅ Converted to modular settings structure")
    
    def _create_modular_settings(self, settings_dir: Path, config: Dict, original_settings: Path):
        """Create modular settings from original settings.py"""
        
        # Read original settings content
        original_content = original_settings.read_text()
        
        # Create base.py with enterprise enhancements
        base_content = self._generate_base_settings(original_content, config)
        (settings_dir / 'base.py').write_text(base_content,encoding="utf-8")
        
        # Create environment-specific settings
        (settings_dir / 'development.py').write_text(self._generate_development_settings(config),encoding="utf-8")
        (settings_dir / 'production.py').write_text(self._generate_production_settings(config),encoding="utf-8")
        (settings_dir / 'testing.py').write_text(self._generate_testing_settings(config),encoding="utf-8")
        
        # Create __init__.py that handles environment detection
        init_content = f"""
\"\"\"
Enterprise Django Settings - Auto-configured based on environment
\"\"\"

import os
from .base import *

# Environment detection
DJANGO_ENV = os.environ.get('DJANGO_ENV', 'development')

if DJANGO_ENV == 'production':
    from .production import *
elif DJANGO_ENV == 'testing':
    from .testing import *
else:
    from .development import *

# Import original settings to maintain compatibility
try:
    from .original_settings import *
except ImportError:
    pass
"""
        (settings_dir / '__init__.py').write_text(init_content)
    
    def _generate_base_settings(self, original_content: str, config: Dict) -> str:
        """Generate enhanced base settings"""
        # Extract key parts from original settings and enhance them
        base_template = f"""
\"\"\"
Enterprise Base Settings for {config['project_name']}
Generated by Ultimate Django Boilerplate Generator
\"\"\"

import os
from pathlib import Path
from decouple import config as decouple_config
import dj_database_url

# Original settings preserved
{original_content}

# === ENTERPRISE ENHANCEMENTS ===

# Security enhancements
SECURE_SSL_REDIRECT = decouple_config('SECURE_SSL_REDIRECT', default=not DEBUG, cast=bool)
CSRF_COOKIE_SECURE = decouple_config('CSRF_COOKIE_SECURE', default=not DEBUG, cast=bool)
SESSION_COOKIE_SECURE = decouple_config('SESSION_COOKIE_SECURE', default=not DEBUG, cast=bool)
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'

# Static files with WhiteNoise
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

# Database URL support
if os.environ.get('DATABASE_URL'):
    DATABASES['default'] = dj_database_url.config(
        conn_max_age=600,
        conn_health_checks=True,
    )

# Additional installed apps
ENTERPRISE_APPS = [
    'django_extensions',
    'health_check',
    'health_check.db',
    'health_check.cache',
    'health_check.storage',
]

INSTALLED_APPS += ENTERPRISE_APPS

# Additional middleware
ENTERPRISE_MIDDLEWARE = [
    'whitenoise.middleware.WhiteNoiseMiddleware',
]

# Insert after SecurityMiddleware
security_index = None
for i, middleware in enumerate(MIDDLEWARE):
    if 'SecurityMiddleware' in middleware:
        security_index = i
        break

if security_index is not None:
    for enterprise_mw in reversed(ENTERPRISE_MIDDLEWARE):
        MIDDLEWARE.insert(security_index + 1, enterprise_mw)

# Logging configuration
LOGGING = {{
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {{
        'console': {{
            'class': 'logging.StreamHandler',
        }},
    }},
    'root': {{
        'handlers': ['console'],
        'level': 'INFO',
    }},
}}
"""
        return base_template
    
    def _generate_development_settings(self, config: Dict) -> str:
        """Generate development-specific settings"""
        return f"""
\"\"\"
Development Settings for {config['project_name']}
\"\"\"

from .base import *

DEBUG = True

# Development-specific apps
DEV_APPS = [
    'debug_toolbar',
]

INSTALLED_APPS += DEV_APPS

# Debug Toolbar middleware
MIDDLEWARE.insert(0, 'debug_toolbar.middleware.DebugToolbarMiddleware')

# Debug Toolbar configuration
INTERNAL_IPS = [
    '127.0.0.1',
]

# Email configuration for development
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# Allow all hosts for development
ALLOWED_HOSTS = ['*']
"""
    
    def _generate_production_settings(self, config: Dict) -> str:
        """Generate production-specific settings"""
        return f"""
\"\"\"
Production Settings for {config['project_name']}
\"\"\"

from .base import *

DEBUG = False

# Security settings for production
SECURE_HSTS_SECONDS = 31536000  # 1 year
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Production logging
LOGGING['handlers']['file'] = {{
    'level': 'ERROR',
    'class': 'logging.FileHandler',
    'filename': '/var/log/django/error.log',
}}
LOGGING['root']['handlers'] = ['file', 'console']
"""
    
    def _generate_testing_settings(self, config: Dict) -> str:
        """Generate testing-specific settings"""
        return f"""
\"\"\"
Testing Settings for {config['project_name']}
\"\"\"

from .base import *

# Use faster password hasher for tests
PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.MD5PasswordHasher',
]

# Use in-memory database for tests
DATABASES['default'] = {{
    'ENGINE': 'django.db.backends.sqlite3',
    'NAME': ':memory:',
}}
"""
    
    def _create_enterprise_structure(self, project_path: Path, config: Dict):
        """Create enterprise directory structure"""
        directories = [
            project_path / 'apps',
            project_path / 'apps' / 'core',
            project_path / 'static',
            project_path / 'static' / 'css',
            project_path / 'static' / 'js',
            project_path / 'static' / 'images',
            # Templates
            project_path / 'templates',
            project_path / 'templates' / 'admin',
            project_path / 'templates' / 'registration',
            # Requirements
            project_path / 'requirements',
            # Documentation
            project_path / 'docs',
            project_path / 'docs' / 'architecture',
            project_path / 'docs' / 'deployment',
            # Configuration
            project_path / 'config',
            project_path / 'config' / 'environments',
             # Scripts
            project_path / 'scripts',
            project_path / 'scripts' / 'deployment',
            project_path / 'scripts' / 'monitoring',
        ]

        # Add SRE directories if enabled
        if 'sre' in config['features']:
            directories.extend([
                project_path / 'monitoring',
                project_path / 'monitoring' / 'dashboards',
                project_path / 'monitoring' / 'alerts',
            ])
        
         # Add Docker directories if enabled
        if 'docker' in config['features']:
            directories.extend([
                project_path / 'docker',
                project_path / 'docker' / 'development',
                project_path / 'docker' / 'production',
            ])
        
        for directory in directories:
            directory.mkdir(exist_ok=True)
            if 'apps' in str(directory):
                (directory / '__init__.py').touch()

        
        print("✅ Created enterprise directory structure")
    
    def _enhance_settings_with_enterprise_features(self, project_path: Path, config: Dict):
        """Add enterprise features to settings"""
        settings_init = project_path / config['project_name'] / 'settings' / '__init__.py'
        
        if settings_init.exists():
            content = settings_init.read_text()
            
            # Add feature-based configurations
            feature_configs = self._get_feature_configurations(config)
            enhanced_content = content.replace(
                '# Import original settings to maintain compatibility',
                feature_configs + '\n# Import original settings to maintain compatibility'
            )
            
            settings_init.write_text(enhanced_content)
        
        print("✅ Enhanced settings with enterprise features")
    
    def _get_feature_configurations(self, config: Dict) -> str:
        """Generate configuration based on selected features"""
        configurations = []
        
        if 'docker' in config['features']:
            configurations.append("""
# Docker-specific configurations
if os.environ.get('DOCKER_CONTAINER'):
    ALLOWED_HOSTS = ['*']
    DATABASES['default']['HOST'] = os.environ.get('DB_HOST', 'db')
            """)
        
        if 'sre' in config['features']:
            
            configurations.append("""
# SRE and Monitoring configurations
INSTALLED_APPS.append('django_prometheus')
MIDDLEWARE.insert(0, 'django_prometheus.middleware.PrometheusBeforeMiddleware')
MIDDLEWARE.append('django_prometheus.middleware.PrometheusAfterMiddleware')
            """)
        
        return '\n'.join(configurations)
    
    def _setup_development_environment(self, project_path: Path, config: Dict):
        """Setup development tools and configurations"""
        # Create requirements files
        requirements_content = self._generate_requirements(config)
        requirements_dir = project_path / 'requirements'
        
        (requirements_dir / 'base.txt').write_text(requirements_content['base'],encoding="utf-8")
        (requirements_dir / 'dev.txt').write_text(requirements_content['dev'],encoding="utf-8")
        (requirements_dir / 'production.txt').write_text(requirements_content['production'],encoding="utf-8")
        
        # Create .env.example
        env_example = f"""
# Django Settings
DEBUG=False
SECRET_KEY=your-super-secret-key-here-for-{config['project_name']}
ALLOWED_HOSTS=localhost,127.0.0.1

# Database
DATABASE_URL=sqlite:///db.sqlite3

# Feature Flags
ENABLE_SRE={str('sre' in config['features']).lower()}
ENABLE_DOCKER={str('docker' in config['features']).lower()}
"""
        (project_path / '.env.example').write_text(env_example)
        
        # Create .gitignore
        gitignore = self._generate_gitignore()
        (project_path / '.gitignore').write_text(gitignore,encoding="utf-8")
        
        # Create pre-commit config
        pre_commit_config = self._generate_pre_commit_config()
        (project_path / '.pre-commit-config.yaml').write_text(pre_commit_config,encoding="utf-8")
        
        print("✅ Development environment setup completed")
    
    def _add_enterprise_configurations(self, project_path: Path, config: Dict):
        """Add enterprise configuration files"""
        # Create Docker files if enabled
        if 'docker' in config['features']:
            self._create_docker_configuration(project_path, config)
        
        
        # Create basic core app
        self._create_core_app(project_path, config)
        
        # Create enhanced README
        readme_content = self._generate_readme(config)
        (project_path / 'README.md').write_text(readme_content,encoding="utf-8")
        
        print("✅ Enterprise configurations added")
    
    def _generate_requirements(self, config: Dict) -> Dict[str, str]:
        """Generate requirements files"""
        base_req = [
            "Django>=4.2,<5.0",
            "python-decouple>=3.8",
            "whitenoise>=6.4.0",
            "dj-database-url>=1.0.0",
            "django-extensions>=3.2.1",
            "django-health-check>=3.16.5",
        ]
        
        dev_req = base_req + [
            "pytest>=7.3.1",
            "pytest-django>=4.5.2",
            "black>=23.7.0",
            "isort>=5.12.0",
            "flake8>=6.0.0",
            "pre-commit>=3.3.0",
            "django-debug-toolbar>=4.1.0",
        ]
        
        prod_req = base_req + [
            "gunicorn>=20.1.0",
        ]
        
        if 'sre' in config['features']:
            prod_req.append("django-prometheus>=2.3.0")
        
        return {
            'base': '\n'.join(base_req),
            'dev': '\n'.join(dev_req),
            'production': '\n'.join(prod_req)
        }
    
    def _generate_gitignore(self) -> str:
        """Generate .gitignore file"""
        return """
# Django
*.log
*.pot
*.pyc
__pycache__/
db.sqlite3
media/
staticfiles/

# Environment variables
.env
.venv

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
"""
    
    def _generate_pre_commit_config(self) -> str:
        """Generate pre-commit configuration"""
        return """
repos:
-   repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
    -   id: black
-   repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
    -   id: isort
"""
    
    def _create_docker_configuration(self, project_path: Path, config: Dict):
        """Generate Docker configuration using f-strings."""

        # Assign variables for clarity
        python_version = config['python_version']
        project_name = config['project_name']

        # --- Dockerfile ---
        dockerfile = f"""
    # Multi-stage Docker build for Enterprise Django
    FROM python:{python_version}-slim as builder

    # Install build dependencies
    RUN apt-get update && apt-get install -y \\
        gcc \\
        postgresql-dev \\
        && rm -rf /var/lib/apt/lists/*

    # Create virtual environment
    RUN python -m venv /opt/venv
    ENV PATH="/opt/venv/bin:$PATH"

    # Install dependencies
    COPY requirements/production.txt .
    RUN pip install --upgrade pip
    RUN pip install -r production.txt

    # --- Runtime stage ---
    FROM python:{python_version}-slim

    # Install runtime dependencies
    RUN apt-get update && apt-get install -y \\
        libpq5 \\
        && rm -rf /var/lib/apt/lists/*

    # Copy virtual environment
    COPY --from=builder /opt/venv /opt/venv
    ENV PATH="/opt/venv/bin:$PATH"

    # Create app user
    RUN useradd --create-home --shell /bin/bash app
    USER app
    WORKDIR /home/app

    # Copy project
    COPY --chown=app:app . .

    # Collect static files
    RUN python manage.py collectstatic --noinput

    # Run gunicorn
    CMD ["gunicorn", "--bind", "0.0.0.0:8000", "{project_name}.wsgi:application"]
    """
        
        # --- docker-compose.yml ---
        compose_docker_file = f"""
    version: '3.8'

    services:
    web:
        build: .
        command: gunicorn --bind 0.0.0.0:8000 {project_name}.wsgi:application
        volumes:
        - .:/app
        ports:
        - "8000:8000"
        environment:
        - DATABASE_URL=postgres://user:password@db:5432/{project_name}
        - DJANGO_ENV=production
        depends_on:
        - db

    db:
        image: postgres:13
        environment:
        - POSTGRES_DB={project_name}
        - POSTGRES_USER=user
        - POSTGRES_PASSWORD=password
        volumes:
        - postgres_data:/var/lib/postgresql/data

    volumes:
    postgres_data:
    """
        
        try:
            (project_path / 'Dockerfile').write_text(dockerfile, encoding="utf-8")
            (project_path / 'docker-compose.yml').write_text(compose_docker_file, encoding="utf-8")
            print("✅ Docker configuration files created")
        except Exception as e:
            print(f"Error generating Docker configuration: {e}")
    
    def _create_core_app(self, project_path: Path, config: Dict):
        """Create a basic core app"""
        core_app_dir = project_path / 'apps' / 'core'
        
        # Create basic app structure
        (core_app_dir / 'models.py').write_text("# Core app models\n",encoding="utf-8")
        (core_app_dir / 'views.py').write_text("# Core app views\n",encoding="utf-8")
        (core_app_dir / 'admin.py').write_text("# Core app admin\n",encoding="utf-8")
        
        # Create apps.py
        apps_content = f"""
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.core'
    verbose_name = 'Core Application'
"""
        (core_app_dir / 'apps.py').write_text(apps_content,encoding="utf-8")
    
    def _generate_readme(self, config: Dict) -> str:
        """Generate README.md"""
        return f"""# {config['project_name']}

Enterprise Django Project generated with Ultimate Django Boilerplate Generator.

## Features

- ✅ Built on Django's official startproject foundation
- ✅ Modular settings architecture
- ✅ Enterprise security configurations
- ✅ Development tools pre-configured
- ✅ {'Docker support' if 'docker' in config['features'] else ''}
- ✅ {'SRE monitoring' if 'sre' in config['features'] else ''}

## Quick Start

```bash
python manage.py migrate
python manage.py runserver"""