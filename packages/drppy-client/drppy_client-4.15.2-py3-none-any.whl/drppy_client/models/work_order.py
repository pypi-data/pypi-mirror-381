# coding: utf-8

"""
    DigitalRebar Provision Server

    # An RestFUL API-driven Provisioner and DHCP server  # noqa: E501

    OpenAPI spec version: 4.15.0
    Contact: support@rackn.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from drppy_client.configuration import Configuration


class WorkOrder(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'archived': 'bool',
        'available': 'bool',
        'blueprint': 'str',
        'bundle': 'str',
        'context': 'str',
        'create_time': 'datetime',
        'created_at': 'datetime',
        'created_by': 'str',
        'current_job': 'str',
        'current_task': 'int',
        'end_time': 'datetime',
        'endpoint': 'str',
        'errors': 'list[str]',
        'filter': 'str',
        'job_exit_state': 'str',
        'job_result_errors': 'list[str]',
        'job_state': 'str',
        'last_modified_at': 'datetime',
        'last_modified_by': 'str',
        'machine': 'str',
        'meta': 'Meta',
        'params': 'dict(str, object)',
        'profiles': 'list[str]',
        'read_only': 'bool',
        'retry_task_attempt': 'int',
        'runnable': 'bool',
        'stage': 'str',
        'start_time': 'datetime',
        'state': 'str',
        'status': 'str',
        'task_error_stacks': 'list[TaskStack]',
        'tasks': 'list[str]',
        'uuid': 'str',
        'validated': 'bool'
    }

    attribute_map = {
        'archived': 'Archived',
        'available': 'Available',
        'blueprint': 'Blueprint',
        'bundle': 'Bundle',
        'context': 'Context',
        'create_time': 'CreateTime',
        'created_at': 'CreatedAt',
        'created_by': 'CreatedBy',
        'current_job': 'CurrentJob',
        'current_task': 'CurrentTask',
        'end_time': 'EndTime',
        'endpoint': 'Endpoint',
        'errors': 'Errors',
        'filter': 'Filter',
        'job_exit_state': 'JobExitState',
        'job_result_errors': 'JobResultErrors',
        'job_state': 'JobState',
        'last_modified_at': 'LastModifiedAt',
        'last_modified_by': 'LastModifiedBy',
        'machine': 'Machine',
        'meta': 'Meta',
        'params': 'Params',
        'profiles': 'Profiles',
        'read_only': 'ReadOnly',
        'retry_task_attempt': 'RetryTaskAttempt',
        'runnable': 'Runnable',
        'stage': 'Stage',
        'start_time': 'StartTime',
        'state': 'State',
        'status': 'Status',
        'task_error_stacks': 'TaskErrorStacks',
        'tasks': 'Tasks',
        'uuid': 'Uuid',
        'validated': 'Validated'
    }

    def __init__(self, archived=None, available=None, blueprint=None, bundle=None, context=None, create_time=None, created_at=None, created_by=None, current_job=None, current_task=None, end_time=None, endpoint=None, errors=None, filter=None, job_exit_state=None, job_result_errors=None, job_state=None, last_modified_at=None, last_modified_by=None, machine=None, meta=None, params=None, profiles=None, read_only=None, retry_task_attempt=None, runnable=None, stage=None, start_time=None, state=None, status=None, task_error_stacks=None, tasks=None, uuid=None, validated=None, _configuration=None):  # noqa: E501
        """WorkOrder - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._archived = None
        self._available = None
        self._blueprint = None
        self._bundle = None
        self._context = None
        self._create_time = None
        self._created_at = None
        self._created_by = None
        self._current_job = None
        self._current_task = None
        self._end_time = None
        self._endpoint = None
        self._errors = None
        self._filter = None
        self._job_exit_state = None
        self._job_result_errors = None
        self._job_state = None
        self._last_modified_at = None
        self._last_modified_by = None
        self._machine = None
        self._meta = None
        self._params = None
        self._profiles = None
        self._read_only = None
        self._retry_task_attempt = None
        self._runnable = None
        self._stage = None
        self._start_time = None
        self._state = None
        self._status = None
        self._task_error_stacks = None
        self._tasks = None
        self._uuid = None
        self._validated = None
        self.discriminator = None

        self.archived = archived
        if available is not None:
            self.available = available
        self.blueprint = blueprint
        if bundle is not None:
            self.bundle = bundle
        if context is not None:
            self.context = context
        if create_time is not None:
            self.create_time = create_time
        if created_at is not None:
            self.created_at = created_at
        if created_by is not None:
            self.created_by = created_by
        if current_job is not None:
            self.current_job = current_job
        self.current_task = current_task
        if end_time is not None:
            self.end_time = end_time
        if endpoint is not None:
            self.endpoint = endpoint
        if errors is not None:
            self.errors = errors
        if filter is not None:
            self.filter = filter
        if job_exit_state is not None:
            self.job_exit_state = job_exit_state
        if job_result_errors is not None:
            self.job_result_errors = job_result_errors
        if job_state is not None:
            self.job_state = job_state
        if last_modified_at is not None:
            self.last_modified_at = last_modified_at
        if last_modified_by is not None:
            self.last_modified_by = last_modified_by
        if machine is not None:
            self.machine = machine
        if meta is not None:
            self.meta = meta
        if params is not None:
            self.params = params
        if profiles is not None:
            self.profiles = profiles
        if read_only is not None:
            self.read_only = read_only
        if retry_task_attempt is not None:
            self.retry_task_attempt = retry_task_attempt
        if runnable is not None:
            self.runnable = runnable
        if stage is not None:
            self.stage = stage
        if start_time is not None:
            self.start_time = start_time
        self.state = state
        if status is not None:
            self.status = status
        if task_error_stacks is not None:
            self.task_error_stacks = task_error_stacks
        if tasks is not None:
            self.tasks = tasks
        self.uuid = uuid
        if validated is not None:
            self.validated = validated

    @property
    def archived(self):
        """Gets the archived of this WorkOrder.  # noqa: E501

        Archived indicates whether the complete log for the async action can be retrieved via the API.  If Archived is true, then the log cannot be retrieved.  # noqa: E501

        :return: The archived of this WorkOrder.  # noqa: E501
        :rtype: bool
        """
        return self._archived

    @archived.setter
    def archived(self, archived):
        """Sets the archived of this WorkOrder.

        Archived indicates whether the complete log for the async action can be retrieved via the API.  If Archived is true, then the log cannot be retrieved.  # noqa: E501

        :param archived: The archived of this WorkOrder.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and archived is None:
            raise ValueError("Invalid value for `archived`, must not be `None`")  # noqa: E501

        self._archived = archived

    @property
    def available(self):
        """Gets the available of this WorkOrder.  # noqa: E501

        Available tracks whether or not the model passed validation.  # noqa: E501

        :return: The available of this WorkOrder.  # noqa: E501
        :rtype: bool
        """
        return self._available

    @available.setter
    def available(self, available):
        """Sets the available of this WorkOrder.

        Available tracks whether or not the model passed validation.  # noqa: E501

        :param available: The available of this WorkOrder.  # noqa: E501
        :type: bool
        """

        self._available = available

    @property
    def blueprint(self):
        """Gets the blueprint of this WorkOrder.  # noqa: E501

        Blueprint defines the tasks and base parameters for this action  # noqa: E501

        :return: The blueprint of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._blueprint

    @blueprint.setter
    def blueprint(self, blueprint):
        """Sets the blueprint of this WorkOrder.

        Blueprint defines the tasks and base parameters for this action  # noqa: E501

        :param blueprint: The blueprint of this WorkOrder.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and blueprint is None:
            raise ValueError("Invalid value for `blueprint`, must not be `None`")  # noqa: E501

        self._blueprint = blueprint

    @property
    def bundle(self):
        """Gets the bundle of this WorkOrder.  # noqa: E501

        Bundle tracks the name of the store containing this object. This field is read-only, and cannot be changed via the API.  # noqa: E501

        :return: The bundle of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._bundle

    @bundle.setter
    def bundle(self, bundle):
        """Sets the bundle of this WorkOrder.

        Bundle tracks the name of the store containing this object. This field is read-only, and cannot be changed via the API.  # noqa: E501

        :param bundle: The bundle of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._bundle = bundle

    @property
    def context(self):
        """Gets the context of this WorkOrder.  # noqa: E501

        Contexts contains the name of the current execution context. An empty string indicates that an agent running on a Machine should be executing tasks, and any other value means that an agent running with its context set for this value should be executing tasks.  # noqa: E501

        :return: The context of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._context

    @context.setter
    def context(self, context):
        """Sets the context of this WorkOrder.

        Contexts contains the name of the current execution context. An empty string indicates that an agent running on a Machine should be executing tasks, and any other value means that an agent running with its context set for this value should be executing tasks.  # noqa: E501

        :param context: The context of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._context = context

    @property
    def create_time(self):
        """Gets the create_time of this WorkOrder.  # noqa: E501

        CreateTime is the time the work order was created.  This is distinct from StartTime, as there may be a significant delay before the workorder starts running.  # noqa: E501

        :return: The create_time of this WorkOrder.  # noqa: E501
        :rtype: datetime
        """
        return self._create_time

    @create_time.setter
    def create_time(self, create_time):
        """Sets the create_time of this WorkOrder.

        CreateTime is the time the work order was created.  This is distinct from StartTime, as there may be a significant delay before the workorder starts running.  # noqa: E501

        :param create_time: The create_time of this WorkOrder.  # noqa: E501
        :type: datetime
        """

        self._create_time = create_time

    @property
    def created_at(self):
        """Gets the created_at of this WorkOrder.  # noqa: E501

        CreatedAt is the time that this object was created.  # noqa: E501

        :return: The created_at of this WorkOrder.  # noqa: E501
        :rtype: datetime
        """
        return self._created_at

    @created_at.setter
    def created_at(self, created_at):
        """Sets the created_at of this WorkOrder.

        CreatedAt is the time that this object was created.  # noqa: E501

        :param created_at: The created_at of this WorkOrder.  # noqa: E501
        :type: datetime
        """

        self._created_at = created_at

    @property
    def created_by(self):
        """Gets the created_by of this WorkOrder.  # noqa: E501

        CreatedBy stores the value of the user that created this object. Note: This value is stored ONLY if the object was created by a user which means that `currentUserName` needs to be populated in the authBlob  # noqa: E501

        :return: The created_by of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._created_by

    @created_by.setter
    def created_by(self, created_by):
        """Sets the created_by of this WorkOrder.

        CreatedBy stores the value of the user that created this object. Note: This value is stored ONLY if the object was created by a user which means that `currentUserName` needs to be populated in the authBlob  # noqa: E501

        :param created_by: The created_by of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._created_by = created_by

    @property
    def current_job(self):
        """Gets the current_job of this WorkOrder.  # noqa: E501

        The UUID of the job that is currently running.  # noqa: E501

        :return: The current_job of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._current_job

    @current_job.setter
    def current_job(self, current_job):
        """Sets the current_job of this WorkOrder.

        The UUID of the job that is currently running.  # noqa: E501

        :param current_job: The current_job of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._current_job = current_job

    @property
    def current_task(self):
        """Gets the current_task of this WorkOrder.  # noqa: E501

        The index into the Tasks list for the task that is currently running (if a task is running) or the next task that will run (if no task is currently running).  If -1, then the first task will run next, and if it is equal to the length of the Tasks list then all the tasks have finished running.  # noqa: E501

        :return: The current_task of this WorkOrder.  # noqa: E501
        :rtype: int
        """
        return self._current_task

    @current_task.setter
    def current_task(self, current_task):
        """Sets the current_task of this WorkOrder.

        The index into the Tasks list for the task that is currently running (if a task is running) or the next task that will run (if no task is currently running).  If -1, then the first task will run next, and if it is equal to the length of the Tasks list then all the tasks have finished running.  # noqa: E501

        :param current_task: The current_task of this WorkOrder.  # noqa: E501
        :type: int
        """
        if self._configuration.client_side_validation and current_task is None:
            raise ValueError("Invalid value for `current_task`, must not be `None`")  # noqa: E501

        self._current_task = current_task

    @property
    def end_time(self):
        """Gets the end_time of this WorkOrder.  # noqa: E501

        EndTime The time the async action failed or finished or cancelled.  # noqa: E501

        :return: The end_time of this WorkOrder.  # noqa: E501
        :rtype: datetime
        """
        return self._end_time

    @end_time.setter
    def end_time(self, end_time):
        """Sets the end_time of this WorkOrder.

        EndTime The time the async action failed or finished or cancelled.  # noqa: E501

        :param end_time: The end_time of this WorkOrder.  # noqa: E501
        :type: datetime
        """

        self._end_time = end_time

    @property
    def endpoint(self):
        """Gets the endpoint of this WorkOrder.  # noqa: E501

        Endpoint tracks the owner of the object among DRP endpoints  # noqa: E501

        :return: The endpoint of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._endpoint

    @endpoint.setter
    def endpoint(self, endpoint):
        """Sets the endpoint of this WorkOrder.

        Endpoint tracks the owner of the object among DRP endpoints  # noqa: E501

        :param endpoint: The endpoint of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._endpoint = endpoint

    @property
    def errors(self):
        """Gets the errors of this WorkOrder.  # noqa: E501

        If there are any errors in the validation process, they will be available here.  # noqa: E501

        :return: The errors of this WorkOrder.  # noqa: E501
        :rtype: list[str]
        """
        return self._errors

    @errors.setter
    def errors(self, errors):
        """Sets the errors of this WorkOrder.

        If there are any errors in the validation process, they will be available here.  # noqa: E501

        :param errors: The errors of this WorkOrder.  # noqa: E501
        :type: list[str]
        """

        self._errors = errors

    @property
    def filter(self):
        """Gets the filter of this WorkOrder.  # noqa: E501

        Filter is a list filter for this WorkOrder  # noqa: E501

        :return: The filter of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._filter

    @filter.setter
    def filter(self, filter):
        """Sets the filter of this WorkOrder.

        Filter is a list filter for this WorkOrder  # noqa: E501

        :param filter: The filter of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._filter = filter

    @property
    def job_exit_state(self):
        """Gets the job_exit_state of this WorkOrder.  # noqa: E501

        The final disposition of the current job. Can be one of \"reboot\",\"poweroff\",\"stop\", or \"complete\" Other substates may be added as time goes on  # noqa: E501

        :return: The job_exit_state of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._job_exit_state

    @job_exit_state.setter
    def job_exit_state(self, job_exit_state):
        """Sets the job_exit_state of this WorkOrder.

        The final disposition of the current job. Can be one of \"reboot\",\"poweroff\",\"stop\", or \"complete\" Other substates may be added as time goes on  # noqa: E501

        :param job_exit_state: The job_exit_state of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._job_exit_state = job_exit_state

    @property
    def job_result_errors(self):
        """Gets the job_result_errors of this WorkOrder.  # noqa: E501

        ResultErrors is a list of error from the task.  This is filled in by the task if it is written to do so.  This tracks results without requiring job logs.  # noqa: E501

        :return: The job_result_errors of this WorkOrder.  # noqa: E501
        :rtype: list[str]
        """
        return self._job_result_errors

    @job_result_errors.setter
    def job_result_errors(self, job_result_errors):
        """Sets the job_result_errors of this WorkOrder.

        ResultErrors is a list of error from the task.  This is filled in by the task if it is written to do so.  This tracks results without requiring job logs.  # noqa: E501

        :param job_result_errors: The job_result_errors of this WorkOrder.  # noqa: E501
        :type: list[str]
        """

        self._job_result_errors = job_result_errors

    @property
    def job_state(self):
        """Gets the job_state of this WorkOrder.  # noqa: E501

        The state the current job is in.  Must be one of \"created\", \"failed\", \"finished\", \"incomplete\"  # noqa: E501

        :return: The job_state of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._job_state

    @job_state.setter
    def job_state(self, job_state):
        """Sets the job_state of this WorkOrder.

        The state the current job is in.  Must be one of \"created\", \"failed\", \"finished\", \"incomplete\"  # noqa: E501

        :param job_state: The job_state of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._job_state = job_state

    @property
    def last_modified_at(self):
        """Gets the last_modified_at of this WorkOrder.  # noqa: E501

        LastModifiedAt is the time that this object was last modified.  # noqa: E501

        :return: The last_modified_at of this WorkOrder.  # noqa: E501
        :rtype: datetime
        """
        return self._last_modified_at

    @last_modified_at.setter
    def last_modified_at(self, last_modified_at):
        """Sets the last_modified_at of this WorkOrder.

        LastModifiedAt is the time that this object was last modified.  # noqa: E501

        :param last_modified_at: The last_modified_at of this WorkOrder.  # noqa: E501
        :type: datetime
        """

        self._last_modified_at = last_modified_at

    @property
    def last_modified_by(self):
        """Gets the last_modified_by of this WorkOrder.  # noqa: E501

        LastModifiedBy stores the value of the user that last modified this object. NOTE: This value is populated ONLY if the object was modified by a user which means any actions done using machine tokens will not get tracked  # noqa: E501

        :return: The last_modified_by of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._last_modified_by

    @last_modified_by.setter
    def last_modified_by(self, last_modified_by):
        """Sets the last_modified_by of this WorkOrder.

        LastModifiedBy stores the value of the user that last modified this object. NOTE: This value is populated ONLY if the object was modified by a user which means any actions done using machine tokens will not get tracked  # noqa: E501

        :param last_modified_by: The last_modified_by of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._last_modified_by = last_modified_by

    @property
    def machine(self):
        """Gets the machine of this WorkOrder.  # noqa: E501

        Machine is the key of the machine running the WorkOrder  # noqa: E501

        :return: The machine of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._machine

    @machine.setter
    def machine(self, machine):
        """Sets the machine of this WorkOrder.

        Machine is the key of the machine running the WorkOrder  # noqa: E501

        :param machine: The machine of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._machine = machine

    @property
    def meta(self):
        """Gets the meta of this WorkOrder.  # noqa: E501


        :return: The meta of this WorkOrder.  # noqa: E501
        :rtype: Meta
        """
        return self._meta

    @meta.setter
    def meta(self, meta):
        """Sets the meta of this WorkOrder.


        :param meta: The meta of this WorkOrder.  # noqa: E501
        :type: Meta
        """

        self._meta = meta

    @property
    def params(self):
        """Gets the params of this WorkOrder.  # noqa: E501

        Params that have been directly set on the Machine.  # noqa: E501

        :return: The params of this WorkOrder.  # noqa: E501
        :rtype: dict(str, object)
        """
        return self._params

    @params.setter
    def params(self, params):
        """Sets the params of this WorkOrder.

        Params that have been directly set on the Machine.  # noqa: E501

        :param params: The params of this WorkOrder.  # noqa: E501
        :type: dict(str, object)
        """

        self._params = params

    @property
    def profiles(self):
        """Gets the profiles of this WorkOrder.  # noqa: E501

        Profiles An array of profiles to apply to this machine in order when looking for a parameter during rendering.  # noqa: E501

        :return: The profiles of this WorkOrder.  # noqa: E501
        :rtype: list[str]
        """
        return self._profiles

    @profiles.setter
    def profiles(self, profiles):
        """Sets the profiles of this WorkOrder.

        Profiles An array of profiles to apply to this machine in order when looking for a parameter during rendering.  # noqa: E501

        :param profiles: The profiles of this WorkOrder.  # noqa: E501
        :type: list[str]
        """

        self._profiles = profiles

    @property
    def read_only(self):
        """Gets the read_only of this WorkOrder.  # noqa: E501

        ReadOnly tracks if the store for this object is read-only. This flag is informational, and cannot be changed via the API.  # noqa: E501

        :return: The read_only of this WorkOrder.  # noqa: E501
        :rtype: bool
        """
        return self._read_only

    @read_only.setter
    def read_only(self, read_only):
        """Sets the read_only of this WorkOrder.

        ReadOnly tracks if the store for this object is read-only. This flag is informational, and cannot be changed via the API.  # noqa: E501

        :param read_only: The read_only of this WorkOrder.  # noqa: E501
        :type: bool
        """

        self._read_only = read_only

    @property
    def retry_task_attempt(self):
        """Gets the retry_task_attempt of this WorkOrder.  # noqa: E501

        This tracks the number of retry attempts for the current task. When a task succeeds, the retry value is reset.  # noqa: E501

        :return: The retry_task_attempt of this WorkOrder.  # noqa: E501
        :rtype: int
        """
        return self._retry_task_attempt

    @retry_task_attempt.setter
    def retry_task_attempt(self, retry_task_attempt):
        """Sets the retry_task_attempt of this WorkOrder.

        This tracks the number of retry attempts for the current task. When a task succeeds, the retry value is reset.  # noqa: E501

        :param retry_task_attempt: The retry_task_attempt of this WorkOrder.  # noqa: E501
        :type: int
        """

        self._retry_task_attempt = retry_task_attempt

    @property
    def runnable(self):
        """Gets the runnable of this WorkOrder.  # noqa: E501

        Runnable indicates that this is Runnable.  # noqa: E501

        :return: The runnable of this WorkOrder.  # noqa: E501
        :rtype: bool
        """
        return self._runnable

    @runnable.setter
    def runnable(self, runnable):
        """Sets the runnable of this WorkOrder.

        Runnable indicates that this is Runnable.  # noqa: E501

        :param runnable: The runnable of this WorkOrder.  # noqa: E501
        :type: bool
        """

        self._runnable = runnable

    @property
    def stage(self):
        """Gets the stage of this WorkOrder.  # noqa: E501

        The stage that this is currently in.  # noqa: E501

        :return: The stage of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._stage

    @stage.setter
    def stage(self, stage):
        """Sets the stage of this WorkOrder.

        The stage that this is currently in.  # noqa: E501

        :param stage: The stage of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._stage = stage

    @property
    def start_time(self):
        """Gets the start_time of this WorkOrder.  # noqa: E501

        StartTime The time the async action started running.  # noqa: E501

        :return: The start_time of this WorkOrder.  # noqa: E501
        :rtype: datetime
        """
        return self._start_time

    @start_time.setter
    def start_time(self, start_time):
        """Sets the start_time of this WorkOrder.

        StartTime The time the async action started running.  # noqa: E501

        :param start_time: The start_time of this WorkOrder.  # noqa: E501
        :type: datetime
        """

        self._start_time = start_time

    @property
    def state(self):
        """Gets the state of this WorkOrder.  # noqa: E501

        State The state the async action is in.  Must be one of \"created\", \"running\", \"failed\", \"finished\", \"cancelled\"  # noqa: E501

        :return: The state of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this WorkOrder.

        State The state the async action is in.  Must be one of \"created\", \"running\", \"failed\", \"finished\", \"cancelled\"  # noqa: E501

        :param state: The state of this WorkOrder.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and state is None:
            raise ValueError("Invalid value for `state`, must not be `None`")  # noqa: E501

        self._state = state

    @property
    def status(self):
        """Gets the status of this WorkOrder.  # noqa: E501

        Status is a short text snippet for humans explaining the current state.  # noqa: E501

        :return: The status of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this WorkOrder.

        Status is a short text snippet for humans explaining the current state.  # noqa: E501

        :param status: The status of this WorkOrder.  # noqa: E501
        :type: str
        """

        self._status = status

    @property
    def task_error_stacks(self):
        """Gets the task_error_stacks of this WorkOrder.  # noqa: E501

        This list of previous task lists and current tasks to handle errors. Upon completing the list, the previous task list will be executed.  This will be capped to a depth of 1.  Error failures can not be handled.  # noqa: E501

        :return: The task_error_stacks of this WorkOrder.  # noqa: E501
        :rtype: list[TaskStack]
        """
        return self._task_error_stacks

    @task_error_stacks.setter
    def task_error_stacks(self, task_error_stacks):
        """Sets the task_error_stacks of this WorkOrder.

        This list of previous task lists and current tasks to handle errors. Upon completing the list, the previous task list will be executed.  This will be capped to a depth of 1.  Error failures can not be handled.  # noqa: E501

        :param task_error_stacks: The task_error_stacks of this WorkOrder.  # noqa: E501
        :type: list[TaskStack]
        """

        self._task_error_stacks = task_error_stacks

    @property
    def tasks(self):
        """Gets the tasks of this WorkOrder.  # noqa: E501

        The current tasks that are being processed.  # noqa: E501

        :return: The tasks of this WorkOrder.  # noqa: E501
        :rtype: list[str]
        """
        return self._tasks

    @tasks.setter
    def tasks(self, tasks):
        """Sets the tasks of this WorkOrder.

        The current tasks that are being processed.  # noqa: E501

        :param tasks: The tasks of this WorkOrder.  # noqa: E501
        :type: list[str]
        """

        self._tasks = tasks

    @property
    def uuid(self):
        """Gets the uuid of this WorkOrder.  # noqa: E501

        Uuid is the key of this particular WorkOrder.  # noqa: E501

        :return: The uuid of this WorkOrder.  # noqa: E501
        :rtype: str
        """
        return self._uuid

    @uuid.setter
    def uuid(self, uuid):
        """Sets the uuid of this WorkOrder.

        Uuid is the key of this particular WorkOrder.  # noqa: E501

        :param uuid: The uuid of this WorkOrder.  # noqa: E501
        :type: str
        """
        if self._configuration.client_side_validation and uuid is None:
            raise ValueError("Invalid value for `uuid`, must not be `None`")  # noqa: E501

        self._uuid = uuid

    @property
    def validated(self):
        """Gets the validated of this WorkOrder.  # noqa: E501

        Validated tracks whether or not the model has been validated.  # noqa: E501

        :return: The validated of this WorkOrder.  # noqa: E501
        :rtype: bool
        """
        return self._validated

    @validated.setter
    def validated(self, validated):
        """Sets the validated of this WorkOrder.

        Validated tracks whether or not the model has been validated.  # noqa: E501

        :param validated: The validated of this WorkOrder.  # noqa: E501
        :type: bool
        """

        self._validated = validated

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(WorkOrder, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, WorkOrder):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, WorkOrder):
            return True

        return self.to_dict() != other.to_dict()
