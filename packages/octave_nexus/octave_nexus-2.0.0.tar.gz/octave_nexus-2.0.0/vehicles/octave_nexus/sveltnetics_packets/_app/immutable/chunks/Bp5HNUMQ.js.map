{"version":3,"file":"Bp5HNUMQ.js","sources":["../../../../../../src/lib/trinkets/Barcode/_Screenplays/unpack.js","../../../../../../src/lib/trinkets/Barcode/Vision/Trinket.svelte","../../../../../../src/lib/trinkets/Barcode/_Screenplays/pack.js"],"sourcesContent":["\nimport pako from 'pako';\n\n\n// Decompress the base64-encoded compressed string\nexport const unpack_string = (base64String) => {\n    // Convert base64 string to binary string\n    const binaryString = atob (base64String);\n\n    // Convert binary string to Uint8Array\n    const binaryLen = binaryString.length;\n    const bytes = new Uint8Array(binaryLen);\n    for (let i = 0; i < binaryLen; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    // Decompress the Uint8Array using pako\n    const decompressed = pako.inflate(bytes, { to: 'string' });\n\n    return decompressed;\n}","\n\n<script>\n\n/*\n\timport Barcode_Vision from '$lib/trinkets/Barcode/Vision/Trinket.svelte'\n\t\n\tconst on_barcode_found = async ({ hexadecimal_string }) => {\n\t\t// stop scanning if found.\n\t\t\n\t\tbarcode_vision.stop_the_scan ();\n\t}\n\t\n\t<Barcode_Vision\n\t\tbind:this={ barcode_vision }\n\t\tfound={ on_barcode_found }\n\t\t\n\t\tstyles={{\n\t\t\t\n\t\t}}\n\t/>\n*/\n\n/*\n\ttodo:\n\t\task for camera permission:\n\t\t\t\"Permit Vision\"\n\t\t\t\n\t\tCode:\n\t\t\tAztec\n\t\t\tQR\n*/\n\n/*\n\thttps://scanapp.org/html5-qrcode-docs/docs/intro\n\thttps://www.npmjs.com/package/html5-qrcode\n*/\n\n///\n//\nimport { TabGroup, Tab, TabAnchor } from '@skeletonlabs/skeleton';\nimport { ConicGradient } from '@skeletonlabs/skeleton';\nimport { onMount, onDestroy } from 'svelte';\nimport { Html5QrcodeScanner, Html5QrcodeScanType, Html5Qrcode, Html5QrcodeSupportedFormats } from \"html5-qrcode\";\n//\n//\nimport { parse_styles } from '$lib/trinkets/styles/parse'\n//\n//\\\n\nimport { unpack_string } from '../_Screenplays/unpack'\n\n\nexport let found = () => {}\nexport let styles = {}\n\nlet actual_styles = parse_styles (Object.assign ({}, {\n\t\"height\": \"400px\", \n\t\"width\": \"100%\",\n\t\"max-width\": \"600px\", \n\t\"margin\": \"0 auto\"\n}, styles))\n\nlet can_scan = \"yes\"\nconst stop = () => {\n\tcan_scan = \"no\"\n}\n\nconst on_camera_success = async (decodedText, decodedResult) => {\n\tif (can_scan !== \"yes\") {\n\t\treturn;\n\t}\n\t\n\tconst hexadecimal_string = unpack_string (decodedText)\n\t\n\tfound ({\n\t\thexadecimal_string,\n\t\tdecodedText,\n\t\tdecodedResult\n\t})\n}\n\nconst on_camera_error = function () {\n\tconst le_error = arguments [0];\n\tif (le_error === \"QR code parse error, error = NotFoundException: No MultiFormat Readers were able to detect the code.\") {\n\t\tconsole.info (\"The code was not visualized.\");\n\t\treturn;\n\t}\n\t\n\t\n\tconsole.log ('on_error', arguments)\n}\n\nlet HTML5_QR_Barcode_Scanner;\n\nconst open_camera = () => {\n\tconst config = {\n\t\tfps: 10,\n\t\tqrbox: {\n\t\t\twidth: 500, \n\t\t\theight: 500\n\t\t},\n\t\tformatsToSupport: [\n\t\t\tHtml5QrcodeSupportedFormats.QR_CODE,\n\t\t\tHtml5QrcodeSupportedFormats.AZTEC\t\t\t\n\t\t],\n\t\t\n\t\t// rememberLastUsedCamera: true,\n\t\t// Only support camera scan type.\n\t\t// supportedScanTypes: [ Html5QrcodeScanType.SCAN_TYPE_CAMERA ]\n\t}\n\t\n\tif (true) {\n\t\tHTML5_QR_Barcode_Scanner = new Html5QrcodeScanner (\n\t\t\t\"barcode_vision\", \n\t\t\tconfig\n\t\t);\n\n\t\tHTML5_QR_Barcode_Scanner.render (\n\t\t\ton_camera_success,\n\t\t\ton_camera_error\n\t\t);\n\t\t\n\t}\n}\n\nexport const stop_the_scan = () => {\n\tif (HTML5_QR_Barcode_Scanner) {\n\t\tHTML5_QR_Barcode_Scanner.pause ()\t\t\n\t\t// HTML5_QR_Barcode_Scanner.clear ()\n\t}\n}\n\nlet prepared = \"no\"\nonMount (async () => {\n\topen_camera ();\n\tprepared = \"yes\"\n});\n\nonDestroy (async () => {\n\tif (HTML5_QR_Barcode_Scanner) {\n\t\ttry {\n\t\t\tHTML5_QR_Barcode_Scanner.clear ()\n\t\t}\n\t\tcatch (exception) {\n\t\t\tconsole.error (exception)\n\t\t}\n\t}\n})\n\n</script>\n\n\n<div \n\tmonitor=\"barcode vision\"\n\tid='barcode_vision'\n\tstyle={ actual_styles }\n></div>\n","\n\nimport pako from 'pako';\n\nexport const pack_string = (the_string) => {\n\t// converts string to a Uint8Array (binary format)\n\tconst string_as_Uint8Array = new TextEncoder ().encode (the_string);\n\n\t// Compress the binary data using pako\n\tconst packed = pako.deflate (string_as_Uint8Array);\n\n\t// Convert compressed binary data to a base64 string for easier handling\n\treturn btoa (String.fromCharCode (...new Uint8Array (packed)));\n}\n"],"names":["unpack_string","base64String","binaryString","binaryLen","bytes","i","pako","ctx","insert_hydration","target","div","anchor","found","styles","$$props","actual_styles","parse_styles","on_camera_success","decodedText","decodedResult","hexadecimal_string","on_camera_error","HTML5_QR_Barcode_Scanner","open_camera","config","Html5QrcodeSupportedFormats","Html5QrcodeScanner","stop_the_scan","onMount","onDestroy","exception","pack_string","the_string","string_as_Uint8Array","packed"],"mappings":"4NAKY,MAACA,EAAiBC,GAAiB,CAE3C,MAAMC,EAAe,KAAMD,CAAY,EAGjCE,EAAYD,EAAa,OACzBE,EAAQ,IAAI,WAAWD,CAAS,EACtC,QAASE,EAAI,EAAGA,EAAIF,EAAWE,IAC3BD,EAAMC,CAAC,EAAIH,EAAa,WAAWG,CAAC,EAMxC,OAFqBC,EAAK,QAAQF,EAAO,CAAE,GAAI,SAAU,CAG7D,yMCwISG,EAAa,CAAA,CAAA,UAHtBC,EAIMC,EAAAC,EAAAC,CAAA,kDAxGK,MAAAC,EAAK,IAAA,OACL,OAAAC,EAAM,CAAA,CAAA,EAAAC,EAEbC,EAAgBC,EAAc,OAAO,WACxC,OAAU,QACV,MAAS,OACT,YAAa,QACb,OAAU,UACRH,UAOGI,EAAiB,MAAUC,EAAaC,IAAa,OAKpDC,EAAqBpB,EAAekB,CAAW,EAErDN,EAAK,CACJ,mBAAAQ,EACA,YAAAF,EACA,cAAAC,KAIIE,EAAe,UAAA,CAEhB,GADa,UAAW,CAAC,IACZ,uGAAsG,CACtH,QAAQ,KAAM,8BAA8B,SAK7C,QAAQ,IAAK,WAAY,SAAS,OAG/BC,QAEEC,EAAW,IAAA,OACVC,EAAM,CACX,IAAK,GACL,OACC,MAAO,IACP,OAAQ,GAAA,EAET,kBACCC,EAA4B,QAC5BA,EAA4B,KAAK,GASlCH,EAA+B,IAAAI,EAC9B,iBACAF,CAAA,EAGDF,EAAyB,OACxBL,EACAI,CAAA,GAMUM,EAAa,IAAA,CACrBL,GACHA,EAAyB,MAAK,GAMhC,OAAAM,EAAO,SAAA,CACNL,EAAW,IAIZM,EAAS,SAAA,IACJP,MAEFA,EAAyB,MAAK,QAExBQ,EAAS,CACf,QAAQ,MAAOA,CAAS,6NC7If,MAACC,EAAeC,GAAe,CAE1C,MAAMC,EAAuB,IAAI,cAAe,OAAQD,CAAU,EAG5DE,EAAS5B,EAAK,QAAS2B,CAAoB,EAGjD,OAAO,KAAM,OAAO,aAAc,GAAG,IAAI,WAAYC,CAAM,CAAC,CAAC,CAC9D"}