class ThermalResistance:
    '''Класс для расчета температуры наружного воздуха, тепловой инерционности, сопротивления теплопередаче через наружные ограждения здания'''
    def __doc__(self):
        return 'Класс для расчета температуры наружного воздуха, тепловой инерционности, сопротивления теплопередаче через наружные ограждения здания'
    
    def __init__(self, name, localisation, δ_m, λ_m, c_m, ρ_m, ц_m = None, внутри = "стена", снаружи = "поверхность_соприкасающаяся_непосредственно_с_наружным_воздухом"):
        '''
           Конструктор класса с параметрами по умолчанию
        name, str - наименование материала ограждающей конструкции
        localisation - данные из файла LocalisationData
        δ_m, м - толщина слоя
        λ_m, Вт * м⁻¹ * ℃⁻¹ - теплопроводность материала
        c_m, Дж * кг⁻¹ * ℃⁻¹ - теплоёмкость материала
        ρ_m, кг * м⁻³ - плотность материала
        ц_m, ₽ * м⁻³ - цена материала отнесенная на единицу объема
        внутри, Вт * м⁻² * ℃⁻¹  - Коэффициент теплоотдачи внутренней поверхности - α_в. На выбор: стена, пол, гладкий_потолок, ребристый_потолок, окно, зенитный_фонарь
        снаружи, Вт * м⁻² * ℃⁻¹ - Коэффициент теплоотдачи наружной поверхности - α_н. На выбор:
            - поверхность_соприкасающаяся_непосредственно_с_наружным_воздухом
            - перекрытия_над_холодным_подвалом_сообщающимся_с_наружным_воздухом
            - перекрытия_выходящие_на_чердак_или_в_неотапливаемый_подвал_со_световыми_проемами
            - перекрытия_выходящие_в_неотапливаемый_подвал_без_световых_проемов
            - перекрытие_уложенное_непосредственно_на_грунт
        '''
        self.name = name
        self.loc = localisation
        # согласно СП 50.13330.2012 Таблица 4 https://docs.cntd.ru/document/1200095525
        if внутри == "стена":
            self.α_в = 8.7# Вт * м⁻² * ℃⁻¹
        elif внутри == "пол":
            self.α_в = 8.7# Вт * м⁻² * ℃⁻¹
        elif внутри == "гладкий_потолок":
            self.α_в = 8.7# Вт * м⁻² * ℃⁻¹        
        elif внутри == "ребристый_потолок":
            self.α_в = 7.6# Вт * м⁻² * ℃⁻¹
        elif внутри == "окно":
            self.α_в = 8# Вт * м⁻² * ℃⁻¹
        elif внутри == "зенитный_фонарь":
            self.α_в = 9.9# Вт * м⁻² * ℃⁻¹
        else:
            print("Ошибка! ThermalResistance " + str(name) + " При вводе значения типа поверхности ограждения внутри! Не существует: " + str(внутри))
        self.внутри = внутри
            
        # согласно СП 50.13330.2012 Таблица 6 https://docs.cntd.ru/document/1200095525
        if снаружи == "поверхность_соприкасающаяся_непосредственно_с_наружным_воздухом":
            self.α_н = 23# Вт * м⁻² * ℃⁻¹
        elif снаружи == "перекрытия_над_холодным_подвалом_сообщающимся_с_наружным_воздухом":
            self.α_н = 17# Вт * м⁻² * ℃⁻¹
        elif снаружи == "перекрытия_выходящие_на_чердак_или_в_неотапливаемый_подвал_со_световыми_проемами":
            self.α_н = 12# Вт * м⁻² * ℃⁻¹
        elif снаружи == "перекрытия_выходящие_в_неотапливаемый_подвал_без_световых_проемов":
            self.α_н = 6# Вт * м⁻² * ℃⁻¹
        elif снаружи == "перекрытие_уложенное_непосредственно_на_грунт":
            self.α_н = 1000# Вт * м⁻² * ℃⁻¹!!!Нужно уточнить значение
        else:
            print("Ошибка! ThermalResistance " + str(name) + " При вводе значения типа поверхности ограждения внутри! Не существует: " + str(снаружи))
        self.снаружи = снаружи
        
        self.δ_m = δ_m
        self.λ_m = λ_m
        self.c_m = c_m
        self.ρ_m = ρ_m
        self.ц_m = ц_m
       
        if (len(δ_m) != len(λ_m) or len(δ_m) != len(c_m) or len(δ_m) != len(ρ_m)):
            print("Ошибка! ThermalResistance name = \"" + str(name) + "\". Массив толщин не совпадает по количеству элементов с массивом теплопроводностей, или теплоемкостей, или плотностей")

        if ц_m != None and len(δ_m) != len(ц_m):
            print("Ошибка! ThermalResistance name = \"" + str(name) + "\". Массив толщин не совпадает по количеству элементов с массивом цен материала")

    def Д_огр(self):
        '''
        Д_огр, ⎷̅с - Тепловая инерционность ограждающей конструкции   
        '''
        _Д_огр = 0
        for i in range(len(self.δ_m)):
            _Д_огр += self.δ_m[i] / self.λ_m[i] * 0.27 * pow(self.ρ_m[i]*self.c_m[i]*self.λ_m[i], 0.5)
        return _Д_огр

    def R(self):
        '''
        R, ℃ * м² * Вт⁻¹ - Полные сопротивления теплопередаче через наружные ограждения здания   
        '''
        R_sum = 0
        for i in range(len(self.δ_m)):
            R_sum += self.δ_m[i] / self.λ_m[i]
        R_sum = R_sum + 1 / self.α_в + 1 / self.α_н
        return R_sum
    
    def t_б_хн(self):
        ''', ℃ - расчетная температура наружного воздуха. Берется в соответствии с СП 131.13330.2020 СТРОИТЕЛЬНАЯ КЛИМАТОЛОГИЯ'''
        Д_огр = self.Д_огр()
        #print("Для: " + str(name) + " Д_огр = " + str(Д_огр))
        if 4 < Д_огр < 7:
            _t_б_хн = 0.5 * (self.loc.t_б5_хн + self.loc.t_б1_хн)#, ℃ -расчетная температура наружного воздуха
        elif 7 < Д_огр:
            _t_б_хн = self.loc.t_б5_хн#, ℃ - температура воздуха наиболее холодной пятидневки обеспеченностью 0.98
        elif 0 < Д_огр < 4:
            _t_б_хн = self.loc.t_б1_хн#, ℃ - температура воздуха наиболее холодных суток обеспеченностью 0.98 
        else:
            print('Ошибка! Конструктора WallLosses: ' + str(self.name) + '. Для Д_огр = ' + str(Д_огр) + '; t_б_хн не было задано!')
            _t_б_хн = nan
        #print('Для "' + str(self.name) + '" t_б_хн = ' + str(_t_б_хн) + '℃')
        return _t_б_хн

    def Удельная_стоимость(self):
        '''
        Удельная_стоимость, ₽ * кс⁻² - стоимость тепловой изоляции отнесенная на единицу площади. Расчитывается как сумма произведений толщин на цену материала для всех слоев.
        '''
        if self.ц_m == None or sum(self.ц_m) == 0:
            print('Ошибка! Конструктора WallLosses: ' + str(self.name) + '. Для Удельная_стоимость() не была задана ц_m!')
        else:
            St_sum = 0
            for i in range(len(self.δ_m)):
                St_sum += self.δ_m[i] * self.ц_m[i]
            return St_sum

    def examples():
        """Возвращает примеры для создания конструкторов"""
        return "#-------------------------------------------------------------\n#Пример работы с конструктором ThermalResistance\n#Импорт классов и методов. Если файл и класс локализации будет взять из модуля exoheat.\nfrom exoheat.LocalisationData import Localisation\n#Задание собственного экземпляра файла LocalisationData. Его нужно поместить в туже папу что и данный файл\n#from LocalisationData import Localisation\n\n#Импорт и изучение классов и методов\nfrom exoheat.Walls import ThermalResistance\n#Справка по классу, а в первую очередь по конструктору\nprint(help(ThermalResistance))\n#Локализация проекта\nloc = Localisation()\n\nr_floor = ThermalResistance('Железобетон, Раствор цементно-песчаный', loc,\n                            [0.25,        0.02],  #δ_m, м\n                            [1.69,        0.93],  #λ_m, Вт * м⁻¹ * ℃⁻¹\n                            [0.84,        0.84],  #c_m, кДж * кг⁻¹ * ℃⁻¹\n                            [2500,        1800],  #ρ_m, кг * м⁻³\n                            внутри = 'пол', снаружи = 'перекрытия_выходящие_в_неотапливаемый_подвал_без_световых_проемов')\nprint('Имя : ' + r_floor.name + ' R = ' + str(r_floor.R()) \\\n      + ' Д_огр = ' + str(r_floor.Д_огр())+ ' t_б_хн = ' + str(r_floor.t_б_хн()))\n\n#Пример использования с заданием цены за кубический метр материала каждого слоя	  \nr_conc_sht = ThermalResistance('ЖБ  , Штукатурка', loc,\n                               [0.25, 0.02],#δ_m, м - толщина слоя\n                               [1.69, 0.93],#λ_m, Вт * м⁻¹ * ℃⁻¹ - теплопроводность материала\n                               [0.84, 0.84],#c_m, Дж * кг⁻¹ * ℃⁻¹ - теплоёмкость материала\n                               [2500, 1800],#ρ_m, кг * м⁻³ - плотность материала\n                               [6100, 7500],#ц_m, ₽ * м⁻³ - цена материала\n                               внутри='стена',\n                               снаружи='поверхность_соприкасающаяся_непосредственно_с_наружным_воздухом')\nprint('Имя : ' + r_conc_sht.name + ' R = ' + str(r_conc_sht.R()) \\\n      + ' Д_огр = ' + str(r_conc_sht.Д_огр())+ ' t_б_хн = ' + str(r_conc_sht.t_б_хн()))\n\n#Пример конструктора в котором задается стоимость всего изделия приведенная к стоимости кубуческого метра слоя материала\nr_float_st = ThermalResistance('Флоат-ст2 Стекло, Силикон, Стекло, Воздух, Стекло, Силикон, Стекло', loc,# для силиконов https://s.siteapi.org/f3460fa8c7140e3/docs/2330f4def1e368bb7655a0f12a383115ea330aa7.pdf\n                               [0.0032, 0.001,   0.0032,   0.04, 0.0032,  0.001,  0.0032], #δ_m, м\n                               [0.76,   1   ,    0.76,   0.0084,   0.76,   1   ,    0.76], #λ_m, Вт * м⁻¹ * ℃⁻¹\n                               [0.84,   0.84,    0.84,    1.007,   0.84,   0.84,    0.84], #c_m, кДж * кг⁻¹ * ℃⁻¹\n                               [2500,   1300,    2500,   1.2754,   2500,   1300,    2500], #ρ_m, кг * м⁻³\n                               [3541/1.3/0.575/0.0032, 0, 0,  0,      0,      0,       0], #ц_m, ₽ * м⁻³ - цена материала #https://www.okonsib.ru/zakazat-steklopaket-bez-ramy.html\n                               внутри = 'окно', снаружи = 'поверхность_соприкасающаяся_непосредственно_с_наружным_воздухом')\nprint('Имя : ' + r_float_st.name + ' R = ' + str(r_float_st.R()) \\\n      + ' Д_огр = ' + str(r_float_st.Д_огр())+ ' t_б_хн = ' + str(r_float_st.t_б_хн()))\n#-------------------------------------------------------------"

class WallLosses:
    '''Класс для расчета количества теряемой тепловой энергии за счет теплопроводности через боковые, напольные, потолочные ограждения'''

    def __doc__(self):
        return 'Класс для расчета количества теряемой тепловой энергии за счет теплопроводности через боковые, напольные, потолочные ограждения'

    def __init__(self, name, localisation, resistance, ограждение = "наружное", ориентир_потерь = "С", F_c = 1, H_здания = 3):
        
        '''
        Конструктор класса с параметрами по умолчанию
        name, str - стена
        localisation - данные из файла LocalisationData
        resistance - для расчета t_б_хн, тепловой инерционности, сопротивления теплопередаче через наружные ограждения здания
        ограждение, б/р - Коэффициент тип ограждения - а: наружное, чердачное, пол
        ориентир_потерь, б/р - доля добавочных тепловых потерь через ограждения:
             Для сторон света - β: "С", "СВ", "СЗ", "Ю", "ЮВ", "ЮЗ", "В", "З";
             Для угловых помещений по сторонам света - β: "Су", "СВу", "СЗу", "Ву";
             Для потолка, или пол, или другое - β: "П"
             Для дверей - +β: "двойные_без_тамбура:H_д", "двойные_с_тамбуром:H_д", "одинарные:H_д", "тройные_с_двумя_тамбурами:H_д";
             Для ворот - +β: "_без_тамбура, _с_тамбуром".
        F_c, м² - площадь ограждающей конструкции
        H_здания, м - высота здания. Для полов не нужно задавать
        '''
        #Исходные данные
        self.name = name
        self.loc = localisation
        self.res = resistance
        self.ограждение = ограждение
        self.ориентир_потерь = ориентир_потерь
        
        k_n = 0.3#Коэффициент повышения температуры наружного воздуха по высоте помещения. Из методики Шелгинского
        if ограждение == "наружное":
            self.а = 1
            self.t_в1 = localisation.t_вр + 0.5 * (H_здания - 2) * k_n# среднее значение температуры внутреннего воздуха у боковых стен
        elif ограждение == "чердачное":
            self.а = 0.9
            self.t_в1 = localisation.t_вр + (H_здания - 2) * k_n# среднее значение температуры внутреннего воздуха у чердачного перекрытия
        elif ограждение == "пол":
            self.а = 0.75
            self.t_в1 = localisation.t_вр# среднее значение температуры внутреннего воздуха у пола

        #Расчет ориентира потерь
        #Вертикальные ограждения и вертикальные проекции наклонных ограждений обращенных:
        val_ориентир_потерь = True #Проверка, учитывающая что β является суммой из нескольких (например на северной стене может быть дверь), то нужно отделять ту часть расчета потерь, в которой расчитываем потери только через стену или окно, от той, в которой расчитываем потери через стену и дверь.
        if "С" in ориентир_потерь or "СВ" in ориентир_потерь or "СЗ" in ориентир_потерь or "В" in ориентир_потерь:
            self.β = 0.1
        elif "ЮВ" in ориентир_потерь or "З" in ориентир_потерь:
            self.β = 0.05
        elif "Ю" in ориентир_потерь or "ЮЗ" in ориентир_потерь:
            self.β = 0.0
        #Каждое наружное ограждение угловых помещений:    
        elif "Су" in ориентир_потерь or "СВу" in ориентир_потерь or "СЗу" in ориентир_потерь or "Ву" in ориентир_потерь:
            self.β = 0.05
        #Потолок, или пол, или другое
        elif "П" in ориентир_потерь:
            self.β = 0.1
        else:
            print('Ошибка! Не корректно задано значение "ориентир_потерь" для стены: "' + str(self.name) + '"')
            val_ориентир_потерь = False
            
        #Наружные двери высотой Н_д, м и не оборудованные воздушными завесами:    
        if "двойные_без_тамбура" in ориентир_потерь:
            H_д = float(ориентир_потерь.split(':')[1])
            self.β += 0.34 * H_д
        elif "двойные_с_тамбуром" in ориентир_потерь:
            H_д = float(ориентир_потерь.split(':')[1])
            self.β += 0.27 * H_д
        elif "одинарные" in ориентир_потерь:
            H_д = float(ориентир_потерь.split(':')[1])
            self.β += 0.22 * H_д
        elif "тройные_с_двумя_тамбурами" in ориентир_потерь:
            H_д = float(ориентир_потерь.split(':')[1])
            self.β += 0.20 * H_д
        #Наружные ворота без воздушных завес:    
        elif "ворота_без_тамбура" in ориентир_потерь:
            self.β += 3
        elif "ворота_с_тамбуром" in ориентир_потерь:
            self.β += 1
        elif val_ориентир_потерь and len(ориентир_потерь) > 3:#провереям длину формулировки для того чтоб не выдавалась ошибка для случаев, когда не расчитываем двери или ворота
            print('Ошибка! Не корректно задано значение "ориентир_потерь" для дверей и ворот: "' + str(self.name) + '"')
        
        # Площадь боковой поверхности:     
        self.F_c = F_c
        self.H_здания = H_здания
        #print("Площадь боковой поверхности = " + str(self.F_c))

        #self.R_ст = self.res.R() #wtyy

        # --- Окончание конструктора ---

    def Q_losses(self, t_хн = None, t_в1 = None):
        '''
        Возвращает количество теряемой тепловой энергии через ограждующую конструкцию, кВт
        t_хн, ℃ - расчетная температура наружного воздуха. if t_хн == None: t_хн = resistance.t_б_хн()
        t_в1, ℃ - расчетная средняя температура воздуха у боковых стен, окон, пола, потолка внутри помещения. if t_в1 == None: t_в1 = self.t_в1
        '''
        if t_хн == None: t_хн = self.res.t_б_хн()
        if t_в1 == None: t_в1 = self.t_в1

        Q_losses = 0.001 * (t_в1 - t_хн) * self.а * (1 + self.β) * self.F_c / self.res.R()
        return Q_losses

    def S_matherials(self):
        '''
        Возвращает совокупную стоимость ограждающей конструкции, ₽
        '''
        return self.F_c * self.res.Удельная_стоимость()
        

def f_zon(l_f, l_b, lenz = 4, d_zon = 2):
        '''
        Возвращает массив площадей при делении пола на зоны(по умолчанию 4), по принципу внешние 3 зоны в виде замкнутых полосок, расположенных по периметру площади пола, шириной d_zon(по умолчанию 2 м), а самая внутренняя она же 4-ая вычисляется как полощадь
        l_f, м - ширина фасада дома
        l_b, м - длинна стороны дома
        lenz, шт - максимальное количество зон на которые можно разбивает площадь пола (по нормативу 4)
        d_zon, м - ширина зон в виде полосок по перемитру площади
        '''
        #d_zon = 2#ширина зоны
        f_zon_m = []
        _l_f = l_f - d_zon * 2
        _l_b = l_b - d_zon * 2
        f_dom_z = 0
        v_l = True #можно взять зону в виде полоски
        if _l_f < 0 or _l_b < 0:
            v_l = False
        if v_l == True and lenz > 1: #можно ли зоны представить в виде замкнутых полосок, расположенных по периметру площади пола
            f_dom_z = 2 * (l_f + l_b) * d_zon
            #print("Перим = " + str(f_dom_z))
            f_zon_m += f_zon(_l_f, _l_b, lenz - 1, d_zon)#рукурсия для расчета площадей вложенных зон
        else:
            f_dom_z = l_f * l_b
            #print("Площадь = " + str(f_dom_z))
        if f_dom_z > 0:
            f_zon_m.insert(0, f_dom_z)#вставляем в начало массива
        return f_zon_m

class FloorLosses:
    '''Класс для расчета количества теряемой тепловой энергии за счет теплопроводности через напольные ограждения(перекрытия) на основе деления ограждения(перекрытия) на площадные зоны'''

    def __doc__(self):
        return 'Класс для расчета количества теряемой тепловой энергии за счет теплопроводности через напольные ограждения(перекрытия) на основе деления ограждения(перекрытия) на площадные зоны'

    def __init__(self, name, localisation, resistance, ограждение = "пол", зона = 4 , F_c = 1):
        
        '''
        Конструктор класса, который расчитвает потери через пол, потолок!!!
        name, str - название зоны пола или потолка
        localisation - данные из файла LocalisationData
        resistance - для расчета t_б_хн, тепловой инерционности, сопротивления теплопередаче через наружные ограждения здания
        ограждение, б/р - Коэффициент тип ограждения - а: пол, чердачное
        зона - максимальное количество зан на которые делится пол. По умолчанию 4.
        площади первой, второй, третьей и четвертой зон, отсчитываются от контура здания полосами шириной 2 м вдоль контура здания; в четвертую зону относят весь пол, не попавший в остальные три зоны;
        F_c, м² - площадь ограждающей конструкции: пол, потолок
        '''
        #Исходные данные
        self.name = name
        self.loc = localisation
        self.res = resistance
        self.ограждение = ограждение

        if ограждение == "пол":
            self.а = 0.75
        elif ограждение == "чердачное":
            self.а = 0.9
        else:
            print('Ошибка! Конструктора FloorLosses: ' + str(self.name) + '. Для ограждения = ' + str(ограждение) + '; коэффициент a не был задан!')
            self.а = nan
        #Согласно СП 50.13330.2012 Таблица Е.3 https://docs.cntd.ru/document/1200095525
        self.зона = зона
        if зона == 1:
            self.а_z = 2.1/7.7#Где R_пол = 2.1 ℃ * м² * Вт⁻¹
        elif зона == 2:
            self.а_z = 3.8/7.7#Где R_пол = 3.8 ℃ * м² * Вт⁻¹
        elif зона == 3:
            self.а_z = 5.2/7.7#Где R_пол = 5.2 ℃ * м² * Вт⁻¹
        elif зона == 4:
            self.а_z = 7.7/7.7#Где R_пол = 7.7 ℃ * м² * Вт⁻¹
        else:
            print('Ошибка! Конструктора FloorLosses: ' + str(self.name) + '. Для зона = ' + str(зона) + '; коэффициент а_z не был задан!')
            self.а_z = nan
		

        # Площадь боковой поверхности:     
        self.F_c = F_c
        # --- Окончание конструктора ---

    def Q_losses(self, t_хн = None, t_вр = None):
        '''
        Возвращает количество теряемой тепловой энергии через одельную зону пола, потолка, кВт
        t_хн, ℃ -- температура воздуха в подвале или грунта на глубине промерзания. if t_хн == None: t_хн = resistance.t_б_хн()
        t_вр, ℃ - расчетная средняя температура воздуха у пола внутри помещения. if t_вр == None: t_вр = self.loc.t_вр
        '''
        if t_хн == None: t_хн = self.res.t_б_хн()
        if t_вр == None: t_вр = self.loc.t_вр

        Q_losses = 0.001 * (t_вр - t_хн) * self.а * self.F_c / (self.res.R() * self.а_z)
        return Q_losses

    def S_matherials(self):
        '''
        Возвращает совокупную стоимость материалов ограждающей конструкции, ₽
        '''
        return self.F_c * self.res.Удельная_стоимость()

def wall_wind_direct(wall, wind):
    '''
    Возвращает отношение ориентира стены по отношению к направлению ветра:
    наветренная, паралельная, заветренная.
    wall, румбы - ориентир стены по сторонам света
    wind, румбы - направление ветра по сторонам света
     *румбы : "С", "СВ", "В", "ЮВ", "Ю", "ЮЗ", "З", "СЗ"
     ** - если "Ш" штиль то считаем, что сторона паралельная ветру
    '''
    param = ""
    if wall == "П" or wind == "Ш": param = "паралельная"
    else:
        rumb = ["С", "СВ", "В", "ЮВ", "Ю", "ЮЗ", "З", "СЗ"]
        delta = abs(rumb.index(wall) - rumb.index(wind))
        if delta > 4: delta = 8 - delta
        if delta < 2: param = "наветренная"
        elif delta == 2: param = "паралельная"
        elif delta > 2: param = "заветренная"
    return param

class WallInfiltration:
    '''Класс для расчета количества теряемой тепловой энергии за счет инфильтрации через поверхности, щели, проемы боковых ограждений'''

    def __doc__(self):
        return 'Класс для расчета количества теряемой тепловой энергии за счет инфильтрации через поверхности, щели, проемы боковых ограждений'

    def __init__(self, name, localisation, resistance, ограждение = "стена_непроизводственного_здания", ориентир_потерь = "С", H = None, h_нс = None, h_нн = None, h_нв = None, l_c = None):
        
        '''
        Конструктор класса с параметрами по умолчанию
        name, str - название ограждающей конструкции
        localisation - данные из файла LocalisationData
        resistance - для расчета t_б_хн, тепловой инерционности, сопротивления теплопередаче через наружные ограждения здания
        ограждение - щели, поры и иные неплотности ограждения по обе стороны конструкции, ограждающей помещение, из-за которых
        возникает разность давлений, побуждающая воздух перемещаться. Возможные варианты для выбора:
         - стена_непроизводственного_здания;
         - стена_производственного_здания;
         - аэрационный_проём;
         - аэрационный_проём_с_кондициоринованием;
         - стык_панелей_непроизводственного_здания;
         - стык_панелей_производственного_здания;
         - окно_или_балконная_дверь_с_тройными_переплетами_из_дерева;
         - окно_или_балконная_дверь_с_тройными_переплетами_из_пластика;
         - окно_или_балконная_дверь_с_раздельными_переплетами_из_дерева;
         - окно_или_балконная_дверь_с_раздельными_переплетами_из_пластика;
         - окно_или_балконная_дверь_с_одинарным_остеклением_из_дерева;
         - окно_или_балконная_дверь_со_спаренными_переплетами_из_пластика;
         - входная_дверь_в_квартиру;
         - входная_дверь_непроизводственного_здания;
         - окно_дверь_или_ворота_производственного_здания.
        ориентир_потерь - преобладающее направление ветра за декабрь - февраль, оно указывает азимут точки, откуда дует ветер. Служит для определения наветренных и заветренных сторон
        H, м - высота здания от уровня земли до чердачного перекрытия или до центра вытяжных отверстий аэрационных фонарей
        * для ограждений не являющимися "стык_панелей_непроизводственного_здания" или "стык_панелей_производственного_здания" h_нс, h_нв, l_c имеют следующие определения:
          h_нс, м - нижняя отметка всей стены. Например высота от уровня земли до пола этажа.
          h_нн, м - нижняя отметка участка ограждения с отсчетом от h_нс. Если нижняя отметка находится на уровне h_нс то h_нн = 0м.
          h_нв, м - вернхяя отметка участка ограждения с отсчетом от h_нс. Для h_нн = 0м, h_нв фактически будет равна высоте участака ограждения.
          l_c, м - ширина участка ограждения
        * для ограждений являющимися "стык_панелей_непроизводственного_здания" или "стык_панелей_производственного_здания" h_нс, h_нв, l_c имеют следующие определения:
          h_нс, м - нижняя отметка всей стены от которой начинается мощение вертикальных, диагональных и горизонтальных щелей. Например h_нс может выступать в качестве
          высоты от уровня земли до пола этажа (или низа окна). Относительно ее отсчитываются h_нн и h_нв.
          [h_нн, ...], м - массив высот на которых расположены нижние отметки щелей с длинной равной l_c. При этом если щель или её нажняя отметка расположенна на высоте h_нс, то
          для нее h_нн = 0. Этот параметр является массивом, то задавать значения следует h_нн = [0, h_нн1, h_нн2 ...] и т.д. по количеству щелей.
          [h_нв, ...], м - массив высот на которых расположены верхние отметки щелей с длинной равной l_c. При этом если щель или её верхняя отметка расположенна на высоте h_нс, то
          для нее h_нв = 0. Этот параметр является массивом, то задавать значения следует h_нв = [0, h_нв1, h_нв2 ...] и т.д. по количеству щелей.
          [l_c, ...], м - массив длинн горизонтальных, вертикальных, диагональных щелей. Для вертикльной щели справедливо равенство l_c == h_нв - h_нн, для горизонтальной h_нв == h_нн.
          Этот параметр является массивом, то задавать значения следует l_c = [0, l_c1, l_c2 ...] и т.д. по количеству щелей. 
        
        источник https://studizba.com/files/show/djvu/697-12-uchebnoe-posobie--energeticheskie.html
        '''
        #Исходные данные
        self.name = name
        self.loc = localisation
        self.res = resistance
        self.ограждение = ограждение
        
        #б/р, коэффициент, учитывающий подогрев инфильтрующегося воздуха при прохождениии через ограждения за счет тепла, получаемого от потоков теплоты уходящих через ограждения наружу
        self.K_т_dict = {
            "стена_непроизводственного_здания": 0.7, #1 Наружные стены, перекрытия и покрытия жилых, общественных, административных и бытовых зданий и помещений
            "стена_производственного_здания": 0.7, #2 Наружные стены, перекрытия и покрытия производственных зданий и помещений
            "аэрационный_проём": 1, #9 Фонари производственных зданий
            "аэрационный_проём_с_кондициоринованием": 1, #10 Окна и фонари производственных зданий с кондиционированием воздуха
            "стык_панелей_непроизводственного_здания": 0.7, #3 Стыки между панелями наружных стен: а) жилых зданий
            "стык_панелей_производственного_здания": 0.7, #3 Стыки между панелями наружных стен: б) производственных зданий
            "окно_или_балконная_дверь_с_тройными_переплетами_из_дерева": 0.7, #6 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с деревянными переплетами: окна и фонари производственных зданий с кондиционированием воздуха
            "окно_или_балконная_дверь_с_тройными_переплетами_из_пластика": 0.7, #7 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с пластмассовыми или алюминиевыми переплетами
            "окно_или_балконная_дверь_с_раздельными_переплетами_из_дерева": 0.8, #6 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с деревянными переплетами: окна и фонари производственных зданий с кондиционированием воздуха
            "окно_или_балконная_дверь_с_раздельными_переплетами_из_пластика": 0.8, #7 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с пластмассовыми или алюминиевыми переплетами
            "окно_или_балконная_дверь_с_одинарным_остеклением_из_дерева": 1, #6 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с деревянными переплетами: окна и фонари производственных зданий с кондиционированием воздуха
            "окно_или_балконная_дверь_со_спаренными_переплетами_из_пластика": 1, #7 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с пластмассовыми или алюминиевыми переплетами
            "входная_дверь_в_квартиру": 1, #4 Входные двери в квартиры
            "входная_дверь_непроизводственного_здания": 1, #5 Входные двери в жилые, общественные и бытовые здания
            "окно_дверь_или_ворота_производственного_здания": 1 #8 Окна, двери и ворота производственных зданий
        }
        try: self.K_т = self.K_т_dict[ограждение]
        except KeyError: print('Ошибка! В конструкторе WallInfiltration ' + str(name) + ' При вводе значения типа "ограждение"! Не существует: ' + str(ограждение))

        # согласно СП 50.13330.2012 Таблица 9 https://docs.cntd.ru/document/1200095525
        #кг * м⁻² * ч⁻¹(* - кг * м⁻¹ * ч⁻¹), нормируемая поперечная воздухопроницаемость ограждающих конструкций СП 50.13330.2012 стр 18 https://www.minstroyrf.gov.ru/upload/iblock/430/%D0%A1%D0%9F50.13330.2012%20%D0%A2%D0%B5%D0%BF%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F%20%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0%20%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B9.pdf
        self.G_н_dict = {
            "стена_непроизводственного_здания": 0.5, #1 Наружные стены, перекрытия и покрытия жилых, общественных, административных и бытовых зданий и помещений
            "стена_производственного_здания": 1, #2 Наружные стены, перекрытия и покрытия производственных зданий и помещений
            "аэрационный_проём": 10, #9 Фонари производственных зданий
            "аэрационный_проём_с_кондициоринованием": 6, #10 Окна и фонари производственных зданий с кондиционированием воздуха
            "стык_панелей_непроизводственного_здания": 0.5, #3 Стыки между панелями наружных стен: а) жилых зданий
            "стык_панелей_производственного_здания": 1.0, #3 Стыки между панелями наружных стен: б) производственных зданий
            "окно_или_балконная_дверь_с_тройными_переплетами_из_дерева": 6, #6 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с деревянными переплетами: окна и фонари производственных зданий с кондиционированием воздуха
            "окно_или_балконная_дверь_с_тройными_переплетами_из_пластика": 5, #7 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с пластмассовыми или алюминиевыми переплетами
            "окно_или_балконная_дверь_с_раздельными_переплетами_из_дерева": 6, #6 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с деревянными переплетами: окна и фонари производственных зданий с кондиционированием воздуха
            "окно_или_балконная_дверь_с_раздельными_переплетами_из_пластика": 5, #7 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с пластмассовыми или алюминиевыми переплетами
            "окно_или_балконная_дверь_с_одинарным_остеклением_из_дерева": 6, #6 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с деревянными переплетами: окна и фонари производственных зданий с кондиционированием воздуха
            "окно_или_балконная_дверь_со_спаренными_переплетами_из_пластика": 5, #7 Окна и балконные двери жилых, общественных и бытовых зданий и помещений с пластмассовыми или алюминиевыми переплетами
            "входная_дверь_в_квартиру": 1.5, #4 Входные двери в квартиры
            "входная_дверь_непроизводственного_здания": 7, #5 Входные двери в жилые, общественные и бытовые здания
            "окно_дверь_или_ворота_производственного_здания": 8 #8 Окна, двери и ворота производственных зданий
        }#* - кг * м⁻¹ * ч⁻¹
        
        try: self.G_н = self.G_н_dict[ограждение]
        except KeyError: print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". При вводе значения типа "ограждение"! Не существует: ' + str(ограждение))

        self.ориентир_потерь = ориентир_потерь

        if (ограждение in self.K_т_dict.keys()) and (ограждение not in ["стык_панелей_непроизводственного_здания", "стык_панелей_производственного_здания"]):#площадные варианты потерь
            if H == None or h_нс == None or h_нн == None or h_нв == None or l_c == None:
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать значения для: H, h_нс, h_нн, h_нв, l_c.')
            if H < 0 or h_нс < 0 or h_нн < 0 or h_нв < 0 or l_c <= 0:
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать не отрицательные значения для: H, h_нс, h_нн, h_нв, l_c.')
            elif h_нн > h_нв: print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". h_нн не может быть больше h_нв')
            elif H < h_нс + h_нв: print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". H не может быть меньше h_нс + h_нв')
            self.H = H
            self.h_нс = h_нс
            self.h_нн = h_нн
            self.h_нв = h_нв
            self.l_c = l_c
        elif ограждение in ["стык_панелей_непроизводственного_здания", "стык_панелей_производственного_здания"]:#щелевые варианты потерь
            if H == None or h_нс == None or h_нн == None or h_нв == None or l_c == None:
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать значения для: H, h_нс, h_нн, h_нв, l_c.')
            if H < 0 or h_нс < 0:
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать не отрицательные значения для: H, h_нс.')
            else:
                self.H = H
                self.h_нс = h_нс
                #self.l_c = l_c
        
            if str(type(h_нн)) != "<class 'list'>" or str(type(h_нв)) != "<class 'list'>" or str(type(l_c)) != "<class 'list'>":
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать значения для: h_нн, h_нв, l_c в виде массивов')
            elif len(h_нн) <= 0 or len(h_нв) <= 0 or len(l_c) <= 0:
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать не пустые массивы для: h_нн, h_нв, l_c')
            elif sum(n < 0 for n in h_нн) > 0 or sum(n < 0 for n in h_нв) > 0 or sum(n < 0 for n in l_c) > 0:
                print('Ошибка! В конструкторе WallInfiltration: "' + str(name) + '". Необходимо задать не отрицательные значения для всех элементов массивов: h_нн, h_нв, l_c')
            else:
                self.h_нн = h_нн
                self.h_нв = h_нв
                self.l_c = l_c
                #можно придумать алтернативу не ввиде массивов
           
        else: print('Ошибка! В конструкторе WallInfiltration ' + str(name) + ' Невозможно кооректно расчитать геометрию ограждения: ' + str(ограждение))
            
        self.h_р = None#м, уровень, через ограждения расположенные ниже которого будет осуществляться инфильтрация воздуха. Не расчитан
        self.K_1н = 0.6#аэродинамический коэффициент обтекания здания для наветренных сторон
        self.K_1з = -0.45#аэродинамический коэффициент обтекания здания для заветренных сторон
        self.K_2 = 1#коэффициента, учитывающего изменение ветрового давления на ограждения
     
        # --- Окончание конструктора ---
    def H_р(self, t_хн = None, W_нр = None, W_dir = None, t_вр = None):
        '''
        м, уровень, через ограждения расположенные ниже которого будет осуществляться инфильтрация воздуха
        t_хн, ℃ - расчетная температура наружного воздуха. if t_хн == None: t_хн = resistance.t_б_хн()
        W_нр, м*с⁻¹ - максимальная из средних скоростей ветра по румбам за январь. if W_нр == None: W_нр = localisation.W_нр
        W_dir, б/р - Преобладающее направление ветра за декабрь - февраль. Допустимые значения 'С', 'СВ', 'В', 'ЮВ', 'Ю', 'ЮЗ', 'З', 'СЗ'. if W_dir == None: W_dir = localisation.W_dir
        '''
        if t_хн == None: t_хн = self.res.t_б_хн()
        if W_нр == None: W_нр = self.loc.W_нр
        if W_dir == None: W_dir = self.loc.W_dir
        if t_вр == None: t_вр = self.loc.t_вр
        
        #кг * м⁻³, плотность воздуха внутри помещения
        self.ρ_в = self.loc.ρ_в0 * (273.15 + self.loc.t_0) / (273.15 + t_вр)
        #print("ρ_в = " + str(ρ_в) + " кг * м⁻³")

        #кг * м⁻³, плотность воздуха наружная
        self.ρ_н = self.loc.ρ_в0 * (273.15 + self.loc.t_0) / (273.15 + t_хн)
        #print("ρ_н = " + str(ρ_н) + " кг * м⁻³")

        self.wall_direct = wall_wind_direct(self.ориентир_потерь, W_dir)
        #print("Сторона стены: " + str(wall_direct))

        self.vet = [0, 0]
        if self.wall_direct == "наветренная": self.vet = [+1, -1]#на наветренной стороне здания
        elif self.wall_direct == "заветренная": self.vet = [-1, -1]#на заветренной стороне здания
        elif self.wall_direct == "паралельная": self.vet = [-1, +1]#параллельно направлению ветра
        else: print('Ошибка! метода WallInfiltration.Q_losses(): ' + str(self.name) + '. Для wall_direct = ' + str(self.wall_direct) + '; коэффициенты vet не были заданы!')

        #м, уровень, через ограждения расположенные ниже которого будет осуществляться инфильтрация воздуха
        if self.ρ_н != self.ρ_в:
            self.h_р = 0.5 * self.H + self.vet[0] * 0.25 * (self.K_1н + self.vet[1] * self.K_1з) * self.K_2 * self.ρ_н * W_нр**2 / (self.loc.g * (self.ρ_н - self.ρ_в))
        else: self.h_р = 0.5 * self.H#поправки на инфильтрацию не будет при одинаковых плотностях иначе деление на 0
        #print("h_р = " + str(h_р) + " м - Уровень, через ограждения расположенные ниже которого будет осуществляться инфильтрация воздуха")
        return self.h_р


    def Q_losses(self, t_хн = None, W_нр = None, W_dir = None, t_вр = None):
        '''
        Возвращает количество теряемой тепловой энергии через ограждующую конструкцию за счет инфильтрации, кВт
        t_хн, ℃ - расчетная температура наружного воздуха. if t_хн == None: t_хн = resistance.t_б_хн()
        W_нр, м*с⁻¹ - максимальная из средних скоростей ветра по румбам за январь. if W_нр == None: W_нр = localisation.W_нр
        W_dir, б/р - Преобладающее направление ветра за декабрь - февраль. Допустимые значения 'С', 'СВ', 'В', 'ЮВ', 'Ю', 'ЮЗ', 'З', 'СЗ'. if W_dir == None: W_dir = localisation.W_dir
        t_вр, ℃ - расчетная средняя температура воздуха у боковых стен, окон, пола, потолка внутри помещения. if t_вр == None: t_вр = self.loc.t_вр
        '''
        if t_хн == None: t_хн = self.res.t_б_хн()
        if W_нр == None: W_нр = self.loc.W_нр
        if W_dir == None: W_dir = self.loc.W_dir
        if t_вр == None: t_вр = self.loc.t_вр

        h_р = self.H_р(t_хн = t_хн, W_нр = W_нр, W_dir = W_dir, t_вр = t_вр)#Всегда рассчитываем высоту ниже, которой будут потери с инфильтрацией

        if (self.ограждение in self.K_т_dict.keys()) and (self.ограждение not in ["стык_панелей_непроизводственного_здания", "стык_панелей_производственного_здания"]):#площадные варианты потерь
            if self.h_нн + self.h_нс > self.h_р:
                #print('Предупреждение! В WallInfiltration: "' + str(self.name)
                #      + '". Для функции Q_losses не была расчитана для проверки функция H_р = '
                #      + str(round(h_р, 3)) + ' < (h_нв + h_нс) = ' + str(self.h_нв + self.h_нс) + '. Следовательно инфильтрации не будет!')
                self.F_c = 0
                return 0
            elif self.h_р > self.h_нв + self.h_нс:
                self.F_c = (self.h_нв - self.h_нн) * self.l_c #площадь ограждение учавствует полностью в потерях за счет инфильтрации
                self.h_н = (self.h_нв + self.h_нн) / 2#высота от h_нс до середены высоты ограждения
            elif (self.h_нн + self.h_нс) < self.h_р and self.h_р < (self.h_нв + self.h_нс):
                self.F_c = (self.h_р - self.h_нн - self.h_нс) * self.l_c#площадь ограждение учавствует частично в потерях за счет инфильтрации
                self.h_н = (self.h_р + self.h_нн) / 2#высота от h_нс до середены высоты ограждения, учавствующем в инфильтрации
            else: print('Ошибка! В методе Q_losses класса WallInfiltration: "' + str(name) + '". Не предусмотрен случай для расчета площади self.F_c')

        elif self.ограждение in ["стык_панелей_непроизводственного_здания", "стык_панелей_производственного_здания"]:#щелевые варианты потерь
            self.m_L_c = []
            self.m_h_н = []
            if self.h_нс >= self.h_р:
                #print('Предупреждение! В WallInfiltration: "' + str(self.name)
                #      + '". Для функции Q_losses не была расчитана для проверки функция H_р = '
                #      + str(round(h_р, 3)) + ' < (h_нс) = ' + str(+ self.h_нс) + '. Следовательно инфильтрации не будет!')
                return 0#чтоб не считать лишнего для созданных условий h_нв >=0, h_нв >= 0
            
            for i_c in range(len(self.l_c)):
                if self.h_р >= self.h_нв[i_c] + self.h_нс:#щелевые ограждение учавствует полностью в потерях за счет инфильтрации
                    self.m_L_c.append(self.l_c[i_c])
                    self.m_h_н.append((self.h_нн[i_c] + self.h_нв[i_c]) / 2)
                elif (self.h_нс + self.h_нв[i_c] >= self.h_р) and (self.h_р > self.h_нс + self.h_нн[i_c]):
                    self.m_L_c.append(self.l_c[i_c] * ((self.h_р - self.h_нс) - self.h_нн[i_c]) / (self.h_нв[i_c] - self.h_нн[i_c]))#пропорцией вычисляем длину щели участвующую в инфильтрации
                    self.m_h_н.append((self.h_нн[i_c] + (self.h_р - self.h_нс)) / 2)#средняя отметка щели с отсчетом от h_нс
                elif self.h_р <= self.h_нс + self.h_нн[i_c]: pass#ничего не добавляем
                else:
                    print('Ошибка! В методе Q_losses класса WallInfiltration: "' + str(self.name) + '". Не предусмотрен случай для расчета щелевого ограждения')

        #print('self.F_c = ' + str(self.F_c))
        self.G_и = 0
       
        if self.ограждение in ["стык_панелей_непроизводственного_здания", "стык_панелей_производственного_здания"]:#щелевые варианты потерь
            self.dp_огр = []
            for i in range(len(self.m_h_н)):
                #Па, разности давлений по обе стороны ограждений 
                dp_огр = (0.5 * self.H - self.h_нс - self.m_h_н[i]) * (self.ρ_н - self.ρ_в) * self.loc.g
                + self.vet[0] * 0.25 * (self.K_1н + self.vet[1] * self.K_1з) * self.K_2 * self.ρ_н * W_нр**2
                #print("dp_огр = " + str(dp_огр) + " Па - Разности давлений по обе стороны ограждений")
                self.dp_огр.append(dp_огр)
                #кг/ч, количество воздуха, инфильтрующегося в помещение через стыки панелей и блоков ограждений
                self.G_и += 0.1 * self.G_н * self.m_L_c[i] * dp_огр
        else:#площадные варианты потерь
            #Па, разности давлений по обе стороны ограждений 
            self.dp_огр = (0.5 * self.H - self.h_н - self.h_нс) * (self.ρ_н - self.ρ_в) * self.loc.g
            + self.vet[0] * 0.25 * (self.K_1н + self.vet[1] * self.K_1з) * self.K_2 * self.ρ_н * W_нр**2
            #print("self.dp_огр = " + str(self.dp_огр) + " Па - Разности давлений по обе стороны ограждений")

        if self.ограждение in ["стена_непроизводственного_здания", "стена_производственного_здания"]:
            #кг/ч, количество воздуха, поступающего в здание инфильтруясь через его наружные стены, покрытия и перекрытия
            self.G_и = 0.216 * self.G_н * self.F_c * pow(abs(self.dp_огр), 0.667)
        if self.ограждение in [",окно_или_балконная_дверь_с_тройными_переплетами_из_дерева",
                               ",окно_или_балконная_дверь_с_тройными_переплетами_из_пластика",                                                                                           
                               ",окно_или_балконная_дверь_с_раздельными_переплетами_из_дерева",                                                                                          
                               ",окно_или_балконная_дверь_с_раздельными_переплетами_из_пластика",                                                                                        
                               ",окно_или_балконная_дверь_с_одинарным_остеклением_из_дерева",                                                                                            
                               ",окно_или_балконная_дверь_со_спаренными_переплетами_из_пластика",                                                                                        
                               ",входная_дверь_в_квартиру",                                                                                                                              
                               ",входная_дверь_непроизводственного_здания",                                                                                                              
                               ",окно_дверь_или_ворота_производственного_здания"]:
            #м**2*ч*Па * кг⁻¹, минимально-допустимая величина сопротивления воздухопроницанию ограждения
            R_в = self.dp_огр / self.G_н#м**2*ч*Па/кг, для стен, покрытий, перекрытий
            #кг/ч, количество воздуха, инфильтрующегося в помещение через окна, балконные двери, ворота, аэрационные фонари
            self.G_и = 0.216 * (self.F_c * pow(abs(self.dp_огр), 0.667) / R_в)
        if self.ограждение in ["аэрационный_проём", "аэрационный_проём_с_кондициоринованием"]:
            #кг/ч, количество воздуха, инфильтрующегося в помещение через аэрационные проемы и иные неплотности значительных размеров
            self.G_и = 3456 * self.F_c * pow(abs(self.dp_огр), 0.5)
        #----------------------------------------------
       
        Q_losses = 0.00028 * (t_вр - t_хн) * self.loc.c_в * self.G_и * self.K_т
        return Q_losses

    ################################################################################################################
    
class HeatDissipation:
    """Класс для расчета тепловыделений от людей и электрических приборов"""
    
    def _doc_(self):
        return 'Класс для расчета тепловыделений от людей и электрических приборов'
    def __init__(self, name, q_тв_ч = 0.2, М_л = 5, W_расч = 240):

       '''
       Конструктор класса
       q_тв_ч, кВт/чел - количество теплоты, выделяемое одним человеком
       М_л, чел - количество людей, находящихся в помещении в рассмотриваемый момент
       W_расч, кВт/ч - суммарное электропотребление дома
       '''
       self.name = name
       self.q_тв_ч = q_тв_ч#кВт/чел (мужчина при работе средней тяжести, при температуре воздуха в помещении 20 ℃)
       self.М_л = М_л#чел
       self.W_расч = W_расч#кВт/ч

    def Q_тв_л(self):
          '''
          Q_тв_л, кВт - Тепловыделения от работающих людей
          '''
          Q_тв_л_ = self.q_тв_ч * self.М_л
          #print("Q_тв_л = " + str(round(Q_тв_л_, 2)) + str(" кВт"))
          return Q_тв_л_

    def Q_тв_ап(self):
          '''
          Q_тв_ап, кВт - Тепловыделения от электрических приборов
          '''
          Q_тв_ап_ = 0.2 * self.W_расч * 24
          #print("Q_тв_ап = " + str(round(Q_тв_ап_, 3)) + str(" кВт"))
          return Q_тв_ап_ / 1000

class WaterSupply:
    """Класс для расчета максимальной тепловой нагрузки на горячее водоснабжение зданий в отопительный и летний периоды"""
    def __doc__(self):
        return 'Класс для расчета максимальной тепловой нагрузки на горячее водоснабжение зданий в отопительный и летний периоды'

    def __init__(self, name, t_хв_з = 5, t_хв_л = 15, t_гв = 65, a_гв = 90, М = 5, k_ч_max = 6.3, β = 0.8):
        '''
        Конструктор класса
        t_хв_з, ℃ - расчетная температура горячей воды у водоразборных приборов зданий зимой;
        t_хв_л, ℃ - расчетная температура холодной воды у водоразборных приборов зданий для летнего периода;
        t_гв, ℃ - расчетная температура холодной воды у водоразборных приборов зданий;
        a_гв, л/(сут*чел) - норма расхода горячей воды одним жителем (принимается по СП 30.13330.2020)
        М, чел - количество жителей
        k_ч_max, б/р - коэффициент часовой неравномерности потребления воды на ЖКХ;
        t_хв_л, ℃ - расчетная температура холодной воды у водоразборных приборов зданий для летнего периода;
        β, б/р - коэффициент неравномерности, учитывающий вероятность несовпадения во времени максимальных нагрузок.
        '''
        self.name = name
        self.t_хв_з = t_хв_з#℃
        self.t_хв_л = t_хв_л#℃
        self.t_гв = t_гв#℃
        self.a_гв = a_гв#л/(сут*чел) - для жилых домов с сидячими ваннами, оборудованными душами
        self.М = М#чел
        self.с_в = 4.19#кДж/(кг*℃) - теплоемкость воды
        self.k_ч_max = k_ч_max
        self.β = β
        
    def Q_гв_ср(self):
        '''Q_гв_ср, кВт - средняя тепловая нагрузка на горячее водоснабжение для отопительного периода'''
        Q_гв_ср_ = (1.2 * self.М * self.a_гв * self.с_в * (self.t_гв - self.t_хв_з))/(24*60*60)
        #print("Q_гв_ср = " + str(round(Q_гв_ср, 2)) + str(" кВт"))
        return Q_гв_ср_

    def Q_гв_р(self):
        '''Q_гв_р, кВт - максимальная тепловая нагрузка на горячее водоснабжение для отопительного периода'''
        Q_гв_р_ = self.Q_гв_ср() * self.k_ч_max
        #print("Q_гв_р = " + str(round(Q_гв_р, 2)) + str(" кВт"))
        return Q_гв_р_

    def Q_гв_ср_л(self):
        '''Q_гв_ср_л, кВт - средняя тепловая нагрузка на горячее водоснабжение для летнего периода'''
        Q_гв_ср_л_ = self.β * self.Q_гв_ср() * (self.t_гв - self.t_хв_л )/(self.t_гв - self.t_хв_з)
        #print("Q_гв_ср_л = " + str(round(Q_гв_ср_л, 2)) + str(" кВт"))
        return Q_гв_ср_л_

    def Q_гв_р_л(self):
        '''Q_гв_р_л, кВт - максимальная тепловая нагрузка на горячее водоснабжение зданий в летний период'''
        Q_гв_р_л_ = self.Q_гв_ср_л() * self.k_ч_max
        #print("Q_гв_р_л = " + str(round(Q_гв_р_л, 2)) + str(" кВт"))
        return Q_гв_р_л_

    def Q_гв_ср_сумм(self):
        return self.Q_гв_ср() + self.Q_гв_ср_л()

    def Q_гв_р_сумм(self):
        return self.Q_гв_р() + self.Q_гв_р_л()
          
