# coding: utf-8

"""
    Tator REST API

    Interface to the Tator backend.  # noqa: E501

    The version of the OpenAPI document: v1
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from ..configuration import Configuration


class AttributeFilterSpec(object):
    """
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'attribute': 'str',
        'inverse': 'bool',
        'operation': 'str',
        'value': 'object'
    }

    attribute_map = {
        'attribute': 'attribute',
        'inverse': 'inverse',
        'operation': 'operation',
        'value': 'value'
    }

    def __init__(self, attribute=None, inverse=False, operation=None, value=None, local_vars_configuration=None):  # noqa: E501
        """AttributeFilterSpec - a model defined in OpenAPI"""
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._attribute = None
        self._inverse = None
        self._operation = None
        self._value = None
        self.discriminator = None

        if attribute is not None:
            self.attribute = attribute
        if inverse is not None:
            self.inverse = inverse
        if operation is not None:
            self.operation = operation
        self.value = value

    @property
    def attribute(self):
        """
        Name of the attribute or field to search on.                               Given a user defined type (Localization, State, or Media) with defined attributes                any attribute is searchable by its name. If a Localization has an attribute named 'Species'                the name to use to search on that column is 'Species'.                 Additional built-in columns are available to search on dependent on the underlying metadata               type being searched. To search a built in field, a '$' character must be used in front of the column               name from main.models.                              The following table shows common columns and to which types they apply. Any internal column                of the model may be searched in this manner.                              '$' must precede these names in search attempts. E.g. `created_by` is supplied as `$created_by`.                <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td>x</td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>parent</td>         <td>Foreign key to parent element</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr> </table> <br /><br />The following special columns are available for searching on related data. Also must be preceded with a '$'. <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>related_localizations</td>         <td>Returns media that contain localizations that match this subquery</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>related_states</td>         <td>Returns media that contain states that match this subquery</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>related_media</td>         <td>Returns metadata that is associated with media matching this subquery</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>track_membership</td>         <td>Returns localizations that are in a matching track (localization-state)</td>         <td>X</td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>coincident_states</td>         <td>Returns metadata that is coincident with state(s) (same frame/media)</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>coincident_localizations</td>         <td>Returns metadata that is coincident with a localization(s) (same frame/media)</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr> </table> <b>IMPORTANT:</b> Only the 'search' operation is valid for these special columns

        :return: The attribute of this AttributeFilterSpec. 
        :rtype: str
        """
        return self._attribute

    @attribute.setter
    def attribute(self, attribute):
        """
        Name of the attribute or field to search on.                               Given a user defined type (Localization, State, or Media) with defined attributes                any attribute is searchable by its name. If a Localization has an attribute named 'Species'                the name to use to search on that column is 'Species'.                 Additional built-in columns are available to search on dependent on the underlying metadata               type being searched. To search a built in field, a '$' character must be used in front of the column               name from main.models.                              The following table shows common columns and to which types they apply. Any internal column                of the model may be searched in this manner.                              '$' must precede these names in search attempts. E.g. `created_by` is supplied as `$created_by`.                <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>section</td>         <td>Media section</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>created_datetime</td>         <td>The time of creation for this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>created_by</td>         <td>The user id who created this datum</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_datetime</td>         <td>The last modification time</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>modified_by</td>         <td>The last modification user</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>name</td>         <td>The name of the element</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>fps</td>         <td>The frames per second</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>deleted</td>         <td>Whether the media is marked deleted</td>         <td></td>         <td></td>         <td>X</td>         <td>X</td>         <td>X</td>     </tr>     <tr>         <td>variant_deleted</td>         <td>Whether the metadata is marked deleted</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>archive_state</td>         <td>The current archive state of the media</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>x, y, u, or v</td>         <td>Geometric coordinates</td>         <td></td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>width or height</td>         <td>Geometric sizes</td>         <td>x</td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>incident</td>         <td>Available when doing a related search</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>parent</td>         <td>Foreign key to parent element</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr> </table> <br /><br />The following special columns are available for searching on related data. Also must be preceded with a '$'. <table border=\"1\">     <tr>         <th>Name</th>         <th>Description</th>         <th>Localizations</th>         <th>States</th>         <th>Medias</th>         <th>Leaves</th>         <th>Files</th>     </tr>     <tr>         <td>related_localizations</td>         <td>Returns media that contain localizations that match this subquery</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>related_states</td>         <td>Returns media that contain states that match this subquery</td>         <td></td>         <td></td>         <td>X</td>         <td></td>         <td></td>     </tr>     <tr>         <td>related_media</td>         <td>Returns metadata that is associated with media matching this subquery</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>track_membership</td>         <td>Returns localizations that are in a matching track (localization-state)</td>         <td>X</td>         <td></td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>coincident_states</td>         <td>Returns metadata that is coincident with state(s) (same frame/media)</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr>     <tr>         <td>coincident_localizations</td>         <td>Returns metadata that is coincident with a localization(s) (same frame/media)</td>         <td>X</td>         <td>X</td>         <td></td>         <td></td>         <td></td>     </tr> </table> <b>IMPORTANT:</b> Only the 'search' operation is valid for these special columns

        :param attribute: The attribute of this AttributeFilterSpec.
        :type: str
        """

        self._attribute = attribute

    @property
    def inverse(self):
        """
        Whether to apply NOT to result

        :return: The inverse of this AttributeFilterSpec. 
        :rtype: bool
        """
        return self._inverse

    @inverse.setter
    def inverse(self, inverse):
        """
        Whether to apply NOT to result

        :param inverse: The inverse of this AttributeFilterSpec.
        :type: bool
        """

        self._inverse = inverse

    @property
    def operation(self):
        """
        Name of the operation to apply. Not all operations apply to all attributes.

        :return: The operation of this AttributeFilterSpec. 
        :rtype: str
        """
        return self._operation

    @operation.setter
    def operation(self, operation):
        """
        Name of the operation to apply. Not all operations apply to all attributes.

        :param operation: The operation of this AttributeFilterSpec.
        :type: str
        """
        allowed_values = ["eq", "gt", "gte", "lt", "lte", "icontains", "iendswidth", "istartswith", "isnull", "in", "date_eq", "date_gte", "date_gt", "date_lt", "date_lte", "date_range", "distance_lte", "search"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and operation not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `operation` ({0}), must be one of {1}"  # noqa: E501
                .format(operation, allowed_values)
            )

        self._operation = operation

    @property
    def value(self):
        """
        Boolean, integer, float, string, datetime, [lon, lat], float array.

        :return: The value of this AttributeFilterSpec. 
        :rtype: object
        """
        return self._value

    @value.setter
    def value(self, value):
        """
        Boolean, integer, float, string, datetime, [lon, lat], float array.

        :param value: The value of this AttributeFilterSpec.
        :type: object
        """

        self._value = value

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, AttributeFilterSpec):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, AttributeFilterSpec):
            return True

        return self.to_dict() != other.to_dict()
