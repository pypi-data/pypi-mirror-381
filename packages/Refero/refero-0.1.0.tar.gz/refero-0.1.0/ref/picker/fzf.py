from __future__ import annotations

from typing import Any, Callable, Dict, List, Sequence, TypeVar, Optional
import os
import sys
import time
import subprocess
import tempfile
import json
import secrets

import ref.config as ref_config
from ref.console import echo

T = TypeVar("T")


def _base_hint_text() -> str:
    return "Ctrl-n/p:Nav  |  Tab: toggle  |  Enter: confirm  |  Esc: cancel"


def _normal_header_hint(with_help: bool = True) -> str:
    base = _base_hint_text()
    return (base + "  |  Ctrl-h: help") if with_help else base
 
def _help_header_hint() -> str:
    base = _base_hint_text()
    return base + "  |  Ctrl-g: hidden help"

def _help_overlay_lines_for(context: str) -> List[str]:
    ctx = (context or "").strip().lower()
    if ctx == "tags":
        return [
            _help_header_hint(),
            "★ = currently set; Tab to select/unselect or type new tags (comma-separated) | then press Enter to add",
        ]
    if ctx in {"collections", "collection"}:
        return [
            _help_header_hint(),
            "★ = currently set; filter collection names by typing | then press Tab to select/unselect",
        ]
    if ctx in {"note", "notes"}:
        return [
            "Enter: select note  |  Esc: cancel  |  Ctrl-g: hidden help",
            "Ctrl-n/p: navigate notes",
        ]
    if ctx == "related":
        return [
            _help_header_hint(),
            "★ = currently related; filter and toggle items to link/unlink",
        ]
    # generic fallback
    return [
        _help_header_hint(),
    ]


def _escape_for_fzf_action_arg(text: str) -> str:
    """Escape special chars for fzf action arguments inside parentheses.

    fzf uses ',' to separate bindings/actions and ')' to end arg list; both must be escaped.
    Also escape backslashes first to avoid double-processing.
    """
    s = text.replace("\\", "\\\\")
    s = s.replace(")", "\\)")
    s = s.replace(",", "\\,")
    return s


def _binding_help_lines(cfg: ref_config.RefConfig, context: str) -> List[str]:
    binding_lines = cfg.picker_help_lines()
    if binding_lines:
        return [_help_header_hint()] + binding_lines
    return _help_overlay_lines_for(context)


class FzfPicker:
    def __call__(
        self,
        items: Sequence[T],
        header_filter: Callable[[T], str] = str,
        match_filter: Callable[[T], str] = str,  # kept for signature compatibility
        default_index: int = 0,  # unused for fzf
        context: str = "pick",
    ) -> List[T]:
        """Pick items using the system fzf binary.

        The header text is generated by `header_filter`. We assume the header contains
        fields separated by the configured delimiter (default: " :: "), with the
        5th field being the Zotero item key and the 6th being the citekey, matching
        the defaults used by `ref` and enabling fzf placeholders like {5} and {6}.
        """
        cfg = ref_config.load()
        fzf_bin = cfg.fzf_binary
        flags: List[str] = list(cfg.fzf_extra_flags)
        bindings: List[str] = list(cfg.fzf_extra_bindings)

        # Ensure UI appears even for a single item: strip auto-accept flags if present
        eff_flags = list(flags)
        if len(items) == 1:
            disallowed = {"--select-1", "-1", "--exit-0", "-0"}
            eff_flags = [f for f in eff_flags if str(f) not in disallowed]

        # Align default window style with other --pick flows if not explicitly configured
        def _has_flag(name: str) -> bool:
            return any((f == name) for f in eff_flags)

        def _has_flag_prefix(prefix: str) -> bool:
            return any(str(f).startswith(prefix) for f in eff_flags)

        # Ensure inline info area (matches fzf_multiselect_lines)
        if not (_has_flag("--info=inline") or _has_flag_prefix("--info=")):
            eff_flags.append("--info=inline")

        # Ensure sync/cycle/multi to match UX of tag/collection/relate pickers
        if not _has_flag("--sync"):
            eff_flags.append("--sync")
        if not _has_flag("--cycle"):
            eff_flags.append("--cycle")
        if not _has_flag("--multi"):
            eff_flags.append("--multi")

        # Default selection marker to star for visual consistency unless user set one
        has_marker_flag = any((f == "--marker") for f in eff_flags)
        if not has_marker_flag:
            eff_flags += ["--marker", "★"]

        # Provide a consistent prompt if user didn't set one
        has_prompt_flag = any((f == "--prompt") or str(f).startswith("--prompt=") for f in eff_flags)
        if not has_prompt_flag:
            eff_flags += ["--prompt", "pick> "]

        # Default concise header hint (only if user hasn't set a header already)
        concise_hint = _normal_header_hint(with_help=True)
        has_header_flag = any(
            (f == "--header") or str(f).startswith("--header=") for f in eff_flags
        )
        if not has_header_flag:
            eff_flags = list(eff_flags) + ["--header", concise_hint]

        # Provide a Ctrl-h help overlay by default unless user already bound ctrl-h
        has_ctrl_h = any(str(b).strip().lower().startswith("ctrl-h:") for b in bindings)
        if not has_ctrl_h:
            # Always use bindings-based dynamic help for main picker
            help_lines = _binding_help_lines(cfg, context)
            help_text = _escape_for_fzf_action_arg("\n".join(help_lines))
            bindings = list(bindings) + [f"ctrl-h:change-header({help_text})"]

            # Add Ctrl-g to restore original header and hide help overlay
            has_ctrl_g = any(str(b).strip().lower().startswith("ctrl-g:") for b in bindings)
            if not has_ctrl_g:
                original_header: Optional[str] = None
                # Prefer any user-specified header in flags
                for i, f in enumerate(eff_flags):
                    sf = str(f)
                    if sf.startswith("--header="):
                        original_header = sf.split("=", 1)[1]
                        break
                    if sf == "--header" and i + 1 < len(eff_flags):
                        original_header = str(eff_flags[i + 1])
                        break
                if not original_header:
                    # Fallback to concise header without the help hint
                    original_header = _normal_header_hint(with_help=False)
                restore_text = _escape_for_fzf_action_arg(original_header)
                bindings.append(f"ctrl-g:change-header({restore_text})")

        # Build command
        cmd: List[str] = [fzf_bin] + eff_flags
        for b in bindings:
            cmd += ["--bind", b]

        # Determine delimiter (default to the template default)
        delimiter = " :: "
        for i, f in enumerate(flags):
            if f.startswith("--delimiter="):
                delimiter = f.split("=", 1)[1]
                break
            if f == "--delimiter" and i + 1 < len(flags):
                delimiter = flags[i + 1]
                break

        # Prepare input lines and a lookup by key
        lines: List[str] = []
        key_to_item: Dict[str, T] = {}
        for it in items:
            header = header_filter(it)
            lines.append(header)
            # Best-effort: extract key as the 5th field using the configured delimiter
            try:
                parts = header.split(delimiter)
                if len(parts) >= 5:
                    key_field = parts[4].strip()
                    key_to_item[key_field] = it
            except Exception:
                # ignore extraction errors; selection mapping may fail for such lines
                pass

        # Optionally spin up preview daemon and wire FDs/env if using preview-client
        preview_arg: Optional[str] = None
        for i, f in enumerate(eff_flags):
            sf = str(f)
            if sf.startswith("--preview="):
                preview_arg = sf.split("=", 1)[1]
                break
            if sf == "--preview" and i + 1 < len(eff_flags):
                preview_arg = str(eff_flags[i + 1])
                break

        use_daemon = isinstance(preview_arg, str) and ("preview-client" in preview_arg)

        env_for_fzf: Optional[Dict[str, str]] = None
        pass_fds: Optional[tuple[int, int]] = None
        daemon: Optional[subprocess.Popen] = None
        req_r = req_w = resp_r = resp_w = None  # type: ignore[assignment]

        if use_daemon:
            try:
                prefer_tcp = (os.name == "nt") or (os.environ.get("REF_PREVIEW_FORCE_TCP") == "1")
                preload_keys = list(key_to_item.keys())
                daemon_env = os.environ.copy()
                if prefer_tcp:
                    # TCP mode: daemon writes host/port/token to meta file
                    meta_fd, meta_path = tempfile.mkstemp(prefix="ref_preview_meta_", suffix=".json")
                    os.close(meta_fd)
                    token = secrets.token_urlsafe(16)
                    daemon_env["REF_PREVIEW_DAEMON_MODE"] = "tcp"
                    daemon_env["REF_PREVIEW_DAEMON_HOST"] = "127.0.0.1"
                    daemon_env["REF_PREVIEW_DAEMON_META"] = meta_path
                    daemon_env["REF_PREVIEW_DAEMON_TOKEN"] = token
                    if preload_keys:
                        daemon_env["REF_PREVIEW_DAEMON_PRELOAD"] = ",".join(preload_keys)

                    daemon = subprocess.Popen(
                        [sys.executable, "-m", "ref.commands.preview_daemon"],
                        env=daemon_env,
                        stdin=subprocess.DEVNULL,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        close_fds=True,
                    )

                    # Wait briefly for meta file to appear
                    ok = False
                    for _ in range(100):  # up to ~1s
                        if daemon.poll() is not None:
                            break
                        try:
                            with open(meta_path, "r", encoding="utf-8") as fp:
                                meta = json.load(fp)
                            host = str(meta.get("host") or "127.0.0.1")
                            port = int(meta.get("port") or 0)
                            if port > 0:
                                env_for_fzf = os.environ.copy()
                                env_for_fzf["REF_PREVIEW_TCP_HOST"] = host
                                env_for_fzf["REF_PREVIEW_TCP_PORT"] = str(port)
                                env_for_fzf["REF_PREVIEW_TCP_TOKEN"] = token
                                env_for_fzf["REF_PREVIEW_DAEMON_PRETTY"] = "1"
                                ok = True
                                break
                        except Exception:
                            pass
                        time.sleep(0.01)
                    # cleanup meta file path (no longer needed)
                    try:
                        os.unlink(meta_path)
                    except Exception:
                        pass

                    if not ok:
                        echo("Preview daemon failed to start (TCP); falling back to direct preview.", err=True)
                        env_for_fzf = None
                        pass_fds = None
                        daemon = None
                else:
                    # POSIX FD mode
                    req_r, req_w = os.pipe()
                    resp_r, resp_w = os.pipe()
                    daemon_env["REF_PREVIEW_DAEMON_REQ_R_FD"] = str(req_r)
                    daemon_env["REF_PREVIEW_DAEMON_RESP_W_FD"] = str(resp_w)
                    if preload_keys:
                        daemon_env["REF_PREVIEW_DAEMON_PRELOAD"] = ",".join(preload_keys)

                    daemon = subprocess.Popen(
                        [sys.executable, "-m", "ref.commands.preview_daemon"],
                        env=daemon_env,
                        stdin=subprocess.DEVNULL,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        close_fds=True,
                        pass_fds=(req_r, resp_w),
                    )

                    try:
                        os.close(req_r)
                    except Exception:
                        pass
                    try:
                        os.close(resp_w)
                    except Exception:
                        pass

                    env_for_fzf = os.environ.copy()
                    env_for_fzf["REF_PREVIEW_DAEMON_IN_FD"] = str(req_w)
                    env_for_fzf["REF_PREVIEW_DAEMON_OUT_FD"] = str(resp_r)
                    env_for_fzf["REF_PREVIEW_DAEMON_PRETTY"] = "1"
                    pass_fds = (req_w, resp_r)

                    # Early failure detection
                    time.sleep(0.02)
                    if daemon.poll() is not None and daemon.returncode != 0:
                        echo("Preview daemon failed to start; falling back to direct preview.", err=True)
                        try:
                            os.close(req_w)
                        except Exception:
                            pass
                        try:
                            os.close(resp_r)
                        except Exception:
                            pass
                        env_for_fzf = None
                        pass_fds = None
                        daemon = None
            except Exception:
                # If daemon fails, fall back to plain fzf; preview_client will self-fallback
                echo("Preview daemon unavailable; falling back to direct preview.", err=True)
                env_for_fzf = None
                pass_fds = None
                daemon = None

        # Run fzf
        try:
            run_kwargs: Dict[str, Any] = {
                "input": ("\n".join(lines) + ("\n" if lines else "")),
                "text": True,
                "capture_output": True,
                "check": False,
            }
            if env_for_fzf is not None:
                run_kwargs["env"] = env_for_fzf
            if pass_fds is not None:
                run_kwargs["pass_fds"] = pass_fds
            proc = subprocess.run(cmd, **run_kwargs)
        except FileNotFoundError:
            # fzf is not installed or not found in PATH
            echo(f"fzf not found: {fzf_bin}. Please install fzf or set 'fzf-binary' in config.yaml.", err=True)
            return []
        finally:
            # Clean up: close writer/reader ends in parent; signal daemon via EOF
            if use_daemon:
                try:
                    if req_w is not None:
                        os.close(req_w)
                except Exception:
                    pass
                try:
                    if resp_r is not None:
                        os.close(resp_r)
                except Exception:
                    pass
                # Let daemon exit on EOF; wait briefly then terminate if needed
                if daemon is not None:
                    try:
                        daemon.wait(timeout=0.2)
                    except Exception:
                        try:
                            daemon.terminate()
                        except Exception:
                            pass

        if proc.returncode != 0:
            # User cancel is typically non-zero with empty stderr; real errors include stderr
            err = (proc.stderr or "").strip()
            if err:
                echo("fzf failed. Check your 'fzf-extra-bindings' and 'fzf-extra-flags' in ~/.config/ref/config.yaml.\n" + err, err=True)
            return []

        out = (proc.stdout or "").splitlines()
        selected: List[T] = []
        for line in out:
            # Map via key field first; fallback to exact header match if needed
            it: T | None = None
            try:
                parts = line.split(delimiter)
                if len(parts) >= 5:
                    key_field = parts[4].strip()
                    it = key_to_item.get(key_field)
            except Exception:
                it = None
            if it is None:
                # Fallback: header equality (may be ambiguous if duplicates exist)
                for src, header in zip(items, lines):
                    if header == line:
                        it = src
                        break
            if it is not None:
                selected.append(it)

        return selected



def fzf_multiselect_lines(
    lines: List[str],
    *,
    prompt: str = "select",
    header: str = "",
    marker: str = "★",
    preselect_all: bool = True,
    print_query: bool = False,
    with_help: bool = True,
    context: str = "",
) -> tuple[Optional[List[str]], Optional[str]]:
    """Run a generic multi-select fzf session over pre-rendered lines.

    - lines: display lines; you may prefix preselected entries with "<marker><space>" and
      others with two spaces to visually align (e.g., "★ foo" vs "  foo").
    - Returns (selected_lines, query) where selected_lines have any leading
      marker and indentation stripped. If user cancels, returns (None, None).
    - If print_query is True, returns the fzf query string as the second tuple element.
    """
    cfg = ref_config.load()
    fzf_bin = cfg.fzf_binary

    cmd: List[str] = [fzf_bin, "--multi", "--sync", "--cycle", "--marker", marker, "--prompt", f"{prompt}> ", "--info=inline"]
    # Compose header: use provided header or a concise default; append Ctrl-h hint if requested
    final_header = header.strip()
    if not final_header:
        final_header = _normal_header_hint(with_help=with_help)
    elif with_help and ("Ctrl-h" not in final_header and "ctrl-h" not in final_header.lower()):
        final_header = f"{final_header} | Ctrl-h for help"
    if final_header:
        cmd += ["--header", final_header]
    # Add default Ctrl-h help overlay binding if not already provided
    if with_help:
        # For aux pickers (tags/collections/label/relate/note), always use static help
        help_lines = _help_overlay_lines_for(context)
        help_text = _escape_for_fzf_action_arg("\n".join(help_lines))
        cmd += ["--bind", f"ctrl-h:change-header({help_text})"]
        # Add Ctrl-g to restore original header and hide help hint
        base_header = header.strip()
        if not base_header:
            base_header = _normal_header_hint(with_help=False)
        restore_text = _escape_for_fzf_action_arg(base_header)
        cmd += ["--bind", f"ctrl-g:change-header({restore_text})"]
    if preselect_all:
        cmd += ["--query", f"^{marker} ", "--bind", "load:select-all+clear-query"]
    if print_query:
        cmd.append("--print-query")

    # Ensure fzf gets at least one newline so it opens even with no items
    input_text = "\n".join(lines) + "\n"
    try:
        proc = subprocess.run(cmd, input=input_text, text=True, capture_output=True, check=False)
    except FileNotFoundError:
        # Let caller decide how to report/exit
        raise

    if proc.returncode != 0:
        return None, None

    out_lines = (proc.stdout or "").splitlines()
    query: Optional[str] = None
    payload: List[str] = out_lines
    if print_query:
        query = (out_lines[0] if out_lines else "")
        payload = out_lines[1:]

    cleaned: List[str] = []
    prefix1 = f"{marker} "
    for ln in payload:
        s = ln.rstrip("\n")
        if s.startswith(prefix1):
            s = s[len(prefix1):]
        elif s.startswith("  "):
            s = s[2:]
        cleaned.append(s)

    return cleaned, query
