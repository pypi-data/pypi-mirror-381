"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from attio.types import BaseModel, Nullable, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Union
from typing_extensions import Annotated, TypeAliasType, TypedDict


PostV2WebhooksEventTypeRequest = Literal[
    "call-recording.created",
    "comment.created",
    "comment.resolved",
    "comment.unresolved",
    "comment.deleted",
    "list.created",
    "list.updated",
    "list.deleted",
    "list-attribute.created",
    "list-attribute.updated",
    "list-entry.created",
    "list-entry.updated",
    "list-entry.deleted",
    "object-attribute.created",
    "object-attribute.updated",
    "note.created",
    "note-content.updated",
    "note.updated",
    "note.deleted",
    "record.created",
    "record.merged",
    "record.updated",
    "record.deleted",
    "task.created",
    "task.updated",
    "task.deleted",
    "workspace-member.created",
]
r"""Type of event the webhook is subscribed to."""


PostV2WebhooksDollarAndOperatorNotEqualsRequest = Literal["not_equals",]


class PostV2WebhooksDollarAndNotEqualsRequestTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarAndOperatorNotEqualsRequest
    value: str


class PostV2WebhooksDollarAndNotEqualsRequest(BaseModel):
    field: str

    operator: PostV2WebhooksDollarAndOperatorNotEqualsRequest

    value: str


PostV2WebhooksDollarAndOperatorEqualsRequest = Literal["equals",]


class PostV2WebhooksDollarAndEqualsRequestTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarAndOperatorEqualsRequest
    value: str


class PostV2WebhooksDollarAndEqualsRequest(BaseModel):
    field: str

    operator: PostV2WebhooksDollarAndOperatorEqualsRequest

    value: str


PostV2WebhooksDollarAndRequestUnionTypedDict = TypeAliasType(
    "PostV2WebhooksDollarAndRequestUnionTypedDict",
    Union[
        PostV2WebhooksDollarAndEqualsRequestTypedDict,
        PostV2WebhooksDollarAndNotEqualsRequestTypedDict,
    ],
)


PostV2WebhooksDollarAndRequestUnion = TypeAliasType(
    "PostV2WebhooksDollarAndRequestUnion",
    Union[
        PostV2WebhooksDollarAndEqualsRequest, PostV2WebhooksDollarAndNotEqualsRequest
    ],
)


class PostV2WebhooksFilterRequest2TypedDict(TypedDict):
    dollar_and: List[PostV2WebhooksDollarAndRequestUnionTypedDict]


class PostV2WebhooksFilterRequest2(BaseModel):
    dollar_and: Annotated[
        List[PostV2WebhooksDollarAndRequestUnion], pydantic.Field(alias="$and")
    ]


PostV2WebhooksDollarOrOperatorNotEqualsRequest = Literal["not_equals",]


class PostV2WebhooksDollarOrNotEqualsRequestTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarOrOperatorNotEqualsRequest
    value: str


class PostV2WebhooksDollarOrNotEqualsRequest(BaseModel):
    field: str

    operator: PostV2WebhooksDollarOrOperatorNotEqualsRequest

    value: str


PostV2WebhooksDollarOrOperatorEqualsRequest = Literal["equals",]


class PostV2WebhooksDollarOrEqualsRequestTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarOrOperatorEqualsRequest
    value: str


class PostV2WebhooksDollarOrEqualsRequest(BaseModel):
    field: str

    operator: PostV2WebhooksDollarOrOperatorEqualsRequest

    value: str


PostV2WebhooksDollarOrRequestUnionTypedDict = TypeAliasType(
    "PostV2WebhooksDollarOrRequestUnionTypedDict",
    Union[
        PostV2WebhooksDollarOrEqualsRequestTypedDict,
        PostV2WebhooksDollarOrNotEqualsRequestTypedDict,
    ],
)


PostV2WebhooksDollarOrRequestUnion = TypeAliasType(
    "PostV2WebhooksDollarOrRequestUnion",
    Union[PostV2WebhooksDollarOrEqualsRequest, PostV2WebhooksDollarOrNotEqualsRequest],
)


class PostV2WebhooksFilterRequest1TypedDict(TypedDict):
    dollar_or: List[PostV2WebhooksDollarOrRequestUnionTypedDict]


class PostV2WebhooksFilterRequest1(BaseModel):
    dollar_or: Annotated[
        List[PostV2WebhooksDollarOrRequestUnion], pydantic.Field(alias="$or")
    ]


PostV2WebhooksFilterRequestUnionTypedDict = TypeAliasType(
    "PostV2WebhooksFilterRequestUnionTypedDict",
    Union[PostV2WebhooksFilterRequest1TypedDict, PostV2WebhooksFilterRequest2TypedDict],
)
r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""


PostV2WebhooksFilterRequestUnion = TypeAliasType(
    "PostV2WebhooksFilterRequestUnion",
    Union[PostV2WebhooksFilterRequest1, PostV2WebhooksFilterRequest2],
)
r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""


class PostV2WebhooksSubscriptionRequestTypedDict(TypedDict):
    event_type: PostV2WebhooksEventTypeRequest
    r"""Type of event the webhook is subscribed to."""
    filter_: Nullable[PostV2WebhooksFilterRequestUnionTypedDict]
    r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""


class PostV2WebhooksSubscriptionRequest(BaseModel):
    event_type: PostV2WebhooksEventTypeRequest
    r"""Type of event the webhook is subscribed to."""

    filter_: Annotated[
        Nullable[PostV2WebhooksFilterRequestUnion], pydantic.Field(alias="filter")
    ]
    r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["filter"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PostV2WebhooksDataRequestTypedDict(TypedDict):
    target_url: str
    r"""URL where the webhook events will be delivered to."""
    subscriptions: List[PostV2WebhooksSubscriptionRequestTypedDict]
    r"""One or more events the webhook is subscribed to."""


class PostV2WebhooksDataRequest(BaseModel):
    target_url: str
    r"""URL where the webhook events will be delivered to."""

    subscriptions: List[PostV2WebhooksSubscriptionRequest]
    r"""One or more events the webhook is subscribed to."""


class PostV2WebhooksRequestTypedDict(TypedDict):
    data: PostV2WebhooksDataRequestTypedDict


class PostV2WebhooksRequest(BaseModel):
    data: PostV2WebhooksDataRequest


PostV2WebhooksType = Literal["invalid_request_error",]


PostV2WebhooksCode = Literal["validation_type",]


PostV2WebhooksEventTypeResponse = Literal[
    "call-recording.created",
    "comment.created",
    "comment.resolved",
    "comment.unresolved",
    "comment.deleted",
    "list.created",
    "list.updated",
    "list.deleted",
    "list-attribute.created",
    "list-attribute.updated",
    "list-entry.created",
    "list-entry.updated",
    "list-entry.deleted",
    "object-attribute.created",
    "object-attribute.updated",
    "note.created",
    "note-content.updated",
    "note.updated",
    "note.deleted",
    "record.created",
    "record.merged",
    "record.updated",
    "record.deleted",
    "task.created",
    "task.updated",
    "task.deleted",
    "workspace-member.created",
]
r"""Type of event the webhook is subscribed to."""


PostV2WebhooksDollarAndOperatorNotEqualsResponse = Literal["not_equals",]


class PostV2WebhooksDollarAndNotEqualsResponseTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarAndOperatorNotEqualsResponse
    value: str


class PostV2WebhooksDollarAndNotEqualsResponse(BaseModel):
    field: str

    operator: PostV2WebhooksDollarAndOperatorNotEqualsResponse

    value: str


PostV2WebhooksDollarAndOperatorEqualsResponse = Literal["equals",]


class PostV2WebhooksDollarAndEqualsResponseTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarAndOperatorEqualsResponse
    value: str


class PostV2WebhooksDollarAndEqualsResponse(BaseModel):
    field: str

    operator: PostV2WebhooksDollarAndOperatorEqualsResponse

    value: str


PostV2WebhooksDollarAndResponseUnionTypedDict = TypeAliasType(
    "PostV2WebhooksDollarAndResponseUnionTypedDict",
    Union[
        PostV2WebhooksDollarAndEqualsResponseTypedDict,
        PostV2WebhooksDollarAndNotEqualsResponseTypedDict,
    ],
)


PostV2WebhooksDollarAndResponseUnion = TypeAliasType(
    "PostV2WebhooksDollarAndResponseUnion",
    Union[
        PostV2WebhooksDollarAndEqualsResponse, PostV2WebhooksDollarAndNotEqualsResponse
    ],
)


class PostV2WebhooksFilterResponse2TypedDict(TypedDict):
    dollar_and: List[PostV2WebhooksDollarAndResponseUnionTypedDict]


class PostV2WebhooksFilterResponse2(BaseModel):
    dollar_and: Annotated[
        List[PostV2WebhooksDollarAndResponseUnion], pydantic.Field(alias="$and")
    ]


PostV2WebhooksDollarOrOperatorNotEqualsResponse = Literal["not_equals",]


class PostV2WebhooksDollarOrNotEqualsResponseTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarOrOperatorNotEqualsResponse
    value: str


class PostV2WebhooksDollarOrNotEqualsResponse(BaseModel):
    field: str

    operator: PostV2WebhooksDollarOrOperatorNotEqualsResponse

    value: str


PostV2WebhooksDollarOrOperatorEqualsResponse = Literal["equals",]


class PostV2WebhooksDollarOrEqualsResponseTypedDict(TypedDict):
    field: str
    operator: PostV2WebhooksDollarOrOperatorEqualsResponse
    value: str


class PostV2WebhooksDollarOrEqualsResponse(BaseModel):
    field: str

    operator: PostV2WebhooksDollarOrOperatorEqualsResponse

    value: str


PostV2WebhooksDollarOrResponseUnionTypedDict = TypeAliasType(
    "PostV2WebhooksDollarOrResponseUnionTypedDict",
    Union[
        PostV2WebhooksDollarOrEqualsResponseTypedDict,
        PostV2WebhooksDollarOrNotEqualsResponseTypedDict,
    ],
)


PostV2WebhooksDollarOrResponseUnion = TypeAliasType(
    "PostV2WebhooksDollarOrResponseUnion",
    Union[
        PostV2WebhooksDollarOrEqualsResponse, PostV2WebhooksDollarOrNotEqualsResponse
    ],
)


class PostV2WebhooksFilterResponse1TypedDict(TypedDict):
    dollar_or: List[PostV2WebhooksDollarOrResponseUnionTypedDict]


class PostV2WebhooksFilterResponse1(BaseModel):
    dollar_or: Annotated[
        List[PostV2WebhooksDollarOrResponseUnion], pydantic.Field(alias="$or")
    ]


PostV2WebhooksFilterResponseUnionTypedDict = TypeAliasType(
    "PostV2WebhooksFilterResponseUnionTypedDict",
    Union[
        PostV2WebhooksFilterResponse1TypedDict, PostV2WebhooksFilterResponse2TypedDict
    ],
)
r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""


PostV2WebhooksFilterResponseUnion = TypeAliasType(
    "PostV2WebhooksFilterResponseUnion",
    Union[PostV2WebhooksFilterResponse1, PostV2WebhooksFilterResponse2],
)
r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""


class PostV2WebhooksSubscriptionResponseTypedDict(TypedDict):
    event_type: PostV2WebhooksEventTypeResponse
    r"""Type of event the webhook is subscribed to."""
    filter_: Nullable[PostV2WebhooksFilterResponseUnionTypedDict]
    r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""


class PostV2WebhooksSubscriptionResponse(BaseModel):
    event_type: PostV2WebhooksEventTypeResponse
    r"""Type of event the webhook is subscribed to."""

    filter_: Annotated[
        Nullable[PostV2WebhooksFilterResponseUnion], pydantic.Field(alias="filter")
    ]
    r"""Filters to determine whether the webhook event should be sent. If null, the filter always passes."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["filter"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PostV2WebhooksIDTypedDict(TypedDict):
    workspace_id: str
    r"""The ID of the workspace the webhook belongs to."""
    webhook_id: str
    r"""The ID of the webhook."""


class PostV2WebhooksID(BaseModel):
    workspace_id: str
    r"""The ID of the workspace the webhook belongs to."""

    webhook_id: str
    r"""The ID of the webhook."""


PostV2WebhooksStatus = Literal[
    "active",
    "degraded",
    "inactive",
]
r"""The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive."""


class PostV2WebhooksDataResponseTypedDict(TypedDict):
    target_url: str
    r"""URL where the webhook events will be delivered to."""
    subscriptions: List[PostV2WebhooksSubscriptionResponseTypedDict]
    r"""One or more events the webhook is subscribed to."""
    id: PostV2WebhooksIDTypedDict
    status: PostV2WebhooksStatus
    r"""The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive."""
    created_at: str
    r"""When the webhook was created."""
    secret: str
    r"""The key which is used to sign the webhook events. This is only shown when setting up the webhook initially."""


class PostV2WebhooksDataResponse(BaseModel):
    target_url: str
    r"""URL where the webhook events will be delivered to."""

    subscriptions: List[PostV2WebhooksSubscriptionResponse]
    r"""One or more events the webhook is subscribed to."""

    id: PostV2WebhooksID

    status: PostV2WebhooksStatus
    r"""The state of the webhook. Webhooks marked as active and degraded will receive events, inactive ones will not. If a webhook remains in the degraded state for 7 days, it will be marked inactive."""

    created_at: str
    r"""When the webhook was created."""

    secret: str
    r"""The key which is used to sign the webhook events. This is only shown when setting up the webhook initially."""


class PostV2WebhooksResponseTypedDict(TypedDict):
    r"""Success"""

    data: PostV2WebhooksDataResponseTypedDict


class PostV2WebhooksResponse(BaseModel):
    r"""Success"""

    data: PostV2WebhooksDataResponse
