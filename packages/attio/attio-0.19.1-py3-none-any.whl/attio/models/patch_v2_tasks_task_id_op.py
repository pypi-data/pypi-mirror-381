"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .task import Task, TaskTypedDict
from attio.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from attio.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute5TypedDict(TypedDict):
    value: NotRequired[str]
    r"""A raw text field. Values are limited to 10MB."""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute5(BaseModel):
    value: Optional[str] = None
    r"""A raw text field. Values are limited to 10MB."""


PatchV2TasksTaskIDCountryCode = Literal[
    "AF",
    "AX",
    "AL",
    "DZ",
    "AS",
    "AD",
    "AO",
    "AI",
    "AQ",
    "AG",
    "AR",
    "AM",
    "AW",
    "AU",
    "AT",
    "AZ",
    "BS",
    "BH",
    "BD",
    "BB",
    "BY",
    "BE",
    "BZ",
    "BJ",
    "BM",
    "BT",
    "BO",
    "BA",
    "BW",
    "BV",
    "BR",
    "IO",
    "BN",
    "BG",
    "BF",
    "BI",
    "KH",
    "CM",
    "CA",
    "CV",
    "KY",
    "CF",
    "TD",
    "CL",
    "CN",
    "CX",
    "CC",
    "CO",
    "KM",
    "CG",
    "CD",
    "CK",
    "CR",
    "CI",
    "HR",
    "CU",
    "CW",
    "CY",
    "CZ",
    "DK",
    "DJ",
    "DM",
    "DO",
    "EC",
    "EG",
    "SV",
    "GQ",
    "ER",
    "EE",
    "ET",
    "FK",
    "FO",
    "FJ",
    "FI",
    "FR",
    "GF",
    "PF",
    "TF",
    "GA",
    "GM",
    "GE",
    "DE",
    "GH",
    "GI",
    "GR",
    "GL",
    "GD",
    "GP",
    "GU",
    "GT",
    "GG",
    "GN",
    "GW",
    "GY",
    "HT",
    "HM",
    "VA",
    "HN",
    "HK",
    "HU",
    "IS",
    "IN",
    "ID",
    "IR",
    "IQ",
    "IE",
    "IM",
    "IL",
    "IT",
    "JM",
    "JP",
    "JE",
    "JO",
    "KZ",
    "KE",
    "KI",
    "KR",
    "KW",
    "KG",
    "LA",
    "LV",
    "LB",
    "LS",
    "LR",
    "LY",
    "LI",
    "LT",
    "LU",
    "MO",
    "MK",
    "MG",
    "MW",
    "MY",
    "MV",
    "ML",
    "MT",
    "MH",
    "MQ",
    "MR",
    "MU",
    "YT",
    "MX",
    "FM",
    "MD",
    "MC",
    "MN",
    "ME",
    "MS",
    "MA",
    "MZ",
    "MM",
    "NA",
    "NR",
    "NP",
    "NL",
    "AN",
    "NC",
    "NZ",
    "NI",
    "NE",
    "NG",
    "NU",
    "NF",
    "MP",
    "NO",
    "OM",
    "PK",
    "PW",
    "PS",
    "PA",
    "PG",
    "PY",
    "PE",
    "PH",
    "PN",
    "PL",
    "PT",
    "PR",
    "QA",
    "RE",
    "RO",
    "RU",
    "RW",
    "BL",
    "SH",
    "KN",
    "LC",
    "MF",
    "PM",
    "VC",
    "WS",
    "SM",
    "ST",
    "SA",
    "SN",
    "SS",
    "RS",
    "SC",
    "SL",
    "SG",
    "SK",
    "SI",
    "SB",
    "SO",
    "ZA",
    "GS",
    "ES",
    "LK",
    "SD",
    "SR",
    "SJ",
    "SZ",
    "SE",
    "CH",
    "SY",
    "TW",
    "TJ",
    "TZ",
    "TH",
    "TL",
    "TG",
    "TK",
    "TO",
    "TT",
    "TN",
    "TR",
    "TM",
    "TC",
    "TV",
    "UG",
    "UA",
    "AE",
    "GB",
    "US",
    "UM",
    "UY",
    "UZ",
    "VU",
    "VE",
    "VN",
    "VG",
    "VI",
    "WF",
    "EH",
    "YE",
    "ZM",
    "ZW",
    "BQ",
    "KP",
    "SX",
    "XK",
    "AC",
]
r"""The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to."""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute4TypedDict(TypedDict):
    original_phone_number: NotRequired[str]
    r"""The raw, original phone number, as inputted."""
    country_code: NotRequired[Nullable[PatchV2TasksTaskIDCountryCode]]
    r"""The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to."""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute4(BaseModel):
    original_phone_number: Optional[str] = None
    r"""The raw, original phone number, as inputted."""

    country_code: OptionalNullable[PatchV2TasksTaskIDCountryCode] = UNSET
    r"""The ISO 3166-1 alpha-2 country code representing the country that this phone number belongs to."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["original_phone_number", "country_code"]
        nullable_fields = ["country_code"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute3TypedDict(TypedDict):
    value: NotRequired[float]
    r"""Numbers are persisted as 64 bit floats."""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute3(BaseModel):
    value: Optional[float] = None
    r"""Numbers are persisted as 64 bit floats."""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute2TypedDict(TypedDict):
    email_address: NotRequired[str]
    r"""An email address string"""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute2(BaseModel):
    email_address: Optional[str] = None
    r"""An email address string"""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute1TypedDict(TypedDict):
    domain: NotRequired[str]
    r"""The full domain of the website."""


class PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute1(BaseModel):
    domain: Optional[str] = None
    r"""The full domain of the website."""


PatchV2TasksTaskIDSlugOrIDOfMatchingAttributeUnionTypedDict = TypeAliasType(
    "PatchV2TasksTaskIDSlugOrIDOfMatchingAttributeUnionTypedDict",
    Union[
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute1TypedDict,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute2TypedDict,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute3TypedDict,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute5TypedDict,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute4TypedDict,
    ],
)


PatchV2TasksTaskIDSlugOrIDOfMatchingAttributeUnion = TypeAliasType(
    "PatchV2TasksTaskIDSlugOrIDOfMatchingAttributeUnion",
    Union[
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute1,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute2,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute3,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute5,
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttribute4,
    ],
)


class PatchV2TasksTaskIDLinkedRecord2TypedDict(TypedDict):
    target_object: str
    r"""A UUID or slug to identify the object that the referenced record belongs to."""
    slug_or_id_of_matching_attribute: List[
        PatchV2TasksTaskIDSlugOrIDOfMatchingAttributeUnionTypedDict
    ]
    r"""In addition to referencing records directly by record ID, you may also reference by a matching attribute of your choice. For example, if you want to add a reference to the person record with email \"alice@website.com\", you should pass a value with `target_object` set to `\"people\"` and `email_addresses` set to `[{email_address:\"alice@website.com\"}]`. The key should be the slug or ID of the matching attribute you would like to use and the value should be an array containing a single value of the appropriate attribute type (as specified below). Matching on multiple values is not currently supported. Matching attributes must be unique. This process is similar to how you use the `matching_attribute` query param in Attio's [assert endpoints](/rest-api/endpoint-reference/records/assert-a-record)."""


class PatchV2TasksTaskIDLinkedRecord2(BaseModel):
    target_object: str
    r"""A UUID or slug to identify the object that the referenced record belongs to."""

    slug_or_id_of_matching_attribute: Annotated[
        List[PatchV2TasksTaskIDSlugOrIDOfMatchingAttributeUnion],
        pydantic.Field(alias="[slug_or_id_of_matching_attribute]"),
    ]
    r"""In addition to referencing records directly by record ID, you may also reference by a matching attribute of your choice. For example, if you want to add a reference to the person record with email \"alice@website.com\", you should pass a value with `target_object` set to `\"people\"` and `email_addresses` set to `[{email_address:\"alice@website.com\"}]`. The key should be the slug or ID of the matching attribute you would like to use and the value should be an array containing a single value of the appropriate attribute type (as specified below). Matching on multiple values is not currently supported. Matching attributes must be unique. This process is similar to how you use the `matching_attribute` query param in Attio's [assert endpoints](/rest-api/endpoint-reference/records/assert-a-record)."""


class PatchV2TasksTaskIDLinkedRecord1TypedDict(TypedDict):
    target_object: str
    r"""The ID or slug of the parent object the tasks refers to. This can reference both standard and custom objects.`"""
    target_record_id: str
    r"""The ID of the parent record the task refers to."""


class PatchV2TasksTaskIDLinkedRecord1(BaseModel):
    target_object: str
    r"""The ID or slug of the parent object the tasks refers to. This can reference both standard and custom objects.`"""

    target_record_id: str
    r"""The ID of the parent record the task refers to."""


PatchV2TasksTaskIDLinkedRecordUnionTypedDict = TypeAliasType(
    "PatchV2TasksTaskIDLinkedRecordUnionTypedDict",
    Union[
        PatchV2TasksTaskIDLinkedRecord1TypedDict,
        PatchV2TasksTaskIDLinkedRecord2TypedDict,
    ],
)


PatchV2TasksTaskIDLinkedRecordUnion = TypeAliasType(
    "PatchV2TasksTaskIDLinkedRecordUnion",
    Union[PatchV2TasksTaskIDLinkedRecord1, PatchV2TasksTaskIDLinkedRecord2],
)


class PatchV2TasksTaskIDAssigneeTypedDict(TypedDict):
    workspace_member_email_address: str
    r"""Workspace member actors can be referenced by email address as well as actor ID."""


class PatchV2TasksTaskIDAssignee(BaseModel):
    workspace_member_email_address: str
    r"""Workspace member actors can be referenced by email address as well as actor ID."""


PatchV2TasksTaskIDReferencedActorType = Literal["workspace-member",]
r"""The actor type of the task assignee. Only `workspace-member` actors can be assigned to tasks. [Read more information on actor types here](/docs/actors)."""


class PatchV2TasksTaskIDAssigneeWorkspaceMemberTypedDict(TypedDict):
    referenced_actor_type: PatchV2TasksTaskIDReferencedActorType
    r"""The actor type of the task assignee. Only `workspace-member` actors can be assigned to tasks. [Read more information on actor types here](/docs/actors)."""
    referenced_actor_id: str
    r"""The ID of the actor assigned to this task."""


class PatchV2TasksTaskIDAssigneeWorkspaceMember(BaseModel):
    referenced_actor_type: PatchV2TasksTaskIDReferencedActorType
    r"""The actor type of the task assignee. Only `workspace-member` actors can be assigned to tasks. [Read more information on actor types here](/docs/actors)."""

    referenced_actor_id: str
    r"""The ID of the actor assigned to this task."""


PatchV2TasksTaskIDAssigneeUnionTypedDict = TypeAliasType(
    "PatchV2TasksTaskIDAssigneeUnionTypedDict",
    Union[
        PatchV2TasksTaskIDAssigneeTypedDict,
        PatchV2TasksTaskIDAssigneeWorkspaceMemberTypedDict,
    ],
)


PatchV2TasksTaskIDAssigneeUnion = TypeAliasType(
    "PatchV2TasksTaskIDAssigneeUnion",
    Union[PatchV2TasksTaskIDAssignee, PatchV2TasksTaskIDAssigneeWorkspaceMember],
)


class PatchV2TasksTaskIDDataTypedDict(TypedDict):
    deadline_at: NotRequired[Nullable[str]]
    r"""The deadline of the task, in ISO 8601 format."""
    is_completed: NotRequired[bool]
    r"""Whether the task has been completed."""
    linked_records: NotRequired[List[PatchV2TasksTaskIDLinkedRecordUnionTypedDict]]
    r"""Records linked to the task. Creating record links within task content text is not possible via the API at present."""
    assignees: NotRequired[List[PatchV2TasksTaskIDAssigneeUnionTypedDict]]
    r"""Workspace members assigned to this task."""


class PatchV2TasksTaskIDData(BaseModel):
    deadline_at: OptionalNullable[str] = UNSET
    r"""The deadline of the task, in ISO 8601 format."""

    is_completed: Optional[bool] = None
    r"""Whether the task has been completed."""

    linked_records: Optional[List[PatchV2TasksTaskIDLinkedRecordUnion]] = None
    r"""Records linked to the task. Creating record links within task content text is not possible via the API at present."""

    assignees: Optional[List[PatchV2TasksTaskIDAssigneeUnion]] = None
    r"""Workspace members assigned to this task."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["deadline_at", "is_completed", "linked_records", "assignees"]
        nullable_fields = ["deadline_at"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PatchV2TasksTaskIDRequestBodyTypedDict(TypedDict):
    data: PatchV2TasksTaskIDDataTypedDict


class PatchV2TasksTaskIDRequestBody(BaseModel):
    data: PatchV2TasksTaskIDData


class PatchV2TasksTaskIDRequestTypedDict(TypedDict):
    task_id: str
    request_body: PatchV2TasksTaskIDRequestBodyTypedDict


class PatchV2TasksTaskIDRequest(BaseModel):
    task_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]

    request_body: Annotated[
        PatchV2TasksTaskIDRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]


PatchV2TasksTaskIDNotFoundType = Literal["invalid_request_error",]


PatchV2TasksTaskIDNotFoundCode = Literal["not_found",]


PatchV2TasksTaskIDBadRequestType = Literal["invalid_request_error",]


PatchV2TasksTaskIDCodeValidationType = Literal["validation_type",]


class PatchV2TasksTaskIDResponseTypedDict(TypedDict):
    r"""Success"""

    data: TaskTypedDict


class PatchV2TasksTaskIDResponse(BaseModel):
    r"""Success"""

    data: Task
