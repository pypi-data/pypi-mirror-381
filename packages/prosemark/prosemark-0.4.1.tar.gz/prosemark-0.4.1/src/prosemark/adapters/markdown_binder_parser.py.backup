"""Markdown binder parser for converting between binder structures and markdown text."""

import re

from prosemark.domain.models import Binder, BinderItem, NodeId
from prosemark.exceptions import BinderFormatError


class MarkdownBinderParser:
    """Parser for converting between Binder objects and markdown list format.

    This adapter handles bidirectional conversion between:
    - Binder domain objects with tree structure
    - Markdown unordered list representation with links

    Supported markdown format:
    ```
    - [Title](file.md)
      - [Nested Item](nested.md)
    - [Another Root](another.md)
    ```

    The parser maintains:
    - Hierarchical structure through indentation
    - NodeId extraction from filenames (assumes {id}.md pattern)
    - Placeholder support for items without links
    - Proper tree parent-child relationships
    """

    # Pattern to match markdown list items with optional links
    # Updated to handle brackets in titles and empty links
    LIST_ITEM_PATTERN = re.compile(r'^(\s*)- \[(.*?)\](?:\(([^)]*)\))?(?:\s*)$', re.MULTILINE)

    # Pattern to extract NodeId from markdown links (assuming {id}.md format, possibly with path)
    NODE_ID_PATTERN = re.compile(r'([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:\.md)?$')

    def parse_to_binder(self, markdown_content: str) -> Binder:
        """Parse markdown content into a Binder object.

        Args:
            markdown_content: Markdown text with unordered list structure

        Returns:
            Binder object with parsed hierarchy

        Raises:
            BinderFormatError: If markdown format is invalid or malformed

        """
        try:
            # Check for malformed markdown patterns before parsing
            lines = markdown_content.strip().split('\n')
            for line in lines:
                line = line.strip()
                if line:  # Skip empty lines
                    # Check for malformed bracket patterns
                    if '- [' in line and line.count('[') != line.count(']'):
                        raise BinderFormatError('Malformed markdown: unmatched brackets')
                    if '- [' in line and '[' in line and not line.endswith(']') and ')' not in line:
                        raise BinderFormatError('Malformed markdown: unclosed bracket')

            # Find all list items with their indentation
            matches = self.LIST_ITEM_PATTERN.findall(markdown_content)
            if not matches:
                # Check if there's any content that looks like it should be a list item but isn't matching
                lines = markdown_content.strip().split('\n')
                for line in lines:
                    line = line.strip()
                    if line and ('- ' in line or '* ' in line or line.startswith('  - ')):
                        raise BinderFormatError('Malformed markdown: invalid list item format')
                # If there's any non-empty content but no valid list items, it might be malformed
                if any(line.strip() for line in lines):
                    raise BinderFormatError('Malformed markdown: content found but no valid list items')
                return Binder(roots=[])

            # Build tree structure
            root_items = []
            item_stack: list[tuple[int, BinderItem]] = []  # (indent_level, item)

            for indent_str, title, link in matches:
                indent_level = len(indent_str)

                # Extract NodeId from link if present
                node_id = self._extract_node_id(link) if link else None

                # Create binder item
                item = BinderItem(display_title=title.strip(), node_id=node_id, children=[])

                # Find parent based on indentation
                parent = self._find_parent(item_stack, indent_level)

                if parent is None:
                    # Root level item
                    root_items.append(item)
                else:
                    # Child item
                    parent.children.append(item)

                # Update stack - remove items at same or deeper levels, then add current
                item_stack = [(level, stack_item) for level, stack_item in item_stack if level < indent_level]
                item_stack.append((indent_level, item))

            return Binder(roots=root_items)

        except Exception as exc:
            raise BinderFormatError('Failed to parse markdown binder content') from exc

    def render_from_binder(self, binder: Binder) -> str:
        """Render Binder object as markdown list content.

        Args:
            binder: Binder object to render

        Returns:
            Markdown text with unordered list structure

        """
        lines: list[str] = []

        for root_item in binder.roots:
            self._render_item(root_item, 0, lines)

        return '\n'.join(lines)

    def _extract_node_id(self, link: str) -> NodeId | None:
        """Extract NodeId from markdown link.

        Args:
            link: Markdown link text (e.g., "0192f0c1-2345-7123-8abc-def012345678.md")

        Returns:
            NodeId if valid UUID found, None otherwise

        """
        if not link:
            return None

        match = self.NODE_ID_PATTERN.search(link.strip())
        if not match:
            return None

        try:
            return NodeId(match.group(1))
        except (ValueError, TypeError):  # pragma: no cover
            # Invalid NodeId format
            return None

    def _find_parent(self, item_stack: list[tuple[int, BinderItem]], target_level: int) -> BinderItem | None:
        """Find the appropriate parent for an item at target indentation level.

        Args:
            item_stack: Stack of (indent_level, item) tuples
            target_level: Target indentation level for new item

        Returns:
            Parent BinderItem or None if root level

        """
        if target_level == 0:
            return None

        # Find the most recent item at a shallower level
        for level, item in reversed(item_stack):
            if level < target_level:
                return item

        return None

    def _render_item(self, item: BinderItem, indent_level: int, lines: list[str]) -> None:
        """Recursively render a BinderItem and its children.

        Args:
            item: BinderItem to render
            indent_level: Current indentation level
            lines: List to append rendered lines to

        """
        indent = '  ' * indent_level

        if item.id is None:
            # Placeholder item without link
            line = f'{indent}- [{item.display_title}]()'
        else:
            # Item with NodeId link
            line = f'{indent}- [{item.display_title}]({item.id}.md)'

        lines.append(line)

        # Render children at deeper indentation
        for child in item.children:
            self._render_item(child, indent_level + 1, lines)
