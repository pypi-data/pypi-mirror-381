#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RAT Engine Web åº”ç”¨ Python å®ç°

å°†æ‰€æœ‰ Web åº”ç”¨åŠŸèƒ½ï¼ˆè£…é¥°å™¨ã€è·¯ç”±ã€CLI ç­‰ï¼‰å®Œå…¨ç§»åˆ° Python å±‚ï¼Œ
Rust å±‚ä¸“æ³¨äºé«˜æ€§èƒ½é€šä¿¡å’Œåº•å±‚ä¼˜åŒ–ã€‚

ç‰¹æ€§ï¼š
- å®Œæ•´çš„ Web åº”ç”¨è£…é¥°å™¨ (@app.html, @app.json, @app.sse, @app.chunk, @app.file, @app.custom ç­‰)
- è·¯å¾„å‚æ•°æ”¯æŒ (/user/<id>, /user/<int:id> ç­‰)
- è¯·æ±‚ä¸Šä¸‹æ–‡ç®¡ç†
- ä¸­é—´ä»¶æ”¯æŒ
- é”™è¯¯å¤„ç†
- CLI å·¥å…·
- æ€§èƒ½ç›‘æ§
"""

import re
import json
import inspect
import functools
from typing import Dict, List, Callable, Any, Optional, Union, Tuple
from urllib.parse import unquote
import threading
import signal
from contextlib import contextmanager
from enum import Enum
from .grpc_decorators import add_grpc_decorators_to_app
from .cache_config import build_cache_config

class ResponseType(Enum):
    """å“åº”ç±»å‹æšä¸¾"""
    HTML = "html"
    JSON = "json"
    TEXT = "text"
    SSE = "sse"
    FILE = "file"
    CUSTOM = "custom"
    CUSTOM_BYTES = "custom_bytes"
    SSE_JSON = "sse_json"
    SSE_TEXT = "sse_text"
    CHUNK = "chunk"
    REDIRECT = "redirect"

class TypedResponse:
    """å¸¦ç±»å‹æ ‡è¯†çš„å“åº”å¯¹è±¡"""
    def __init__(self, content: Any, response_type: ResponseType, **kwargs):
        self.content = content
        self.response_type = response_type
        self.kwargs = kwargs

from ._rat_engine import Router as PyRouter, Server as PyServer, ServerConfig
from ._rat_engine import CompressionConfig, CompressionType
from ._rat_engine import PyGrpcMainThread

# ç›´æ¥ä» _rat_engine å¯¼å…¥ HTTP ç±»ï¼Œä¸ä½¿ç”¨å›é€€å®ç°
from ._rat_engine import HttpRequest, HttpResponse, HttpMethod
# æˆåŠŸä» Rust å¯¼å…¥ HttpRequest, HttpResponse å’Œ HttpMethod


# å…¨å±€è¯·æ±‚ä¸Šä¸‹æ–‡
_request_context = threading.local()


class RequestContext:
    """è¯·æ±‚ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    
    def __init__(self, request: HttpRequest):
        self.request = request
        self.path_params = {}
    
    def __enter__(self):
        _request_context.current = self
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if hasattr(_request_context, 'current'):
            delattr(_request_context, 'current')


def get_current_request() -> Optional[HttpRequest]:
    """è·å–å½“å‰è¯·æ±‚å¯¹è±¡"""
    context = getattr(_request_context, 'current', None)
    return context.request if context else None


def get_path_params() -> Dict[str, Any]:
    """è·å–å½“å‰è¯·æ±‚çš„è·¯å¾„å‚æ•°"""
    context = getattr(_request_context, 'current', None)
    return context.path_params if context else {}


class Route:
    """è·¯ç”±å®šä¹‰"""
    
    def __init__(self, pattern: str, handler: Callable, methods: List[str]):
        self.pattern = pattern
        self.handler = handler
        self.handler_name = handler.__name__ if hasattr(handler, '__name__') else str(handler)
        self.methods = [m.upper() for m in methods]
        self.regex, self.param_names = self._compile_pattern(pattern)
    
    def _compile_pattern(self, pattern: str) -> Tuple[re.Pattern, List[str]]:
        """ç¼–è¯‘è·¯å¾„æ¨¡å¼ä¸ºæ­£åˆ™è¡¨è¾¾å¼"""
        param_names = []
        
        # å¤„ç†è·¯å¾„å‚æ•° <name> å’Œ <type:name>
        def replace_param(match):
            param_def = match.group(1)
            if ':' in param_def:
                param_type, param_name = param_def.split(':', 1)
                param_names.append((param_name, param_type))
                
                # æ ¹æ®ç±»å‹ç”Ÿæˆæ­£åˆ™è¡¨è¾¾å¼
                if param_type == 'int':
                    return r'(\d+)'
                elif param_type == 'float':
                    return r'([\d.]+)'
                elif param_type == 'path':
                    return r'(.+)'
                else:
                    return r'([^/]+)'
            else:
                param_names.append((param_def, 'string'))
                return r'([^/]+)'
        
        # è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦å¹¶æ›¿æ¢å‚æ•°
        escaped = re.escape(pattern)
        escaped = escaped.replace(r'\<', '<').replace(r'\>', '>')
        regex_pattern = re.sub(r'<([^>]+)>', replace_param, escaped)
        
        # ç¡®ä¿å®Œå…¨åŒ¹é…
        regex_pattern = f'^{regex_pattern}$'
        
        return re.compile(regex_pattern), param_names
    
    def match(self, path: str, method: str) -> Optional[Dict[str, Any]]:
        """åŒ¹é…è·¯å¾„å’Œæ–¹æ³•"""
        if method.upper() not in self.methods:
            return None
        
        match = self.regex.match(path)
        if not match:
            return None
        
        # æå–è·¯å¾„å‚æ•°
        params = {}
        for i, (name, param_type) in enumerate(self.param_names):
            value = match.group(i + 1)
            
            # ç±»å‹è½¬æ¢
            if param_type == 'int':
                params[name] = int(value)
            elif param_type == 'float':
                params[name] = float(value)
            else:
                params[name] = unquote(value)
        
        return params

    def match_simple(self, path: str, method: str) -> bool:
        """ç®€å•çš„è·¯å¾„å’Œæ–¹æ³•åŒ¹é…ï¼ˆä¸éœ€è¦å‚æ•°åŒ¹é…ï¼‰"""
        if method.upper() not in self.methods:
            return False

        # ç®€å•çš„è·¯å¾„åŒ¹é…ï¼šå°†è·¯å¾„å‚æ•°æ›¿æ¢ä¸ºé€šé…ç¬¦
        pattern = self.pattern
        # å°† <type:name> æ›¿æ¢ä¸º *
        import re
        simple_pattern = re.sub(r'<[^>]+>', '*', pattern)
        # å°†å¤šä¸ªè¿ç»­çš„*åˆå¹¶ä¸ºä¸€ä¸ª
        simple_pattern = re.sub(r'\*+', '*', simple_pattern)
        # è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼
        simple_pattern = simple_pattern.replace('*', '.*')
        simple_pattern = '^' + simple_pattern + '$'

        match = re.match(simple_pattern, path)
        return match is not None


class Middleware:
    """ä¸­é—´ä»¶åŸºç±»"""
    
    def before_request(self, request: HttpRequest) -> Optional[HttpResponse]:
        """è¯·æ±‚å‰å¤„ç†ï¼Œè¿”å› Response åˆ™ä¸­æ–­åç»­å¤„ç†"""
        return None
    
    def after_request(self, request: HttpRequest, response: HttpResponse) -> HttpResponse:
        """è¯·æ±‚åå¤„ç†ï¼Œå¯ä»¥ä¿®æ”¹å“åº”"""
        return response
    
    def on_error(self, request: HttpRequest, error: Exception) -> Optional[HttpResponse]:
        """é”™è¯¯å¤„ç†ï¼Œè¿”å› Response åˆ™ä½¿ç”¨è¯¥å“åº”"""
        return None


class RatApp:
    """RAT Engine Web åº”ç”¨ç±»"""
    
    def __init__(self, name: str = "rat_app", **engine_kwargs):
        self.name = name
        self.routes: List[Route] = []
        self.middlewares: List[Middleware] = []
        self.error_handlers: Dict[int, Callable] = {}
        self.before_request_handlers: List[Callable] = []
        self.after_request_handlers: List[Callable] = []
        self._stop_event = None
        
        # æ‰©å±•ç³»ç»Ÿ
        self.extensions: Dict[str, Any] = {}  # å·²æ³¨å†Œçš„æ‰©å±•
        self._startup_handlers: List[Callable] = []  # å¯åŠ¨æ—¶å›è°ƒ
        self._shutdown_handlers: List[Callable] = []  # å…³é—­æ—¶å›è°ƒ
        
        # ğŸ”¥ ä½¿ç”¨æ–°çš„ RatEngineBuilder ä½œä¸ºåç«¯ï¼ˆæš‚æ—¶æ³¨é‡Šæ‰ï¼Œç­‰APIç¨³å®šåå†å¯ç”¨ï¼‰
        # self._engine_builder = RatEngineBuilder()
        # self._engine = None
        
        # ä» kwargs ä¸­é…ç½®å¼•æ“å‚æ•°ï¼ˆæš‚æ—¶ä¿ç•™åŸæœ‰é€»è¾‘ï¼‰
        # TODO: è¿ç§»åˆ°æ–°çš„ RatEngineBuilder
        
        # Celery é…ç½®ç©ºé—´
        self.celery_config: Dict[str, Any] = {
            'broker_url': None,
            'result_backend': None,
            'task_serializer': 'json',
            'result_serializer': 'json',
            'accept_content': ['json'],
            'timezone': 'UTC',
            'enable_utc': True,
            'task_routes': {},
            'beat_schedule': {},
            'worker_prefetch_multiplier': 1,
            'task_acks_late': True,
            'worker_disable_rate_limits': False,
            'task_reject_on_worker_lost': True,
        }
        self._celery_app = None  # Celery åº”ç”¨å®ä¾‹
        
        # è£…é¥°å™¨å¼ºåˆ¶æ¨¡å¼é…ç½®ï¼ˆå§‹ç»ˆå¯ç”¨ï¼‰
        self._strict_decorator_mode = True
        self._decorator_call_stack = set()  # è·Ÿè¸ªè£…é¥°å™¨è°ƒç”¨æ ˆ
        
        # å½“å‰è¯·æ±‚å¯¹è±¡
        self.current_request: Optional[HttpRequest] = None
        
        # åˆ›å»ºåº•å±‚ Rust ç»„ä»¶ï¼ˆç”¨äºå…¼å®¹ç°æœ‰ä»£ç ï¼‰
        self.config = ServerConfig()  # ä½¿ç”¨é»˜è®¤é…ç½®
        self._router = PyRouter()  # ä½¿ç”¨æ— å‚æ•°çš„æ„é€ å‡½æ•°
        self.server = PyServer(self.config)
        
        # åˆ›å»º gRPC ä¸»çº¿ç¨‹ç®¡ç†å™¨
        self.main_thread = PyGrpcMainThread()
        
        # gRPC ç›¸å…³çŠ¶æ€è·Ÿè¸ª
        self._grpc_routes_registered = False  # æ˜¯å¦æœ‰ gRPC è·¯ç”±æ³¨å†Œ
        self._grpc_bridge_initialized = False  # gRPC é˜Ÿåˆ—æ¡¥æ¥æ˜¯å¦å·²åˆå§‹åŒ–
        
        # HTTP é˜Ÿåˆ—æ¡¥æ¥ç›¸å…³çŠ¶æ€è·Ÿè¸ª
        self._http_routes_registered = False  # æ˜¯å¦æœ‰ HTTP è·¯ç”±æ³¨å†Œ
        self._http_bridge_initialized = False  # HTTP é˜Ÿåˆ—æ¡¥æ¥æ˜¯å¦å·²åˆå§‹åŒ–
        
        # å»¶è¿Ÿåˆ° run æ—¶æ³¨å†Œå…¨å±€å¤„ç†å‡½æ•°
        self._global_handler_registered = False
        self._logging_middleware = None
        
        # æ·»åŠ  gRPC è£…é¥°å™¨æ–¹æ³•åˆ°åº”ç”¨å®ä¾‹
        add_grpc_decorators_to_app(self)
    
    def add_extension(self, extension, name: str = None):
        """æ·»åŠ æ‰©å±•åˆ°åº”ç”¨
        
        Args:
            extension: æ‰©å±•å®ä¾‹ï¼Œåº”è¯¥æœ‰ init_app æ–¹æ³•
            name: æ‰©å±•åç§°ï¼Œå¦‚æœä¸æä¾›åˆ™ä½¿ç”¨æ‰©å±•ç±»å
        """
        if name is None:
            name = extension.__class__.__name__
        
        # æ£€æŸ¥æ‰©å±•æ˜¯å¦å·²æ³¨å†Œ
        if name in self.extensions:
            raise ValueError(f"Extension '{name}' is already registered")
        
        # æ³¨å†Œæ‰©å±•
        self.extensions[name] = extension
        
        # å¦‚æœæ‰©å±•æœ‰ init_app æ–¹æ³•ï¼Œè°ƒç”¨å®ƒ
        if hasattr(extension, 'init_app'):
            extension.init_app(self)
        
        return extension
    
    def get_extension(self, name: str):
        """è·å–å·²æ³¨å†Œçš„æ‰©å±•
        
        Args:
            name: æ‰©å±•åç§°
            
        Returns:
            æ‰©å±•å®ä¾‹ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å› None
        """
        return self.extensions.get(name)
    
    def configure_celery(self, **config):
        """é…ç½® Celery è®¾ç½®
        
        Args:
            **config: Celery é…ç½®å‚æ•°
        """
        self.celery_config.update(config)
    
    def get_celery_app(self):
        """è·å–æˆ–åˆ›å»º Celery åº”ç”¨å®ä¾‹
        
        Returns:
            Celery åº”ç”¨å®ä¾‹
        """
        if self._celery_app is None:
            try:
                from celery import Celery
                
                # åˆ›å»º Celery åº”ç”¨
                self._celery_app = Celery(self.name)
                
                # åº”ç”¨é…ç½®
                self._celery_app.config_from_object(self.celery_config)
                
            except ImportError:
                raise ImportError("Celery is not installed. Install it with: pip install celery")
        
        return self._celery_app
    
    def on_startup(self, func: Callable):
        """æ³¨å†Œå¯åŠ¨æ—¶å›è°ƒå‡½æ•°
        
        Args:
            func: å›è°ƒå‡½æ•°
        """
        self._startup_handlers.append(func)
        return func
    
    def on_shutdown(self, func: Callable):
        """æ³¨å†Œå…³é—­æ—¶å›è°ƒå‡½æ•°
        
        Args:
            func: å›è°ƒå‡½æ•°
        """
        self._shutdown_handlers.append(func)
        return func
    
    def _call_startup_handlers(self):
        """è°ƒç”¨æ‰€æœ‰å¯åŠ¨å›è°ƒå‡½æ•°"""
        for handler in self._startup_handlers:
            try:
                handler()
            except Exception as e:
                # rat_engine_py.rat_error(f"âš ï¸ å¯åŠ¨å›è°ƒå‡½æ•°æ‰§è¡Œå¤±è´¥: {e}")
                pass
    
    def _call_shutdown_handlers(self):
        """è°ƒç”¨æ‰€æœ‰å…³é—­å›è°ƒå‡½æ•°"""
        for handler in self._shutdown_handlers:
            try:
                handler()
            except Exception as e:
                # rat_engine_py.rat_error(f"âš ï¸ å…³é—­å›è°ƒå‡½æ•°æ‰§è¡Œå¤±è´¥: {e}")
                pass
    
    def _setup_graceful_shutdown(self):
        """è®¾ç½®ä¼˜é›…é€€å‡ºæœºåˆ¶"""
        import threading
        
        self._stop_event = threading.Event()
        
        def signal_handler(signum, frame):
            # rat_engine_py.rat_startup_log(f"\nğŸ›‘ æ”¶åˆ°ä¿¡å· {signum}ï¼Œæ­£åœ¨ä¼˜é›…å…³é—­æœåŠ¡å™¨...")
            self._stop_event.set()

        # åªåœ¨ä¸»çº¿ç¨‹ä¸­æ³¨å†Œä¿¡å·å¤„ç†å™¨
        try:
            if threading.current_thread() is threading.main_thread():
                signal.signal(signal.SIGINT, signal_handler)
                signal.signal(signal.SIGTERM, signal_handler)
            else:
                # åœ¨å­çº¿ç¨‹ä¸­ï¼Œåªåˆ›å»ºåœæ­¢äº‹ä»¶ï¼Œä¸è®¾ç½®ä¿¡å·å¤„ç†å™¨
                # rat_engine_py.rat_warn("âš ï¸ åœ¨å­çº¿ç¨‹ä¸­è¿è¡Œï¼Œè·³è¿‡ä¿¡å·å¤„ç†å™¨è®¾ç½®")
                pass
        except ValueError as e:
            # å¦‚æœä¿¡å·å¤„ç†å™¨è®¾ç½®å¤±è´¥ï¼Œåªè®°å½•è­¦å‘Š
            # rat_engine_py.rat_warn(f"âš ï¸ æ— æ³•è®¾ç½®ä¿¡å·å¤„ç†å™¨: {e}")
            # rat_engine_py.rat_info("ğŸ’¡ æç¤ºï¼šåœ¨å­çº¿ç¨‹ä¸­è¿è¡Œæ—¶ï¼Œè¯·æ‰‹åŠ¨è°ƒç”¨ app.stop() æ¥åœæ­¢æœåŠ¡å™¨")
            pass
    

    
    # æ–°å¢ï¼šåŸºäºå“åº”ç±»å‹çš„è£…é¥°å™¨
    def html(self, rule: str, methods: Optional[List[str]] = None, **options):
        """HTML å“åº”è£…é¥°å™¨ - è¿”å›å€¼å°†è¢«è§†ä¸º HTML å†…å®¹"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            @functools.wraps(func)
            def html_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # å¦‚æœå·²ç»æ˜¯HttpResponseæˆ–TypedResponseï¼Œç›´æ¥è¿”å›
                if isinstance(result, (HttpResponse, TypedResponse)):
                    return result
                # å¤„ç† tuple è¿”å›å€¼æ ¼å¼
                if isinstance(result, tuple):
                    if len(result) == 2:
                        content, second = result
                        # æ£€æŸ¥ç¬¬äºŒä¸ªå…ƒç´ æ˜¯å¦ä¸ºæ•´æ•°ï¼ˆçŠ¶æ€ç ï¼‰
                        if isinstance(second, int):
                            # (content, status_code) æ ¼å¼
                            return TypedResponse(str(content), ResponseType.HTML, status_code=second)
                        else:
                            # (content, content_type) æ ¼å¼ - å‘åå…¼å®¹
                            return TypedResponse(str(content), ResponseType.CUSTOM, content_type=second)
                    elif len(result) == 3:
                        # (content, status_code, headers) æ ¼å¼
                        content, status_code, headers = result
                        return TypedResponse(str(content), ResponseType.HTML, status_code=status_code, headers=headers)
                # è¿”å›TypedResponseå¯¹è±¡ï¼ŒæŒ‡å®šä¸ºHTMLç±»å‹
                return TypedResponse(str(result), ResponseType.HTML)
            
            self._add_route(rule, html_wrapper, methods, _from_decorator=True)
            return html_wrapper
        
        return decorator
    
    def json(self, rule: str, methods: Optional[List[str]] = None, **options):
        """JSON å“åº”è£…é¥°å™¨ - è¿”å›å€¼å°†è¢«åºåˆ—åŒ–ä¸º JSON"""
        if methods is None:
            methods = ['GET', 'POST']
        
        def decorator(func):
            @functools.wraps(func)
            def json_wrapper(*args, **kwargs):
                # å¤„ç†ä»Rustä¼ é€’çš„å…ƒç»„å‚æ•°
                if args:
                    request_data = args[0]
                    # å¦‚æœæ˜¯å…ƒç»„ä¸”åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œè§£åŒ…
                    if isinstance(request_data, tuple) and len(request_data) == 1:
                        request_data = request_data[0]
                else:
                    request_data = kwargs.get('request_data')
                
                # ç§»é™¤kwargsä¸­å¯èƒ½é‡å¤çš„request_dataå‚æ•°
                kwargs.pop('request_data', None)
                
                # æ£€æŸ¥åŸå§‹å‡½æ•°çš„ç­¾åï¼Œåªä¼ é€’å®ƒæ¥å—çš„å‚æ•°
                import inspect
                sig = inspect.signature(func)
                filtered_kwargs = {}
                for param_name in sig.parameters:
                    if param_name in kwargs:
                        filtered_kwargs[param_name] = kwargs[param_name]
                
                result = func(request_data, **filtered_kwargs)
                # å¦‚æœå·²ç»æ˜¯HttpResponseæˆ–TypedResponseï¼Œç›´æ¥è¿”å›
                if isinstance(result, (HttpResponse, TypedResponse)):
                    return result
                # å¦åˆ™ç›´æ¥è¿”å›å­—å…¸ï¼ˆRustç«¯ä¼šå¤„ç†ä¸ºJSONï¼‰
                return result
            
            self._add_route(rule, json_wrapper, methods, _from_decorator=True)
            return json_wrapper
        
        return decorator
    
    def sse(self, rule: str, **options):
        """SSE å“åº”è£…é¥°å™¨ - è‡ªåŠ¨æ³¨å†Œä¸ºæµå¼è·¯ç”±"""
        def decorator(func):
            @functools.wraps(func)
            def sse_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # å¤„ç† generator å¯¹è±¡ - ç›´æ¥è¿”å›ç”Ÿæˆå™¨ï¼Œè®© Rust ç«¯å¤„ç†
                if hasattr(result, '__iter__') and not isinstance(result, (str, bytes)) and not hasattr(result, 'get_sender'):
                    # ç›´æ¥è¿”å›ç”Ÿæˆå™¨ï¼Œä¸å†è½¬æ¢ä¸º TypedResponse
                    return result
                # å¦‚æœè¿”å›å­—ç¬¦ä¸²ï¼Œæ ‡è®°ä¸º SSE å“åº”
                elif isinstance(result, str):
                    return TypedResponse(result, ResponseType.SSE)
                # å¦‚æœè¿”å› SSE é€šé“å¯¹è±¡ï¼Œç›´æ¥è¿”å›ï¼ˆRust å±‚ä¼šå¤„ç†ï¼‰
                elif hasattr(result, 'get_sender') and hasattr(result, 'take_response'):
                    # ç®¡ç† SSE è¿æ¥
                    if not hasattr(self, '_sse_channels'):
                        self._sse_channels = {}
                    
                    import time
                    connection_id = f"sse_{int(time.time())}_{id(result)}"
                    self._sse_channels[connection_id] = result
                    
                    sender = result.get_sender()
                    
                    def cleanup_close():
                        self._sse_channels.pop(connection_id, None)
                    
                    if hasattr(sender, 'close_callback'):
                        sender.close_callback = cleanup_close
                    
                    return result
                return result
            
            # æ ‡è®°ä¸º SSE è·¯ç”±ï¼Œç”¨äºè‡ªåŠ¨æ³¨å†Œä¸ºæµå¼è·¯ç”±
            sse_wrapper._is_sse_route = True
            self._add_route(rule, sse_wrapper, ['GET'], _from_decorator=True)
            return sse_wrapper
        
        return decorator
    
    def file(self, rule: str, methods: Optional[List[str]] = None, **options):
        """æ–‡ä»¶å“åº”è£…é¥°å™¨ - è¿”å›å€¼å°†è¢«è§†ä¸ºæ–‡ä»¶è·¯å¾„æˆ–æ–‡ä»¶å†…å®¹"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            @functools.wraps(func)
            def file_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # è¿”å›TypedResponseå¯¹è±¡
                if isinstance(result, str):
                    return TypedResponse(result, ResponseType.FILE)
                elif isinstance(result, tuple) and len(result) == 2:
                    # æ”¯æŒ (file_path, mime_type) æ ¼å¼
                    file_path, mime_type = result
                    return TypedResponse(file_path, ResponseType.FILE, mime_type=mime_type)
                return result
            
            self._add_route(rule, file_wrapper, methods, _from_decorator=True)
            return file_wrapper
        
        return decorator
    
    def custom(self, rule: str, methods: Optional[List[str]] = None, **options):
        """è‡ªå®šä¹‰å“åº”è£…é¥°å™¨ - æ”¯æŒå…ƒç»„æ ¼å¼ (content, content_type) æˆ– (content, content_type, status_code)"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            @functools.wraps(func)
            def custom_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # å¦‚æœå·²ç»æ˜¯HttpResponseæˆ–TypedResponseï¼Œç›´æ¥è¿”å›
                if isinstance(result, (HttpResponse, TypedResponse)):
                    return result
                # å¤„ç† tuple è¿”å›å€¼æ ¼å¼
                if isinstance(result, tuple):
                    if len(result) == 2:
                        # (content, content_type) æ ¼å¼
                        content, content_type = result
                        if isinstance(content, str):
                            return TypedResponse(content, ResponseType.CUSTOM, content_type=content_type)
                        elif isinstance(content, bytes):
                            return TypedResponse(content, ResponseType.CUSTOM_BYTES, content_type=content_type)
                        else:
                            # å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                            return TypedResponse(str(content), ResponseType.CUSTOM, content_type=content_type)
                    elif len(result) == 3:
                        # (content, content_type, status_code) æ ¼å¼
                        content, content_type, status_code = result
                        if isinstance(content, str):
                            return TypedResponse(content, ResponseType.CUSTOM, status_code=status_code, content_type=content_type)
                        elif isinstance(content, bytes):
                            return TypedResponse(content, ResponseType.CUSTOM_BYTES, status_code=status_code, content_type=content_type)
                        else:
                            # å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                            return TypedResponse(str(content), ResponseType.CUSTOM, status_code=status_code, content_type=content_type)

                elif isinstance(result, str):
                    # é»˜è®¤ä¸º text/plain; charset=utf-8
                    return TypedResponse(result, ResponseType.CUSTOM, content_type='text/plain; charset=utf-8')
                elif isinstance(result, bytes):
                    # é»˜è®¤ä¸º application/octet-stream
                    return TypedResponse(result, ResponseType.CUSTOM_BYTES, content_type='application/octet-stream')
                return result
            
            self._add_route(rule, custom_wrapper, methods, _from_decorator=True)
            return custom_wrapper
        
        return decorator
    
    def sse_json(self, rule: str, **options):
        """SSE JSON å“åº”è£…é¥°å™¨ - è¿”å›å€¼å°†è¢«è§†ä¸º SSE æ ¼å¼çš„ JSON æ•°æ®æµ"""
        def decorator(func):
            @functools.wraps(func)
            def sse_json_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # è¿”å›TypedResponseå¯¹è±¡
                if isinstance(result, str):
                    return TypedResponse(result, ResponseType.SSE_JSON)
                return result
            
            self._add_route(rule, sse_json_wrapper, ['GET'], _from_decorator=True)
            return sse_json_wrapper
        
        return decorator
    
    def chunk(self, rule: str, methods: Optional[List[str]] = None, **options):
        """åˆ†å—ä¼ è¾“å“åº”è£…é¥°å™¨ - è¿”å›å€¼å°†è¢«è§†ä¸ºåˆ†å—æ•°æ®"""
        if methods is None:
            methods = ['GET']
        
        def decorator(func):
            @functools.wraps(func)
            def chunk_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # å¤„ç† generator å¯¹è±¡
                if hasattr(result, '__iter__') and not isinstance(result, (str, bytes)):
                    # å°† generator è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                    chunk_data = ''.join(str(chunk) for chunk in result)
                    return TypedResponse(chunk_data, ResponseType.CHUNK)
                # è¿”å›TypedResponseå¯¹è±¡
                elif isinstance(result, str):
                    return TypedResponse(result, ResponseType.CHUNK)
                return result
            
            self._add_route(rule, chunk_wrapper, methods, _from_decorator=True)
            return chunk_wrapper
        
        return decorator
    
    def sse_text(self, rule: str, **options):
        """SSE æ–‡æœ¬å“åº”è£…é¥°å™¨ - è¿”å›å€¼å°†è¢«è§†ä¸º SSE æ ¼å¼çš„æ–‡æœ¬æµ"""
        def decorator(func):
            @functools.wraps(func)
            def sse_text_wrapper(*args, **kwargs):
                result = func(*args, **kwargs)
                # è¿”å›TypedResponseå¯¹è±¡
                if isinstance(result, str):
                    return TypedResponse(result, ResponseType.SSE_TEXT)
                elif isinstance(result, list):
                    # è‡ªåŠ¨å°†åˆ—è¡¨è½¬æ¢ä¸ºæ¢è¡Œç¬¦åˆ†éš”çš„æ–‡æœ¬
                    text_content = "\n".join(str(item) for item in result)
                    return TypedResponse(text_content, ResponseType.SSE_TEXT)
                return result
            
            self._add_route(rule, sse_text_wrapper, ['GET'], _from_decorator=True)
            return sse_text_wrapper
        
        return decorator
    

    
    def _add_route(self, rule: str, handler: Callable, methods: List[str], _from_decorator: bool = False):
        """æ·»åŠ è·¯ç”±ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
        
        Args:
            rule: è·¯ç”±è§„åˆ™
            handler: å¤„ç†å‡½æ•°
            methods: HTTP æ–¹æ³•åˆ—è¡¨
            _from_decorator: æ˜¯å¦æ¥è‡ªè£…é¥°å™¨è°ƒç”¨ï¼ˆå†…éƒ¨å‚æ•°ï¼‰
        """
        # ä¸¥æ ¼è£…é¥°å™¨æ¨¡å¼æ£€æŸ¥ - å§‹ç»ˆå¯ç”¨
        if not _from_decorator:
            # æ£€æŸ¥è°ƒç”¨æ ˆï¼Œç¡®å®šæ˜¯å¦æ¥è‡ªè£…é¥°å™¨
            import inspect
            frame = inspect.currentframe()
            decorator_found = False
            
            try:
                # å‘ä¸Šéå†è°ƒç”¨æ ˆï¼ŒæŸ¥æ‰¾è£…é¥°å™¨è°ƒç”¨
                current_frame = frame.f_back
                while current_frame:
                    code_name = current_frame.f_code.co_name
                    # æ£€æŸ¥æ˜¯å¦æ¥è‡ªè£…é¥°å™¨æ–¹æ³•
                    if code_name in ['html', 'json', 'sse', 'file', 'custom', 'sse_json', 'chunk', 'sse_text']:
                        decorator_found = True
                        break
                    current_frame = current_frame.f_back
            finally:
                del frame  # é¿å…å¾ªç¯å¼•ç”¨
            
            if not decorator_found:
                raise RuntimeError(
                    f"ğŸš« ä¸¥æ ¼è£…é¥°å™¨æ¨¡å¼ï¼šè·¯ç”± '{rule}' å¿…é¡»é€šè¿‡è£…é¥°å™¨æ³¨å†Œï¼\n"
                    f"è¯·ä½¿ç”¨ @app.html(), @app.json(), @app.sse() ç­‰è£…é¥°å™¨æ³¨å†Œè·¯ç”±ã€‚\n"
                    f"ä¸¥ç¦ç›´æ¥è°ƒç”¨ router.add_route() æˆ– app._add_route() æ–¹æ³•ï¼"
                )
        
        # ğŸ” [DEBUG] è·å–handleråç§°
        handler_name = handler.__name__ if hasattr(handler, '__name__') else str(handler)
        # rat_engine_py.rat_debug(f"ğŸ [PYTHON DEBUG] æ³¨å†Œè·¯ç”±:")
        # rat_engine_py.rat_debug(f"   è§„åˆ™: {rule}")
        # rat_engine_py.rat_debug(f"   æ–¹æ³•: {methods}")
        # rat_engine_py.rat_debug(f"   Handleråç§°: {handler_name}")
        # rat_engine_py.rat_debug(f"   Handlerå‡½æ•°: {handler}")

        route = Route(rule, handler, methods)
        self.routes.append(route)

        # æ ‡è®°æœ‰ HTTP è·¯ç”±æ³¨å†Œ
        self._http_routes_registered = True
    
    def add_middleware(self, middleware: Middleware):
        """æ·»åŠ ä¸­é—´ä»¶"""
        self.middlewares.append(middleware)
    
    def is_strict_decorator_mode(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†ä¸¥æ ¼è£…é¥°å™¨æ¨¡å¼ï¼ˆå§‹ç»ˆä¸º Trueï¼‰"""
        return True
        
    def enable_compression(
        self,
        min_size=1024,
        level=None,
        enable_gzip=None,
        enable_deflate=None,
        enable_brotli=None,
        enable_zstd=None,
        enable_lz4=None,
        excluded_content_types=None,
        excluded_extensions=None,
    ):
        """
        å¯ç”¨å‹ç¼©åŠŸèƒ½
        
        Args:
            min_size: æœ€å°å‹ç¼©å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼Œé»˜è®¤ä¸º 1024
            level: å‹ç¼©çº§åˆ«ï¼ˆ1-9ï¼‰ï¼Œé»˜è®¤ä¸º 6
            enable_gzip: æ˜¯å¦å¯ç”¨ Gzip å‹ç¼©ï¼Œé»˜è®¤ä¸º True
            enable_deflate: æ˜¯å¦å¯ç”¨ Deflate å‹ç¼©ï¼Œé»˜è®¤ä¸º True
            enable_brotli: æ˜¯å¦å¯ç”¨ Brotli å‹ç¼©ï¼Œé»˜è®¤ä¸º True
            enable_zstd: æ˜¯å¦å¯ç”¨ Zstd å‹ç¼©ï¼Œé»˜è®¤ä¸º True
            enable_lz4: æ˜¯å¦å¯ç”¨ LZ4 å‹ç¼©ï¼Œé»˜è®¤ä¸º False
            excluded_content_types: æ’é™¤çš„å†…å®¹ç±»å‹åˆ—è¡¨
            excluded_extensions: æ’é™¤çš„æ–‡ä»¶æ‰©å±•ååˆ—è¡¨
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
        """
        # å°†è°ƒç”¨è½¬å‘ç»™åº•å±‚çš„ routerï¼Œä½¿ç”¨å…³é”®å­—å‚æ•°
        self._router.enable_compression(
            min_size=min_size,
            level=level,
            enable_gzip=enable_gzip,
            enable_deflate=enable_deflate,
            enable_brotli=enable_brotli,
            enable_zstd=enable_zstd,
            enable_lz4=enable_lz4,
            excluded_content_types=excluded_content_types,
            excluded_extensions=excluded_extensions,
        )
    
    def enable_cache(self, **kwargs):
        """
        å¯ç”¨ç¼“å­˜åŠŸèƒ½

        æ­¤æ–¹æ³•æ¥å—ç¼“å­˜é…ç½®å‚æ•°ï¼Œè‡ªåŠ¨è½¬æ¢ä¸º JSON é…ç½®ä¼ é€’ç»™ Rust å±‚

        Args:
            **kwargs: ç¼“å­˜é…ç½®å‚æ•°ï¼Œè¯¦æƒ…è¯·å‚è€ƒ cache_config.build_cache_config å‡½æ•°

        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨

        Raises:
            ValueError: ç¼ºå°‘å¿…éœ€é…ç½®å­—æ®µæ—¶æŠ›å‡º

        Example:
            # åŸºæœ¬é…ç½®
            app.enable_cache(
                max_memory=64*1024*1024,
                max_entries=1000,
                eviction_strategy="Lru",
                default_ttl=60,
                cleanup_interval=300,
                enable_ttl=True,
                enable_stats=True,
                stats_interval=60,
                enable_memory_pool=True,
                pool_size=1024
            )
        """
        # ä½¿ç”¨ç¼“å­˜é…ç½®æ¨¡å—æ„å»º JSON é…ç½®
        config_json = build_cache_config(**kwargs)

        # è°ƒç”¨Rustæ–¹æ³•
        try:
            self._router.enable_cache(config_json)
        except Exception as e:
            import traceback
            traceback.print_exc()
            raise

        return self

    def disable_compression(self):
        """
        ç¦ç”¨å‹ç¼©åŠŸèƒ½

        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
        """
        self._router.disable_compression()
        return self
    
    def disable_cache(self):
        """
        ç¦ç”¨ç¼“å­˜åŠŸèƒ½
        
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
        """
        self._router.disable_cache()
        return self
    
    def enable_version_manager(
        self, 
        max_encoding_versions: int = 5,
        enable_precompression: bool = True,
        hot_encoding_threshold: float = 0.1,
        store_original_data: bool = True,
        cleanup_age_threshold: int = 3600,
        cleanup_idle_threshold: int = 1800
    ):
        """
        å¯ç”¨å¤šç‰ˆæœ¬ç¼“å­˜ç®¡ç†å™¨
        
        å¤šç‰ˆæœ¬ç¼“å­˜ç®¡ç†å™¨å¯ä»¥ä¸ºåŒä¸€å†…å®¹å­˜å‚¨å¤šä¸ªç¼–ç ç‰ˆæœ¬ï¼ˆå¦‚gzipã€brç­‰ï¼‰ï¼Œ
        æ ¹æ®å®¢æˆ·ç«¯æ”¯æŒçš„ç¼–ç è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ç‰ˆæœ¬ï¼Œæå‡ç¼“å­˜å‘½ä¸­ç‡å’Œå“åº”é€Ÿåº¦ã€‚
        
        Args:
            max_encoding_versions: æœ€å¤§ç¼–ç ç‰ˆæœ¬æ•°ï¼Œé»˜è®¤ä¸º 5
            enable_precompression: æ˜¯å¦å¯ç”¨é¢„å‹ç¼©ï¼Œé»˜è®¤ä¸º True
            hot_encoding_threshold: çƒ­ç‚¹ç¼–ç é˜ˆå€¼ï¼ˆä½¿ç”¨ç‡ï¼‰ï¼Œé»˜è®¤ä¸º 0.1
            store_original_data: æ˜¯å¦å­˜å‚¨åŸå§‹æ•°æ®ï¼Œé»˜è®¤ä¸º True
            cleanup_age_threshold: æ¸…ç†ç­–ç•¥çš„å¹´é¾„é˜ˆå€¼ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ä¸º 3600
            cleanup_idle_threshold: æ¸…ç†ç­–ç•¥çš„ç©ºé—²æ—¶é—´é˜ˆå€¼ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ä¸º 1800
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            app.enable_version_manager(
                max_encoding_versions=5,
                enable_precompression=True,
                hot_encoding_threshold=0.1
            )
        """
        self._router.enable_version_manager(
            max_encoding_versions=max_encoding_versions,
            enable_precompression=enable_precompression,
            hot_encoding_threshold=hot_encoding_threshold,
            store_original_data=store_original_data,
            cleanup_age_threshold=cleanup_age_threshold,
            cleanup_idle_threshold=cleanup_idle_threshold
        )
        return self
    
    # ========== åè®®é…ç½®æ–¹æ³• ==========
    
    def enable_h2c(self):
        """
        å¯ç”¨ H2C (HTTP/2 over cleartext) åè®®æ”¯æŒ
        
        H2C å…è®¸åœ¨éåŠ å¯†è¿æ¥ä¸Šä½¿ç”¨ HTTP/2 åè®®ï¼Œä¸»è¦ç”¨äºï¼š
        - å¼€å‘ç¯å¢ƒæµ‹è¯•
        - å†…ç½‘æœåŠ¡é€šä¿¡
        - gRPC over HTTP/2 æ˜æ–‡ä¼ è¾“
        
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
        """
        self._router.enable_h2c()
        return self
    
    def enable_h2(self):
        """
        å¯ç”¨ HTTP/2 åè®®æ”¯æŒ
        
        HTTP/2 æä¾›äº†æ›´å¥½çš„æ€§èƒ½å’Œå¤šè·¯å¤ç”¨èƒ½åŠ›ï¼Œé€‚ç”¨äºï¼š
        - ç°ä»£ Web åº”ç”¨
        - é«˜å¹¶å‘åœºæ™¯
        - éœ€è¦æœåŠ¡å™¨æ¨é€çš„åº”ç”¨
        
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
        """
        self._router.enable_h2()
        return self
    
    def configure_protocols(self, *, enable_h2c: bool = False, enable_h2: bool = False):
        """
        æ‰¹é‡é…ç½®åè®®æ”¯æŒ
        
        Args:
            enable_h2c: æ˜¯å¦å¯ç”¨ H2C (HTTP/2 over cleartext)
            enable_h2: æ˜¯å¦å¯ç”¨ HTTP/2
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            app.configure_protocols(enable_h2c=True, enable_h2=True)
        """
        if enable_h2c:
            self._router.enable_h2c()
        if enable_h2:
            self._router.enable_h2()
        return self
    
    def is_h2c_enabled(self) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦å¯ç”¨äº† H2C åè®®
        
        Returns:
            bool: æ˜¯å¦å¯ç”¨äº† H2C
        """
        return self._router.is_h2c_enabled()
    
    def is_h2_enabled(self) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦å¯ç”¨äº† HTTP/2 åè®®
        
        Returns:
            bool: æ˜¯å¦å¯ç”¨äº† HTTP/2
        """
        return self._router.is_h2_enabled()
    
    # ========== è¯ä¹¦é…ç½®æ–¹æ³• ==========
    
    def enable_development_mode(self, hostnames: list = None):
        """
        å¯ç”¨å¼€å‘æ¨¡å¼ï¼ˆè‡ªåŠ¨ç”Ÿæˆè‡ªç­¾åè¯ä¹¦ï¼‰
        
        Args:
            hostnames: ä¸»æœºååˆ—è¡¨ï¼Œé»˜è®¤ä¸º ["localhost", "127.0.0.1"]
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            app.enable_development_mode(["localhost", "127.0.0.1"])
        """
        if hostnames is None:
            hostnames = ["localhost", "127.0.0.1"]
        self._router.enable_development_mode(hostnames)
        return self
    
    def configure_acme_certs(self, domains: list, cert_config):
        """
        é…ç½® ACME è‡ªåŠ¨è¯ä¹¦
        
        Args:
            domains: åŸŸååˆ—è¡¨
            cert_config: è¯ä¹¦ç®¡ç†å™¨é…ç½®å¯¹è±¡
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            from rat_engine import CertManagerConfig
            cert_config = CertManagerConfig.acme_config(
                email="admin@example.com",
                production=False
            )
            app.configure_acme_certs(["example.com"], cert_config)
        """
        self._router.configure_acme_certs(domains, cert_config)
        return self
    
    def configure_mtls(self, cert_config):
        """
        é…ç½® mTLS åŒå‘è®¤è¯
        
        Args:
            cert_config: è¯ä¹¦ç®¡ç†å™¨é…ç½®å¯¹è±¡ï¼Œå¿…é¡»å¯ç”¨ mTLS
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            from rat_engine import CertManagerConfig
            cert_config = CertManagerConfig.mtls_self_signed_config(
                auto_generate_client_cert=True,
                client_cert_subject="CN=Client,O=Example Corp"
            )
            app.configure_mtls(cert_config)
        """
        self._router.configure_mtls(cert_config)
        return self
    
    def configure_production_certs(self, cert_config):
        """
        é…ç½®ç”Ÿäº§ç¯å¢ƒè¯ä¹¦
        
        Args:
            cert_config: è¯ä¹¦ç®¡ç†å™¨é…ç½®å¯¹è±¡
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            from rat_engine import CertManagerConfig
            cert_config = CertManagerConfig.production_config(
                cert_file="/path/to/cert.pem",
                key_file="/path/to/key.pem"
            )
            app.configure_production_certs(cert_config)
        """
        self._router.configure_production_certs(cert_config)
        return self
    
    def enable_spa(self, fallback_path: str = "/index.html"):
        """
        å¯ç”¨ SPA (å•é¡µåº”ç”¨) æ”¯æŒ
        
        Args:
            fallback_path: SPA å›é€€è·¯å¾„ï¼Œé€šå¸¸æ˜¯ index.html
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            app.enable_spa("/index.html")
            app.enable_spa("/app/index.html")
        """
        self._router.enable_spa(fallback_path)
        return self
    
    def disable_spa(self):
        """
        ç¦ç”¨ SPA (å•é¡µåº”ç”¨) æ”¯æŒ
        
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            app.disable_spa()
        """
        self._router.disable_spa()
        return self
    
    def configure_spa(self, enabled: bool, fallback_path: Optional[str] = None):
        """
        é…ç½® SPA (å•é¡µåº”ç”¨) è®¾ç½®
        
        Args:
            enabled: æ˜¯å¦å¯ç”¨ SPA æ”¯æŒ
            fallback_path: SPA å›é€€è·¯å¾„ï¼Œå½“å¯ç”¨æ—¶å¿…é¡»æä¾›
            
        Returns:
            self: è¿”å›è‡ªèº«ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨
            
        Example:
            app.configure_spa(True, "/index.html")
            app.configure_spa(False)
        """
        self._router.configure_spa(enabled, fallback_path)
        return self

    def configure_logging(self, level: str = "info", enable_access_log: bool = True, enable_error_log: bool = True,
                         enable_colors: bool = True, enable_emoji: bool = True,
                         show_timestamp: bool = True, show_module: bool = True, log_file: str = None):
        """é…ç½®æ—¥å¿—ç³»ç»Ÿï¼ˆä»£ç†åˆ°server.configure_loggingï¼‰

        Args:
            level: æ—¥å¿—çº§åˆ« ("error", "warn", "info", "debug", "trace")
            enable_access_log: æ˜¯å¦å¯ç”¨è®¿é—®æ—¥å¿—
            enable_error_log: æ˜¯å¦å¯ç”¨é”™è¯¯æ—¥å¿—
            enable_colors: æ˜¯å¦å¯ç”¨é¢œè‰²è¾“å‡º
            enable_emoji: æ˜¯å¦å¯ç”¨ emoji
            show_timestamp: æ˜¯å¦æ˜¾ç¤ºæ—¶é—´æˆ³
            show_module: æ˜¯å¦æ˜¾ç¤ºæ¨¡å—å
            log_file: æ—¥å¿—æ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰
        """
        # æ„å»ºæ—¥å¿—é…ç½®JSON
        log_config_json = {
            "level": level,
            "enable_colors": enable_colors,
            "enable_emoji": enable_emoji,
            "show_timestamp": show_timestamp,
            "show_module": show_module,
            "log_file": log_file
        }
        import json
        log_config_str = json.dumps(log_config_json)

        # ä»£ç†åˆ°serverçš„configure_loggingæ–¹æ³•
        self.server.configure_logging(log_config_str)
        self._logging_configured = True
    
        
    def before_request(self, func: Callable):
        """è¯·æ±‚å‰å¤„ç†è£…é¥°å™¨"""
        self.before_request_handlers.append(func)
        return func
    
    def after_request(self, func: Callable):
        """è¯·æ±‚åå¤„ç†è£…é¥°å™¨"""
        self.after_request_handlers.append(func)
        return func
    
    def errorhandler(self, code: int):
        """é”™è¯¯å¤„ç†è£…é¥°å™¨"""
        def decorator(func):
            self.error_handlers[code] = func
            return func
        return decorator
    
    def _handle_request(self, request_data) -> HttpResponse:
        """å¤„ç† HTTP è¯·æ±‚çš„æ ¸å¿ƒé€»è¾‘"""
        # ğŸ”§ [è°ƒè¯•ä¿¡æ¯] è¯·æ±‚å¤„ç†è°ƒè¯• - å¦‚éœ€è°ƒè¯•è¯·æ±‚å¤„ç†é—®é¢˜ï¼Œå¯å–æ¶ˆæ³¨é‡Šä»¥ä¸‹è¡Œ
        # print(f"ğŸ”§ [PYTHON-DEBUG] _handle_request è¢«è°ƒç”¨")
        # print(f"ğŸ”§ [PYTHON-DEBUG] request_data ç±»å‹: {type(request_data)}")
        # print(f"ğŸ”§ [PYTHON-DEBUG] request_data å†…å®¹: {request_data}")
        
        # å¦‚æœä¼ å…¥çš„æ˜¯å­—å…¸ï¼Œè½¬æ¢ä¸º HttpRequest å¯¹è±¡
        if isinstance(request_data, dict):
            # ğŸ” è°ƒè¯•Pythonå±‚æ¥æ”¶åˆ°çš„path_params
            path_params = request_data.get('path_params', {})
            print(f"ğŸ [Python DEBUG] web_appæ¥æ”¶åˆ°path_params: {path_params} (ç±»å‹: {type(path_params)}, é•¿åº¦: {len(path_params) if path_params else 'N/A'})")

            request = HttpRequest(
                method=request_data.get('method', 'GET'),
                path=request_data.get('path', '/'),
                query_string=request_data.get('query', ''),
                headers=request_data.get('headers', {}),
                body=request_data.get('body', b''),
                remote_addr=request_data.get('remote_addr', '127.0.0.1:0'),
                real_ip=request_data.get('real_ip', '127.0.0.1'),
                path_params=path_params
            )
        else:
            request = request_data
            
        # è®¾ç½®å½“å‰è¯·æ±‚
        self.current_request = request
        try:
            with RequestContext(request) as ctx:
                # ä¸­é—´ä»¶å‰å¤„ç†
                for middleware in self.middlewares:
                    response = middleware.before_request(request)
                    if response:
                        return self._apply_after_middleware(request, response)
                
                # è¯·æ±‚å‰å¤„ç†å™¨
                for handler in self.before_request_handlers:
                    result = handler()
                    if isinstance(result, HttpResponse):
                        return self._apply_after_middleware(request, result)
                
                # è·¯ç”±åŒ¹é… - ç›´æ¥ä½¿ç”¨Rustå±‚å¤„ç†å¥½çš„path_paramså’Œpython_handler_name
                print(f"ğŸ [PYTHON DEBUG] æ”¶åˆ°è¯·æ±‚:")
                print(f"   è·¯å¾„: {request.path}")
                print(f"   æ–¹æ³•: {request.method}")
                print(f"   path_params: {request.path_params}")
                print(f"   python_handler_name: {getattr(request, 'python_handler_name', 'Not Available')}")

                # æ£€æŸ¥å¿…éœ€çš„å­—æ®µ
                python_handler_name = getattr(request, 'python_handler_name', None)
                if not python_handler_name:
                    print(f"ğŸš¨ [PYTHON ERROR] python_handler_nameä¸ºç©ºï¼")
                    return self._handle_error(request, 500, "Internal server error: missing python_handler_name from Rust layer")

                # ğŸ” ä¿®å¤ï¼špath_paramsä¸ºç©ºdictæ˜¯æ­£å¸¸çš„ï¼ˆæ¯”å¦‚é¦–é¡µè·¯ç”±ï¼‰ï¼Œä¸åº”è¯¥æŠ¥é”™
                if request.path_params is None:
                    print(f"ğŸš¨ [PYTHON ERROR] path_paramsä¸ºNoneï¼")
                    return self._handle_error(request, 500, "Internal server error: path_params is None from Rust layer")

                # ç›´æ¥ä½¿ç”¨Rustå±‚çš„æ•°æ®
                ctx.path_params = request.path_params

                # æ ¹æ®python_handler_nameæŸ¥æ‰¾å¤„ç†å™¨
                target_handler = None
                for route in self.routes:
                    if route.handler_name == python_handler_name:
                        target_handler = route.handler
                        break

                if not target_handler:
                    print(f"ğŸš¨ [PYTHON ERROR] æ‰¾ä¸åˆ°å¤„ç†å™¨: {python_handler_name}")
                    return self._handle_error(request, 500, f"Handler not found: {python_handler_name}")

                print(f"ğŸ”§ [PYTHON DEBUG] ä½¿ç”¨å¤„ç†å™¨: {python_handler_name}")
                response = self._call_handler(target_handler, request, request.path_params)
                return self._apply_after_middleware(request, response)
        
        except Exception as e:
            return self._handle_exception(request, e)
        finally:
            # æ¸…ç†å½“å‰è¯·æ±‚
            self.current_request = None
    
    def _call_handler(self, handler: Callable, request: HttpRequest, params: Dict[str, Any]) -> HttpResponse:
        """è°ƒç”¨è·¯ç”±å¤„ç†å‡½æ•°"""
        # æ£€æŸ¥å‡½æ•°ç­¾å
        sig = inspect.signature(handler)
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯è£…é¥°å™¨åŒ…è£…çš„å‡½æ•°ï¼ˆé€šè¿‡æ£€æŸ¥__wrapped__å±æ€§ï¼‰
        if hasattr(handler, '__wrapped__'):
            # ğŸ”§ [è°ƒè¯•ä¿¡æ¯] è£…é¥°å™¨è°ƒç”¨è°ƒè¯• - å¦‚éœ€è°ƒè¯•è£…é¥°å™¨åŒ…è£…å‡½æ•°è°ƒç”¨é—®é¢˜ï¼Œå¯å–æ¶ˆæ³¨é‡Šä»¥ä¸‹è¡Œ
            # print(f"ğŸ”§ [PYTHON-DEBUG] è°ƒç”¨è£…é¥°å™¨åŒ…è£…çš„å‡½æ•°")
            # print(f"ğŸ”§ [PYTHON-DEBUG] ä¼ é€’çš„å‚æ•°: {params}")
            # å¯¹äºè£…é¥°å™¨åŒ…è£…çš„å‡½æ•°ï¼Œç›´æ¥ä¼ é€’request_dataä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°
            # å¤„ç† body å­—æ®µï¼šå¦‚æœæ˜¯å­—èŠ‚æ•°ç»„ï¼Œå°è¯•è§£ç 
            body_data = request.body
            if isinstance(body_data, (list, bytes)):
                try:
                    if isinstance(body_data, list):
                        # å­—èŠ‚æ•°ç»„è½¬æ¢ä¸ºå­—èŠ‚ä¸²
                        body_bytes = bytes(body_data)
                    else:
                        body_bytes = body_data
                    # å°è¯•è§£ç ä¸º UTF-8 å­—ç¬¦ä¸²
                    body_data = body_bytes.decode('utf-8')
                except (UnicodeDecodeError, ValueError):
                    # è§£ç å¤±è´¥æ—¶ä¿æŒåŸå§‹æ ¼å¼
                    pass
            
            request_data_dict = {
                'method': request.method,
                'path': request.path,
                'query': request.query_string,
                'headers': request.headers,
                'body': body_data,
                'path_params': params  # ä½¿ç”¨è·¯ç”±åŒ¹é…å¾—åˆ°çš„å‚æ•°ï¼Œè€Œä¸æ˜¯request.path_params
            }
            
            # å‡†å¤‡è·¯å¾„å‚æ•°ä½œä¸ºkwargs
            kwargs = {}
            for param_name in params:
                kwargs[param_name] = params[param_name]
            
            result = handler(request_data_dict, **kwargs)
        else:
            # å¯¹äºæœªè£…é¥°çš„å‡½æ•°ï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘
            kwargs = {}
            for param_name, param in sig.parameters.items():
                if param_name == 'request':
                    kwargs[param_name] = request
                elif param_name == 'request_data':
                    # ä¼ é€’åŸå§‹è¯·æ±‚æ•°æ®ï¼ˆå­—å…¸æ ¼å¼ï¼‰
                    # å¤„ç† body å­—æ®µï¼šå¦‚æœæ˜¯å­—èŠ‚æ•°ç»„ï¼Œå°è¯•è§£ç 
                    body_data = request.body
                    if isinstance(body_data, (list, bytes)):
                        try:
                            if isinstance(body_data, list):
                                # å­—èŠ‚æ•°ç»„è½¬æ¢ä¸ºå­—èŠ‚ä¸²
                                body_bytes = bytes(body_data)
                            else:
                                body_bytes = body_data
                            # å°è¯•è§£ç ä¸º UTF-8 å­—ç¬¦ä¸²
                            body_data = body_bytes.decode('utf-8')
                        except (UnicodeDecodeError, ValueError):
                            # è§£ç å¤±è´¥æ—¶ä¿æŒåŸå§‹æ ¼å¼
                            pass
                    
                    request_data_dict = {
                        'method': request.method,
                        'path': request.path,
                        'query': request.query_string,
                        'headers': request.headers,
                        'body': body_data,
                        'path_params': params  # ä½¿ç”¨è·¯ç”±åŒ¹é…å¾—åˆ°çš„å‚æ•°ï¼Œè€Œä¸æ˜¯request.path_params
                    }
                    kwargs[param_name] = request_data_dict
                elif param_name in params:
                    kwargs[param_name] = params[param_name]
            
            # è°ƒç”¨å¤„ç†å‡½æ•°
            if kwargs:
                result = handler(**kwargs)
            else:
                result = handler()
        
        # è½¬æ¢è¿”å›å€¼ä¸º HttpResponse
        return self._make_response(result)
    
    def _make_response(self, result: Any) -> HttpResponse:
        """å°†å¤„ç†å‡½æ•°è¿”å›å€¼è½¬æ¢ä¸º HttpResponse"""
        # _make_response æ”¶åˆ°ç»“æœ
        if isinstance(result, HttpResponse):
            return result
        
        # å¤„ç†æµå¼å“åº”å¯¹è±¡ï¼ˆé‡æ„åçš„æ–°æ¶æ„ï¼‰
        # æ–°æ¶æ„ä¸­ä½¿ç”¨ PySseResponse å’Œ PyChunkedResponse
        
        # å¤„ç† TypedResponse å¯¹è±¡
        if isinstance(result, TypedResponse):
            # è·å–çŠ¶æ€ç å’Œå¤´éƒ¨ä¿¡æ¯
            status_code = result.kwargs.get('status_code', 200)
            headers = result.kwargs.get('headers', {})
            
            if result.response_type == ResponseType.JSON:
                response = HttpResponse.json(result.content, status=status_code)
            elif result.response_type == ResponseType.HTML:
                response = HttpResponse.html(result.content, status=status_code)
            elif result.response_type == ResponseType.TEXT:
                response = HttpResponse.text(result.content, status=status_code)
            elif result.response_type == ResponseType.SSE:
                response = HttpResponse.sse(result.content)
            elif result.response_type == ResponseType.FILE:
                if 'mime_type' in result.kwargs:
                    response = self.send_file(result.content, mimetype=result.kwargs['mime_type'])
                else:
                    response = self.send_file(result.content, **result.kwargs)
            elif result.response_type == ResponseType.REDIRECT:
                response = HttpResponse.redirect(result.content)
            elif result.response_type == ResponseType.CUSTOM:
                response = HttpResponse.text(result.content, status=status_code)
                if 'content_type' in result.kwargs:
                    response.set_header('Content-Type', result.kwargs['content_type'])
            elif result.response_type == ResponseType.CUSTOM_BYTES:
                response = HttpResponse(body=result.content, headers={}, status=status_code)
                if 'content_type' in result.kwargs:
                    response.set_header('Content-Type', result.kwargs['content_type'])
            elif result.response_type == ResponseType.SSE_JSON:
                response = HttpResponse.sse_json(result.content)
            elif result.response_type == ResponseType.SSE_TEXT:
                response = HttpResponse.sse_text(result.content)
            elif result.response_type == ResponseType.CHUNK:
                response = HttpResponse.chunk(result.content)
            else:
                response = HttpResponse.text(str(result.content), status=status_code)
            
            # è®¾ç½®è‡ªå®šä¹‰å¤´éƒ¨
            if headers:
                for header_name, header_value in headers.items():
                    response.set_header(header_name, header_value)
            
            return response
        
        # å¤„ç† tuple è¿”å›å€¼ - æ”¯æŒ (content, status_code) æ ¼å¼
        if isinstance(result, tuple):
            if len(result) == 2:
                content, status_code = result
                # ç¡®ä¿çŠ¶æ€ç æ˜¯æ•´æ•°
                if isinstance(status_code, int):
                    # æ ¹æ®å†…å®¹ç±»å‹è‡ªåŠ¨é€‰æ‹©å“åº”æ ¼å¼
                    if isinstance(content, dict):
                        return HttpResponse.json(content, status=status_code)
                    elif isinstance(content, list):
                        return HttpResponse.json(content, status=status_code)
                    elif isinstance(content, str):
                        # æ£€æŸ¥æ˜¯å¦æ˜¯ HTML å†…å®¹
                        if content.strip().startswith('<') and content.strip().endswith('>'):
                            return HttpResponse.html(content, status=status_code)
                        else:
                            return HttpResponse.text(content, status=status_code)
                    else:
                        # å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                        return HttpResponse.text(str(content), status=status_code)
                else:
                    # å¦‚æœç¬¬äºŒä¸ªå…ƒç´ ä¸æ˜¯çŠ¶æ€ç ï¼ŒæŒ‰ç…§åŸæœ‰çš„ (content, content_type) å¤„ç†
                    content, content_type = result
                    if isinstance(content, str):
                        response = HttpResponse.text(content)
                        response.set_header('Content-Type', str(content_type))
                        return response
                    elif isinstance(content, bytes):
                        response = HttpResponse(body=content, headers={})
                        response.set_header('Content-Type', str(content_type))
                        return response
                    else:
                        # å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                        response = HttpResponse.text(str(content))
                        response.set_header('Content-Type', str(content_type))
                        return response
            elif len(result) == 3:
                # æ”¯æŒ (content, status_code, headers) æ ¼å¼
                content, status_code, headers = result
                if isinstance(status_code, int) and isinstance(headers, dict):
                    if isinstance(content, dict):
                        response = HttpResponse.json(content, status=status_code)
                    elif isinstance(content, list):
                        response = HttpResponse.json(content, status=status_code)
                    elif isinstance(content, str):
                        if content.strip().startswith('<') and content.strip().endswith('>'):
                            response = HttpResponse.html(content, status=status_code)
                        else:
                            response = HttpResponse.text(content, status=status_code)
                    else:
                        response = HttpResponse.text(str(content), status=status_code)
                    
                    # è®¾ç½®é¢å¤–çš„å“åº”å¤´
                    for key, value in headers.items():
                        response.set_header(str(key), str(value))
                    return response
        
        # å¤„ç†å­—å…¸å’Œåˆ—è¡¨ - è‡ªåŠ¨è½¬æ¢ä¸º JSON
        if isinstance(result, (dict, list)):
            return HttpResponse.json(result)
        
        # Default: treat as plain text
        return HttpResponse.text(str(result))
    
    def _apply_after_middleware(self, request: HttpRequest, response: HttpResponse) -> HttpResponse:
        """åº”ç”¨åç½®ä¸­é—´ä»¶å’Œå¤„ç†å™¨"""
        # è¯·æ±‚åå¤„ç†å™¨
        for handler in self.after_request_handlers:
            response = handler(response) or response
        
        # ä¸­é—´ä»¶åå¤„ç†
        for middleware in reversed(self.middlewares):
            response = middleware.after_request(request, response)
        
        return response
    
    def _handle_exception(self, request: HttpRequest, error: Exception) -> HttpResponse:
        """å¤„ç†å¼‚å¸¸"""
        # ä¸­é—´ä»¶é”™è¯¯å¤„ç†
        for middleware in self.middlewares:
            response = middleware.on_error(request, error)
            if response:
                return response
        
        # ä½¿ç”¨å®‰å…¨é”™è¯¯å¤„ç†å™¨
        from rat_engine.security import handle_secure_error
        
        # æ„å»ºè¯·æ±‚ä¿¡æ¯
        request_info = {
            'method': request.method,
            'path': request.path,
            'client_ip': getattr(request, 'remote_addr', 'Unknown'),
            'user_agent': request.headers.get('User-Agent', 'Unknown')
        }
        
        # å®‰å…¨å¤„ç†é”™è¯¯ï¼šè¯¦ç»†ä¿¡æ¯è®°å½•åˆ°æ—¥å¿—ï¼Œå®¢æˆ·ç«¯æ”¶åˆ°é€šç”¨æ¶ˆæ¯
        client_message, error_id = handle_secure_error(
            error, 
            request_info, 
            debug_mode=getattr(self, 'debug', False)
        )
        
        # åœ¨å“åº”å¤´ä¸­åŒ…å«é”™è¯¯IDï¼ˆä¾¿äºè°ƒè¯•ï¼‰
        response = self._handle_error(request, 500, client_message)
        if hasattr(response, 'headers'):
            response.set_header('X-Error-ID', error_id)
        
        return response
    
    def _handle_error(self, request: HttpRequest, code: int, message: str) -> HttpResponse:
        """å¤„ç†é”™è¯¯å“åº”"""
        if code in self.error_handlers:
            try:
                result = self.error_handlers[code]()
                return self._make_response(result)
            except Exception:
                pass
        
        return HttpResponse.error(message, code)
    
    def run(self, host: str = "127.0.0.1", port: int = 8000, debug: bool = False,
            log_level: str = "info", enable_access_log: bool = True, enable_error_log: bool = True, 
            blocking: bool = False, **kwargs):
        """å¯åŠ¨åº”ç”¨
        
        Args:
            host: æœåŠ¡å™¨ä¸»æœºåœ°å€
            port: æœåŠ¡å™¨ç«¯å£
            debug: æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼
            log_level: æ—¥å¿—çº§åˆ« ("error", "warn", "info", "debug", "trace")
            enable_access_log: æ˜¯å¦å¯ç”¨è®¿é—®æ—¥å¿—
            enable_error_log: æ˜¯å¦å¯ç”¨é”™è¯¯æ—¥å¿—
            blocking: æ˜¯å¦é˜»å¡æ¨¡å¼ï¼ˆTrue: é˜»å¡ç›´åˆ°æ”¶åˆ°åœæ­¢ä¿¡å·ï¼ŒFalse: éé˜»å¡ç«‹å³è¿”å›ï¼‰
            **kwargs: å…¶ä»–å‚æ•°
        """
        # å¦‚æœç”¨æˆ·æ²¡æœ‰æ‰‹åŠ¨è°ƒç”¨configure_loggingï¼Œåˆ™ä½¿ç”¨é»˜è®¤é…ç½®
        if not hasattr(self, '_logging_configured'):
            self.configure_logging(level=log_level)

        # è‡ªåŠ¨åˆå§‹åŒ– HTTP é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨ï¼ˆå¦‚æœæœ‰ HTTP è·¯ç”±æ³¨å†Œï¼‰
        if self._http_routes_registered and not self._http_bridge_initialized:
            try:
                # å®šä¹‰é»˜è®¤çš„ HTTP æ¶ˆæ¯å¤„ç†å™¨
                def default_http_message_handler(message_info):
                    """é»˜è®¤çš„ HTTP æ¶ˆæ¯å¤„ç†å™¨"""
                    msg_type = message_info.get('type', 'unknown')
                    if debug:
                        if msg_type == 'connection_established':
                            connection_id = message_info.get('connection_id')
                            protocol = message_info.get('protocol')
                            print(f"ğŸ”— æ–°è¿æ¥å»ºç«‹: {connection_id} (åè®®: {protocol})")
                        elif msg_type == 'connection_closed':
                            connection_id = message_info.get('connection_id')
                            reason = message_info.get('reason')
                            print(f"ğŸ”Œ è¿æ¥å…³é—­: {connection_id} (åŸå› : {reason})")
                        elif msg_type == 'request_received':
                            connection_id = message_info.get('connection_id')
                            request_id = message_info.get('request_id')
                            method = message_info.get('method')
                            path = message_info.get('path')
                            print(f"ğŸ“¨ æ”¶åˆ° HTTP è¯·æ±‚: {method} {path} (è¿æ¥: {connection_id}, è¯·æ±‚: {request_id})")
                
                # åˆå§‹åŒ– HTTP é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨
                if hasattr(self._router, 'initialize_http_queue_bridge'):
                    self._router.initialize_http_queue_bridge(default_http_message_handler)
                    self._http_bridge_initialized = True
                    if debug:
                        print("âœ… æ£€æµ‹åˆ° HTTP è·¯ç”±ï¼ŒHTTP é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨å·²è‡ªåŠ¨åˆå§‹åŒ–")
                else:
                    if debug:
                        print("âš ï¸ å½“å‰ç‰ˆæœ¬ä¸æ”¯æŒ HTTP é˜Ÿåˆ—æ¡¥æ¥ï¼Œä½¿ç”¨æ ‡å‡†æ¨¡å¼")
            except Exception as e:
                if debug:
                    print(f"âš ï¸ HTTP é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
                    print("   å°†ä½¿ç”¨æ ‡å‡†æ¨¡å¼è¿è¡Œ")
                # å³ä½¿åˆå§‹åŒ–å¤±è´¥ä¹Ÿç»§ç»­è¿è¡Œï¼Œä½¿ç”¨æ ‡å‡†æ¨¡å¼
        elif self._http_routes_registered and debug:
            print("â„¹ï¸ HTTP é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨å·²åˆå§‹åŒ–")
        elif not self._http_routes_registered and debug:
            print("â„¹ï¸ æœªæ£€æµ‹åˆ° HTTP è·¯ç”±ï¼Œè·³è¿‡ HTTP é˜Ÿåˆ—æ¡¥æ¥åˆå§‹åŒ–")
        
        # è‡ªåŠ¨åˆå§‹åŒ– gRPC é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨ï¼ˆå¦‚æœæœ‰ gRPC è·¯ç”±æ³¨å†Œï¼‰
        if self._grpc_routes_registered and not self._grpc_bridge_initialized:
            try:
                # é€šè¿‡ main_thread å®ä¾‹è°ƒç”¨ initialize_queue_bridge æ–¹æ³•
                if self.main_thread is not None:
                    self.main_thread.initialize_queue_bridge()
                    self._grpc_bridge_initialized = True
                    if debug:
                        print("âœ… æ£€æµ‹åˆ° gRPC è·¯ç”±ï¼ŒgRPC é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨å·²è‡ªåŠ¨åˆå§‹åŒ–")
                else:
                    if debug:
                        print("âš ï¸ main_thread æœªåˆå§‹åŒ–ï¼Œæ— æ³•åˆå§‹åŒ– gRPC é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨")
            except Exception as e:
                if debug:
                    print(f"âš ï¸ gRPC é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
                    print("   è¯·ç¡®ä¿åœ¨ä½¿ç”¨ gRPC åŠŸèƒ½å‰æ­£ç¡®é…ç½®é˜Ÿåˆ—æ¡¥æ¥")
                # å³ä½¿åˆå§‹åŒ–å¤±è´¥ä¹Ÿç»§ç»­è¿è¡Œï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨å¤„ç†
        elif self._grpc_routes_registered and debug:
            print("â„¹ï¸ gRPC é˜Ÿåˆ—æ¡¥æ¥é€‚é…å™¨å·²åˆå§‹åŒ–")
        elif not self._grpc_routes_registered and debug:
            print("â„¹ï¸ æœªæ£€æµ‹åˆ° gRPC è·¯ç”±ï¼Œè·³è¿‡ gRPC é˜Ÿåˆ—æ¡¥æ¥åˆå§‹åŒ–")
        
        # è®¾ç½®ä¼˜é›…é€€å‡ºæœºåˆ¶ï¼ˆä»…åœ¨é˜»å¡æ¨¡å¼ä¸‹ï¼‰
        if blocking:
            self._setup_graceful_shutdown()
        
        # è°ƒç”¨å¯åŠ¨å›è°ƒå‡½æ•°
        self._call_startup_handlers()
        
        if debug:
            # rat_engine_py.rat_startup_log(f"ğŸš€ RAT Engine starting on http://{host}:{port}")
            # rat_engine_py.rat_info(f"ğŸ“Š Registered {len(self.routes)} routes:")
            for route in self.routes:
                # rat_engine_py.rat_info(f"   {', '.join(route.methods)} {route.pattern}")
                pass
            # rat_engine_py.rat_info(f"ğŸ”§ Middlewares: {len(self.middlewares)}")
            # rat_engine_py.rat_info(f"ğŸ§© Extensions: {len(self.extensions)}")
            for ext_name in self.extensions:
                # rat_engine_py.rat_info(f"   ğŸ“¦ {ext_name}")
                pass
            # rat_engine_py.rat_info(f"âš¡ High-performance Rust backend with work-stealing scheduler")
            mode_text = "é˜»å¡ (Blocking)" if blocking else "éé˜»å¡ (Non-blocking)"
            # rat_engine_py.rat_info(f"ğŸ”„ Mode: {mode_text}")
            # rat_engine_py.rat_info(f"ğŸ“ Log level: {log_level}")
            # rat_engine_py.rat_info(f"ğŸ“‹ Access log: {enable_access_log}, Error log: {enable_error_log}")
            if self.celery_config.get('broker_url'):
                # rat_engine_py.rat_info(f"ğŸ”„ Celery broker: {self.celery_config['broker_url']}")
            if blocking:
                # rat_engine_py.rat_info("â¸ï¸ æŒ‰ Ctrl+C ä¼˜é›…åœæ­¢æœåŠ¡å™¨")
            print("\n" + "="*50)
        
        try:
            # æ³¨å†Œè·¯ç”±åˆ° routerï¼ˆåªæ³¨å†Œä¸€æ¬¡ï¼‰
            if not self._global_handler_registered:
                # æ³¨å†Œæ‰€æœ‰è·¯ç”±åˆ° router
                for route in self.routes:
                    for method in route.methods:
                        # æ£€æŸ¥æ˜¯å¦ä¸º SSE è·¯ç”±
                        if hasattr(route.handler, '_is_sse_route') and route.handler._is_sse_route:
                            # print(f"ğŸ”§ [PYTHON-DEBUG] æ³¨å†ŒSSEè·¯ç”±: {method} {route.pattern}")
                            self._router.add_sse_route(method, route.pattern, route.handler)
                            if debug:
                                print(f"   ğŸ“¡ SSE Registered route: {method} {route.pattern}")
                        else:
                            # ğŸ” [DEBUG] æ‰“å°è·¯ç”±æ³¨å†Œä¿¡æ¯
                            print(f"ğŸ”§ [PYTHON DEBUG] æ³¨å†Œæ™®é€šè·¯ç”±åˆ°Rustå±‚:")
                            print(f"   æ–¹æ³•: {method}")
                            print(f"   è·¯å¾„: {route.pattern}")
                            print(f"   Handleråç§°: {route.handler_name}")
                            print(f"   Handlerå‡½æ•°: {route.handler}")

                            # ğŸ†• ä½¿ç”¨æ–°çš„add_routeæ–¹æ³•ï¼Œä¼ é€’python_handler_name
                            self._router.add_route(method, route.pattern, self._handle_request, route.handler_name)
                            if debug:
                                print(f"   ğŸŒ HTTP Registered route: {method} {route.pattern} (with handler: {route.handler_name})")
                self._global_handler_registered = True
            
            # ä½¿ç”¨æ–°çš„ server å’Œ router è¿è¡Œï¼ˆéé˜»å¡æ¨¡å¼ï¼‰
            try:
                self.server.run(self._router, host, port)
            except Exception as e:
                print(f"[ERROR] server.run æ‰§è¡Œå¤±è´¥: {e}")
                import traceback
                traceback.print_exc()
                raise
        except KeyboardInterrupt:
            if debug:
                print("\nğŸ›‘ Server stopped by user")
            self.stop()
        
        # é˜»å¡æ¨¡å¼ï¼šç­‰å¾…åœæ­¢ä¿¡å·
        if blocking:
            try:
                if debug:
                    print(f"âœ… æœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œè®¿é—® http://{host}:{port}")
                # ä¼˜é›…ç­‰å¾…åœæ­¢ä¿¡å·ï¼ˆæ›¿ä»£æ— é™å¾ªç¯ï¼‰
                self._stop_event.wait()
            except KeyboardInterrupt:
                if debug:
                    print("\nğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨ä¼˜é›…å…³é—­æœåŠ¡å™¨...")
            finally:
                self.stop()
                if debug:
                    print("ğŸ§¹ æ¸…ç†èµ„æºå®Œæˆ")
                    print("ğŸ‘‹ æœåŠ¡å™¨å·²åœæ­¢")
    
    def stop(self):
        """åœæ­¢åº”ç”¨"""
        # è°ƒç”¨å…³é—­å›è°ƒå‡½æ•°
        self._call_shutdown_handlers()
        
        if hasattr(self, '_stop_event'):
            self._stop_event.set()
        # å…¼å®¹æ—§ç‰ˆæœ¬æ²¡æœ‰stopæ–¹æ³•çš„æƒ…å†µ
        if hasattr(self.server, 'stop'):
            self.server.stop()
    
    def is_running(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        return self.server.is_running()
    
    def get_metrics(self) -> Dict[str, float]:
        """è·å–æ€§èƒ½æŒ‡æ ‡"""
        return self.server.get_metrics()
    
    def reset_metrics(self):
        """é‡ç½®æ€§èƒ½æŒ‡æ ‡"""
        self.server.reset_metrics()
    
    def get_server_info(self) -> Dict[str, str]:
        """è·å–æœåŠ¡å™¨ä¿¡æ¯"""
        return self.server.get_server_info()
    
    # æ–‡ä»¶å¤„ç†æ–¹æ³•
    def send_static_file(self, filename: str, static_folder: str = "static") -> HttpResponse:
        """å‘é€é™æ€æ–‡ä»¶
        
        Args:
            filename: æ–‡ä»¶å
            static_folder: é™æ€æ–‡ä»¶å¤¹è·¯å¾„
            
        Returns:
            HttpResponse: æ–‡ä»¶å“åº”
        """
        import os
        import mimetypes
        
        # æ„å»ºå®Œæ•´æ–‡ä»¶è·¯å¾„
        file_path = os.path.join(static_folder, filename)
        
        if not os.path.exists(file_path):
            return HttpResponse(status=404, body=b"File not found")
        
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            
            # çŒœæµ‹ MIME ç±»å‹
            mimetype, _ = mimetypes.guess_type(file_path)
            if not mimetype:
                mimetype = 'application/octet-stream'
            
            response = HttpResponse(status=200, body=content)
            response.set_header('Content-Type', mimetype)
            return response
        except Exception as e:
            return HttpResponse(status=500, body=f"Error reading file: {str(e)}".encode())
    
    def send_file(self, file_path, as_attachment: bool = False, 
                  attachment_filename: str = None, mimetype: str = None) -> HttpResponse:
        """å‘é€æ–‡ä»¶
        
        Args:
            file_path: æ–‡ä»¶è·¯å¾„(str)æˆ–æ–‡ä»¶å¯¹è±¡(BytesIO)
            as_attachment: æ˜¯å¦ä½œä¸ºé™„ä»¶ä¸‹è½½
            attachment_filename: é™„ä»¶æ–‡ä»¶å
            mimetype: MIME ç±»å‹
            
        Returns:
            HttpResponse: æ–‡ä»¶å“åº”
        """
        import os
        from io import BytesIO
        
        # å¤„ç† BytesIO å¯¹è±¡
        if isinstance(file_path, BytesIO):
            content = file_path.getvalue()
            filename = attachment_filename or "download"
        else:
            # å¤„ç†æ–‡ä»¶è·¯å¾„
            if not os.path.exists(file_path):
                return HttpResponse.error("File not found", 404)
            
            # è¯»å–æ–‡ä»¶å†…å®¹
            try:
                with open(file_path, 'rb') as f:
                    content = f.read()
            except Exception as e:
                return HttpResponse.error(f"Error reading file: {str(e)}", 500)
            
            filename = attachment_filename or os.path.basename(file_path)
        
        # åˆ›å»ºæ–‡ä»¶å“åº”
        import mimetypes
        
        if not mimetype:
            mimetype, _ = mimetypes.guess_type(filename)
            if not mimetype:
                mimetype = 'application/octet-stream'
        
        response = HttpResponse(status=200, body=content)
        response.set_header('Content-Type', mimetype)
        
        # è®¾ç½®ä¸‹è½½å¤´
        if as_attachment:
            response.set_header('Content-Disposition', f'attachment; filename="{filename}"')
        
        return response
    
    def send_base64_image(self, base64_data: str, filename: str = None, 
                         mimetype: str = None) -> HttpResponse:
        """å‘é€ Base64 ç¼–ç çš„å›¾ç‰‡
        
        Args:
            base64_data: Base64 ç¼–ç çš„å›¾ç‰‡æ•°æ®
            filename: æ–‡ä»¶å
            mimetype: MIME ç±»å‹
            
        Returns:
            HttpResponse: å›¾ç‰‡å“åº”
        """
        import base64
        
        try:
            # è§£ç  Base64 æ•°æ®
            content = base64.b64decode(base64_data)
            
            # è®¾ç½®é»˜è®¤ MIME ç±»å‹
            if not mimetype:
                mimetype = 'image/png'  # é»˜è®¤ä¸º PNG
            
            response = HttpResponse(status=200, body=content)
            response.set_header('Content-Type', mimetype)
            if filename:
                response.set_header('Content-Disposition', f'inline; filename="{filename}"')
            
            return response
        except Exception as e:
            return HttpResponse(status=400, body=f"Invalid base64 image data: {str(e)}".encode())
    
    def send_from_gridfs(self, gridfs_file, filename: str = None) -> HttpResponse:
        """ä» GridFS å‘é€æ–‡ä»¶
        
        Args:
            gridfs_file: GridFS æ–‡ä»¶å¯¹è±¡
            filename: æ–‡ä»¶å
            
        Returns:
            HttpResponse: æ–‡ä»¶å“åº”
        """
        try:
            # è¯»å– GridFS æ–‡ä»¶å†…å®¹
            content = gridfs_file.read()
            content_type = getattr(gridfs_file, 'content_type', None)
            file_name = filename or getattr(gridfs_file, 'filename', 'file')
            
            # åˆ›å»ºæ–‡ä»¶å“åº”
            response = HttpResponse(status=200, body=content)
            
            if content_type:
                response.set_header('Content-Type', content_type)
            else:
                response.set_header('Content-Type', 'application/octet-stream')
            
            response.set_header('Content-Disposition', f'inline; filename="{file_name}"')
            return response
                
        except Exception as e:
            return HttpResponse(status=500, body=f"GridFS error: {str(e)}".encode())
    
    def send_pil_image(self, pil_image, format: str = 'PNG', filename: str = None, 
                      quality: int = 95) -> HttpResponse:
        """å‘é€ PIL å›¾ç‰‡å¯¹è±¡
        
        Args:
            pil_image: PIL Image å¯¹è±¡
            format: å›¾ç‰‡æ ¼å¼ (PNG, JPEG, etc.)
            filename: æ–‡ä»¶å
            quality: å›¾ç‰‡è´¨é‡ (ä»…å¯¹ JPEG æœ‰æ•ˆ)
            
        Returns:
            HttpResponse: å›¾ç‰‡å“åº”
        """
        try:
            from io import BytesIO
            
            # å°† PIL å›¾ç‰‡è½¬æ¢ä¸ºå­—èŠ‚
            img_buffer = BytesIO()
            save_kwargs = {'format': format}
            if format.upper() == 'JPEG':
                save_kwargs['quality'] = quality
                save_kwargs['optimize'] = True
            
            pil_image.save(img_buffer, **save_kwargs)
            content = img_buffer.getvalue()
            
            # ç¡®å®š MIME ç±»å‹
            mime_types = {
                'PNG': 'image/png',
                'JPEG': 'image/jpeg',
                'JPG': 'image/jpeg',
                'GIF': 'image/gif',
                'BMP': 'image/bmp',
                'WEBP': 'image/webp'
            }
            mimetype = mime_types.get(format.upper(), 'image/png')
            
            # ç”Ÿæˆæ–‡ä»¶å
            if not filename:
                ext = format.lower()
                filename = f'image.{ext}'
            
            # åˆ›å»ºå›¾ç‰‡å“åº”
            response = HttpResponse(status=200, body=content)
            response.set_header('Content-Type', mimetype)
            response.set_header('Content-Disposition', f'inline; filename="{filename}"')
            return response
                
        except Exception as e:
            return HttpResponse(status=500, body=f"PIL image error: {str(e)}".encode())


# ä¾¿åˆ©å‡½æ•°å’Œè£…é¥°å™¨
def request() -> HttpRequest:
    """è·å–å½“å‰è¯·æ±‚å¯¹è±¡"""
    req = get_current_request()
    if req is None:
        raise RuntimeError("No request context available")
    return req


def path_params() -> Dict[str, Any]:
    """è·å–è·¯å¾„å‚æ•°"""
    return get_path_params()


# å¸¸ç”¨ä¸­é—´ä»¶
class CORSMiddleware(Middleware):
    """CORS ä¸­é—´ä»¶"""
    
    def __init__(self, 
                 origins: List[str] = None,
                 methods: List[str] = None,
                 headers: List[str] = None,
                 credentials: bool = False):
        self.origins = origins or ["*"]
        self.methods = methods or ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
        self.headers = headers or ["Content-Type", "Authorization"]
        self.credentials = credentials
    
    def before_request(self, request: HttpRequest) -> Optional[HttpResponse]:
        if request.method == "OPTIONS":
            response = HttpResponse(status=200)
            self._set_cors_headers(response)
            return response
        return None
    
    def after_request(self, request: HttpRequest, response: HttpResponse) -> HttpResponse:
        self._set_cors_headers(response)
        return response
    
    def _set_cors_headers(self, response: HttpResponse):
        response.set_cors(
            origin=", ".join(self.origins),
            methods=self.methods,
            headers=self.headers,
            credentials=self.credentials
        )


class LoggingMiddleware(Middleware):
    """å¢å¼ºçš„æ—¥å¿—ä¸­é—´ä»¶"""
    
    def __init__(self, enable_access_log: bool = True, enable_error_log: bool = True):
        self.enable_access_log = enable_access_log
        self.enable_error_log = enable_error_log
        self.start_time = None
    
    def before_request(self, request: HttpRequest) -> Optional[HttpResponse]:
        import time
        self.start_time = time.time()
        # æ—¥å¿—ç”± Rust å±‚ç»Ÿä¸€å¤„ç†
        return None
    
    def after_request(self, request: HttpRequest, response: HttpResponse) -> HttpResponse:
        # æ—¥å¿—ç”± Rust å±‚ç»Ÿä¸€å¤„ç†
        return response
    
    def on_error(self, request: HttpRequest, error: Exception) -> Optional[HttpResponse]:
        # é”™è¯¯ä¿¡æ¯ç”± Rust å±‚ç»Ÿä¸€å¤„ç†å’Œæ‰“å°
        return None


# CLI å·¥å…·
def create_app_from_file(filename: str) -> RatApp:
    """ä»æ–‡ä»¶åˆ›å»ºåº”ç”¨"""
    import importlib.util
    
    spec = importlib.util.spec_from_file_location("app", filename)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    
    # æŸ¥æ‰¾ RatApp åº”ç”¨å®ä¾‹
    for name in dir(module):
        obj = getattr(module, name)
        if isinstance(obj, RatApp):
            return obj
    
    raise ValueError(f"No RatApp found in {filename}")


def run_cli():
    """å‘½ä»¤è¡Œå·¥å…·å…¥å£"""
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(description="RAT Engine CLI")
    parser.add_argument("app", help="Python file containing RatApp")
    parser.add_argument("--host", default="127.0.0.1", help="Host to bind to")
    parser.add_argument("--port", type=int, default=8000, help="Port to bind to")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("--workers", type=int, help="Number of worker threads")
    parser.add_argument("--max-connections", type=int, help="Maximum connections")
    
    args = parser.parse_args()
    
    try:
        app = create_app_from_file(args.app)
        
        # æ›´æ–°æœåŠ¡å™¨é…ç½®
        if args.workers:
            app._router = PyRouter()
            app.server = PyServer(
                host=args.host,
                port=args.port,
                workers=args.workers,
                max_connections=args.max_connections
            )
            app._global_handler_registered = False
        
        app.run(host=args.host, port=args.port, debug=args.debug)
    
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    run_cli()