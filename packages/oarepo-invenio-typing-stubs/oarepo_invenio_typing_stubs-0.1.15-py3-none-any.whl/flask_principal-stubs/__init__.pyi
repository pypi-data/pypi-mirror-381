from collections import deque
from collections.abc import Callable
from typing import Any, NamedTuple

from flask import Flask

__version__: str

PY3: bool
signals: Any
identity_changed: Any
identity_loaded: Any

class Need(NamedTuple):
    method: str
    value: Any

def UserNeed(value: Any) -> Need: ...
def RoleNeed(value: Any) -> Need: ...
def TypeNeed(value: Any) -> Need: ...
def ActionNeed(value: Any) -> Need: ...

class ItemNeed(NamedTuple):
    method: str
    value: Any
    type: str

class PermissionDenied(RuntimeError): ...

class Identity:
    id: Any
    auth_type: str | None
    provides: set[Need | ItemNeed]

    def __init__(self, id: Any, auth_type: str | None = None) -> None: ...
    def can(self, permission: Permission) -> bool: ...
    def __repr__(self) -> str: ...

class AnonymousIdentity(Identity):
    def __init__(self) -> None: ...

class IdentityContext:
    permission: Permission
    http_exception: int | None

    def __init__(
        self, permission: Permission, http_exception: int | None = None
    ) -> None: ...
    @property
    def identity(self) -> Identity: ...
    def can(self) -> bool: ...
    def __call__(self, f: Callable[..., Any]) -> Callable[..., Any]: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *args: Any) -> bool: ...

class Permission:
    needs: set[tuple]  # keep typing as we want to add many types of needs here
    excludes: set[tuple]  # keep typing as we want to add many types of needs here

    def __init__(self, *needs: Need | ItemNeed) -> None: ...
    def _bool(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def __and__(self, other: Permission) -> Permission: ...
    def __or__(self, other: Permission) -> Permission: ...
    def __contains__(self, other: Permission) -> bool: ...
    def __repr__(self) -> str: ...
    def require(self, http_exception: int | None = None) -> IdentityContext: ...
    def test(self, http_exception: int | None = None) -> None: ...
    def reverse(self) -> Permission: ...
    def union(self, other: Permission) -> Permission: ...
    def difference(self, other: Permission) -> Permission: ...
    def issubset(self, other: Permission) -> bool: ...
    def allows(self, identity: Identity) -> bool: ...
    def can(self) -> bool: ...

class Denial(Permission):
    def __init__(self, *excludes: Need | ItemNeed) -> None: ...

def session_identity_loader() -> Identity | None: ...
def session_identity_saver(identity: Identity) -> None: ...

class Principal:
    identity_loaders: deque[Callable[[], Identity | None]]
    identity_savers: deque[Callable[[Identity], None]]
    use_sessions: bool
    skip_static: bool
    _static_path: str

    def __init__(
        self,
        app: Flask | None = None,
        use_sessions: bool = True,
        skip_static: bool = False,
    ) -> None: ...
    def _init_app(self, app: Flask) -> None: ...
    def init_app(self, app: Flask) -> None: ...
    def set_identity(self, identity: Identity) -> None: ...
    def identity_loader(
        self, f: Callable[[], Identity | None]
    ) -> Callable[[], Identity | None]: ...
    def identity_saver(
        self, f: Callable[[Identity], None]
    ) -> Callable[[Identity], None]: ...
    def _set_thread_identity(self, identity: Identity) -> None: ...
    def _on_identity_changed(self, app: Flask, identity: Identity) -> None: ...
    def _on_before_request(self) -> None: ...
    def _is_static_route(self) -> bool: ...
