from collections.abc import Iterator
from io import (
    BufferedReader,
    BytesIO,
)
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Type,
    Union,
)
from uuid import UUID

# type: ignore[import-untyped]
from invenio_files_rest.models import (
    Bucket,
    ObjectVersion,
)
from invenio_records_resources.records.api import FileRecord, Record
from werkzeug.wsgi import LimitedStream

def ensure_enabled(func: Callable) -> Callable: ...

class FilesManager[R: Record = Record, F: FileRecord = FileRecord]:
    def __getitem__(self, key: str) -> F: ...
    def __init__(
        self,
        record: R,
        file_cls: Optional[Type[F]] = ...,
        bucket: None = ...,
        enabled: bool = ...,
        order: List[str] | None = ...,
        default_preview: Optional[str] = ...,
        entries: Optional[Dict[str, F]] = ...,
        options: Optional[Dict[str, Any]] = ...,
    ): ...
    def __len__(self) -> int: ...
    def __setitem__(self, key: str, value: Any): ...
    def _parse_set_value(
        self, value: Any
    ) -> tuple[Any, Any, Optional[Dict[str, Any]]]: ...
    @property
    def bucket(self) -> Bucket: ...
    @property
    def bucket_id(self) -> UUID: ...
    def set_quota(self, quota_size: int, max_file_size: Optional[int] = ...): ...
    def lock(self): ...
    def unlock(self): ...
    def commit(self, file_key: str): ...
    def copy(self, src_files: FilesManager, copy_obj: bool = ...): ...
    @property
    def count(self) -> int: ...
    def create(
        self, key: str, *, obj=..., stream=..., data=..., transfer=..., **kwargs
    ) -> F: ...
    def create_bucket(self): ...
    def create_obj(
        self,
        key: str,
        stream: Union[BufferedReader, BytesIO, LimitedStream],
        data: Optional[Dict[str, Any]] = ...,
        **kwargs,
    ) -> ObjectVersion: ...
    def delete(
        self,
        key: str,
        remove_obj: bool = ...,
        softdelete_obj: bool = ...,
        remove_rf: bool = ...,
    ) -> F: ...
    def delete_all(
        self, remove_obj: bool = ..., softdelete_obj: bool = ..., remove_rf: bool = ...
    ): ...
    @property
    def entries(self) -> Dict[str, F]: ...
    @property
    def exts(self) -> List[Any]: ...
    @property
    def mimetypes(self) -> List[Any]: ...
    def remove_bucket(self, force: bool = ...): ...
    def unset_bucket(self): ...
    def set_bucket(self, bucket: Bucket, overwrite: bool = ...): ...
    def sync(self, src_files: FilesManager, delete_extras: bool = ...): ...
    def teardown(self, full: bool = ...): ...
    @property
    def total_bytes(self) -> int: ...
    def update(
        self,
        key: str,
        obj: Optional[ObjectVersion] = ...,
        stream: Optional[Union[BufferedReader, BytesIO, LimitedStream]] = ...,
        data: Optional[Dict[str, Any]] = ...,
        **kwargs,
    ) -> F: ...
    @property
    def enabled(self) -> bool: ...
    @enabled.setter
    def enabled(self, value: bool): ...
    @property
    def default_preview(self) -> Optional[str]: ...
    @default_preview.setter
    def default_preview(self, key: Optional[str]): ...
    @property
    def order(self) -> List[str]: ...
    @order.setter
    def order(self, new_order: List[str]): ...
    def __iter__(self) -> Iterator[str]: ...
    def __delitem__(self, key: str): ...
    def __repr__(self) -> str: ...
